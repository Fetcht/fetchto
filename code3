===============================================
File: include/RE/G/GArrayBase.h
===============================================
#pragma once

#include "GMemory.h"

namespace RE
{
	class GMemoryHeap;

	template <class T>
	class GArrayBase
	{
	public:
		using ValueType = typename T::ValueType;
		using AllocatorType = typename T::AllocatorType;
		using SizePolicyType = typename T::SizePolicyType;
		using SelfType = GArrayBase<T>;

		struct iterator
		{
		public:
			iterator() :
				array(nullptr),
				curIndex(-1)
			{}

			iterator(SelfType* a_arr, SPInt a_idx = 0) :
				array(a_arr),
				curIndex(a_idx)
			{}

			bool operator==(const iterator& a_it) const
			{
				return array == a_it.array && curIndex == a_it.curIndex;
			}

			bool operator!=(const iterator& a_it) const
			{
				return array != a_it.array || curIndex != a_it.curIndex;
			}

			iterator& operator++()
			{
				if (array) {
					if (curIndex < static_cast<SPInt>(array->GetSize())) {
						++curIndex;
					}
				}
				return *this;
			}

			iterator operator++(std::int32_t)
			{
				iterator it(*this);
						 operator++();
				return it;
			}

			iterator& operator--()
			{
				if (array) {
					if (curIndex >= 0) {
						--curIndex;
					}
				}
				return *this;
			}

			iterator operator--(std::int32_t)
			{
				iterator it(*this);
						 operator--();
				return it;
			}

			iterator operator+(std::int32_t a_delta) const
			{
				return iterator(array, curIndex + a_delta);
			}

			iterator operator-(std::int32_t a_delta) const
			{
				return iterator(array, curIndex - a_delta);
			}

			SPInt operator-(const iterator& a_right) const
			{
				assert(array == a_right.array);
				return curIndex - a_right.curIndex;
			}

			ValueType& operator*() const
			{
				assert(array);
				return (*array)[curIndex];
			}

			ValueType* operator->() const
			{
				assert(array);
				return &(*array)[curIndex];
			}

			ValueType* GetPtr() const
			{
				assert(array);
				return &(*array)[curIndex];
			}

			bool IsFinished() const
			{
				return !array || curIndex < 0 || curIndex >= static_cast<std::int32_t>(array->GetSize());
			}

			void Remove()
			{
				if (!IsFinished()) {
					array->RemoveAt(curIndex);
				}
			}

			SPInt GetIndex() const
			{
				return curIndex;
			}

		private:
			SelfType* array;
			SPInt     curIndex;
		};

		struct const_iterator
		{
		public:
			const_iterator() :
				array(nullptr),
				curIndex(-1)
			{}

			const_iterator(const SelfType* a_arr, SPInt a_idx = 0) :
				array(a_arr),
				curIndex(a_idx)
			{}

			bool operator==(const const_iterator& a_it) const
			{
				return array == a_it.array && curIndex == a_it.curIndex;
			}

			bool operator!=(const const_iterator& a_it) const
			{
				return array != a_it.array || curIndex != a_it.curIndex;
			}

			const_iterator& operator++()
			{
				if (array) {
					if (curIndex < static_cast<std::int32_t>(array->GetSize())) {
						++curIndex;
					}
				}
				return *this;
			}

			const_iterator operator++(std::int32_t)
			{
				const_iterator it(*this);
							   operator++();
				return it;
			}

			const_iterator& operator--()
			{
				if (array) {
					if (curIndex >= 0)
						--curIndex;
				}
				return *this;
			}

			const_iterator operator--(std::int32_t)
			{
				const_iterator it(*this);
							   operator--();
				return it;
			}

			const_iterator operator+(std::int32_t a_delta) const
			{
				return const_iterator(array, curIndex + a_delta);
			}

			const_iterator operator-(std::int32_t a_delta) const
			{
				return const_iterator(array, curIndex - a_delta);
			}

			SPInt operator-(const const_iterator& a_right) const
			{
				assert(array == a_right.array);
				return curIndex - a_right.curIndex;
			}

			const ValueType& operator*() const
			{
				assert(array);
				return (*array)[curIndex];
			}

			const ValueType* operator->() const
			{
				assert(array);
				return &(*array)[curIndex];
			}

			const ValueType* GetPtr() const
			{
				assert(array);
				return &(*array)[curIndex];
			}

			bool IsFinished() const
			{
				return !array || curIndex < 0 || curIndex >= static_cast<std::int32_t>(array->GetSize());
			}

			SPInt GetIndex() const
			{
				return curIndex;
			}

		private:
			const SelfType* array;
			SPInt           curIndex;
		};

		GFC_MEMORY_REDEFINE_NEW(GArrayBase, AllocatorType::StatId);

		GArrayBase() :
			data()
		{}

		GArrayBase(std::int32_t a_size) :
			data(a_size)
		{}

		GArrayBase(const SelfType& a_array) :
			data(a_array.data)
		{}

		GArrayBase(GMemoryHeap* a_heap) :
			data(a_heap)
		{}

		GArrayBase(GMemoryHeap* a_heap, std::int32_t a_size) :
			data(a_heap, a_size)
		{}

		GArrayBase(const ValueType& a_defaultVal) :
			data(a_defaultVal)
		{}

		GArrayBase(const ValueType& a_defaultVal, std::int32_t a_size) :
			data(a_defaultVal, a_size)
		{}

		SizePolicyType* GetSizePolicy() const
		{
			return data.policy;
		}

		void SetSizePolicy(const SizePolicyType& a_policy)
		{
			data.policy = a_policy;
		}

		bool NeverShrinking() const
		{
			return data.policy.NeverShrinking();
		}

		UPInt GetSize() const
		{
			return data.size;
		}

		UPInt GetCapacity() const
		{
			return data.GetCapacity();
		}

		UPInt GetNumBytes() const
		{
			return data.GetCapacity() * sizeof(ValueType);
		}

		void ClearAndRelease()
		{
			data.ClearAndRelease();
		}

		void Clear()
		{
			data.Resize(0);
		}

		void Resize(UPInt a_newSize)
		{
			data.Resize(a_newSize);
		}

		void Reserve(UPInt a_newCapacity)
		{
			if (a_newCapacity > data.GetCapacity()) {
				data.Reserve(a_newCapacity);
			}
		}

		ValueType& At(UPInt a_index)
		{
			assert(a_index < data.size);
			return data.data[a_index];
		}

		const ValueType& At(UPInt a_index) const
		{
			assert(a_index < data.size);
			return data.data[a_index];
		}

		ValueType ValueAt(UPInt a_index) const
		{
			assert(a_index < data.size);
			return data.data[a_index];
		}

		ValueType& operator[](UPInt a_index)
		{
			assert(a_index < data.size);
			return data.data[a_index];
		}

		const ValueType& operator[](UPInt a_index) const
		{
			assert(a_index < data.size);
			return data.data[a_index];
		}

		void PushBack(const ValueType& a_val)
		{
			data.PushBack(a_val);
		}

		template <class S>
		void PushBackAlt(const S& a_val)
		{
			data.PushBackAlt(a_val);
		}

		void PopBack()
		{
			assert(data.size > 0);
			data.Resize(data.size - 1);
		}

		ValueType& Front()
		{
			return At(0);
		}

		const ValueType& Front() const
		{
			return At(0);
		}

		ValueType& Back()
		{
			return At(data.size - 1);
		}

		const ValueType& Back() const
		{
			return At(data.size - 1);
		}

		const SelfType& operator=(const SelfType& a_array)
		{
			Resize(a_array.GetSize());
			for (UPInt i = 0; i < data.size; i++) {
				*(data.data + i) = a_array[i];
			}
			return *this;
		}

		void RemoveMultipleAt(UPInt a_index, UPInt a_num)
		{
			assert(a_index + a_num <= data.size);

			if (data.size == a_num) {
				Clear();
			} else {
				AllocatorType::DestructArray(data.data + a_index, a_num);
				AllocatorType::CopyArrayForward(
					data.data + a_index,
					data.data + a_index + a_num,
					data.size + a_num - a_index);
				data.size -= a_num;
			}
		}

		void RemoveAt(UPInt a_index)
		{
			assert(a_index < data.size);

			if (data.size == 1) {
				Clear();
			} else {
				AllocatorType::Destruct(data.data + a_index);
				AllocatorType::CopyArrayForward(
					data.data + a_index,
					data.data + a_index + 1,
					data.size - 1 - a_index);
				--data.size;
			}
		}

		void InsertAt(UPInt a_index, const ValueType& a_val = ValueType())
		{
			assert(a_index <= data.size);

			data.Resize(data.size + 1);
			if (a_index < data.size - 1) {
				AllocatorType::CopyArrayBackward(
					data.data + a_index + 1,
					data.data + a_index,
					data.size - 1 - a_index);
			}
			AllocatorType::Construct(data.data + a_index, a_val);
		}

		void InsertMultipleAt(UPInt a_index, UPInt a_num, const ValueType& a_val = ValueType())
		{
			assert(a_index <= data.size);

			data.Resize(data.size + a_num);
			if (a_index < data.size - a_num) {
				AllocatorType::CopyArrayBackward(
					data.data + a_index + a_num,
					data.data + a_index,
					data.size - a_num - a_index);
			}

			for (UPInt i = 0; i < a_num; ++i) {
				AllocatorType::Construct(data.data + a_index + i, a_val);
			}
		}

		void Append(const SelfType& a_other)
		{
			Append(a_other.data.data, a_other.GetSize());
		}

		void Append(const ValueType a_other[], UPInt a_count)
		{
			data.Append(a_other, a_count);
		}

		iterator begin()
		{
			return iterator(this);
		}

		iterator end()
		{
			return iterator(this, static_cast<SPInt>(GetSize()));
		}

		iterator Last()
		{
			return iterator(this, static_cast<SPInt>(GetSize() - 1));
		}

		const_iterator begin() const
		{
			return const_iterator(this);
		}

		const_iterator end() const
		{
			return const_iterator(this, static_cast<SPInt>(GetSize()));
		}

		const_iterator Last() const
		{
			return const_iterator(this, static_cast<SPInt>(GetSize() - 1));
		}

		// members
		T data;  // 00
	};
}


===============================================
File: include/RE/G/GArrayConstPolicy.h
===============================================
#pragma once

namespace RE
{
	template <std::int32_t MinCapacity = 0, std::int32_t Granularity = 4, bool NeverShrink = false>
	struct GArrayConstPolicy
	{
	public:
		using SelfType = GArrayConstPolicy<MinCapacity, Granularity, NeverShrink>;

		GArrayConstPolicy() :
			capacity(0)
		{}

		GArrayConstPolicy(const SelfType&) :
			capacity(0)
		{}

		UPInt GetMinCapacity() const { return MinCapacity; }
		UPInt GetGranularity() const { return Granularity; }
		bool  NeverShrinking() const { return NeverShrink; }

		UPInt GetCapacity() const { return capacity; }
		void  SetCapacity(UPInt a_capacity) { capacity = a_capacity; }

		// members
		UPInt capacity;  // 0
	};
	static_assert(sizeof(GArrayDefaultPolicy) == 0x8);
}


===============================================
File: include/RE/G/GArrayData.h
===============================================
#pragma once

#include "RE/G/GArrayDataBase.h"

namespace RE
{
	template <class T, class Allocator, class SizePolicy>
	struct GArrayData : GArrayDataBase<T, Allocator, SizePolicy>
	{
	public:
		using ValueType = T;
		using AllocatorType = Allocator;
		using SizePolicyType = SizePolicy;
		using BaseType = GArrayDataBase<T, Allocator, SizePolicy>;
		using SelfType = GArrayData<T, Allocator, SizePolicy>;

		GArrayData() :
			BaseType()
		{}

		GArrayData(std::int32_t a_size) :
			BaseType()
		{
			Resize(a_size);
		}

		GArrayData(const SelfType& a_arrayData) :
			BaseType(a_arrayData.policy)
		{
			Append(a_arrayData.data, a_arrayData.size);
		}

		void Reserve(UPInt a_newCapacity)
		{
			BaseType::Reserve(this, a_newCapacity);
		}

		void Resize(UPInt a_newSize)
		{
			UPInt oldSize = this->size;
			BaseType::ResizeNoConstruct(this, a_newSize);
			if (a_newSize > oldSize) {
				Allocator::ConstructArray(this->data + oldSize, a_newSize - oldSize);
			}
		}

		void PushBack(const ValueType& a_val)
		{
			BaseType::ResizeNoConstruct(this, this->size + 1);
			Allocator::Construct(this->data + this->size - 1, a_val);
		}

		template <class S>
		void PushBackAlt(const S& a_val)
		{
			BaseType::ResizeNoConstruct(this, this->size + 1);
			Allocator::ConstructAlt(this->data + this->size - 1, a_val);
		}

		void Append(const ValueType a_other[], UPInt a_count)
		{
			if (a_count) {
				UPInt oldSize = this->size;
				BaseType::ResizeNoConstruct(this, this->size + a_count);
				Allocator::ConstructArray(this->data + oldSize, a_count, a_other);
			}
		}
	};
}


===============================================
File: include/RE/G/GArrayDataBase.h
===============================================
#pragma once

namespace RE
{
	template <class T, class Allocator, class SizePolicy>
	struct GArrayDataBase
	{
	public:
		using ValueType = T;
		using AllocatorType = Allocator;
		using SizePolicyType = SizePolicy;
		using SelfType = GArrayDataBase<T, Allocator, SizePolicy>;

		GArrayDataBase() :
			data(nullptr),
			size(0),
			policy()
		{}

		GArrayDataBase(const SizePolicy& a_policy) :
			data(nullptr),
			size(0),
			policy(a_policy)
		{}

		~GArrayDataBase()
		{
			Allocator::DestructArray(data, size);
			Allocator::Free(data);
		}

		UPInt GetCapacity() const
		{
			return policy.GetCapacity();
		}

		void ClearAndRelease()
		{
			Allocator::DestructArray(data, size);
			Allocator::Free(data);
			data = nullptr;
			size = 0;
			policy.SetCapacity(0);
		}

		void Reserve(const void* a_heapAddr, UPInt a_newCapacity)
		{
			if (policy.NeverShrinking() && a_newCapacity < GetCapacity())
				return;

			if (a_newCapacity < policy.GetMinCapacity())
				a_newCapacity = policy.GetMinCapacity();

			if (a_newCapacity == 0) {
				if (data) {
					Allocator::Free(data);
					data = nullptr;
				}
				policy.SetCapacity(0);
			} else {
				UPInt gran = policy.GetGranularity();
				UPInt newCapacity = (a_newCapacity + gran - 1) / gran * gran;
				if (data) {
					if (Allocator::IsMovable()) {
						data = (T*)Allocator::Realloc(data, sizeof(T) * newCapacity);
					} else {
						T* newData = (T*)Allocator::Alloc(a_heapAddr, sizeof(T) * newCapacity);
						for (UPInt i = 0; i < size; ++i) {
							Allocator::Construct(&newData[i], data[i]);
							Allocator::Destruct(&data[i]);
						}
						Allocator::Free(data);
						data = newData;
					}
				} else {
					data = (T*)Allocator::Alloc(a_heapAddr, sizeof(T) * newCapacity);
				}
				policy.SetCapacity(newCapacity);
			}
		}

		void ResizeNoConstruct(const void* a_heapAddr, UPInt a_newSize)
		{
			UPInt oldSize = size;

			if (a_newSize < oldSize) {
				Allocator::DestructArray(data + a_newSize, oldSize - a_newSize);
				if (a_newSize < (policy.GetCapacity() >> 1)) {
					Reserve(a_heapAddr, a_newSize);
				}
			} else if (a_newSize >= policy.GetCapacity()) {
				Reserve(a_heapAddr, a_newSize + (a_newSize >> 2));
			}
			size = a_newSize;
		}

		// members
		T*         data;    // 00
		UPInt      size;    // 08
		SizePolicy policy;  // 10
	};
}


===============================================
File: include/RE/G/GArrayDefaultPolicy.h
===============================================
#pragma once

namespace RE
{
	struct GArrayDefaultPolicy
	{
	public:
		GArrayDefaultPolicy() :
			capacity(0)
		{}

		GArrayDefaultPolicy(const GArrayDefaultPolicy&) :
			capacity(0)
		{}

		UPInt GetMinCapacity() const { return 0; }
		UPInt GetGranularity() const { return 4; }
		bool  NeverShrinking() const { return false; }

		UPInt GetCapacity() const { return capacity; }
		void  SetCapacity(UPInt a_capacity) { capacity = a_capacity; }

		// members
		UPInt capacity;  // 0
	};
	static_assert(sizeof(GArrayDefaultPolicy) == 0x8);
}


===============================================
File: include/RE/G/GArrayLH.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GArrayBase.h"
#include "RE/G/GArrayData.h"
#include "RE/G/GArrayDefaultPolicy.h"
#include "RE/G/GStats.h"

namespace RE
{
	template <class T, std::uint32_t SID = GStatGroup::kGStat_Default_Mem, class SizePolicy = GArrayDefaultPolicy>
	class GArrayLH : public GArrayBase<GArrayData<T, GAllocatorLH<T, SID>, SizePolicy>>
	{
	public:
		using ValueType = T;
		using AllocatorType = GAllocatorLH<T, SID>;
		using SizePolicyType = SizePolicy;
		using SelfType = GArrayLH<T, SID, SizePolicy>;
		using BaseType = GArrayBase<GArrayData<T, GAllocatorLH<T, SID>, SizePolicy>>;

		GArrayLH() :
			BaseType()
		{}

		GArrayLH(std::int32_t a_size) :
			BaseType(a_size)
		{}

		GArrayLH(const SizePolicyType& a_policy) :
			BaseType()
		{
			SetSizePolicy(a_policy);
		}

		GArrayLH(const SelfType& a_array) :
			BaseType(a_array)
		{}

		const SelfType& operator=(const SelfType& a_array)
		{
			BaseType::operator=(a_array);
			return *this;
		}
	};
	static_assert(sizeof(GArrayLH<void*>) == 0x18);
}


===============================================
File: include/RE/G/GAtomic.h
===============================================
#pragma once

namespace RE
{
	class GLock
	{
	public:
		class Locker
		{
		public:
			Locker(GLock* a_lock);
			~Locker();

			// members
			GLock* lock;  // 0
		};
		static_assert(sizeof(Locker) == 0x8);

		GLock(std::uint32_t a_spinCount = 0);
		~GLock();

		void operator delete(void*) = delete;

		void Lock();
		void Unlock();

		// members
		WinAPI::CRITICAL_SECTION cs;  // 00
	};
	static_assert(sizeof(GLock) == 0x28);

	template <class T>
	class GAtomicValueBase
	{
	public:
		// members
		volatile T value;  // 0
	};
	//static_assert(sizeof(GAtomicValueBase<std::int32_t>) == 0x4);

	template <class T>
	class GAtomicInt : public GAtomicValueBase<T>  // 0
	{
	public:
	};
	//static_assert(sizeof(GAtomicInt<std::int32_t>) == 0x4);
}


===============================================
File: include/RE/G/GColor.h
===============================================
#pragma once

namespace RE
{
	class GColor
	{
	public:
		struct RGB32
		{
			std::uint8_t blue;   // 0
			std::uint8_t green;  // 1
			std::uint8_t red;    // 2
			std::uint8_t alpha;  // 3
		};
		static_assert(sizeof(RGB32) == 0x4);

		union ColorData
		{
			RGB32         channels;
			std::uint32_t raw;
		};
		static_assert(sizeof(ColorData) == 0x4);

		// members
		ColorData colorData;  // 0
	};
	static_assert(sizeof(GColor) == 0x4);
}


===============================================
File: include/RE/G/GConstructorMov.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class GConstructorMov
	{
	public:
		static void Construct(void* a_ptr)
		{
			::new (a_ptr) T{};
		}

		static void Construct(void* a_ptr, const T& a_source)
		{
			::new (a_ptr) T{ a_source };
		}

		template <class S>
		static void ConstructAlt(void* a_ptr, const S& a_source)
		{
			::new (a_ptr) T{ a_source };
		}

		static void ConstructArray(void* a_ptr, UPInt a_count)
		{
			T* ptr = static_cast<T*>(a_ptr);
			for (UPInt i = 0; i < a_count; ++i) {
				Construct(ptr++);
			}
		}

		static void ConstructArray(void* a_ptr, UPInt count, const T& source)
		{
			T* ptr = (T*)a_ptr;
			for (UPInt i = 0; i < count; ++i) {
				Construct(ptr++, source);
			}
		}

		static void ConstructArray(void* a_ptr, UPInt a_count, const T* a_source)
		{
			T* ptr = (T*)a_ptr;
			for (UPInt i = 0; i < a_count; ++i) {
				Construct(ptr++, *(a_source++));
			}
		}

		static void Destruct(T* a_ptr)
		{
			a_ptr->~T();
		}

		static void DestructArray(T* a_ptr, UPInt a_count)
		{
			a_ptr += a_count - 1;
			for (UPInt i = 0; i < a_count; ++i) {
				(a_ptr--)->~T();
			}
		}

		static void CopyArrayForward(T* a_dst, const T* a_src, UPInt a_count)
		{
			std::memmove(a_dst, a_src, a_count * sizeof(T));
		}

		static void CopyArrayBackward(T* a_dst, const T* a_src, UPInt a_count)
		{
			std::memmove(a_dst, a_src, a_count * sizeof(T));
		}

		static bool IsMovable()
		{
			return true;
		}
	};
	static_assert(sizeof(GConstructorMov<void*>) == 0x1);
}


===============================================
File: include/RE/G/GEvent.h
===============================================
#pragma once

#include "RE/G/GAcquireInterface.h"
#include "RE/G/GMutex.h"
#include "RE/G/GWaitCondition.h"
#include "RE/G/GWaitable.h"

namespace RE
{
	class GEvent :
		public GWaitable,         // 00
		public GAcquireInterface  // 18
	{
	public:
		volatile bool  state;               // 20
		volatile bool  temporary;           // 21
		std::uint16_t  pad22;               // 22
		std::uint32_t  pad24;               // 24
		mutable GMutex stateMutex;          // 28
		GWaitCondition stateWaitCondition;  // 50
	};
	static_assert(sizeof(GEvent) == 0x58);
}


===============================================
File: include/RE/G/GFixedSizeHash.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class GFixedSizeHash
	{
	public:
		// http::/www.cs.yorku.ca/~oz/hash.html
		static inline UPInt SDBM_Hash(const void* a_dataIn, UPInt a_size, UPInt a_seed = 5381)
		{
			const std::uint8_t* data = static_cast<const std::uint8_t*>(a_dataIn);
			UPInt               hash = a_seed;
			while (a_size > 0) {
				hash = (hash << 16) + (hash << 6) - hash + static_cast<const UPInt>(data[a_size--]);
			}
			return hash;
		}

		UPInt operator()(const T& a_data) const
		{
			return SDBM_Hash(&a_data, sizeof(T));
		}
	};
	static_assert(sizeof(GFixedSizeHash<void*>) == 0x1);
}


===============================================
File: include/RE/G/GFxASCharacter.h
===============================================
#pragma once

#include "RE/G/GASObjectInterface.h"
#include "RE/G/GFxCharacter.h"

namespace RE
{
	class GASMovieClipObject;
	class GFxMovieDef;

	class GFxASCharacter :
		public GFxCharacter,       // 000
		public GASObjectInterface  // 098
	{
	public:
		virtual ~GFxASCharacter();  // 00

		// override (GFxCharacter)
		void Unk_01(void) override;  // 01
		void Unk_04(void) override;  // 04
		void Unk_05(void) override;  // 05
		void Unk_06(void) override;  // 06
		void Unk_07(void) override;  // 07
		void Unk_08(void) override;  // 08
		void Unk_09(void) override;  // 09
		void Unk_0A(void) override;  // 0A
		void Unk_0B(void) override;  // 0B
		void Unk_0C(void) override;  // 0C
		void Unk_22(void) override;  // 22
		void Unk_23(void) override;  // 23
		void Unk_2C(void) override;  // 2C
		void Unk_2D(void) override;  // 2D
		void Unk_2E(void) override;  // 2E
		void Unk_2F(void) override;  // 2F
		void Unk_30(void) override;  // 30

		// override (GASObjectInterface)
		void GASObjectInterface_02(void) override;                                           // 02
		void GASObjectInterface_03(void) override;                                           // 03
		void GASObjectInterface_04(void) override;                                           // 04
		void GASObjectInterface_05(void) override;                                           // 05
		void GASObjectInterface_06(void) override;                                           // 06
		void GASObjectInterface_07(void) override;                                           // 07
		void GASObjectInterface_08(void) override;                                           // 08
		void GASObjectInterface_09(void) override;                                           // 09
		void GASObjectInterface_0A(void) override;                                           // 0A
		void GASObjectInterface_0B(void) override;                                           // 0B
		void Set__proto__(GASStringContext* a_stringContext, GASObject* a_object) override;  // 0D
		void GASObjectInterface_12(void) override;                                           // 12
		void GASObjectInterface_13(void) override;                                           // 13
		void GASObjectInterface_14(void) override;                                           // 14

		// add
		virtual void                Unk_31(void);    // 31
		virtual void                Unk_32(void);    // 32
		virtual void                Unk_33(void);    // 33
		virtual void                Unk_34(void);    // 34
		virtual void                Unk_35(void);    // 35 - pure
		virtual void                Unk_36(void);    // 36
		virtual void                Unk_37(void);    // 37
		virtual void                Unk_38(void);    // 38
		virtual void                Unk_39(void);    // 39
		virtual void                Unk_3A(void);    // 3A
		virtual void                Unk_3B(void);    // 3B
		virtual void                Unk_3C(void);    // 3C
		virtual void                Unk_3D(void);    // 3D
		virtual void                Unk_3E(void);    // 3E
		virtual void                Unk_3F(void);    // 3F
		virtual void                Unk_40(void);    // 40
		virtual GASMovieClipObject* GetMovieClip();  // 41 - { return nullptr; }
		virtual void                Unk_42(void);    // 42
		virtual void                Unk_43(void);    // 43
		virtual void                Unk_44(void);    // 44
		virtual void                Unk_45(void);    // 45
		virtual void                Unk_46(void);    // 46
		virtual void                Unk_47(void);    // 47
		virtual void                Unk_48(void);    // 48
		virtual void                Unk_49(void);    // 49
		virtual void                Unk_4A(void);    // 4A
		virtual void                Unk_4B(void);    // 4B
		virtual void                Unk_4C(void);    // 4C
		virtual void                Unk_4D(void);    // 4D
		virtual void                Unk_4E(void);    // 4E
		virtual void                Unk_4F(void);    // 4F
		virtual void                Unk_50(void);    // 50
		virtual void                Unk_51(void);    // 51
		virtual void                Unk_52(void);    // 52
		virtual void                Unk_53(void);    // 53
		virtual void                Unk_54(void);    // 54
		virtual void                Unk_55(void);    // 55
		virtual void                Unk_56(void);    // 56
		virtual void                Unk_57(void);    // 57

		// members
		std::uint64_t unk0B0;    // 0B0
		std::uint64_t unk0B8;    // 0B8
		std::uint64_t unk0C0;    // 0C0
		GFxMovieDef*  movieDef;  // 0C8
		std::uint64_t unk0D0;    // 0D0
		std::uint64_t unk0D8;    // 0D0
		std::uint64_t unk0E0;    // 0D0
		std::uint64_t unk0E8;    // 0D0
		std::uint64_t unk0F0;    // 0D0
		std::uint64_t unk0F8;    // 0D0
		std::uint64_t unk100;    // 0D0
		std::uint64_t unk118;    // 0D0
	};
	static_assert(sizeof(GFxASCharacter) == 0x110);
}


===============================================
File: include/RE/G/GFxActionControl.h
===============================================
#pragma once

#include "RE/G/GFxState.h"

namespace RE
{
	class GFxActionControl : public GFxState
	{
	public:
		enum class ActionControlFlags
		{
			kNone = 0,
			kVerbose = 1 << 0,
			kSuppressErrors = 1 << 1,
			kLogRootFilenames = 1 << 2,   // Display filename for root movie
			kLogChildFilenames = 1 << 3,  // Display filename for child movie
			kLongFilenames = 1 << 4       // Display full path
		};

		inline GFxActionControl(ActionControlFlags a_actionFlags = ActionControlFlags::kLogChildFilenames) :
			GFxState(StateType::kActionControl),
			actionFlags(a_actionFlags),
			pad1C(0)
		{}

		[[nodiscard]] constexpr ActionControlFlags GetFlags() const { return *actionFlags; }
		constexpr void                             SetFlags(ActionControlFlags a_actionFlags) { actionFlags = a_actionFlags; }

		constexpr void SetVerboseLogging() noexcept { actionFlags.set(ActionControlFlags::kVerbose); }
		constexpr void UnsetVerboseLogging() noexcept { actionFlags.reset(ActionControlFlags::kVerbose); }

		constexpr void SetErrorSuppression() noexcept { actionFlags.set(ActionControlFlags::kSuppressErrors); }
		constexpr void UnsetErrorSuppression() noexcept { actionFlags.reset(ActionControlFlags::kSuppressErrors); }

		constexpr void SetRootFilenameLogging() noexcept { actionFlags.set(ActionControlFlags::kLogRootFilenames); }
		constexpr void UnsetRootFilenameLogging() noexcept { actionFlags.reset(ActionControlFlags::kLogRootFilenames); }

		constexpr void SetChildFilenameLogging() noexcept { actionFlags.set(ActionControlFlags::kLogChildFilenames); }
		constexpr void UnsetChildFilenameLogging() noexcept { actionFlags.reset(ActionControlFlags::kLogChildFilenames); }

		constexpr void SetAllFilenameLogging() noexcept { actionFlags.set(ActionControlFlags::kLogRootFilenames, ActionControlFlags::kLogChildFilenames); }
		constexpr void UnsetAllFilenameLogging() noexcept { actionFlags.reset(ActionControlFlags::kLogRootFilenames, ActionControlFlags::kLogChildFilenames); }

		constexpr void SetLongFilenameLogging() noexcept { actionFlags.set(ActionControlFlags::kLongFilenames); }
		constexpr void UnsetLongFilenameLogging() noexcept { actionFlags.reset(ActionControlFlags::kLongFilenames); }

		// members
		stl::enumeration<ActionControlFlags, std::uint32_t> actionFlags;  // 18
		std::uint32_t                                       pad1C;        // 1C
	};
	static_assert(sizeof(GFxActionControl) == 0x20);
}


===============================================
File: include/RE/G/GFxButtonCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxCharacterDef.h"

namespace RE
{
	// 0x17e8568
	class GFxButtonCharacterDef : public GFxCharacterDef
	{
	public:
		~GFxButtonCharacterDef() override;  // 00

		// override (GFxResource)
		std::uint32_t GetResourceTypeCode() const override;  // 02

		// override (GFxCharacterDef)
		virtual void          Unk_06(void);       // 06
		virtual GFxCharacter* CreateCharacter();  // 09

		// members
		std::uint64_t unk20[8];  // 20
	};
	static_assert(sizeof(GFxButtonCharacterDef) == 0x60);
}


===============================================
File: include/RE/G/GFxCharacter.h
===============================================
#pragma once

#include "RE/G/GFxLogBase.h"
#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GFxResourceID.h"
#include "RE/G/GMatrix2D.h"
#include "RE/G/GRefCountBaseWeakSupport.h"
#include "RE/G/GRenderer.h"

namespace RE
{
	class GASEnvironment;
	class GFxSprite;

	class GFxCharacter :
		public GRefCountBaseWeakSupport<GFxCharacter, GFxStatMovieViews::kGFxStatMV_MovieClip_Mem>,  // 00
		public GFxLogBase<GFxCharacter>                                                              // 18
	{
	public:
		~GFxCharacter() override;  // 00

		// add
		virtual void            Unk_01(void);      // 01
		virtual void            Unk_02(void);      // 02
		virtual void            Unk_03(void);      // 03
		virtual void            Unk_04(void);      // 04
		virtual void            Unk_05(void);      // 05
		virtual void            Unk_06(void);      // 06
		virtual void            Unk_07(void);      // 07
		virtual void            Unk_08(void);      // 08
		virtual void            Unk_09(void);      // 09
		virtual void            Unk_0A(void);      // 0A
		virtual void            Unk_0B(void);      // 0B
		virtual void            Unk_0C(void);      // 0C
		virtual void            Unk_0D(void);      // 0D
		virtual void            Unk_0E(void);      // 0E
		virtual void            Unk_0F(void);      // 0F
		virtual void            Unk_10(void);      // 10
		virtual void            Unk_11(void);      // 11
		virtual void            Unk_12(void);      // 12
		virtual void            Unk_13(void);      // 13
		virtual void            Unk_14(void);      // 14
		virtual void            Unk_15(void);      // 15
		virtual void            Unk_16(void);      // 16 - pure
		virtual void            Unk_17(void);      // 17
		virtual void            Unk_18(void);      // 18
		virtual void            Unk_19(void);      // 19
		virtual void            Unk_1A(void);      // 1A
		virtual void            Unk_1B(void);      // 1B
		virtual GASEnvironment* GetEnvironment();  // 1C
		virtual void            Unk_1D(void);      // 1D
		virtual void            Unk_1E(void);      // 1E
		virtual void            Unk_1F(void);      // 1F
		virtual void            Unk_20(void);      // 20
		virtual void            Unk_21(void);      // 21
		virtual void            Unk_22(void);      // 22
		virtual void            Unk_23(void);      // 23
		virtual void            Unk_24(void);      // 24
		virtual void            Unk_25(void);      // 25
		virtual void            Unk_26(void);      // 26
		virtual void            Unk_27(void);      // 27
		virtual void            Unk_28(void);      // 28
		virtual void            Unk_29(void);      // 29
		virtual void            Unk_2A(void);      // 2A
		virtual void            Unk_2B(void);      // 2B
		virtual void            Unk_2C(void);      // 2C
		virtual void            Unk_2D(void);      // 2D
		virtual void            Unk_2E(void);      // 2E
		virtual void            Unk_2F(void);      // 2F
		virtual void            Unk_30(void);      // 30

		// members
		GFxResourceID     resourceID;      // 20
		std::uint32_t     pad24;           // 24
		std::int64_t      createdFrame;    // 28
		GFxSprite*        parentClip;      // 30
		GRenderer::Cxform colorTransform;  // 38
		GMatrix2D         matrix;          // 58
		std::uint64_t     unk70;           // 70
		std::uint64_t     unk78;           // 78
		std::uint64_t     unk80;           // 80
		std::uint32_t     unk88;           // 88
		std::uint32_t     unk8C;           // 8C
		std::uint32_t     unk90;           // 90
		std::uint16_t     unk94;           // 94
		std::uint16_t     unk96;           // 96
	};
	static_assert(sizeof(GFxCharacter) == 0x98);
}


===============================================
File: include/RE/G/GFxCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxResource.h"
#include "RE/G/GFxResourceID.h"
#include "RE/G/GPoint.h"

namespace RE
{
	class GFxCharacter;

	class GFxCharacterDef : public GFxResource
	{
	public:
		// add
		virtual void          Unk_04(void);                                            // 04
		virtual bool          Unk_05(const GPointF& a_pt, bool a_arg2, void* a_arg3);  // 05 - { return false; }
		virtual void          Unk_06(void);                                            // 06
		virtual void          Unk_07(void);                                            // 07
		virtual std::uint32_t GetVersion();                                            // 08
		virtual GFxCharacter* CreateCharacter();                                       // 09

		// members
		GFxResourceID resourceId;  // 18
		std::uint32_t pad1C;       // 1C
	};
	static_assert(sizeof(GFxCharacterDef) == 0x20);
}


===============================================
File: include/RE/G/GFxConstShapeCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxConstShapeWithStyles.h"
#include "RE/G/GFxShapeBaseCharacterDef.h"

namespace RE
{
	class GFxConstShapeCharacterDef : public GFxShapeBaseCharacterDef
	{
	public:
		~GFxConstShapeCharacterDef() override;  // 00

		// override (GFxCharacterDef)
		void Unk_04(void) override;                                            // 04
		bool Unk_05(const GPointF& a_pt, bool a_arg2, void* a_arg3) override;  // 05
		void Unk_06(void) override;                                            // 06
		void Unk_07(void) override;                                            // 07

		// override (GFxShapeBaseCharacterDef)
		void Unk_0A(void) override;  // 0A
		void Unk_0B(void) override;  // 0B
		void Unk_0C(void) override;  // 0C
		void Unk_0D(void) override;  // 0D
		void Unk_0E(void) override;  // 0E
		void Unk_0F(void) override;  // 0F
		void Unk_10(void) override;  // 10
		void Unk_11(void) override;  // 11

		// add
		virtual void Unk_12(void);  // 12
		virtual void Unk_13(void);  // 13
		virtual void Unk_14(void);  // 14
		virtual void Unk_15(void);  // 15

		// members
		GFxConstShapeWithStyles shape;  // 20
	};
	static_assert(sizeof(GFxConstShapeCharacterDef) == 0x98);
}


===============================================
File: include/RE/G/GFxConstShapeNoStyles.h
===============================================
#pragma once

#include "RE/G/GFxShapeBase.h"

namespace RE
{
	class GFxConstShapeNoStyles : public GFxShapeBase
	{
		~GFxConstShapeNoStyles() override;  // 00

		// override (GFxShapeBase)
		bool         HitTest(const GPointF& a_pt, bool a_arg2, void* a_arg3) override;  // 03
		void         Unk_04(void* a_arg1, float a_arg2, void* a_arg3) override;         // 04
		void         Unk_05(GRectF& a_arg1) override;                                   // 05
		void         Unk_06(void* a_arg1, float a_arg2) override;                       // 06
		void         Unk_07(void) override;                                             // 07
		bool         Unk_08(void* a_arg1) override;                                     // 08
		void*        Unk_0F(void) override;                                             // 0F
		std::int32_t Unk_10(void) override;                                             // 10
		void         Unk_11(std::int32_t* a_arg1, std::int32_t* a_arg2) override;       // 11
		void*        Unk_12(void) override;                                             // 12

		// members
		std::uint64_t unk40;  // 40
	};
	static_assert(sizeof(GFxConstShapeNoStyles) == 0x48);
}


===============================================
File: include/RE/G/GFxConstShapeWithStyles.h
===============================================
#pragma once

#include "RE/G/GFxConstShapeNoStyles.h"

namespace RE
{
	class GFxConstShapeWithStyles : public GFxConstShapeNoStyles
	{
		~GFxConstShapeWithStyles() override;

		// override (GFxShapeBase)
		void* GetBounds(GRectF& a_arg1) const override;                                                          // 01
		void  SetBounds(GRectF& a_arg1) override;                                                                // 02
		void  Unk_04(void* a_arg1, float a_arg2, void* a_arg3) override;                                         // 04
		void* GetFillStyles(std::int32_t& a_arg1) const override;                                                // 09
		void* GetLineStyles(std::int32_t& a_arg1) const override;                                                // 0A
		void  GetStyles(void* a_arg1) const override;                                                            // 0B
		void  GetStyles(void* a_arg1, std::int32_t* a_arg2, void* a_arg3, std::int32_t* a_arg4) const override;  // 0C
		void  SetPercent(float a_arg1) override;                                                                 // 0D
		float GetPercent() const override;                                                                       // 0E

		// members
		std::uint64_t unk48;        // 48
		std::uint64_t unk50;        // 50
		std::uint32_t unk58;        // 58
		std::uint32_t unk5C;        // 5C
		float         percent;      // 60
		GRectF        shapeBounds;  // 64
		std::uint32_t pad74;        // 74
	};
	static_assert(sizeof(GFxConstShapeWithStyles) == 0x78);
}


===============================================
File: include/RE/G/GFxEditTextCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxCharacterDef.h"

namespace RE
{
	class GFxEditTextCharacterDef : public GFxCharacterDef
	{
	public:
		~GFxEditTextCharacterDef() override;  // 00

		// override (GFxResource)
		std::uint32_t GetResourceTypeCode() const override;  // 02

		// override (GFxCharacterDef)
		virtual GFxCharacter* CreateCharacter();  // 09

		// members
		std::uint64_t unk20[11];  // 20
	};
	static_assert(sizeof(GFxEditTextCharacterDef) == 0x78);
}


===============================================
File: include/RE/G/GFxEvent.h
===============================================
#pragma once

#include "RE/G/GFxKey.h"
#include "RE/G/GFxSpecialKeysState.h"
#include "RE/G/GNewOverrideBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxEvent : public GNewOverrideBase<GStatGroups::kGStat_Default_Mem>
	{
	public:
		enum class EventType
		{
			kNone,

			// Informative events sent to the player.
			kMouseMove,
			kMouseDown,
			kMouseUp,
			kMouseWheel,
			kKeyDown,
			kKeyUp,
			kSceneResize,
			kSetFocus,
			kKillFocus,

			// Action events, to be handled by user.
			kDoShowMouse,
			kDoHideMouse,
			kDoSetMouseCursor,

			kCharEvent,
			kIMEEvent
		};

		GFxEvent(EventType a_eventType = EventType::kNone) :
			GNewOverrideBase<GStatGroups::kGStat_Default_Mem>(),
			type(a_eventType)
		{}

		// members
		stl::enumeration<EventType, std::uint32_t> type;  // 0
	};
	static_assert(sizeof(GFxEvent) == 0x4);

	class GFxMouseEvent : public GFxEvent
	{
	public:
		inline GFxMouseEvent() :
			GFxEvent(),
			x(0.0),
			y(0.0),
			scrollDelta(0.0),
			button(0),
			mouseIndex(0)
		{}

		inline GFxMouseEvent(EventType a_eventType, std::uint32_t a_button, float a_x, float a_y, float a_scrollDelta = 0.0, std::uint32_t a_mouseIndex = 0) :
			GFxEvent(a_eventType),
			x(a_x),
			y(a_y),
			scrollDelta(a_scrollDelta),
			button(a_button),
			mouseIndex(a_mouseIndex)
		{}

		inline GFxMouseEvent(EventType a_eventType, std::uint32_t a_mouseIndex) :
			GFxEvent(a_eventType),
			x(0.0),
			y(0.0),
			scrollDelta(0.0),
			button(0),
			mouseIndex(a_mouseIndex)
		{}

		// members
		float         x;            // 04
		float         y;            // 08
		float         scrollDelta;  // 0C
		std::uint32_t button;       // 10
		std::uint32_t mouseIndex;   // 14
	};
	static_assert(sizeof(GFxMouseEvent) == 0x18);

	class GFxKeyEvent : public GFxEvent
	{
	public:
		inline GFxKeyEvent() :
			GFxEvent(),
			keyCode(GFxKey::kVoidSymbol),
			asciiCode(0),
			pad09(0),
			pad0B(0),
			wCharCode(0),
			specialKeyState(),
			keyboardIndex(0),
			pad12(0)
		{}

		inline GFxKeyEvent(EventType a_eventType, GFxKey::Code a_keyCode, std::uint8_t a_ascii, std::uint32_t a_wchar, GFxSpecialKeysState a_specialKeyState, std::uint8_t a_keyboardIndex = 0) :
			GFxEvent(a_eventType),
			keyCode(a_keyCode),
			asciiCode(a_ascii),
			pad09(0),
			pad0B(0),
			wCharCode(a_wchar),
			specialKeyState(a_specialKeyState),
			keyboardIndex(a_keyboardIndex),
			pad12(0)
		{}

		// members
		GFxKey::Code        keyCode;          // 04
		std::uint8_t        asciiCode;        // 08
		std::uint8_t        pad09;            // 09
		std::uint16_t       pad0B;            // 0B
		std::uint32_t       wCharCode;        // 0C
		GFxSpecialKeysState specialKeyState;  // 10
		std::uint8_t        keyboardIndex;    // 11
		std::uint16_t       pad12;            // 12
	};
	static_assert(sizeof(GFxKeyEvent) == 0x14);
}


===============================================
File: include/RE/G/GFxExternalInterface.h
===============================================
#pragma once

#include "RE/G/GFxState.h"

namespace RE
{
	class GFxMovieView;
	class GFxValue;

	class GFxExternalInterface : public GFxState
	{
	public:
		inline static constexpr auto RTTI = RTTI_GFxExternalInterface;

		GFxExternalInterface() :
			GFxState(StateType::kExternalInterface)
		{}

		~GFxExternalInterface() override = default;  // 00

		// add
		virtual void Callback(GFxMovieView* a_movieView, const char* a_methodName, const GFxValue* a_args, std::uint32_t a_numArgs) = 0;  // 01
	};
	static_assert(sizeof(GFxExternalInterface) == 0x18);
}


===============================================
File: include/RE/G/GFxFileConstants.h
===============================================
#pragma once

namespace RE
{
	class GFxFileConstants
	{
	public:
		// FileFormatType is an enumeration including all file formats supported and/or used by GFx.
		enum class FileFormatType
		{
			kUnopened,  // No attempt was made to open file, so its format is not yet determined
			kUnknown,   // The file was opened, but its format is unknown

			// Swf file formats
			kSWF,  // SWF file formats
			kGFX,  // GFX file format (extracted SWF)

			// Image formats supported by swf
			kJPEG = 10,  // JPEG image file format
			kPNG = 11,   // PNG image file format
			kGIF = 12,   // GIF image file format
			// Other image formats
			kTGA = 13,   // TGA image file format
			kDDS = 14,   // DDS compressed texture file format
			kHDR = 15,   // HDR image file format
			kBMP = 16,   // BMP image file format
			kDIB = 17,   // DIB image file format
			kPFM = 18,   // PFM image file format
			kTIFF = 19,  // TIFF image file format

			// Sound formats
			kWAVE = 20,  // WAVE sound file format

			kNextAvail,
			kOriginal = 65535
		};
	};
}


===============================================
File: include/RE/G/GFxFunctionHandler.h
===============================================
#pragma once

#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxValue;
	class GFxMovie;

	class GFxFunctionHandler : public GRefCountBase<GFxFunctionHandler, GStatGroups::kGStat_Default_Mem>
	{
	public:
		inline static constexpr auto RTTI = RTTI_GFxFunctionHandler;

		struct Params
		{
			GFxValue* const     retVal;           // 00
			GFxMovie* const     movie;            // 08
			GFxValue* const     thisPtr;          // 10
			GFxValue* const     argsWithThisRef;  // 18
			GFxValue* const     args;             // 20
			const std::uint32_t argCount;         // 28
			const std::uint32_t pad2C;            // 2C
			void* const         userData;         // 30
		};
		static_assert(sizeof(Params) == 0x38);

		virtual ~GFxFunctionHandler() = default;  // 00

		// add
		virtual void Call(Params& a_params) = 0;  // 01
	};
	static_assert(sizeof(GFxFunctionHandler) == 0x10);
}


===============================================
File: include/RE/G/GFxInitImportActions.h
===============================================
#pragma once

#include "RE/G/GASExecuteTag.h"

namespace RE
{
	class GFxInitImportActions : public GASExecuteTag
	{
	public:
		virtual ~GFxInitImportActions();  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		bool Unk_05(void) override;                   // 05

		// members
		std::uint32_t movieIndex;  // 08
		std::uint32_t pad0C;       // 0C
	};
	static_assert(sizeof(GFxInitImportActions) == 0x10);
}


===============================================
File: include/RE/G/GFxKey.h
===============================================
#pragma once

namespace RE
{
	class GFxKey
	{
	public:
		enum Code : std::uint32_t
		{
			kVoidSymbol = 0,

			// A through Z and numbers 0 through 9.
			kA = 65,
			kB,
			kC,
			kD,
			kE,
			kF,
			kG,
			kH,
			kI,
			kJ,
			kK,
			kL,
			kM,
			kN,
			kO,
			kP,
			kQ,
			kR,
			kS,
			kT,
			kU,
			kV,
			kW,
			kX,
			kY,
			kZ,
			kNum0 = 48,
			kNum1,
			kNum2,
			kNum3,
			kNum4,
			kNum5,
			kNum6,
			kNum7,
			kNum8,
			kNum9,

			// Numeric keypad.
			kKP_0 = 96,
			kKP_1,
			kKP_2,
			kKP_3,
			kKP_4,
			kKP_5,
			kKP_6,
			kKP_7,
			kKP_8,
			kKP_9,
			kKP_Multiply,
			kKP_Add,
			kKP_Enter,
			kKP_Subtract,
			kKP_Decimal,
			kKP_Divide,

			// Function keys.
			kF1 = 112,
			kF2,
			kF3,
			kF4,
			kF5,
			kF6,
			kF7,
			kF8,
			kF9,
			kF10,
			kF11,
			kF12,
			kF13,
			kF14,
			kF15,

			// Other keys.
			kBackspace = 8,
			kTab,
			kClear = 12,
			kReturn,
			kShift = 16,
			kControl,
			kAlt,
			kPause,
			kCapsLock = 20,  // Toggle
			kEscape = 27,
			kSpace = 32,
			kPageUp,
			kPageDown,
			kEnd = 35,
			kHome,
			kLeft,
			kUp,
			kRight,
			kDown,
			kInsert = 45,
			kDelete,
			kHelp,
			kNumLock = 144,     // Toggle
			kScrollLock = 145,  // Toggle

			kSemicolon = 186,
			kEqual = 187,
			kComma = 188,  // Platform specific?
			kMinus = 189,
			kPeriod = 190,  // Platform specific?
			kSlash = 191,
			kBar = 192,
			kBracketLeft = 219,
			kBackslash = 220,
			kBracketRight = 221,
			kQuote = 222,

			kOEM_AX = 0xE1,    //  'AX' key on Japanese AX kbd
			kOEM_102 = 0xE2,   //  "<>" or "\|" on RT 102-key kbd.
			kICO_HELP = 0xE3,  //  Help key on ICO
			kICO_00 = 0xE4,    //  00 key on ICO

			kTotal
		};
	};
	static_assert(sizeof(GFxKey) == 0x1);
}


===============================================
File: include/RE/G/GFxKeyboardState.h
===============================================
#pragma once

#include "RE/G/GFxEvent.h"
#include "RE/G/GFxKey.h"
#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GFxSpecialKeysState.h"
#include "RE/G/GRefCountBaseNTS.h"

namespace RE
{
	class GASStringContext;

	class GFxKeyboardState : public GRefCountBaseNTS<GFxKeyboardState, GFxStatMovieViews::kGFxStatMV_Other_Mem>
	{
	public:
		class IListener
		{
		public:
			virtual ~IListener() = default;  // 00

			// add
			virtual void OnKeyDown(GASStringContext* a_sc, int a_code, std::uint8_t a_ascii, std::uint32_t a_charCode, std::uint8_t a_keyboardIndex) = 0;  // 01
			virtual void OnKeyUp(GASStringContext* a_sc, int a_code, std::uint8_t a_ascii, std::uint32_t a_charCode, std::uint8_t a_keyboardIndex) = 0;    // 02
			virtual void Update(int a_code, std::uint8_t a_ascii, std::uint32_t a_charCode, std::uint8_t a_keyboardIndex) = 0;                             // 03
		};
		static_assert(sizeof(IListener) == 0x8);

		class KeyQueue
		{
		public:
			enum
			{
				kKeyQueueSize = 100
			};

			struct KeyRecord
			{
				std::uint32_t       charCode;          // 00
				std::uint16_t       code;              // 04
				std::uint16_t       pad06;             // 06
				GFxEvent::EventType event;             // 08
				std::uint8_t        ascii;             // 0C
				GFxSpecialKeysState specialKeysState;  // 0D
				std::uint8_t        pad0E;             // 0E
				std::uint8_t        pad0F;             // 0F
			};
			static_assert(sizeof(KeyRecord) == 0x10);

			// members
			KeyRecord     buffer[kKeyQueueSize];  // 000
			std::uint32_t putIdx;                 // 640
			std::uint32_t getIdx;                 // 644
			std::uint32_t count;                  // 648
		};
		static_assert(sizeof(KeyQueue) == 0x64C);

		// members
		IListener*   listener;                        // 010
		KeyQueue     keyQueue;                        // 018
		std::uint8_t keyboardIndex;                   // 664
		std::uint8_t keymap[GFxKey::kTotal / 8 + 1];  // 665
		bool         toggled[3];                      // 682
		std::uint8_t pad685;                          // 685
		std::uint8_t pad686;                          // 686
		std::uint8_t pad687;                          // 687
	};
	static_assert(sizeof(GFxKeyboardState) == 0x688);
}


===============================================
File: include/RE/G/GFxLoadProcess.h
===============================================
#pragma once

#include "RE/G/GFxLoaderTask.h"
#include "RE/G/GFxLogBase.h"
#include "RE/G/GFxMovieDataDef.h"
#include "RE/G/GFxStream.h"

namespace RE
{
	class GASExecuteTag;
	class GFxMovieBindProcess;
	class GFxSpriteDef;

	class GFxLoadProcess :
		public GFxLoaderTask,              // 00
		public GFxLogBase<GFxLoadProcess>  // 20
	{
	public:
		using LoadTaskData = GFxMovieDataDef::LoadTaskData;

		virtual ~GFxLoadProcess();  // 00

		struct TimelineType
		{
			enum
			{
				kMovie,
				kSprite,

				kTotal
			};
		};

		// members
		std::uint32_t          parseFlags;                              // 028
		std::uint32_t          pad02C;                                  // 02C
		GFxMovieBindProcess*   movieBindProcess;                        // 030
		LoadTaskData*          loadTaskData;                            // 038
		GFxMovieDataDef*       movieData;                               // 040
		GFxStream              stream;                                  // 048
		std::uint32_t          unk2B8;                                  // 2B8
		std::uint32_t          endOfFile;                               // 2BC
		std::uint64_t          pad2C0;                                  // 2C0
		GFxMovieLoadInfo       movieInfo;                               // 2C8
		std::uint64_t          unk338;                                  // 338
		std::uint32_t          unk340;                                  // 340
		std::uint32_t          numImportedMovies;                       // 344
		std::uint64_t          unk348;                                  // 348
		std::uint32_t          importInfoCount;                         // 350
		std::uint32_t          pad354;                                  // 354
		std::uint32_t          unk358;                                  // 358
		std::uint32_t          pad35C;                                  // 35C
		std::uint64_t          unk360;                                  // 360
		GFxImportNode*         importInfo;                              // 368
		std::uint64_t          unk370;                                  // 370
		std::uint64_t          unk378;                                  // 378
		std::uint64_t          unk380;                                  // 380
		std::uint64_t          unk388;                                  // 388
		std::int32_t           timelineType;                            // 390
		std::uint32_t          pad394;                                  // 394
		GFxSpriteDef*          loadingSprite;                           // 398
		GArray<GASExecuteTag*> loadingFrameData[TimelineType::kTotal];  // 3A0
		GArray<GASExecuteTag*> importActions;                           // 3D0
		GFxStream*             streamEx;                                // 3E8
	};
	static_assert(sizeof(GFxLoadProcess) == 0x3F0);
}


===============================================
File: include/RE/G/GFxLoadStates.h
===============================================
#pragma once

#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxFontCacheManager;
	class GFxLog;
	class GFxMovieDefBindStates;
	class GFxParseControl;
	class GFxProgressHandler;
	class GFxRenderConfig;
	class GFxResourceWeakLib;
	class GFxTaskManager;
	class GFxZlibSupport;

	class GFxLoadStates : public GRefCountBase<GFxLoadStates, GStatGroup::kGStat_Default_Mem>
	{
	public:
		~GFxLoadStates() override;  // 00

		// members
		GFxMovieDefBindStates* movieBindStates;   // 10
		GFxLog*                log;               // 18
		GFxParseControl*       parseControl;      // 20
		GFxProgressHandler*    progressHandler;   // 28
		GFxTaskManager*        taskManager;       // 30
		GFxFontCacheManager*   fontCacheManager;  // 38
		GFxRenderConfig*       renderConfig;      // 40
		GFxState*              jpegSupport;       // 48
		GFxZlibSupport*        zlibSupport;       // 50
		GFxState*              pngSupport;        // 58
		GFxResourceWeakLib*    lib;               // 60
		std::uint64_t          pad68;             // 68
		GString                fileURL;           // 70
		bool                   loadOnThread;      // 78
		std::uint8_t           pad79;             // 79
		std::uint16_t          pad7A;             // 7A
		std::uint32_t          pad7C;             // 7C
		std::uint64_t          unk80[3];          // 80
	};
	static_assert(sizeof(GFxLoadStates) == 0x98);
}


===============================================
File: include/RE/G/GFxLoadUpdateSync.h
===============================================
#pragma once

#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GMutex.h"
#include "RE/G/GRefCountBase.h"

namespace RE
{
	class GFxLoadUpdateSync : public GRefCountBase<GFxLoadUpdateSync, GFxStatMovieData::kGFxStatMD_Other_Mem>
	{
	public:
		~GFxLoadUpdateSync() override;  // 00

		// members
		GMutex mutex;  // 10
		void*  unk38;  // 38
		void*  unk40;  // 40
	};
	static_assert(sizeof(GFxLoadUpdateSync) == 0x48);
}


===============================================
File: include/RE/G/GFxLoader.h
===============================================
#pragma once

#include "RE/G/GFxLoaderImpl.h"
#include "RE/G/GFxResourceLib.h"
#include "RE/G/GFxStateBag.h"
#include "RE/G/GPtr.h"

namespace RE
{
	class GFxFileOpenerBase;
	class GFxJpegSupportBase;
	class GFxZlibSupportBase;
	class GFxLoaderImpl;
	class GFxMovieDef;
	class GFxMovieInfo;
	class GFxResourceLib;

	class GFxLoader : public GFxStateBag
	{
	public:
		enum LoadConstants : std::uint32_t
		{
			kLoadAll = 0,
			kLoadWaitCompletion = 1 << 0,
			kLoadWaitFrame1 = 1 << 1,
			kLoadOrdered = 1 << 4,
			kLoadThreadedBinding = 1 << 5,
			kLoadOnThread = 1 << 6,
			kLoadKeepBindData = 1 << 7,
			kLoadImageFiles = 1 << 16,
			kLoadDisableSWF = 1 << 19,
			kLoadDisableImports = 1 << 20,
			kLoadQuietOpen = 1 << 21,
			kLoadDebugHeap = 1 << 28
		};

		struct LoaderConfig
		{
			std::uint32_t            defLoadFlags;
			GPtr<GFxFileOpenerBase>  fileOpener;
			GPtr<GFxZlibSupportBase> zLibSupport;
			GPtr<GFxJpegSupportBase> jpegSupport;
		};

		// override (GFxStateBag)
		GFxStateBag* GetStateBagImpl() const override;  // 00

		~GFxLoader() override;  // 01

		// add
		[[nodiscard]] virtual bool CheckTagLoader(std::int32_t a_tagType) const;  // 05

		GFxMovieDef*                 CreateMovie(const char* a_filename, LoadConstants a_loadConstants = LoadConstants::kLoadAll, UPInt a_memoryArena = 0);
		[[nodiscard]] GFxLoaderImpl* GetLoaderImpl() const;

		// members
		GPtr<GFxLoaderImpl>  impl;               // 08
		GPtr<GFxResourceLib> strongResourceLib;  // 10
		std::uint32_t        defLoadFlags;       // 18
		std::uint32_t        pad1C;              // 1C
	};
	static_assert(sizeof(GFxLoader) == 0x20);
}


===============================================
File: include/RE/G/GFxLoaderImpl.h
===============================================
#pragma once

#include "RE/G/GAtomic.h"
#include "RE/G/GFxLogBase.h"
#include "RE/G/GFxStateBag.h"
#include "RE/G/GRefCountBase.h"

namespace RE
{
	class GFxStateBagImpl;

	class GFxLoaderImpl :
		public GRefCountBase<GFxLoaderImpl, GStatGroups::kGStat_Default_Mem>,  // 00
		public GFxStateBag,                                                    // 10
		public GFxLogBase<GFxLoaderImpl>                                       // 20
	{
	public:
		~GFxLoaderImpl() override;  // 00

		// members
		GFxStateBagImpl* stateBagImpl;  // 28
		std::uint64_t    pad30;         // 30
		void*            pad38;         // 38
		void*            pad40;         // 40
		GLock            lock;          // 48
		std::uint8_t     pad70;         // 70
		std::uint8_t     pad71;         // 71
		std::uint16_t    pad72;         // 72
		std::uint32_t    pad74;         // 74
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GFxLoaderImpl) == 0x78);
#endif
}


===============================================
File: include/RE/G/GFxLoaderTask.h
===============================================
#pragma once

#include "RE/G/GFxTask.h"

namespace RE
{
	class GFxLoadStates;

	class GFxLoaderTask : public GFxTask
	{
	public:
		// members
		GFxLoadStates* loadStates;  // 18
	};
	static_assert(sizeof(GFxLoaderTask) == 0x20);
}


===============================================
File: include/RE/G/GFxLog.h
===============================================
#pragma once

#include "RE/G/GFxLogBase.h"
#include "RE/G/GFxState.h"

namespace RE
{
	class GFxLog :
		public GFxState,           // 00
		public GFxLogBase<GFxLog>  // 18
	{
	public:
		inline static constexpr auto RTTI = RTTI_GFxLog;

		GFxLog();
		~GFxLog() override = default;  // 00

		// add
		virtual void LogMessageVarg(LogMessageType a_messageType, const char* a_fmt, std::va_list a_argList);  // 01

		void LogMessageByType(LogMessageType a_messageType, const char* a_fmt, ...);
	};
	static_assert(sizeof(GFxLog) == 0x20);
}


===============================================
File: include/RE/G/GFxLogBase.h
===============================================
#pragma once

#include "RE/G/GFxLogConstants.h"

namespace RE
{
	template <class Derived>
	class GFxLogBase : public GFxLogConstants
	{
	public:
		virtual ~GFxLogBase() {}  // 00

		// add
		[[nodiscard]] virtual bool IsVerboseActionErrors() const { return true; }  // 01
	};
	static_assert(sizeof(GFxLogBase<void*>) == 0x8);
}


===============================================
File: include/RE/G/GFxLogConstants.h
===============================================
#pragma once

namespace RE
{
	class GFxLogConstants
	{
	public:
		enum class LogMessageType
		{
			// *** Channels

			// The idea of message channels is that they correspond to separate
			// logs that can be displayed individually. Several message sub-types
			// can, however, be generated within the same channel. End users may
			// choose to ignore the recommended channel structure and either
			// combine all of the messages (default output), or separate them
			// further into individual logs.

			kChannel_General = 0x10,  // Used for end-user messages about I/O, errors, etc.
			kChannel_Script = 0x20,   // Used for script-related messages (bad function parameters, etc.)
			kChannel_Parse = 0x30,    // Used for parse log generated during loading
			kChannel_Action = 0x40,   // Used for action-script instruction execution log
			kChannel_Debug = 0x50,    // Reserved flag for mapping GDebug messages into single log object.
			kChannel_Mask = 0xF0,
			// Standard channel sub-types
			kMessageType_Error = 0,
			kMessageType_Warning = 1,
			kMessageType_Message = 2,

			// *** Combined Log Message types

			// General I/O errors and warnings
			kError = kChannel_General | kMessageType_Error,
			kWarning = kChannel_General | kMessageType_Warning,
			kMessage = kChannel_General | kMessageType_Message,
			// Script errors and warnings
			kScriptError = kChannel_Script | kMessageType_Error,
			kScriptWarning = kChannel_Script | kMessageType_Warning,
			kScriptMessage = kChannel_Script | kMessageType_Message,
			// Parse log messages (generated based on verbosity settings during loading)
			kParse = kChannel_Parse | 0,
			kParseShape = kChannel_Parse | 1,
			kParseMorphShape = kChannel_Parse | 2,
			kParseAction = kChannel_Parse | 3,
			// Action
			kAction = kChannel_Action | 0
		};
	};
	static_assert(sizeof(GFxLogConstants) == 0x1);
}


===============================================
File: include/RE/G/GFxMorphCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxShapeCharacterDef.h"

namespace RE
{
	class GFxMorphCharacterDef : public GFxShapeCharacterDef
	{
	public:
		~GFxMorphCharacterDef() override;

		// override (GFxCharacterDef)
		void Unk_04(void) override;                                            // 04
		bool Unk_05(const GPointF& a_pt, bool a_arg2, void* a_arg3) override;  // 05
		void Unk_07(void) override;                                            // 07

		// override (GFxShapeBaseCharacterDef)
		void Unk_0C(void) override;  // 0C
		void Unk_0D(void) override;  // 0D

		// add
		virtual void Unk_16(void);  // 16

		// members
		GFxConstShapeNoStyles* unkF0;      // F0
		std::uint64_t          unkF8[16];  // F8
	};
	static_assert(sizeof(GFxMorphCharacterDef) == 0x178);
}


===============================================
File: include/RE/G/GFxMovie.h
===============================================
#pragma once

#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GRefCountBase.h"

namespace RE
{
	class GFxFunctionHandler;
	class GFxMovieDef;
	class GFxValue;

	class GFxMovie : public GRefCountBase<GFxMovie, GFxStatMovieViews::kGFxStatMV_Other_Mem>
	{
	public:
		// PlayState describes the play state of the movie clip. When set on a Movie, affects only the root movie clip.
		enum class PlayState
		{
			kPlaying,  // The movie is playing
			kStopped   // The movie is stopped at its current clip. Child clips may still be playing
		};

		// SetVarType describes the delayed assignment queuing behavior of SetVariable and SetVariableDouble functions; the use of this flag allows developers to control the type of effect the variable assignment will have on target objects that have not yet been created at the time of SetVariable call
		enum class SetVarType
		{
			kNormal,    // Sets variable only if target movie clip containing the variable is found
			kSticky,    // Sets variable if target clip is found, otherwise queues a set until the clip is created at path. When the target clip is created, value will be lost
			kPermanent  // Sets variable applied to this and all future clips at given path
		};

		// SetArrayType sets the type of array.
		enum class SetArrayType
		{
			kInt,      // Array of 'Int'
			kDouble,   // Array of 'Double' in memory
			kFloat,    // Array of 'Float' in memory
			kString,   // Array of 'const char*'. (Deprecated; use kValue)
			kStringW,  // Array of 'const wchar_t*'. (Deprecated; use kValue)
			kValue     // Array of Value
		};

		// add
		[[nodiscard]] virtual GFxMovieDef*  GetMovieDef() const;                                                                                                                                                                 // 01 - pure - Obtains the movie definition that created this instance.
		[[nodiscard]] virtual std::uint32_t GetCurrentFrame() const;                                                                                                                                                             // 02 - pure - Obtains the currently active frame of the movie, starting with 0.
		[[nodiscard]] virtual bool          HasLooped() const;                                                                                                                                                                   // 03 - pure - Determines whether the movie clip has looped past its last frame.
		virtual void                        GotoFrame(std::uint32_t a_frameNumber);                                                                                                                                              // 04 - pure - Moves a playhead to a specified frame.
		virtual bool                        GotoLabeledFrame(const char* a_label, std::int32_t a_offset = 0);                                                                                                                    // 05 - pure - Moves a playhead to a specified frame identified by a label.
		virtual void                        SetPlayState(PlayState a_state);                                                                                                                                                     // 06 - pure - Changes playback state of the movie, allowing animation to be paused and resumed.
		[[nodiscard]] virtual PlayState     GetPlayState() const;                                                                                                                                                                // 07 - pure - Obtains the play state of the movie clip, currently either Playing or Stopped.
		virtual void                        SetVisible(bool a_visible);                                                                                                                                                          // 08 - pure - Sets the visibility state of a movie clip.
		[[nodiscard]] virtual bool          GetVisible() const;                                                                                                                                                                  // 09 - pure - Obtains the visibility state of a movie clip.
		virtual bool                        IsAvailable(const char* a_pathToVar) const;                                                                                                                                          // 0A - pure - Checks for availability of a field, method, or nested clip.
		virtual void                        CreateString(GFxValue* a_value, const char* a_string);                                                                                                                               // 0B - pure - Creates strings that are managed by ActionScript runtime.
		virtual void                        CreateStringW(GFxValue* a_value, const wchar_t* a_string);                                                                                                                           // 0C - pure - Creates wide character strings that are managed by ActionScript runtime.
		virtual void                        CreateObject(GFxValue* a_value, const char* a_className = 0, const GFxValue* a_args = 0, std::uint32_t a_numArgs = 0);                                                               // 0D - pure - Creates an instance of an ActionScript Object.
		virtual void                        CreateArray(GFxValue* a_value);                                                                                                                                                      // 0E - pure - Creates an instance of an ActionScript Array object.
		virtual void                        CreateFunction(GFxValue* a_value, GFxFunctionHandler* a_fc, void* a_userData = 0);                                                                                                   // 0F - pure - Creates a function object that wraps a C++ function.
		virtual bool                        SetVariable(const char* a_pathToVar, const GFxValue& a_value, SetVarType a_setType = SetVarType::kSticky);                                                                           // 10 - pure - Sets a variable identified by a path to a new value, specified in UTF-8 encoding.
		virtual bool                        GetVariable(GFxValue* a_val, const char* a_pathToVar) const;                                                                                                                         // 11 - pure - Obtains the value of an ActionScript variable based on its path.
		virtual bool                        SetVariableArray(SetArrayType a_type, const char* a_pathToVar, std::uint32_t a_index, const void* a_data, std::uint32_t a_count, SetVarType a_setType = SetVarType::kSticky) const;  // 12 - pure - Sets array elements in specified range to data items of specified type.
		virtual bool                        SetVariableArraySize(const char* a_pathToVar, std::uint32_t a_count, SetVarType a_setType = SetVarType::kSticky);                                                                    // 13 - pure - Sets the size of the array.
		virtual std::uint32_t               GetVariableArraySize(const char* a_pathToVar);                                                                                                                                       // 14 - pure - Returns the size of array buffer necessary for GetVariableArray.
		virtual bool                        GetVariableArray(SetArrayType a_type, const char* a_pathToVar, std::uint32_t a_index, void* a_data, std::uint32_t a_count);                                                          // 15 - pure - Populates a buffer with results from an ActionScript array.
		virtual bool                        InvokeFmt(const char* a_methodName, GFxValue* a_result, const char* a_argFmt, ...);                                                                                                  // 16 - pure - Calls an ActionScript method on the movie clip.
		virtual bool                        Invoke(const char* a_methodName, GFxValue* a_result, const GFxValue* a_args, std::uint32_t a_numArgs);                                                                               // 17 - pure - Calls an ActionScript method on the movie clip.
		virtual bool                        InvokeArgs(const char* a_methodName, GFxValue* a_result, const char* a_argFmt, std::va_list a_args);                                                                                 // 18 - pure - Invokes an ActionScript method on the movie clip using a format string followed by a variable argument list.

		static float GetRenderPixelScale();

		[[nodiscard]] std::uint32_t GetFrameCount() const;
		[[nodiscard]] float         GetFrameRate() const;
		bool                        SetVariable(const char* a_pathToVar, const char* a_value, SetVarType a_setType = SetVarType::kSticky);
		bool                        SetVariable(const char* a_pathToVar, const wchar_t* a_value, SetVarType a_setType = SetVarType::kSticky);
		bool                        SetVariableDouble(const char* a_pathToVar, double a_value, SetVarType a_setType = SetVarType::kSticky);
		double                      GetVariableDouble(const char* a_pathToVar) const;
		bool                        SetVariableArray(const char* a_pathToVar, std::uint32_t a_index, const GFxValue* a_data, std::uint32_t a_count, SetVarType a_setType = SetVarType::kSticky);
		bool                        GetVariableArray(const char* a_pathToVar, std::uint32_t a_index, GFxValue* a_data, std::uint32_t a_count);
	};
	static_assert(sizeof(GFxMovie) == 0x10);
}


===============================================
File: include/RE/G/GFxMovieBindProcess.h
===============================================
#pragma once

#include "RE/G/GFxLoaderTask.h"
#include "RE/G/GFxMovieDefImpl.h"

namespace RE
{
	class GFxImagePacker;
	class GFxMovieDataDef;

	class GFxMovieBindProcess : public GFxLoaderTask
	{
	public:
		using BindTaskData = GFxMovieDefImpl::BindTaskData;

		class ImagePackVisitor : public GFxMovieDef::ResourceVisitor
		{
		public:
			void Visit(GFxMovieDef* a_movieDef, GFxResource* a_resource, GFxResourceID a_id, const char* a_exportName) override;  // 01

			// members
			GFxImagePacker* imagePacker;
		};
		static_assert(sizeof(ImagePackVisitor) == 0x10);

		// members
		std::uint64_t    unk20;           // 20
		std::uint32_t    unk28;           // 28
		std::uint32_t    pad2C;           // 2C
		GFxImagePacker*  imagePacker;     // 30
		BindTaskData*    bindTaskData;    // 38
		GFxMovieDataDef* movieData;       // 40
		bool             stripped;        // 48
		std::uint8_t     pad49;           // 49
		std::uint16_t    pad4A;           // 4A
		std::uint32_t    pad4C;           // 4C
		GFxMovieDef*     importingMovie;  // 50
		void*            unk58;           // 58
	};
	static_assert(sizeof(GFxMovieBindProcess) == 0x60);
}


===============================================
File: include/RE/G/GFxMovieDataDef.h
===============================================
#pragma once

#include "RE/G/GArrayLH.h"
#include "RE/G/GAtomic.h"
#include "RE/G/GFxLoadUpdateSync.h"
#include "RE/G/GFxResourceReport.h"
#include "RE/G/GFxTimelineDef.h"
#include "RE/G/GHashSet.h"
#include "RE/G/GHashUncached.h"
#include "RE/G/GPtr.h"
#include "RE/G/GRect.h"
#include "RE/G/GRefCountBase.h"
#include "RE/G/GStringHash.h"

namespace RE
{
	class GFxLog;

	struct GFxMovieLoadInfo
	{
		std::uint32_t totalBytes;  // 00
		std::uint32_t version;     // 04
		GRectF        frameRect;   // 08
		float         frameRate;   // 18
		std::uint32_t frameCount;  // 1C
		std::uint32_t swfFlags;    // 20
		std::uint32_t unk24;       // 24
		std::uint64_t unk28;       // 28
		std::uint64_t unk30;       // 30
		std::uint64_t unk38;       // 38
		std::uint16_t unk40;       // 40
		std::uint16_t pad42;       // 42
		std::uint32_t unk44;       // 44
		GString       unk48;       // 48
		GString       unk50;       // 50
		void*         unk58;       // 58
		std::uint64_t unk60;       // 60
		std::uint64_t unk68;       // 68
	};
	static_assert(sizeof(GFxMovieLoadInfo) == 0x70);

	struct GFxResourceSource
	{
		enum SourceType : std::int32_t
		{
			kNormal,
			kImported,
		};

		struct ImportSource
		{
			std::uint32_t index;
			std::uint32_t unk04;
		};

		union ResourceUnion
		{
			GFxResource* resource;
			ImportSource importSource;
		};

		SourceType    type;   // 00
		std::uint32_t pad04;  // 04
		ResourceUnion data;   // 08
	};
	static_assert(sizeof(GFxResourceSource) == 0x10);

	struct GFxImportNode
	{
		struct ImportAssetInfo
		{
			GString       name;         // 00
			std::uint32_t id;           // 08
			std::uint32_t importIndex;  // 0C
		};
		static_assert(sizeof(ImportAssetInfo) == 0x10);

		GArray<ImportAssetInfo> assets;       // 00
		GString                 filename;     // 18
		std::uint32_t           frame;        // 20
		std::uint32_t           movieIndex;   // 24
		GFxImportNode*          nextInChain;  // 28
	};
	static_assert(sizeof(GFxImportNode) == 0x30);

	class GFxMovieDataDef :
		public GFxTimelineDef,    // 00
		public GFxResourceReport  // 20
	{
	public:
		class Allocator
		{
		public:
			void* Alloc(std::size_t a_size);
			void  Free();

			// members
			void*         allocPtr;      // 00
			std::uint64_t memAvailable;  // 08
			void*         lastBlock;     // 10
			GMemoryHeap*  heap;          // 18
		};

		class LoadTaskDataBase : public GRefCountBase<LoadTaskDataBase, GFxStatMovieData::kGFxStatMD_Other_Mem>
		{
		public:
			// members
			Allocator allocator;  // 10
			void*     unk30;      // 30
		};
		static_assert(sizeof(LoadTaskDataBase) == 0x38);

		class LoadTaskData : public LoadTaskDataBase
		{
		public:
			using ResourceHash = GHashUncached<GFxResourceID, GFxResourceSource, GFxResourceID::HashOp>;

			~LoadTaskData() override;  // 00

			// add
			virtual void AddFrameName(GString* a_label, GFxLog* a_log);  // 01
			virtual void SetMovieTagArray(ExecuteTagList* a_data);       // 02
			virtual void SetImportTagArray(ExecuteTagList* a_data);      // 03

			// members
			GMemoryHeap*              loadDataHeap;           // 038
			GMemoryHeap*              imageHeap;              // 040
			GString                   fileURL;                // 048
			GFxMovieLoadInfo          movieInfo;              // 050
			std::uint32_t             fileAttributes;         // 0C0
			std::uint32_t             padC4;                  // 0C4
			void*                     metadata;               // 0C8
			std::uint32_t             metadataSize;           // 0D0
			std::uint32_t             loadStatus;             // 0D4 - 1 when file loaded, 2 when loading finished, 4 if error?
			std::int32_t              frameLoading;           // 0D8
			std::uint8_t              unkDC;                  // 0DC
			std::uint8_t              padDD;                  // 0DD
			std::uint16_t             padDE;                  // 0DE
			std::uint32_t             unkE0;                  // 0E0
			std::uint32_t             padE4;                  // 0E4
			GPtr<GFxLoadUpdateSync>   updateSync;             // 0E8
			std::uint64_t             unkF0;                  // 0F0
			std::uint64_t             unkF8;                  // 0F8
			GFxImportNode*            importInfoBegin;        // 100
			GFxImportNode*            importInfoEnd;          // 108
			std::uint64_t             unk110;                 // 110
			std::uint64_t             unk118;                 // 118
			std::uint64_t             unk120;                 // 120
			std::uint64_t             unk128;                 // 128
			std::uint32_t             importedResourceCount;  // 130
			std::uint32_t             pad134;                 // 134
			GLock                     resourceLock;           // 138
			ResourceHash              resources;              // 160
			std::uint64_t             unk168;                 // 168
			std::uint64_t             unk170;                 // 170
			GLock                     frameLock;              // 178
			GArrayLH<ExecuteTagList>  movieFrames;            // 1A0
			GArrayLH<ExecuteTagList>  importFrames;           // 1B8
			std::int32_t              importFrameCount;       // 1D0
			std::uint32_t             pad1D4;                 // 1D4
			GStringHash<std::int32_t> frameLabels;            // 1D8
			std::uint64_t             unk1E0;                 // 1E0
		};
		static_assert(sizeof(LoadTaskData) == 0x1E8);

		~GFxMovieDataDef() override;  // 00

		// override (GFxResource)
		GFxResourceKey     GetKey() override;                     // 01
		std::uint32_t      GetResourceTypeCode() const override;  // 02
		GFxResourceReport* GetResourceReport() override;          // 03

		// override (GFxCharacterDef)
		std::uint32_t GetVersion() override;  // 08

		// override (GFxTimelineDef)
		std::uint32_t   GetFrameCount() override;                                                                 // 0A
		ExecuteTagList* GetMovieTagArray(ExecuteTagList& a_data, std::int32_t a_frameNumber) override;            // 0B
		ExecuteTagList* GetImportTagArray(ExecuteTagList& a_data, std::int32_t a_frameNumber) override;           // 0C
		bool            GetLabeledFrame(const char* a_label, std::int32_t& a_frameNumber, bool a_arg3) override;  // 0D

		// add
		virtual void          Unk_0E(void);   // 0E
		virtual std::uint32_t GetSWFFlags();  // 0F

		// members
		GFxResourceKey*    resourceKey;   // 28
		void*              unk30;         // 30
		std::uint32_t      fileFormat;    // 38
		std::uint32_t      pad3C;         // 3C
		GPtr<LoadTaskData> loadTaskData;  // 40
	};
	static_assert(sizeof(GFxMovieDataDef) == 0x48);
}


===============================================
File: include/RE/G/GFxMovieDef.h
===============================================
#pragma once

#include "RE/G/GFxResource.h"
#include "RE/G/GFxResourceID.h"
#include "RE/G/GFxStateBag.h"
#include "RE/G/GMemoryHeap.h"
#include "RE/G/GRect.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GASRefCountCollector;
	class GASStringManager;
	class GFxExporterInfo;
	class GFxMovieView;

	// Represents loaded shared data for an SWF movie file. These objects are normally created by Loader::CreateMovie and are shared by all movie instances.
	class GFxMovieDef :
		public GFxResource,  // 00
		public GFxStateBag   // 18
	{
	public:
		// SWF 8 file attributes, returned by GetFileAttributes. These attributes are configured in Publish Settings and Document Properties dialogs of the Flash studio.
		enum FileAttrFlags : std::uint32_t
		{
			kUseNetwork = 1 << 0,  // - Indicates that "Access Network only" was selected for an SWF file in publish settings for local playback security
			kHasMetadata = 1 << 4  // - Indicates that the file has embedded metadata, available through the GetMetadata method
		};

		// VisitResourceMask defines a set of resource mask flag bits passed as a visitMask argument to VisitResources. If a given flag bit is included in the visitMask, the corresponding resource types are included in the enumeration, otherwise they are ignored.
		enum VisitResourceMask : std::uint32_t
		{
			kNestedMovies = 1 << 15,  // Indicates that resources in the imported movies should also be enumerated.

			// Types of resources to visit
			kFonts = 1 << 0,           // Font resources should be enumerated.
			kBitmaps = 1 << 1,         // Image resources with GFxResource::ResourceUse::kBitmap should be enumerated (See GFxResource::ResourceUse). These resources correspond to image shape fills used in the SWF/FLA files.
			kGradientImages = 1 << 2,  // Image resources with GFxResource::ResourceUse::kGradientBitmaps should be enumerated (See GFxResource::ResourceUse). These resources are created based on GradientParams during loading.
			kEditTextFields = 1 << 3,  // Edit text field resources should be enumerated.
			kSounds = 1 << 4,          // Sound resources should be enumerated.
			kSprite = 1 << 5,          // Sprite resources should be enumerated.

			// Combined flags
			kAllLocalImages = (kBitmaps | kGradientImages),            // Combines kBitmaps and kGradientImages.
			kAllImages = (kBitmaps | kGradientImages | kNestedMovies)  // Combines kBitmaps, kGradientImages and kNestedMovies.
		};

		struct MemoryParams
		{
			MemoryParams(UPInt a_memoryArena = 0);

			// members
			GMemoryHeap::HeapDesc desc;                      // 00
			float                 heapLimitMultiplier;       // 40
			std::uint32_t         maxCollectionRoots;        // 44
			std::uint32_t         framesBetweenCollections;  // 48
			std::uint32_t         pad4C;                     // 4C
		};
		static_assert(sizeof(MemoryParams) == 0x50);

		class MemoryContext : public GRefCountBase<MemoryContext, GStatGroups::kGStat_Default_Mem>
		{
		public:
			MemoryContext() = delete;
			~MemoryContext() override;  // 00
		};
		static_assert(sizeof(MemoryContext) == 0x10);

		class MemoryContextImpl : public MemoryContext
		{
		public:
			class HeapLimit : public GMemoryHeap::LimitHandler
			{
			public:
				~HeapLimit() override;

				// override (GMemoryHeap::LimitHandler)
				bool OnExceedLimit(GMemoryHeap* a_heap, UPInt a_overLimit) override;    // 01
				void OnFreeSegment(GMemoryHeap* a_heap, UPInt a_freeingSize) override;  // 02

				// members
				std::uint64_t unk08;  // 08
				std::uint64_t unk10;  // 10
				std::uint64_t unk18;  // 18
				std::uint64_t unk20;  // 20
				std::uint64_t unk28;  // 28
			};
			static_assert(sizeof(HeapLimit) == 0x30);

			// members
			GMemoryHeap*               heap;               // 10
			GPtr<GASRefCountCollector> refCountCollector;  // 18
			GPtr<GASStringManager>     stringManager;      // 20
			std::uint64_t              unk28;              // 28
			HeapLimit                  heapLimit;          // 30
		};
		static_assert(sizeof(MemoryContextImpl) == 0x60);

		struct ImportVisitor
		{
			virtual ~ImportVisitor();  // 00

			// add
			virtual void Visit(GFxMovieDef* a_parentDef, GFxMovieDef* a_importDef, const char* a_importedMovieFilename) = 0;  // 01
		};
		static_assert(sizeof(ImportVisitor) == 0x8);

		struct ResourceVisitor : public GFxFileConstants
		{
			virtual ~ResourceVisitor();  // 00

			// add
			virtual void Visit(GFxMovieDef* a_movieDef, GFxResource* a_resource, GFxResourceID a_id, const char* a_exportName) = 0;  // 01
		};
		static_assert(sizeof(ResourceVisitor) == 0x8);

		// add
		[[nodiscard]] virtual std::uint32_t          GetVersion() const = 0;                                                                                         // 04
		[[nodiscard]] virtual std::uint32_t          GetLoadingFrame() const = 0;                                                                                    // 05
		[[nodiscard]] virtual float                  GetWidth() const = 0;                                                                                           // 06
		[[nodiscard]] virtual float                  GetHeight() const = 0;                                                                                          // 07
		[[nodiscard]] virtual std::uint32_t          GetFrameCount() const = 0;                                                                                      // 08
		[[nodiscard]] virtual float                  GetFrameRate() const = 0;                                                                                       // 09
		[[nodiscard]] virtual GRectF                 GetFrameRect() const = 0;                                                                                       // 0A
		[[nodiscard]] virtual std::uint32_t          GetSWFFlags() const = 0;                                                                                        // 0B
		[[nodiscard]] virtual const char*            GetFileURL() const = 0;                                                                                         // 0C
		virtual void                                 WaitForLoadFinish(bool a_cancel = false) const = 0;                                                             // 0D
		virtual void                                 WaitForFrame(std::uint32_t a_frame) const = 0;                                                                  // 0E
		[[nodiscard]] virtual std::uint32_t          GetFileAttributes() const = 0;                                                                                  // 0F
		virtual std::uint32_t                        GetMetadata(char* a_buff, std::uint32_t a_buffSize) const = 0;                                                  // 10
		[[nodiscard]] virtual GMemoryHeap*           GetLoadDataHeap() const = 0;                                                                                    // 11
		[[nodiscard]] virtual GMemoryHeap*           GetBindDataHeap() const = 0;                                                                                    // 12
		[[nodiscard]] virtual GMemoryHeap*           GetImageHeap() const = 0;                                                                                       // 13
		[[nodiscard]] virtual GFxResource*           GetMovieDataResource() const = 0;                                                                               // 14
		[[nodiscard]] virtual const GFxExporterInfo* GetExporterInfo() const = 0;                                                                                    // 15
		virtual MemoryContext*                       CreateMemoryContext(const char* a_heapName, const MemoryParams& a_memParams, bool a_debugHeap) = 0;             // 16
		virtual GFxMovieView*                        CreateInstance(MemoryContext* a_memContext, bool a_initFirstFrame = true) = 0;                                  // 17
		virtual GFxMovieView*                        CreateInstance(const MemoryParams& a_memParams, bool a_initFirstFrame = true) = 0;                              // 18
		virtual void                                 VisitImportedMovies(ImportVisitor* a_visitor) = 0;                                                              // 19
		virtual void                                 VisitResources(ResourceVisitor* a_visitor, VisitResourceMask a_visitMask = VisitResourceMask::kAllImages) = 0;  // 1A
		virtual GFxResource*                         GetResource(const char* a_exportName) const = 0;                                                                // 1B

		GFxMovieView* CreateInstance(bool a_initFirstFrame = true, UPInt a_memoryArena = 0);
	};
	static_assert(sizeof(GFxMovieDef) == 0x20);
}


===============================================
File: include/RE/G/GFxMovieDefBindStates.h
===============================================
#pragma once

#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxFileOpenerBase;
	class GFxGradientParams;
	class GFxURLBuilder;
	class GFxImageCreator;
	class GFxImportVisitor;
	class GFxFontPackParams;
	class GFxFontCompactorParams;
	class GFxImagePackParamsBase;
	class GFxPreprocessParams;

	class GFxMovieDefBindStates : public GRefCountBase<GFxMovieDefBindStates, GStatGroup::kGStat_Default_Mem>
	{
	public:
		~GFxMovieDefBindStates() override;  // 00

		// members
		GFxFileOpenerBase*      fileOpener;           // 10
		GFxURLBuilder*          urlBuilder;           // 18
		GFxImageCreator*        imageCreator;         // 20
		GFxImportVisitor*       importVisitor;        // 28
		GFxGradientParams*      gradientParams;       // 30
		GFxFontPackParams*      fontPackParams;       // 38
		GFxPreprocessParams*    preprocessParams;     // 40
		GFxFontCompactorParams* fontCompactorParams;  // 48
		GFxImagePackParamsBase* imagePackerParams;    // 50
	};
	static_assert(sizeof(GFxMovieDefBindStates) == 0x58);
}


===============================================
File: include/RE/G/GFxMovieDefImpl.h
===============================================
#pragma once

#include "RE/G/GAtomic.h"
#include "RE/G/GFxLoadUpdateSync.h"
#include "RE/G/GFxMovieDef.h"
#include "RE/G/GFxResource.h"
#include "RE/G/GFxResourceKey.h"
#include "RE/G/GFxResourceLib.h"
#include "RE/G/GPtr.h"
#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxMovieDefImpl : public GFxMovieDef
	{
	public:
		struct ImportData;

		struct ImportedResource
		{
			GPtr<GFxResource> resource;    // 00
			ImportData*       importData;  // 08
		};

		struct ImportData
		{
			GMemoryHeap*      heap;           // 00
			std::uint32_t     importCount;    // 08
			std::uint32_t     pad0C;          // 0C
			ImportedResource* resourceArray;  // 10
			GLock             lock;           // 18
			bool              hasImports;     // 40
			std::uint8_t      pad41;          // 41
			std::uint16_t     pad42;          // 42
			std::uint32_t     pad44;          // 44
			GFxMovieDef*      movieDef;       // 48
		};
		static_assert(sizeof(ImportData) == 0x50);

		class BindTaskData : public GRefCountBase<BindTaskData, GStatGroups::kGStat_Default_Mem>
		{
		public:
			virtual ~BindTaskData();  // 00

			// members
			GMemoryHeap*            bindDataHeap;       // 10
			GFxMovieDataDef*        movieDataResource;  // 18
			GFxMovieDefImpl*        unk20;              // 20
			std::uint32_t           unk28;              // 28
			std::uint32_t           pad2C;              // 2C
			ImportData              importData;         // 30
			GArray<GFxMovieDef*>    importedMovies;     // 80
			GLock                   lock;               // 98
			std::uint64_t           unkC0;              // C0
			std::uint64_t           unkC8;              // C8
			std::uint64_t           unkD0;              // D0
			std::uint32_t           taskState;          // D8
			std::uint32_t           padDC;              // DC
			GPtr<GFxLoadUpdateSync> updateSync;         // E0
			std::uint32_t           loadingFrame;       // E8
			std::uint32_t           bytesLoaded;        // EC
			bool                    hasError;           // F0
			std::uint8_t            padF1;              // F1
			std::uint16_t           padF2;              // F2
			std::uint32_t           padF4;              // F4
		};
		static_assert(sizeof(BindTaskData) == 0xF8);

		virtual ~GFxMovieDefImpl();  // 00

		// add
		virtual GFxResource* GetFont(const char* a_name, std::uint32_t a_fontFlags, std::int32_t& a_arg3);  // 1C

		// members
		GPtr<GFxStateBagImpl>       stateBagImpl;     // 20
		void*                       unk28;            // 28
		GPtr<GFxMovieDefBindStates> movieBindStates;  // 30
		GPtr<BindTaskData>          bindTaskData;     // 38
	};
	static_assert(sizeof(GFxMovieDefImpl) == 0x40);
}


===============================================
File: include/RE/G/GFxMovieImageLoadTask.h
===============================================
#pragma once

#include "RE/G/GFxLoaderTask.h"

namespace RE
{
	class GFxMovieImageLoadTask : public GFxLoaderTask
	{
	public:
		~GFxMovieImageLoadTask() override;  // 00

		// members
		void*         unk20;  // 20
		void*         unk28;  // 28
		void*         unk30;  // 30
		std::uint64_t unk38;  // 38
		std::uint64_t unk40;  // 40
	};
	static_assert(sizeof(GFxMovieImageLoadTask) == 0x48);
}


===============================================
File: include/RE/G/GFxMovieRoot.h
===============================================
#pragma once

#include "RE/G/GColor.h"
#include "RE/G/GFxKeyboardState.h"
#include "RE/G/GFxMovieView.h"

namespace RE
{
	class GFxSprite;

	class GFxActionPriority
	{
	public:
	};
	static_assert(sizeof(GFxActionPriority) == 0x1);

	class GFxMovieRoot :
		public GFxMovieView,      // 0000
		public GFxActionPriority  // 0018
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kDirty = 1 << 10,
			kMovieFocused = 1 << 18,
			kPaused = 1 << 20
		};

		~GFxMovieRoot() override;  // 00

		// override (GFxMovieView)
		GFxMovieDef*                GetMovieDef() const override;                                                                                                                                                                 // 01 - Obtains the movie definition that created this instance.
		std::uint32_t               GetCurrentFrame() const override;                                                                                                                                                             // 02 - Obtains the currently active frame of the movie, starting with 0.
		bool                        HasLooped() const override;                                                                                                                                                                   // 03 - Determines whether the movie clip has looped past its last frame.
		void                        GotoFrame(std::uint32_t a_frameNumber) override;                                                                                                                                              // 04 - Moves a playhead to a specified frame.
		bool                        GotoLabeledFrame(const char* a_label, std::int32_t a_offset = 0) override;                                                                                                                    // 05 - Moves a playhead to a specified frame identified by a label.
		void                        SetPlayState(PlayState a_state) override;                                                                                                                                                     // 06 - Changes playback state of the movie, allowing animation to be paused and resumed.
		PlayState                   GetPlayState() const override;                                                                                                                                                                // 07 - Obtains the play state of the movie clip, currently either Playing or Stopped.
		void                        SetVisible(bool a_visible) override;                                                                                                                                                          // 08 - Sets the visibility state of a movie clip.
		bool                        GetVisible() const override;                                                                                                                                                                  // 09 - Obtains the visibility state of a movie clip.
		bool                        IsAvailable(const char* a_pathToVar) const override;                                                                                                                                          // 0A - Checks for availability of a field, method, or nested clip.
		void                        CreateString(GFxValue* a_value, const char* a_string) override;                                                                                                                               // 0B - Creates strings that are managed by ActionScript runtime.
		void                        CreateStringW(GFxValue* a_value, const wchar_t* a_string) override;                                                                                                                           // 0C - Creates wide character strings that are managed by ActionScript runtime.
		void                        CreateObject(GFxValue* a_value, const char* a_className = 0, const GFxValue* a_args = 0, std::uint32_t a_numArgs = 0) override;                                                               // 0D - Creates an instance of ActionScript Object.
		void                        CreateArray(GFxValue* a_value) override;                                                                                                                                                      // 0E - Creates an instance of an ActionScript Array object.
		void                        CreateFunction(GFxValue* a_value, GFxFunctionHandler* a_fc, void* a_userData = 0) override;                                                                                                   // 0F - Creates a function object that wraps a C++ function.
		bool                        SetVariable(const char* a_pathToVar, const GFxValue& a_value, SetVarType a_setType = SetVarType::kSticky) override;                                                                           // 10 - Sets a variable identified by a path to a new value, specified in UTF-8 encoding.
		bool                        GetVariable(GFxValue* a_val, const char* a_pathToVar) const override;                                                                                                                         // 11 - Obtains the value of an ActionScript variable based on its path.
		bool                        SetVariableArray(SetArrayType a_type, const char* a_pathToVar, std::uint32_t a_index, const void* a_data, std::uint32_t a_count, SetVarType a_setType = SetVarType::kSticky) const override;  // 12 - Sets array elements in specified range to data items of specified type.
		bool                        SetVariableArraySize(const char* a_pathToVar, std::uint32_t a_count, SetVarType a_setType = SetVarType::kSticky) override;                                                                    // 13 - Sets the size of the array.
		std::uint32_t               GetVariableArraySize(const char* a_pathToVar) override;                                                                                                                                       // 14 - Returns the size of array buffer necessary for GetVariableArray.
		bool                        GetVariableArray(SetArrayType a_type, const char* a_pathToVar, std::uint32_t a_index, void* a_data, std::uint32_t a_count) override;                                                          // 15 - Populates a buffer with results from an ActionScript array.
		bool                        Invoke(const char* a_methodName, GFxValue* a_result, const GFxValue* a_args, std::uint32_t a_numArgs) override;                                                                               // 16 - Calls an ActionScript method on the movie clip.
		bool                        InvokeFmt(const char* a_methodName, GFxValue* a_result, const char* a_argFmt, ...) override;                                                                                                  // 17 - Calls an ActionScript method on the movie clip.
		bool                        InvokeArgs(const char* a_methodName, GFxValue* a_result, const char* a_argFmt, std::va_list a_args) override;                                                                                 // 18 - Invokes an ActionScript method on the movie clip using a format string followed by a variable argument list.
		void                        SetViewport(const GViewport& a_viewDesc) override;                                                                                                                                            // 19 - Sets the render-target surface viewport to which the movie is scaled.
		void                        GetViewport(GViewport* a_viewDesc) const override;                                                                                                                                            // 1A - Obtains the render-target surface viewport to which the movie is scaled.
		void                        SetViewScaleMode(ScaleModeType a_type) override;                                                                                                                                              // 1B - Sets the current scale mode for the movie.
		ScaleModeType               GetViewScaleMode() const override;                                                                                                                                                            // 1C - Obtains the current scale mode for the movie.
		void                        SetViewAlignment(AlignType a_type) override;                                                                                                                                                  // 1D - Sets the current alignment mode for the movie.
		AlignType                   GetViewAlignment() const override;                                                                                                                                                            // 1E - Gets the current alignment mode for the movie.
		GRectF                      GetVisibleFrameRect() const override;                                                                                                                                                         // 1F - Obtains the currently visible rectangle.
		void                        SetPerspective3D(const GMatrix3D& a_projMatIn) override;                                                                                                                                      // 20
		void                        SetView3D(const GMatrix3D& a_viewMatIn) override;                                                                                                                                             // 21
		GRectF                      GetSafeRect() const override;                                                                                                                                                                 // 22
		void                        SetSafeRect(const GRectF& a_rect) override;                                                                                                                                                   // 23
		void                        Restart() override;                                                                                                                                                                           // 24
		float                       Advance(float a_deltaT, std::uint32_t a_frameCatchUpCount = 2) override;                                                                                                                      // 25
		void                        Display() override;                                                                                                                                                                           // 26
		void                        DisplayPrePass() override;                                                                                                                                                                    // 27
		void                        SetPause(bool a_pause) override;                                                                                                                                                              // 28
		bool                        IsPaused() const override;                                                                                                                                                                    // 29
		void                        SetBackgroundColor(const GColor a_bgColor) override;                                                                                                                                          // 2A
		void                        SetBackgroundAlpha(float a_alpha) override;                                                                                                                                                   // 2B
		float                       GetBackgroundAlpha() const override;                                                                                                                                                          // 2C
		HEResult                    HandleEvent(const GFxEvent& a_event) override;                                                                                                                                                // 2D
		void                        GetMouseState(std::uint32_t a_mouseIndex, float* a_x, float* a_y, std::uint32_t* a_buttons) override;                                                                                         // 2E
		void                        NotifyMouseState(float a_x, float a_y, std::uint32_t a_buttons, std::uint32_t a_mouseIndex = 0) override;                                                                                     // 2F
		bool                        HitTest(float a_x, float a_y, HitTestType a_testCond = HitTestType::kShapes, std::uint32_t a_controllerIdx = 0) override;                                                                     // 30
		bool                        HitTest3D(GPoint3F* a_ptOut, float a_x, float a_y, std::uint32_t a_controllerIdx = 0) override;                                                                                               // 31
		void                        SetExternalInterfaceRetVal(const GFxValue& a_val) override;                                                                                                                                   // 32
		void*                       GetUserData() const override;                                                                                                                                                                 // 33
		void                        SetUserData(void* a_data) override;                                                                                                                                                           // 34
		bool                        AttachDisplayCallback(const char* a_pathToObject, void (*a_callback)(void* a_user), void* a_user) override;                                                                                   // 35
		bool                        IsMovieFocused() const override;                                                                                                                                                              // 36
		bool                        GetDirtyFlag(bool a_doReset = true) override;                                                                                                                                                 // 37
		void                        SetMouseCursorCount(std::uint32_t a_count) override;                                                                                                                                          // 38
		std::uint32_t               GetMouseCursorCount() const override;                                                                                                                                                         // 39
		void                        SetControllerCount(std::uint32_t a_count) override;                                                                                                                                           // 3A
		std::uint32_t               GetControllerCount() const override;                                                                                                                                                          // 3B
		void                        GetStats(GStatBag* a_bag, bool a_reset = true) override;                                                                                                                                      // 3C
		GMemoryHeap*                GetHeap() const override;                                                                                                                                                                     // 3D
		void                        ForceCollectGarbage() override;                                                                                                                                                               // 3E
		GPointF                     TranslateToScreen(const GPointF& a_p, void* a_userMatrix) override;                                                                                                                           // 3F
		GRectF                      TranslateToScreen(const GRectF& a_p, void* a_userMatrix) override;                                                                                                                            // 40
		bool                        TranslateLocalToScreen(const char* a_pathToCharacter, const GPointF& a_pt, GPointF* a_presPt, void* a_userMatrix) override;                                                                   // 41
		bool                        SetControllerFocusGroup(std::uint32_t a_controllerIdx, std::uint32_t a_focusGroupIndex) override;                                                                                             // 42
		std::uint32_t               GetControllerFocusGroup(std::uint32_t a_controllerIdx) const override;                                                                                                                        // 43
		GFxMovieDef::MemoryContext* GetMemoryContext() const override;                                                                                                                                                            // 44
		void                        Release() override;                                                                                                                                                                           // 45

		// add
		virtual void Unk_46(void);  // 46
		virtual void Unk_47(void);  // 47
		virtual void Unk_48(void);  // 48

		// members
		std::uint64_t                         unk0020;                          // 0020
		GFxMovieDef::MemoryContextImpl*       memoryContext;                    // 0028
		std::uint64_t                         unk0030;                          // 0030
		GMemoryHeap*                          heap;                             // 0038
		std::uint64_t                         unk0040;                          // 0040
		std::uint64_t                         unk0048;                          // 0048
		std::uint64_t                         unk0050;                          // 0050
		GFxSprite*                            timeline;                         // 0058
		GFxMovieDef*                          movieDef;                         // 0060
		std::uint64_t                         unk0068;                          // 0068
		std::uint64_t                         unk0070;                          // 0070
		GViewport                             unk0078;                          // 0078
		std::uint64_t                         unk00B0;                          // 00B0
		std::uint64_t                         unk00B8;                          // 00B8
		ScaleModeType                         viewScaleMode;                    // 00C0
		AlignType                             viewAlignment;                    // 00C4
		GRectF                                visibleFrameRect;                 // 00C8
		std::uint64_t                         unk00D8;                          // 00D8
		GRectF                                safeRect;                         // 00E0
		std::uint64_t                         unk00F0;                          // 00F0
		std::uint64_t                         unk00F8;                          // 00F8
		GMatrix3D*                            perspective3D;                    // 0100
		std::uint64_t                         unk0108;                          // 0108
		std::uint64_t                         unk0110;                          // 0110
		std::uint64_t                         unk0118[(0x09A0 - 0x0118) >> 3];  // 0118
		GColor                                backgroundColor;                  // 09A0
		std::uint32_t                         unk09A4;                          // 09A4
		std::uint64_t                         unk09A8[(0x0A68 - 0x09A8) >> 3];  // 09A8
		std::uint32_t                         mouseCursorCount;                 // 0A68
		std::uint32_t                         controllerCount;                  // 0A6C
		void*                                 userData;                         // 0A70
		std::uint64_t                         unk0A78;                          // 0A78
		GFxKeyboardState                      keyboardState;                    // 0A80
		std::uint64_t                         unk1108[(0x24A0 - 0x1108) >> 3];  // 1108
		GASGlobalContext*                     globalContext;                    // 24A0
		std::uint64_t                         unk24A8[(0x25E0 - 0x24A8) >> 3];  // 1108
		stl::enumeration<Flag, std::uint32_t> flags;                            // 25E0
		std::uint32_t                         unk25E4;                          // 25E4
		std::uint64_t                         unk25E8[(0x2B48 - 0x25E8) >> 3];  // 25E8
		std::uint32_t                         focusGroup;                       // 2B48
		std::uint8_t                          controllerGroups[16];             // 2B4C
		std::uint32_t                         unk2B54;                          // 2B54
		std::uint64_t                         unk2B58[(0x2BE8 - 0x2B58) >> 3];  // 2B58
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GFxMovieRoot) == 0x2BF0);
#endif
}


===============================================
File: include/RE/G/GFxMovieView.h
===============================================
#pragma once

#include "RE/G/GFxMovie.h"
#include "RE/G/GFxMovieDef.h"
#include "RE/G/GFxStateBag.h"
#include "RE/G/GPoint.h"
#include "RE/G/GRect.h"
#include "RE/G/GViewport.h"

namespace RE
{
	class GColor;
	class GFxEvent;
	class GFxValue;
	class GMatrix3D;
	class GMemoryHeap;
	class GPoint3F;
	class GStatBag;
	class GViewport;

	class GFxMovieView :
		public GFxMovie,    // 00
		public GFxStateBag  // 10
	{
		friend class GFxCharacter;

	public:
		// ScaleModeType represents the scaling type used for the SWF file stage, corresponds to Stage.scaleMode property in ActionScript.
		enum class ScaleModeType
		{
			kNoScale,   // The size of SWF content is fixed
			kShowAll,   // Makes the entire SWF content visible in the viewport without distortion while maintaining the original aspect ratio
			kExactFit,  // Makes the entire SWF content visible in the viewport without trying to preserve the original aspect ratio
			kNoBorder   // Scales the SWF content to fill whole viewport area, without distortion but possibly with some cropping while maintaining original aspect ratio
		};

		// Alignment type used for the SWF file stage, corresponds to Stage.align property in ActionScript.
		enum class AlignType
		{
			kCenter,
			kTopCenter,
			kBottomCenter,
			kCenterLeft,
			kCenterRight,
			kTopLeft,
			kTopRight,
			kBottomLeft,
			kBottomRight
		};

		enum class HEResult
		{
			kNotHandled = 0,
			kHandled = 1,
			kNoDefaultAction = 2,
			kCompleted = (kHandled | kNoDefaultAction)
		};

		enum class HitTestType
		{
			kBounds = 0,
			kShapes = 1,
			kButtonEvents = 2,
			kShapesNoInvisible = 3
		};

		~GFxMovieView() override;

		// add
		virtual void                                      SetViewport(const GViewport& a_viewDesc);                                                                           // 19 - pure - Sets the render-target surface viewport to which the movie is scaled.
		virtual void                                      GetViewport(GViewport* a_viewDesc) const;                                                                           // 1A - pure - Obtains the render-target surface viewport to which the movie is scaled.
		virtual void                                      SetViewScaleMode(ScaleModeType a_type);                                                                             // 1B - pure - Sets the current scale mode for the movie.
		[[nodiscard]] virtual ScaleModeType               GetViewScaleMode() const;                                                                                           // 1C - pure - Obtains the current scale mode for the movie.
		virtual void                                      SetViewAlignment(AlignType a_type);                                                                                 // 1D - pure - Sets the current alignment mode for the movie.
		[[nodiscard]] virtual AlignType                   GetViewAlignment() const;                                                                                           // 1E - pure - Gets the current alignment mode for the movie.
		[[nodiscard]] virtual GRectF                      GetVisibleFrameRect() const;                                                                                        // 1F - pure - Obtains the currently visible rectangle.
		virtual void                                      SetPerspective3D(const GMatrix3D& a_projMatIn);                                                                     // 20 - pure
		virtual void                                      SetView3D(const GMatrix3D& a_viewMatIn);                                                                            // 21 - pure
		[[nodiscard]] virtual GRectF                      GetSafeRect() const;                                                                                                // 22 - pure
		virtual void                                      SetSafeRect(const GRectF& a_rect);                                                                                  // 23 - pure
		virtual void                                      Restart();                                                                                                          // 24 - pure
		virtual float                                     Advance(float a_deltaT, std::uint32_t a_frameCatchUpCount = 2);                                                     // 25 - pure
		virtual void                                      Display();                                                                                                          // 26 - pure
		virtual void                                      DisplayPrePass();                                                                                                   // 27 - pure
		virtual void                                      SetPause(bool a_pause);                                                                                             // 28 - pure
		[[nodiscard]] virtual bool                        IsPaused() const;                                                                                                   // 29 - pure
		virtual void                                      SetBackgroundColor(const GColor a_bgColor);                                                                         // 2A - pure
		virtual void                                      SetBackgroundAlpha(float a_alpha);                                                                                  // 2B - pure
		[[nodiscard]] virtual float                       GetBackgroundAlpha() const;                                                                                         // 2C - pure
		virtual HEResult                                  HandleEvent(const GFxEvent& a_event);                                                                               // 2D - pure
		virtual void                                      GetMouseState(std::uint32_t a_mouseIndex, float* a_x, float* a_y, std::uint32_t* a_buttons);                        // 2E - pure
		virtual void                                      NotifyMouseState(float a_x, float a_y, std::uint32_t a_buttons, std::uint32_t a_mouseIndex = 0);                    // 2F - pure
		virtual bool                                      HitTest(float a_x, float a_y, HitTestType a_testCond = HitTestType::kShapes, std::uint32_t a_controllerIdx = 0);    // 30 - pure
		virtual bool                                      HitTest3D(GPoint3F* a_ptOut, float a_x, float a_y, std::uint32_t a_controllerIdx = 0);                              // 31 - pure
		virtual void                                      SetExternalInterfaceRetVal(const GFxValue& a_val);                                                                  // 32 - pure
		[[nodiscard]] virtual void*                       GetUserData() const;                                                                                                // 33 - pure
		virtual void                                      SetUserData(void* a_data);                                                                                          // 34 - pure
		virtual bool                                      AttachDisplayCallback(const char* a_pathToObject, void (*a_callback)(void* a_user), void* a_user);                  // 35 - pure
		[[nodiscard]] virtual bool                        IsMovieFocused() const;                                                                                             // 36 - pure
		virtual bool                                      GetDirtyFlag(bool a_doReset = true);                                                                                // 37 - pure
		virtual void                                      SetMouseCursorCount(std::uint32_t a_count);                                                                         // 38 - pure
		[[nodiscard]] virtual std::uint32_t               GetMouseCursorCount() const;                                                                                        // 39 - pure
		virtual void                                      SetControllerCount(std::uint32_t a_count);                                                                          // 3A - pure
		[[nodiscard]] virtual std::uint32_t               GetControllerCount() const;                                                                                         // 3B - pure
		virtual void                                      GetStats(GStatBag* a_bag, bool a_reset = true);                                                                     // 3C - pure
		[[nodiscard]] virtual GMemoryHeap*                GetHeap() const;                                                                                                    // 3D - pure
		virtual void                                      ForceCollectGarbage();                                                                                              // 3E - pure
		virtual GPointF                                   TranslateToScreen(const GPointF& a_p, void* a_userMatrix);                                                          // 3F - pure
		virtual GRectF                                    TranslateToScreen(const GRectF& a_p, void* a_userMatrix);                                                           // 40 - pure
		virtual bool                                      TranslateLocalToScreen(const char* a_pathToCharacter, const GPointF& a_pt, GPointF* a_presPt, void* a_userMatrix);  // 41 - pure
		virtual bool                                      SetControllerFocusGroup(std::uint32_t a_controllerIdx, std::uint32_t a_focusGroupIndex);                            // 42 - pure
		[[nodiscard]] virtual std::uint32_t               GetControllerFocusGroup(std::uint32_t a_controllerIdx) const;                                                       // 43 - pure
		[[nodiscard]] virtual GFxMovieDef::MemoryContext* GetMemoryContext() const;                                                                                           // 44 - pure
		virtual void                                      Release();                                                                                                          // 45 - pure

		void SetViewport(std::int32_t a_bufW, std::int32_t a_bufH, std::int32_t a_left, std::int32_t a_top, std::int32_t a_width, std::int32_t a_height, GViewport::Flag a_flags = GViewport::Flag::kNone);
		void InvokeNoReturn(const char* a_methodName, const GFxValue* a_args, std::uint32_t a_numArgs);
	};
	static_assert(sizeof(GFxMovieView) == 0x18);
}


===============================================
File: include/RE/G/GFxPlaceObject.h
===============================================
#pragma once

#include "RE/G/GFxPlaceObjectBase.h"

namespace RE
{
	// Rarely used in SWF 3 and later versions
	class GFxPlaceObject : public GFxPlaceObjectBase
	{
	public:
		virtual ~GFxPlaceObject();  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01

		// override (GFxPlaceObjectBase)
		void GetPlaceObjectData(GFxPlaceObjectData& a_data) override;  // 08
		void GetPlaceFlags(GFxPlaceFlags& a_flags) override;           // 0A

		// members
		char data[1];  // 08 - This buffer is sized according to the tag length in the SWF file
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GFxPlaceObject) == 0x10);
#endif
}


===============================================
File: include/RE/G/GFxPlaceObject2.h
===============================================
#pragma once

#include "RE/G/GFxPlaceObjectBase.h"

namespace RE
{
	class GFxPlaceObject2 : public GFxPlaceObjectBase
	{
	public:
		enum class PlaceFlags : std::uint8_t
		{
			kNone = 0,
			kMove = 1 << 0,
			kHasCharacter = 1 << 1,
			kHasMatrix = 1 << 2,
			kHasColorTransform = 1 << 3,
			kHasRatio = 1 << 4,
			kHasName = 1 << 5,
			kHasClipDepth = 1 << 6,
			kHasClipActions = 1 << 7,
		};

		virtual ~GFxPlaceObject2();  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		void Unk_06(void) override;                   // 06
		void Unk_07(void) override;                   // 07

		// override (GFxPlaceObjectBase)
		void  GetPlaceObjectData(GFxPlaceObjectData& a_data) override;  // 08
		void* GetClipActions() override;                                // 09
		void  GetPlaceFlags(GFxPlaceFlags& a_flags) override;           // 0A

		// members
		char data[1];  // 08 - This buffer is sized according to the tag length in the SWF file
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GFxPlaceObject2) == 0x10);
#endif
}


===============================================
File: include/RE/G/GFxPlaceObject2a.h
===============================================
#pragma once

#include "RE/G/GFxPlaceObject2.h"

namespace RE
{
	// PlaceObject2 for SWF Version < 6
	class GFxPlaceObject2a : public GFxPlaceObject2
	{
	public:
		virtual ~GFxPlaceObject2a();  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		void Unk_07(void) override;                   // 07

		// override (GFxPlaceObjectBase)
		void GetPlaceObjectData(GFxPlaceObjectData& a_data) override;  // 08
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GFxPlaceObject2a) == 0x10);
#endif
}


===============================================
File: include/RE/G/GFxPlaceObject3.h
===============================================
#pragma once

#include "RE/G/GFxPlaceObjectBase.h"

namespace RE
{
	class GFxPlaceObject3 : public GFxPlaceObjectBase
	{
	public:
		enum class PlaceFlags1 : std::uint8_t
		{
			kNone = 0,
			kMove = 1 << 0,
			kHasCharacter = 1 << 1,
			kHasMatrix = 1 << 2,
			kHasColorTransform = 1 << 3,
			kHasRatio = 1 << 4,
			kHasName = 1 << 5,
			kHasClipDepth = 1 << 6,
			kHasClipActions = 1 << 7,
		};

		enum class PlaceFlags2 : std::uint8_t
		{
			kNone = 0,
			kHasFilterList = 1 << 0,
			kHasBlendMode = 1 << 1,
			kHasCacheAsBitmap = 1 << 2,
			kHasClassName = 1 << 3,
			kHasImage = 1 << 4,
			kHasVisible = 1 << 5,
			kOpaqueBackground = 1 << 6,
		};

		virtual ~GFxPlaceObject3();  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		void Unk_06(void) override;                   // 06

		// override (GFxPlaceObjectBase)
		void  GetPlaceObjectData(GFxPlaceObjectData& a_data) override;  // 08
		void* GetClipActions() override;                                // 09
		void  GetPlaceFlags(GFxPlaceFlags& a_flags) override;           // 0A

		// members
		char data[1];  // 08 - This buffer is sized according to the tag length in the SWF file
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GFxPlaceObject3) == 0x10);
#endif
}


===============================================
File: include/RE/G/GFxPlaceObjectBase.h
===============================================
#pragma once

#include "RE/G/GASExecuteTag.h"
#include "RE/G/GArray.h"
#include "RE/G/GFxResourceID.h"
#include "RE/G/GMatrix2D.h"
#include "RE/G/GRenderer.h"

namespace RE
{
	enum class GFxPlaceFlags : std::uint8_t
	{
		kNone = 0,
		kMove = 1 << 0,
		kHasCharacter = 1 << 1,
		kHasMatrix = 1 << 2,
		kHasColorTransform = 1 << 3,
		kHasRatio = 1 << 4,
		kHasFilterList = 1 << 5,
		kHasClipDepth = 1 << 6,
		kHasBlendMode = 1 << 7,
	};

	struct GFxPlaceObjectUnpackedData
	{
		using BlendType = GRenderer::BlendType;

		enum class FilterType : std::uint8_t
		{
			kDropShadow = 0,
			kBlur = 1,
			kGlow = 2,
			kBevel = 3,
			kGradientGlow = 4,
			kConvolution = 5,
			kAdjustColor = 6,
			kGradientBevel = 7,

			kFlag_KnockOut = 1 << 5,
			kFlag_HideObject = 1 << 6,
			kFlag_FineBlur = 1 << 7,
		};

		struct Filter
		{
			stl::enumeration<FilterType, std::uint8_t> filterType;        // 00
			std::uint8_t                               pad01;             // 01
			std::uint16_t                              angle;             // 02
			std::uint16_t                              distance;          // 04
			std::uint16_t                              pad06;             // 06
			GRenderer::BlurFilterParams                blurFilterParams;  // 08
			float                                      colorMatrix[20];   // 4C
		};
		static_assert(sizeof(Filter) == 0x9C);

		GArray<Filter>                                filterList;      // 00
		GRenderer::Cxform                             colorTransform;  // 18
		GMatrix2D                                     matrix;          // 38
		float                                         ratio;           // 50
		std::int32_t                                  depth;           // 54
		GFxResourceID                                 characterId;     // 58
		std::uint16_t                                 clipDepth;       // 5C
		stl::enumeration<BlendType, std::uint8_t>     blendMode;       // 5E
		stl::enumeration<GFxPlaceFlags, std::uint8_t> placeFlags;      // 5F
	};
	static_assert(sizeof(GFxPlaceObjectUnpackedData) == 0x60);

	struct GFxPlaceObjectData : public GFxPlaceObjectUnpackedData
	{
		enum class ChangeType
		{
			kAddDisplayObject,
			kModifyDisplayObject,
			kReplaceDisplayObject,
		};

		void*                                      clipActions;  // 60
		const char*                                name;         // 68
		stl::enumeration<ChangeType, std::int32_t> changeType;   // 70
		std::uint32_t                              pad74;        // 74
	};

	class GFxPlaceObjectBase : public GASExecuteTag
	{
	public:
		// add
		virtual void  GetPlaceObjectData(GFxPlaceObjectData& a_data);  // 08 - pure
		virtual void* GetClipActions();                                // 09 - { return nullptr; }
		virtual void  GetPlaceFlags(GFxPlaceFlags& a_flags);           // 0A - pure
	};
	static_assert(sizeof(GFxPlaceObjectBase) == 0x8);
}


===============================================
File: include/RE/G/GFxPlaceObjectUnpacked.h
===============================================
#pragma once

#include "RE/G/GFxPlaceObjectBase.h"

namespace RE
{
	class GFxPlaceObjectUnpacked : public GFxPlaceObjectBase
	{
	public:
		~GFxPlaceObjectUnpacked() override;  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		void Unk_06(void) override;                   // 06

		// override (GFxPlaceObjectBase)
		void GetPlaceObjectData(GFxPlaceObjectData& a_data) override;  // 08
		void GetPlaceFlags(GFxPlaceFlags& a_flags) override;           // 0A

		// members
		GFxPlaceObjectUnpackedData data;  // 08
	};
	static_assert(sizeof(GFxPlaceObjectUnpacked) == 0x68);
}


===============================================
File: include/RE/G/GFxPlayerStats.h
===============================================
#pragma once

#include "RE/G/GStats.h"

namespace RE
{
	struct GFxStatMovieData
	{
		enum GFxStatMovieDatum : std::uint32_t
		{
			kGFxStatMD_Default = GStatGroups::kGStatGroup_GFxMovieData,

			// Memory for a movie.
			kGFxStatMD_Mem,
			kGFxStatMD_CharDefs_Mem,
			kGFxStatMD_ShapeData_Mem,
			kGFxStatMD_Tags_Mem,
			kGFxStatMD_Fonts_Mem,
			kGFxStatMD_Images_Mem,
			kGFxStatMD_Sounds_Mem,
			kGFxStatMD_ActionOps_Mem,
			kGFxStatMD_Other_Mem,

			// Different
			kGFxStatMD_Time,
			kGFxStatMD_Load_Tks,
			kGFxStatMD_Bind_Tks
		};
	};

	struct GFxStatMovieViews
	{
		enum GFxStatMovieView : std::uint32_t
		{
			kGFxStatMV_Default = GStatGroups::kGStatGroup_GFxMovieView,

			// MovieView memory.
			kGFxStatMV_Mem,
			kGFxStatMV_MovieClip_Mem,
			kGFxStatMV_ActionScript_Mem,
			kGFxStatMV_Text_Mem,
			kGFxStatMV_XML_Mem,
			kGFxStatMV_Other_Mem,

			// MovieView Timings.
			kGFxStatMV_Tks,
			kGFxStatMV_Advance_Tks,
			kGFxStatMV_Action_Tks,
			kGFxStatMV_Timeline_Tks,
			kGFxStatMV_Input_Tks,
			kGFxStatMV_Mouse_Tks,
			kGFxStatMV_ScriptCommunication_Tks,
			kGFxStatMV_GetVariable_Tks,
			kGFxStatMV_SetVariable_Tks,
			kGFxStatMV_Invoke_Tks,
			kGFxStatMV_Display_Tks,
			kGFxStatMV_Tessellate_Tks,
			kGFxStatMV_GradientGen_Tks,
		};
	};

	struct GFxStatIMEs
	{
		enum GFxStatIME : std::uint32_t
		{
			kGFxStatIME_Default = GStatGroups::kGStatGroup_GFxIME,

			// IME memory.
			kGFxStatIME_Mem
		};
	};

	struct GFxStatFontCaches
	{
		enum GFxStatFontCache : std::uint32_t
		{
			kGFxStatFC_Default = GStatGroups::kGStatGroup_GFxFontCache,

			// Font Cache memory.
			kGFxStatFC_Mem,
			kGFxStatFC_Batch_Mem,
			kGFxStatFC_GlyphCache_Mem,
			kGFxStatFC_Other_Mem
		};
	};
}


===============================================
File: include/RE/G/GFxRemoveObject.h
===============================================
#pragma once

#include "RE/G/GASExecuteTag.h"

namespace RE
{
	class GFxRemoveObject : public GASExecuteTag
	{
	public:
		~GFxRemoveObject() override;  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		bool Unk_03(void) override;                   // 03
		void Unk_06(void) override;                   // 06

		// members
		std::uint16_t characterId;  // 08
		std::uint16_t depth;        // 0A
		std::uint32_t pad0C;        // 0A
	};
	static_assert(sizeof(GFxRemoveObject) == 0x10);
}


===============================================
File: include/RE/G/GFxRemoveObject2.h
===============================================
#pragma once

#include "RE/G/GASExecuteTag.h"

namespace RE
{
	class GFxRemoveObject2 : public GASExecuteTag
	{
	public:
		~GFxRemoveObject2() override;  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		bool Unk_03(void) override;                   // 03
		void Unk_06(void) override;                   // 06

		// members
		std::uint16_t depth;  // 08
		std::uint16_t pad0A;  // 0A
		std::uint32_t pad0C;  // 0C
	};
	static_assert(sizeof(GFxRemoveObject2) == 0x10);
}


===============================================
File: include/RE/G/GFxRenderConfig.h
===============================================
#pragma once

#include "RE/G/GFxState.h"
#include "RE/G/GPtr.h"
#include "RE/G/GRenderer.h"

namespace RE
{
	class GRenderer;

	class GFxRenderConfig : public GFxState
	{
	public:
		using RenderCapBits = GRenderer::RenderCapBits;
		using VertexFormat = GRenderer::VertexFormat;

		enum class RenderFlag
		{
			kNone = 0,

			kStrokeCorrect = 0,
			kStrokeNormal = 1 << 0,
			kStrokeHairline = 1 << 1,
			kStrokeMask = 0x03,

			kEdgeAA = 1 << 4,
			kOptimizeTriangles = 1 << 5,
			kNoViewCull = 1 << 8
		};

		[[nodiscard]] bool          IsUsingEdgeAA() const;
		[[nodiscard]] bool          IsEdgeAATextured() const;
		[[nodiscard]] bool          IsOptimizingTriangles() const;
		[[nodiscard]] bool          HasCxformAddAlpha() const;
		[[nodiscard]] bool          HasVertexFormat(VertexFormat a_fmt) const;
		[[nodiscard]] RenderFlag    GetStrokeRenderFlags() const;
		[[nodiscard]] RenderCapBits GetRendererCapBits() const;
		[[nodiscard]] GRenderer*    GetRenderer() const;
		void                        SetRenderFlags(RenderFlag a_flags);
		[[nodiscard]] RenderFlag    GetRenderFlags() const;
		void                        SetMaxCurvePixelError(float a_pixelError);
		[[nodiscard]] float         GetMaxCurvePixelError() const;
		[[nodiscard]] float         GetStrokerAAWidth() const;
		void                        SetStrokerAAWidth(float a_aawidth);

		// members
		GPtr<GRenderer>                                renderer;            // 18
		float                                          maxCurvePixelError;  // 20
		stl::enumeration<RenderFlag, std::uint32_t>    renderFlags;         // 24
		float                                          strokerAAWidth;      // 28
		stl::enumeration<RenderCapBits, std::uint32_t> rendererCapBits;     // 2C
		stl::enumeration<VertexFormat, std::uint32_t>  rendererVtxFmts;     // 30
		std::uint32_t                                  pad34;               // 34
	};
	static_assert(sizeof(GFxRenderConfig) == 0x38);
}


===============================================
File: include/RE/G/GFxResource.h
===============================================
#pragma once

#include "RE/G/GAtomic.h"
#include "RE/G/GFxResourceKey.h"
#include "RE/G/GNewOverrideBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxResourceLibBase;
	class GFxResourceReport;

	// Resource is an interface for casting to different types of resources.
	class GFxResource : public GNewOverrideBase<GStatGroups::kGStat_Default_Mem>
	{
		friend class GFxResourceWeakLib;

	public:
		// Different types of resources.
		enum class ResourceType
		{
			// Set this bit if CharacterDef
			kCharacterDefBit = 1 << 7,

			// Non-character types
			kNone = 0,
			kImage,
			kFont,
			// Internal
			kMovieDef,
			kSoundSample,

			// GFxCharacterDef derived types
			kMovieDataDef = kCharacterDefBit | 0,
			kButtonDef,
			kTextDef,
			kEditTextDef,
			kSpriteDef,
			kShapeDef,
			kVideoDef,

			// Mask and shift applied to store ResourceType in type code
			kTypeCode_Mask = 0xFF00,
			kTypeCode_Shift = 8
		};

		// An enumeration listing the attributes of the image resource to use such as bitmap, gradient or font texture etc.
		enum class ResourceUse
		{
			kNone = 0,
			kBitmap = 1,
			kGradient = 2,
			kFontTexture = 3,
			kSoundSample = 4,

			// Use mask within TypeCode
			kTypeCode_Mask = 0xFF
		};

		GFxResource();
		virtual ~GFxResource();  // 00

		// add
		virtual GFxResourceKey              GetKey();                     // 01
		[[nodiscard]] virtual std::uint32_t GetResourceTypeCode() const;  // 02
		virtual GFxResourceReport*          GetResourceReport();          // 03

		static std::uint32_t MakeTypeCode(ResourceType a_resourceType, ResourceUse a_resourceUse = ResourceUse::kNone);  // Creates a resource type code which is a combination of ResourceType and ResourceUse.

		void                       AddRef();                                        // Thread-safe reference count implementation; increments the reference count.
		bool                       AddRef_NotZero();                                // Thread-safe reference count implementation ; increments a reference count if it is not zero.
		void                       Release();                                       // Thread-Safe reference count implementation; release the resources.
		[[nodiscard]] std::int32_t GetRefCount() const;                             // Thread-Safe reference count implementation; returns the reference count.
		void                       SetOwnerResourceLib(GFxResourceLibBase* a_lib);  // Assigns owner library for resource.
		[[nodiscard]] ResourceType GetResourceType() const;                         // Obtains the resource type.
		[[nodiscard]] ResourceUse  GetResourceUse() const;                          // Obtains the type of resource use.

	protected:
		// members
		GAtomicInt<std::int32_t> _refCount;  // 08
		std::uint32_t            _pad0C;     // 0C
		GFxResourceLibBase*      _lib;       // 10
	};
	static_assert(sizeof(GFxResource) == 0x18);
}


===============================================
File: include/RE/G/GFxResourceID.h
===============================================
#pragma once

namespace RE
{
	class GFxResourceID
	{
	public:
		struct IDTypeConstants
		{
			enum IDTypeConstant : std::uint32_t
			{
				kIndexMask = 0x0000FFFF,
				kTypeMask = 0x0FFF0000,
				kGenMask = 0x00030000,

				kSWF = 0,
				kStatic = 1 << 16,
				kExport = 1 << 17,

				kTypeShift = 18,

				kInvalidID = (1 << kTypeShift) | kSWF
			};
		};

		struct IDTypes
		{
			enum IDType : std::uint32_t
			{
				kNone = IDTypeConstants::kSWF,
				kInternalConstant = (0 << IDTypeConstants::kTypeShift) | IDTypeConstants::kStatic,
				kGradientImage = (1 << IDTypeConstants::kTypeShift) | IDTypeConstants::kStatic,
				kDynFontImage = (2 << IDTypeConstants::kTypeShift) | IDTypeConstants::kStatic,
				kFontImage = (1 << IDTypeConstants::kTypeShift) | IDTypeConstants::kExport
			};
		};

		class HashOp
		{
		public:
			UPInt operator()(const GFxResourceID& a_idRef);
		};

		GFxResourceID();
		explicit GFxResourceID(std::uint32_t a_resID);
		GFxResourceID(const GFxResourceID& a_rhs);

		GFxResourceID& operator=(const GFxResourceID& a_rhs);
		bool           operator==(const GFxResourceID& a_rhs) const;
		bool           operator!=(const GFxResourceID& a_rhs) const;
		bool           operator==(std::uint32_t a_idVal) const;
		bool           operator!=(std::uint32_t a_idVal) const;

		[[nodiscard]] std::uint32_t   GetIDValue() const;
		[[nodiscard]] std::uint32_t   GetIDIndex() const;
		[[nodiscard]] IDTypes::IDType GetIDType() const;
		GFxResourceID                 GenerateNextID();

	protected:
		// members
		std::uint32_t id;  // 0
	};
	static_assert(sizeof(GFxResourceID) == 0x4);
}


===============================================
File: include/RE/G/GFxResourceKey.h
===============================================
#pragma once

namespace RE
{
	class GFxResourceKey
	{
	public:
		using KeyHandle = void*;

		enum class KeyType
		{
			kNone,
			kUnique,
			kFile,
			kGradient,
			kSubImage
		};

		class KeyInterface
		{
		public:
			virtual ~KeyInterface();  // 00

			// add
			virtual void        AddRef(KeyHandle a_data) = 0;                                    // 01
			virtual void        Release(KeyHandle a_data) = 0;                                   // 02
			virtual KeyType     GetKeyType(KeyHandle a_data) const = 0;                          // 03
			virtual UPInt       GetHashCode(KeyHandle a_data) const = 0;                         // 04
			virtual bool        KeyEquals(KeyHandle a_data, const GFxResourceKey& a_other) = 0;  // 05
			virtual const char* GetFileURL(KeyHandle a_data) const;                              // 06
		};

		class HashOp
		{
		public:
			UPInt operator()(const GFxResourceKey& a_key)
			{
				return a_key._keyInterface ? a_key._keyInterface->GetHashCode(a_key._keyData) : 0;
			}
		};

		GFxResourceKey();
		GFxResourceKey(KeyInterface* a_keyIntfc, KeyHandle a_keyHandle);
		GFxResourceKey(const GFxResourceKey& a_rhs);
		~GFxResourceKey();

		GFxResourceKey&             operator=(const GFxResourceKey& a_rhs);
		bool                        operator==(const GFxResourceKey& a_other) const;
		[[nodiscard]] KeyType       GetKeyType() const;
		[[nodiscard]] const char*   GetFileURL() const;
		[[nodiscard]] KeyInterface* GetKeyInterface() const;
		[[nodiscard]] KeyHandle     GetKeyData() const;

	protected:
		// members
		KeyInterface* _keyInterface;  // 00
		KeyHandle     _keyData;       // 08
	};
	static_assert(sizeof(GFxResourceKey) == 0x10);
}


===============================================
File: include/RE/G/GFxResourceLib.h
===============================================
#pragma once

#include "RE/G/GEvent.h"
#include "RE/G/GFxResourceKey.h"
#include "RE/G/GHashSet.h"
#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"
#include "RE/G/GString.h"

namespace RE
{
	class GFxResource;
	class GFxResourceWeakLib;

	class GFxResourceLib : public GRefCountBase<GFxResourceLib, GStatGroups::kGStat_Default_Mem>
	{
	public:
		class ResourceSlot : public GRefCountBase<ResourceSlot, GStatGroups::kGStat_Default_Mem>
		{
		public:
			enum class ResolveState
			{
				kInProgress,
				kSuccess,
				kFail,
			};

			const GFxResourceKey& GetKey() const
			{
				return key;
			}

			// members
			GPtr<GFxResourceWeakLib> lib;    // 10
			volatile ResolveState    state;  // 18
			std::uint32_t            pad1C;  // 1C
			GFxResource* volatile resource;  // 20
			GFxResourceKey key;              // 28
			GString        errorMessage;     // 38
			GEvent         resolveComplete;  // 40
		};
		static_assert(sizeof(ResourceSlot) == 0x98);

		struct GFxResourcePtrHashFunc
		{
			UPInt operator()(const GFxResource*& a_data) const
			{
				return (((UPInt)a_data) >> 6) ^ ((UPInt)a_data);
			}
		};
		using PinHashSet = GHashSet<GFxResource*, GFxResourcePtrHashFunc>;

		// members
		GFxResourceWeakLib* weakLib;    // 10
		PinHashSet          pinSet;     // 18
		bool                debugFlag;  // 20
		std::uint8_t        pad21;      // 21
		std::uint16_t       pad22;      // 22
		std::uint32_t       pad24;      // 24
	};
	static_assert(sizeof(GFxResourceLib) == 0x28);
}


===============================================
File: include/RE/G/GFxResourceLibBase.h
===============================================
#pragma once

#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxResource;

	class GFxResourceLibBase : public GRefCountBase<GFxResourceLibBase, GStatGroups::kGStat_Default_Mem>
	{
	public:
		// add
		virtual void RemoveResourceOnRelease(GFxResource* a_res) = 0;  // 01
		virtual void PinResource(GFxResource* a_res) = 0;              // 02
		virtual void UnpinResource(GFxResource* a_res) = 0;            // 03
	};
	static_assert(sizeof(GFxResourceLibBase) == 0x10);
}


===============================================
File: include/RE/G/GFxResourceReport.h
===============================================
#pragma once

#include "RE/G/GString.h"

namespace RE
{
	class GMemoryHeap;
	class GStatBag;

	class GFxResourceReport
	{
	public:
		virtual ~GFxResourceReport()  // 00
		{}

		// add
		virtual GString GetResourceName()  // 01
		{
			return GString();
		}

		virtual GMemoryHeap* GetResourceHeap() const  // 02
		{
			return nullptr;
		}

		virtual void GetStats([[maybe_unused]] GStatBag* a_bag, [[maybe_unused]] bool a_reset = true)  // 03
		{}
	};
	static_assert(sizeof(GFxResourceReport) == 0x8);
}


===============================================
File: include/RE/G/GFxResourceWeakLib.h
===============================================
#pragma once

#include "RE/G/GAtomic.h"
#include "RE/G/GFxResourceLib.h"
#include "RE/G/GFxResourceLibBase.h"
#include "RE/G/GHashSet.h"

namespace RE
{
	class GFxResourceWeakLib : public GFxResourceLibBase
	{
	public:
		using ResourceSlot = GFxResourceLib::ResourceSlot;

		struct ResourceNode
		{
			enum class NodeType
			{
				kResource,
				kResolver,
			};

			NodeType type;

			union
			{
				ResourceSlot* resolver;
				GFxResource*  resource;
			};

			bool operator==(const GFxResourceKey& a_src) const
			{
				assert(resource);
				if (type == NodeType::kResource) {
					return resource->GetKey() == a_src;
				}
				return resolver->GetKey() == a_src;
			}

			bool operator!=(const GFxResourceKey& a_src) const
			{
				return !operator==(a_src);
			}

			struct HashOp
			{
				UPInt operator()(const ResourceNode& a_node) const
				{
					assert(a_node.resource);
					GFxResourceKey key =
						(a_node.type == NodeType::kResource) ? a_node.resource->GetKey() : a_node.resolver->GetKey();
					return operator()(key);
				}

				UPInt operator()(const GFxResourceKey& a_key) const
				{
					return GFxResourceKey::HashOp()(a_key);
				}
			};
		};

		// override (GFxResourceLibBase)
		void RemoveResourceOnRelease(GFxResource* a_res) override;  // 01
		void PinResource(GFxResource* a_res) override;              // 02
		void UnpinResource(GFxResource* a_res) override;            // 03

		// members
		GFxResourceLib*                              strongLib;     // 10
		GLock                                        resourceLock;  // 18
		GHashSet<ResourceNode, ResourceNode::HashOp> resources;     // 40
		GPtr<GMemoryHeap>                            imageHeap;     // 48
	};
	static_assert(sizeof(GFxResourceWeakLib) == 0x50);
}


===============================================
File: include/RE/G/GFxSetBackgroundColor.h
===============================================
#pragma once

namespace RE
{
	class GFxSetBackgroundColor : public GASExecuteTag
	{
	public:
		virtual ~GFxSetBackgroundColor();  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01

		// members
		std::uint64_t unk08;  // 08
	};
	static_assert(sizeof(GFxSetBackgroundColor) == 0x10);
}


===============================================
File: include/RE/G/GFxShapeBase.h
===============================================
#pragma once

#include "RE/G/GNewOverrideBase.h"
#include "RE/G/GRect.h"

namespace RE
{
	class GFxShapeBase : public GNewOverrideBase<GFxStatMovieData::kGFxStatMD_CharDefs_Mem>
	{
		virtual ~GFxShapeBase();  // 00

		// add
		virtual void*        GetBounds(GRectF& a_arg1) const;                                                          // 01
		virtual void         SetBounds(GRectF& a_arg1);                                                                // 02
		virtual bool         HitTest(const GPointF& a_pt, bool a_arg2, void* a_arg3) = 0;                              // 03
		virtual void         Unk_04(void* a_arg1, float a_arg2, void* a_arg3) = 0;                                     // 04
		virtual void         Unk_05(GRectF& a_arg1) = 0;                                                               // 05
		virtual void         Unk_06(void* a_arg1, float a_arg2) = 0;                                                   // 06
		virtual void         Unk_07(void) = 0;                                                                         // 07
		virtual bool         Unk_08(void* a_arg1) = 0;                                                                 // 08
		virtual void*        GetFillStyles(std::int32_t& a_arg1) const;                                                // 09 - { return nullptr; }
		virtual void*        GetLineStyles(std::int32_t& a_arg1) const;                                                // 0A - { return nullptr; }
		virtual void         GetStyles(void* a_arg1) const;                                                            // 0B
		virtual void         GetStyles(void* a_arg1, std::int32_t* a_arg2, void* a_arg3, std::int32_t* a_arg4) const;  // 0C
		virtual void         SetPercent(float a_arg1);                                                                 // 0D
		virtual float        GetPercent() const;                                                                       // 0E - { return 100.0f; }
		virtual void*        Unk_0F(void) = 0;                                                                         // 0F
		virtual std::int32_t Unk_10(void) = 0;                                                                         // 10
		virtual void         Unk_11(std::int32_t* a_arg1, std::int32_t* a_arg2) = 0;                                   // 11
		virtual void*        Unk_12(void) = 0;                                                                         // 12

		// members
		GRectF        edgeBounds;  // 08
		std::int32_t  unk18;       // 18
		std::uint32_t pad1C;       // 1C
		std::uint64_t unk20;       // 20
		std::uint64_t unk28;       // 28
		std::uint64_t unk30;       // 30
		std::uint32_t unk38;       // 38
		std::uint32_t pad3C;       // 3C
	};
	static_assert(sizeof(GFxShapeBase) == 0x40);
}


===============================================
File: include/RE/G/GFxShapeBaseCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxCharacterDef.h"

namespace RE
{
	class GFxShapeBaseCharacterDef : public GFxCharacterDef
	{
	public:
		~GFxShapeBaseCharacterDef() override;  // 00

		// override (GFxResource)
		std::uint32_t GetResourceTypeCode() const override;  // 02

		// override (GFxCharacterDef)
		void Unk_04(void) override = 0;  // 04
		void Unk_06(void) override = 0;  // 06
		void Unk_07(void) override = 0;  // 07

		// add
		virtual void Unk_0A(void) = 0;  // 0A
		virtual void Unk_0B(void) = 0;  // 0B
		virtual void Unk_0C(void) = 0;  // 0C
		virtual void Unk_0D(void) = 0;  // 0D
		virtual void Unk_0E(void) = 0;  // 0E
		virtual void Unk_0F(void) = 0;  // 0F
		virtual void Unk_10(void) = 0;  // 10
		virtual void Unk_11(void) = 0;  // 11
	};
	static_assert(sizeof(GFxShapeBaseCharacterDef) == 0x20);
}


===============================================
File: include/RE/G/GFxShapeCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxShapeBaseCharacterDef.h"
#include "RE/G/GFxShapeWithStyles.h"

namespace RE
{
	class GFxShapeCharacterDef : public GFxShapeBaseCharacterDef
	{
	public:
		~GFxShapeCharacterDef() override;  // 00

		// override (GFxCharacterDef)
		void Unk_04(void) override;                                            // 04
		bool Unk_05(const GPointF& a_pt, bool a_arg2, void* a_arg3) override;  // 05
		void Unk_06(void) override;                                            // 06
		void Unk_07(void) override;                                            // 07

		// override (GFxShapeBaseCharacterDef)
		void Unk_0A(void) override;  // 0A
		void Unk_0B(void) override;  // 0B
		void Unk_0C(void) override;  // 0C
		void Unk_0D(void) override;  // 0D
		void Unk_0E(void) override;  // 0E
		void Unk_0F(void) override;  // 0F
		void Unk_10(void) override;  // 10
		void Unk_11(void) override;  // 11

		// add
		virtual void Unk_12(void);  // 12
		virtual void Unk_13(void);  // 13
		virtual void Unk_14(void);  // 14
		virtual void Unk_15(void);  // 15

		// members
		GFxShapeWithStyles shape;  // 20
	};
	static_assert(sizeof(GFxShapeCharacterDef) == 0xF0);
}


===============================================
File: include/RE/G/GFxShapeNoStyles.h
===============================================
#pragma once

#include "RE/G/GFxShapeBase.h"

namespace RE
{
	class GFxShapeNoStyles : public GFxShapeBase
	{
		~GFxShapeNoStyles() override;  // 00

		// override (GFxShapeBase)
		bool         HitTest(const GPointF& a_pt, bool a_arg2, void* a_arg3) override;  // 03
		void         Unk_04(void* a_arg1, float a_arg2, void* a_arg3) override;         // 04
		void         Unk_05(GRectF& a_arg1) override;                                   // 05
		void         Unk_06(void* a_arg1, float a_arg2) override;                       // 06
		void         Unk_07(void) override;                                             // 07
		bool         Unk_08(void* a_arg1) override;                                     // 08
		void*        Unk_0F(void) override;                                             // 0F
		std::int32_t Unk_10(void) override;                                             // 10 - { return 1; }
		void         Unk_11(std::int32_t* a_arg1, std::int32_t* a_arg2) override;       // 11
		void*        Unk_12(void) override;                                             // 12

		// members
		std::uint64_t unk40;  // 40
		std::uint64_t unk48;  // 48
		std::uint16_t unk50;  // 50
		std::uint16_t unk52;  // 52
		std::uint32_t pad54;  // 54
		void*         unk58;  // 58
		std::int32_t  unk60;  // 60
		std::int32_t  unk64;  // 64
		void*         unk68;  // 68
	};
	static_assert(sizeof(GFxShapeNoStyles) == 0x70);
}


===============================================
File: include/RE/G/GFxShapeWithStyles.h
===============================================
#pragma once

#include "RE/G/GFxShapeNoStyles.h"

namespace RE
{
	class GFxShapeWithStyles : public GFxShapeNoStyles
	{
		~GFxShapeWithStyles() override;

		// override (GFxShapeBase)
		void* GetBounds(GRectF& a_arg1) const override;                                                          // 01
		void  SetBounds(GRectF& a_arg1) override;                                                                // 02
		void  Unk_04(void* a_arg1, float a_arg2, void* a_arg3) override;                                         // 04
		void* GetFillStyles(std::int32_t& a_arg1) const override;                                                // 09
		void* GetLineStyles(std::int32_t& a_arg1) const override;                                                // 0A
		void  GetStyles(void* a_arg1) const override;                                                            // 0B
		void  GetStyles(void* a_arg1, std::int32_t* a_arg2, void* a_arg3, std::int32_t* a_arg4) const override;  // 0C
		void  SetPercent(float a_arg1) override;                                                                 // 0D
		float GetPercent() const override;                                                                       // 0E

		// members
		void*         unk70;            // 70
		std::uint64_t unk78;            // 78
		std::uint16_t unk80;            // 80
		std::uint16_t unk82;            // 82
		std::uint32_t pad84;            // 84
		void*         fillStyles;       // 88 - array with elements 0x38 wide (GFxGradientData?) - fill styles?
		std::int32_t  fillStylesCount;  // 90
		std::uint32_t unk94;            // 94
		std::uint64_t unk98;            // 98
		void*         lineStyles;       // A0 - line styles? (GFxLineStyle)
		std::int32_t  lineStylesCount;  // A8
		std::uint32_t unkAC;            // AC
		std::uint64_t unkB0;            // B0
		float         percent;          // B8
		GRectF        shapeBounds;      // BC
		std::uint32_t padCC;            // CC
	};
	static_assert(sizeof(GFxShapeWithStyles) == 0xD0);
}


===============================================
File: include/RE/G/GFxSpecialKeysState.h
===============================================
#pragma once

namespace RE
{
	class GFxSpecialKeysState
	{
	public:
		enum class Key
		{
			kShiftPressed = 1 << 0,
			kCtrlPressed = 1 << 1,
			kAltPressed = 1 << 2,
			kCapsToggled = 1 << 3,
			kNumToggled = 1 << 4,
			kScrollToggled = 1 << 5,

			kInitializedBit = 1 << 7,
			kInitializedMask = 0xFF
		};

		std::uint8_t states;  // 0
	};
	static_assert(sizeof(GFxSpecialKeysState) == 0x1);
}


===============================================
File: include/RE/G/GFxSprite.h
===============================================
#pragma once

#include "RE/G/GASEnvironment.h"
#include "RE/G/GArray.h"
#include "RE/G/GFxASCharacter.h"

namespace RE
{
	class GFxMovieRoot;
	class GFxSpriteDef;

	class GFxSprite : public GFxASCharacter
	{
	public:
		~GFxSprite() override;  // 00

		// override (GFxASCharacter)
		void                Unk_02(void) override;      // 02
		void                Unk_03(void) override;      // 03
		void                Unk_0A(void) override;      // 0A
		void                Unk_0D(void) override;      // 0D
		void                Unk_0E(void) override;      // 0E
		void                Unk_0F(void) override;      // 0F
		void                Unk_10(void) override;      // 10
		void                Unk_11(void) override;      // 11
		void                Unk_12(void) override;      // 12
		void                Unk_13(void) override;      // 13
		void                Unk_14(void) override;      // 14
		void                Unk_15(void) override;      // 15
		void                Unk_16(void) override;      // 16
		void                Unk_17(void) override;      // 17
		void                Unk_18(void) override;      // 18
		void                Unk_19(void) override;      // 19
		void                Unk_1A(void) override;      // 1A
		void                Unk_1B(void) override;      // 1B
		GASEnvironment*     GetEnvironment() override;  // 1C
		void                Unk_1D(void) override;      // 1D
		void                Unk_1E(void) override;      // 1E
		void                Unk_1F(void) override;      // 1F
		void                Unk_20(void) override;      // 20
		void                Unk_21(void) override;      // 21
		void                Unk_22(void) override;      // 22
		void                Unk_23(void) override;      // 23
		void                Unk_24(void) override;      // 24
		void                Unk_25(void) override;      // 25
		void                Unk_28(void) override;      // 28
		void                Unk_29(void) override;      // 29
		void                Unk_2C(void) override;      // 2C
		void                Unk_2E(void) override;      // 2E
		void                Unk_33(void) override;      // 33
		void                Unk_35(void) override;      // 35
		void                Unk_37(void) override;      // 37
		void                Unk_39(void) override;      // 39
		void                Unk_3B(void) override;      // 3B
		void                Unk_3C(void) override;      // 3C
		void                Unk_3D(void) override;      // 3D
		void                Unk_3E(void) override;      // 3E
		void                Unk_40(void) override;      // 40
		GASMovieClipObject* GetMovieClip() override;    // 41
		void                Unk_42(void) override;      // 42
		void                Unk_43(void) override;      // 43
		void                Unk_46(void) override;      // 46
		void                Unk_47(void) override;      // 47
		void                Unk_48(void) override;      // 48
		void                Unk_49(void) override;      // 49
		void                Unk_4A(void) override;      // 4A
		void                Unk_4B(void) override;      // 4B
		void                Unk_4C(void) override;      // 4C
		void                Unk_4D(void) override;      // 4D
		void                Unk_4E(void) override;      // 4E
		void                Unk_4F(void) override;      // 4F
		void                Unk_50(void) override;      // 50
		void                Unk_51(void) override;      // 51
		void                Unk_52(void) override;      // 52
		void                Unk_53(void) override;      // 53
		void                Unk_54(void) override;      // 54
		void                Unk_57(void) override;      // 57

		// override (GASObjectInterface)
		void GASObjectInterface_02(void) override;  // 02
		void GASObjectInterface_04(void) override;  // 04
		void GASObjectInterface_06(void) override;  // 06
		void GASObjectInterface_08(void) override;  // 08
		void GASObjectInterface_0A(void) override;  // 0A
		void GASObjectInterface_0B(void) override;  // 0B

		// add
		virtual void Unk_58(void);  // 58
		virtual void Unk_59(void);  // 59
		virtual void Unk_5A(void);  // 5A
		virtual void Unk_5B(void);  // 5B
		virtual void Unk_5C(void);  // 5C
		virtual void Unk_5D(void);  // 5D
		virtual void Unk_5E(void);  // 5E

		// members
		GFxSpriteDef*       spriteDef;     // 110
		GFxMovieRoot*       movieRoot;     // 118
		std::uint64_t       unk120[5];     // 120
		std::uint32_t       unk148;        // 148
		std::uint32_t       currentFrame;  // 14C
		GArray<void*>       unk150;        // 150
		GASEnvironment      unk168;        // 168
		std::uint64_t       unk308;        // 308
		std::uint64_t       unk310;        // 310
		GASMovieClipObject* movieClip;     // 318 - smart pointer
		std::uint64_t       unk320;        // 320
		std::uint64_t       unk328;        // 328
		std::uint64_t       unk330;        // 330
		std::uint64_t       unk338;        // 338
		std::uint64_t       unk340;        // 340
		std::uint8_t        unk348;        // 348
		std::uint8_t        unk349;        // 349
		std::uint8_t        unk34A;        // 34A
		std::uint8_t        unk34B;        // 34B
		std::uint32_t       unk34C;        // 34C
	};
	static_assert(sizeof(GFxSprite) == 0x350);
}


===============================================
File: include/RE/G/GFxSpriteDef.h
===============================================
#pragma once

#include "RE/G/GArrayLH.h"
#include "RE/G/GFxTimelineDef.h"
#include "RE/G/GStringHash.h"

namespace RE
{
	class GFxCharacter;
	class GFxMovieDataDef;

	class GFxTimelineIODef : public GFxTimelineDef
	{
	public:
		// add
		virtual void SetLoadingExecuteTagList(ExecuteTagList* a_data) = 0;  // 0E
		virtual void AddFrameName(GString* a_name, GFxLog* a_log) = 0;      // 0F
	};
	static_assert(sizeof(GFxTimelineIODef) == 0x20);

	class GFxSpriteDef : public GFxTimelineIODef
	{
	public:
		~GFxSpriteDef() override;  // 00

		// override (GFxResource)
		std::uint32_t GetResourceTypeCode() const override;  // 02

		// override (GFxCharacterDef)
		bool          Unk_05(const GPointF& a_pt, bool a_arg2, void* a_arg3) override;  // 05
		std::uint32_t GetVersion() override;                                            // 08
		GFxCharacter* CreateCharacter() override;                                       // 09

		// override (GFxTimelineDef)
		std::uint32_t   GetFrameCount() override;                                                                          // 0A
		ExecuteTagList* GetMovieTagArray(ExecuteTagList& a_data, std::int32_t a_frameNumber) override;                     // 0B
		ExecuteTagList* GetImportTagArray(ExecuteTagList& a_data, std::int32_t a_frameNumber) override;                    // 0C - { return nullptr; }
		bool            GetLabeledFrame(const char* a_label, std::int32_t& a_frameNumber, bool a_labelIsNumber) override;  // 0D

		// override (GFxTimelineIODef)
		void SetLoadingExecuteTagList(ExecuteTagList* a_data) override;  // 0E
		void AddFrameName(GString* a_name, GFxLog* a_log) override;      // 0F

		// add
		virtual float            GetWidth();                   // 10 - { return 1.0f; }
		virtual float            GetHeight();                  // 11 - { return 1.0f; }
		virtual GFxMovieDataDef* GetMovieData();               // 12
		virtual void             GetBounds(GRectF& a_bounds);  // 13
		virtual std::int32_t     GetLoadingFrame();            // 14
		virtual std::uint32_t    GetSWFFlags();                // 15
		virtual void*            Unk_16();                     // 16 - { return nullptr; }
		virtual void             Unk_17();                     // 17
		virtual const char*      GetFileURL();                 // 18

		// members
		GFxMovieDataDef*          movieData;     // 20
		GStringHash<std::int32_t> frameLabels;   // 28
		std::int32_t              frameCount;    // 30
		std::int32_t              frameLoading;  // 34
		GArrayLH<ExecuteTagList>  frames;        // 38
		void*                     unk50;         // 50
		std::uint8_t              buttonState;   // 58 - 0x1 = up, 0x2 = down, 0x4 = over
		std::uint8_t              pad59;         // 59
		std::uint16_t             pad5A;         // 5A
		std::uint32_t             pad5C;         // 5C
	};
	static_assert(sizeof(GFxSpriteDef) == 0x60);
}


===============================================
File: include/RE/G/GFxState.h
===============================================
#pragma once

#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxState : public GRefCountBase<GFxState, GStatGroups::kGStat_Default_Mem>
	{
	public:
		inline static constexpr auto RTTI = RTTI_GFxState;

		// An enumeration type defining the type of a State object, such as kRenderConfig, kFSCommandHandler, State_Log, etc. Only one State object of each type can be set on the loader or a movie.
		enum class StateType
		{
			kNone,  // An undefined state value

			// Instance related states
			kRenderConfig,
			kRenderStats,
			kTranslator,  // An international language translator of dynamic text fields
			kLog,         // A log object which generates log messages and is used for debugging
			kImageLoader,
			kActionControl,      // An object that controls the verbosity of output generated during ActionScript execution
			kUserEventHandler,   // A user-installable interface to handle events fired from the player
			kFSCommandHandler,   // A handler gets called when Action Script executes the fscommand() statement
			kExternalInterface,  // A callback method for ActionScript to invoke

			// Loading related states
			kFileOpener,       // A callback interface that is used for opening files
			kURLBuilder,       // The object responsible for building a filename path used for loading objects
			kImageCreator,     // An interface used to create Image objects applied during rendering
			kParseControl,     // An object that is used to determine which SWF/GFx file parsing messages will be generated
			kProgressHandler,  // A user-defined handler to receive SWF/GFx load progress
			kImportVisitor,    // An object which is called during loading (import binding state) of a movie after each import is resolved
			kMeshCacheManager,
			kFontPackParams,  // FontPackParams state, which enables static text cache and provides texture size and pack configuration settings
			kFontCacheManager,
			kFontLib,       // FontLib state, which maintains a list of movies that can be used as font sources
			kFontProvider,  // FontProvider derived state, such as FontProviderWin32 that provides support for system fonts
			kFontMap,       // FontMap state, which maintains a set of font name mappings for internationalization
			kGradientParams,
			kTaskManager,  // An object that executes tasks added to the task queue
			kClipboard,    // An object used for storing plain and rich texts in a text clipboard
			kTextKeyMap,   // TextKeyMap state which contains mappings of keystrokes to text field operation
			kPreprocessParams,
			kIMEManager,  // An object which supports IME implementation on the loader
			kXMLSupport,  // XML::Support state which is responsible for providing XML support
			kJpegSupport,
			kZlibSupport,          // ZlibSupport state that provides ZLib support to the loader
			kFontCompactorParams,  // FontCompactorParams state, which provides configuration options for generating glyphs
			kImagePackerParams,    // ImagePackParamsBase state, which provides the texture configuration options to pack images in textures
			kPNGSupport,
			kAudio,  // Audio state, used to initialize the sound system for playing SWF sound files
			kVideo,  // Video state, used to initialize video playbacks
			kTestStream,
			kSharedObject,  // SharedObjectManagerBase state for handling shared objects
			kLocSupport
		};

		// State constructor, only invoked from derived classes. The constructor takes a StateType as an argument, which defines the state type; this value cannot be changed after object creation
		GFxState(StateType a_st = StateType::kNone);
		~GFxState() override = default;  // 00

		// GetStateType obtains the StateType of this state. The state type of a given object never changes after construction
		[[nodiscard]] StateType GetStateType() const;

	protected:
		StateType     stateType;  // 10
		std::uint32_t pad14;      // 14
	};
	static_assert(sizeof(GFxState) == 0x18);
}


===============================================
File: include/RE/G/GFxStateBag.h
===============================================
#pragma once

#include "RE/G/GFxFileConstants.h"
#include "RE/G/GFxState.h"
#include "RE/G/GPtr.h"

namespace RE
{
	// StateBag collects accessor methods for properties that can be inherited from Loader to MovieDef and from MovieDef to Movie. These properties can be overwritten in any one of above mentioned instances.
	class GFxStateBag : public GFxFileConstants
	{
	protected:
		// add
		[[nodiscard]] virtual GFxStateBag* GetStateBagImpl() const;  // 00

	public:
		virtual ~GFxStateBag();  // 01

		virtual void                    SetState(GFxState::StateType a_stateType, GFxState* a_state);                                                   // 02 - SetState sets an interface to State. The state type is passed to SetState so that we can know which state is being cleared when null is passed
		[[nodiscard]] virtual GFxState* GetStateAddRef(GFxState::StateType a_stateType) const;                                                          // 03 - GetStateAddRef obtains one or more State pointers based on the specified state type
		virtual void                    GetStatesAddRef(GFxState** a_stateList, const GFxState::StateType* a_stateTypes, std::uint32_t a_count) const;  // 04 - GetStatesAddRef fills in a set of states with one call. Initial array a_stateList must contain null pointers

		template <class T>
		T* GetStateAddRef(GFxState::StateType a_state) const
		{
			return static_cast<T*>(GetStateAddRef(a_state));
		}

		[[nodiscard]] GPtr<GFxState> GetState(GFxState::StateType a_stateType) const;

		template <class T>
		GPtr<T> GetState(GFxState::StateType a_stateType) const
		{
			GPtr<T> ptr(GetStateAddRef<T>(a_stateType));
			ptr->Release();
			return ptr;
		}
	};
	static_assert(sizeof(GFxStateBag) == 0x8);
}


===============================================
File: include/RE/G/GFxStateBagImpl.h
===============================================
#pragma once

#include "RE/G/GFxLogBase.h"
#include "RE/G/GFxStateBag.h"
#include "RE/G/GRefCountBase.h"

namespace RE
{
	class GFxStateBagImpl :
		public GRefCountBase<GFxStateBagImpl, GStatGroups::kGStat_Default_Mem>,  // 00
		public GFxStateBag,                                                      // 10
		public GFxLogBase<GFxStateBagImpl>                                       // 20
	{
	public:
		// members
		std::uint64_t unk28[7];
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GFxStateBagImpl) == 0x60);
#endif
}


===============================================
File: include/RE/G/GFxStaticTextCharacterDef.h
===============================================
#pragma once

#include "RE/G/GFxCharacterDef.h"

namespace RE
{
	class GFxStaticTextCharacterDef : public GFxCharacterDef
	{
	public:
		~GFxStaticTextCharacterDef() override;  // 00

		// override (GFxCharacterDef)
		bool          Unk_05(const GPointF& a_pt, bool a_arg2, void* a_arg3) override;  // 05
		void          Unk_06(void) override;                                            // 06
		GFxCharacter* CreateCharacter() override;                                       // 09

		// override (GFxResource)
		std::uint32_t GetResourceTypeCode() const override;  // 02

		// members
		GRectF        bounds;    // 20
		std::uint64_t unk30[7];  // 30
	};
	static_assert(sizeof(GFxStaticTextCharacterDef) == 0x68);
}


===============================================
File: include/RE/G/GFxStream.h
===============================================
#pragma once

#include "RE/G/GFxLogBase.h"
#include "RE/G/GStringDH.h"

namespace RE
{
	class GFxLog;
	class GFxParseControl;

	class GFxStream : public GFxLogBase<GFxStream>
	{
	public:
		virtual ~GFxStream();  // 00

		// members
		GFxLog*          logState;       // 008
		GFxParseControl* parseControl;   // 010
		bool             unk18;          // 018
		std::uint8_t     pad19;          // 019
		std::uint16_t    pad1A;          // 01A
		std::uint32_t    pad1C;          // 01C
		void*            unk20;          // 020
		std::uint16_t    unk28;          // 028
		std::uint16_t    pad2A;          // 02A
		std::uint32_t    pad2C;          // 02C
		GStringDH        fileUrl;        // 030
		std::uint32_t    nextOffset[2];  // 040
		std::uint32_t    nextOffsetIdx;  // 048 - 1-based
		std::uint32_t    seekPos;        // 04C
		std::uint32_t    bufferEndPos;   // 050
		std::uint32_t    bytesFetched;   // 054
		std::uint8_t     unk58;          // 058
		std::uint8_t     pad59;          // 059
		std::uint16_t    pad5A;          // 05A
		std::uint32_t    pad5C;          // 05C
		char*            data;           // 060
		std::uint32_t    bufferSize;     // 068
		char             buffer[0x200];  // 06C
		std::uint32_t    pad26C;         // 26C
	};
	static_assert(sizeof(GFxStream) == 0x270);
}


===============================================
File: include/RE/G/GFxTask.h
===============================================
#pragma once

#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GFxTask : public GRefCountBase<GFxTask, GStatGroups::kGStat_Default_Mem>
	{
	public:
		enum class TaskId
		{
			kType_Computation = 0x00010000,
			kType_IO = 0x00020000,
			kType_Mask = 0x00FF0000,

			kUnknown = kType_Computation | 1,
			kMovieDecoding = kType_Computation | 2,
			kMovieDataLoad = kType_IO | 1,
			kMovieImageLoad = kType_IO | 2,
			kMovieBind = kType_IO | 3,
		};

		enum class TaskState
		{
			kIdle,
			kPending,
			kRunning,
			kAbandoned,
			kFinished,
		};

		GFxTask(TaskId a_id = TaskId::kUnknown) :
			thisTaskId(a_id),
			currentState(TaskState::kIdle)
		{}

		~GFxTask() override  // 00
		{}

		// add
		virtual void Execute() = 0;  // 01

		virtual void OnAbandon([[maybe_unused]] bool a_started)  // 02
		{}

		inline TaskId GetTaskId() const
		{
			return thisTaskId;
		}

		inline TaskId GetTaskType() const
		{
			return static_cast<TaskId>(stl::to_underlying(thisTaskId) & stl::to_underlying(TaskId::kType_Mask));
		}

		inline TaskState GetTaskState() const
		{
			return currentState;
		}

		// members
		TaskId             thisTaskId;    // 10
		volatile TaskState currentState;  // 14
	};
	static_assert(sizeof(GFxTask) == 0x18);
}


===============================================
File: include/RE/G/GFxTimelineDef.h
===============================================
#pragma once

#include "RE/G/GFxCharacterDef.h"

namespace RE
{
	class GASExecuteTag;

	class GFxTimelineDef : public GFxCharacterDef
	{
	public:
		struct ExecuteTagList
		{
			GASExecuteTag** data;  // 00
			std::uint32_t   size;  // 08
		};

		// add
		virtual std::uint32_t   GetFrameCount() = 0;                                                                          // 0A
		virtual ExecuteTagList* GetMovieTagArray(ExecuteTagList& a_data, std::int32_t a_frameNumber) = 0;                     // 0B
		virtual ExecuteTagList* GetImportTagArray(ExecuteTagList& a_data, std::int32_t a_frameNumber) = 0;                    // 0C
		virtual bool            GetLabeledFrame(const char* a_label, std::int32_t& a_frameNumber, bool a_labelIsNumber) = 0;  // 0D
	};
	static_assert(sizeof(GFxTimelineDef) == 0x20);
}


===============================================
File: include/RE/G/GFxTranslator.h
===============================================
#pragma once

#include "RE/G/GFxState.h"
#include "RE/G/GFxWWHelper.h"

namespace RE
{
	class GFxWStringBuffer;

	class GFxTranslator : public GFxState
	{
	public:
		inline static constexpr auto RTTI = RTTI_GFxTranslator;

		using WordWrappingType = GFxWWHelper::WordWrappingType;

		// TranslateCaps is an enumeration type defining the translation capabilities of the Translator object. In general, capability flags are used to determine two things:
		//	* The type of strings can be passed to the Translate virtual function as a key.
		//	* The type of result strings that will be generated by Translate into the result buffer.
		enum class TranslateCap
		{
			kNone = 0,
			kReceiveHTML = 1 << 0,           // Specifies that Translate key can include Flash-HTML tags. If not specified, translate will only receive stripped text content (default)
			kStripTrailingNewLines = 1 << 1  // Forces all trailing new-line symbols to be stripped before the text is passed to Translate. This is important if the original text was in HTML format, since it can have a trailing paragraph tag that is turned into a new line
		};

		class TranslateInfo
		{
		public:
			enum Flag
			{
				kNone = 0,
				kTranslated = 1 << 0,
				kResultHTML = 1 << 1,
				kResultSourceHTML = 1 << 2
			};

			TranslateInfo();

			[[nodiscard]] const char*    GetInstanceName() const;                                                    // An input method which returns the instance name of the textfield being translated.
			[[nodiscard]] const wchar_t* GetKey() const;                                                             // An input method which returns the 'key' string - original text value of the textfield being translated.
			[[nodiscard]] bool           IsKeyHTML() const;                                                          // Determines if the key string (returned by GetKey) is HTML or not.
			void                         SetResult(const wchar_t* a_resultText, UPInt a_resultLen = UPINT_MAX);      // An output method which sets the translated string as a plain text.
			void                         SetResultHTML(const wchar_t* a_resultHTML, UPInt a_resultLen = UPINT_MAX);  // An output method which sets translated string as a HTML text.

			// members
			const wchar_t*                       key;           // 00
			GFxWStringBuffer*                    result;        // 08
			const char*                          instanceName;  // 10
			stl::enumeration<Flag, std::uint8_t> flags;         // 18
			std::uint8_t                         pad19;         // 19
			std::uint16_t                        pad1A;         // 1A
			std::uint32_t                        pad1C;         // 1C
		};
		static_assert(sizeof(TranslateInfo) == 0x20);

		// LineFormatDesc provides information of the line text to be formatted like the length of the text, text position etc. This structure is mainly used by OnWordWrapping to control word wrapping of the text.
		// Note that all members of LineFormatDesc marked as "[in]" are used as input values only and shouldn't be modified. Members marked as "[out]" or "[in, out]" might be modified.
		struct LineFormatDesc
		{
			enum class Alignment
			{
				kLeft = 0,
				kRight = 1,
				kCenter = 2,
				kJustify = 3
			};

			// members
			const wchar_t*                            paraText;                 // 00 - [in] Text of the current paragraph, wide-characters are used
			UPInt                                     paraTextLen;              // 08 - [in] Length of the paragraph text, in characters
			const float*                              widths;                   // 10 - [in] An array of line widths, in pixels, before the character at the corresponding index. The size of the array is NumCharsInLine + 1. Note, this is not the array of character widths. For example, there is a line that contains three characters: ABC. The NumCharInLine will be equal 3, the size of the pWidths will be 4; the pWidth[0] will be always 0 (since there are no characters before the A), the pWidth[1] will contain width of A symbol, pWidths[2] will contain width of A PLUS width of B, and, finally, pWidths[3] will contain total width of the line (width of A PLUS width of B PLUS width of C)
			UPInt                                     lineStartPos;             // 18 - [in] The text position of the first character in line. ParaTextLen[LineStartPos] might be used to get the value of this character
			UPInt                                     numCharsInLine;           // 20 - [in] Number of characters currently in the line
			float                                     visibleRectWidth;         // 28 - [in] Width, in pixels, of client rectangle. This width might be used in calculation of word wrapping position: the total width of line should not exceed this width
			float                                     currentLineWidth;         // 2C - [in] Current line width, in pixels
			float                                     lineWidthBeforeWordWrap;  // 30 - [in] Line width before the proposedWordWrapPoint, in pixels. For example, if line is ABC DEF and proposedWordWrapPoint = 3 (space) then lineWidthBeforeWordWrap will contain the width of ABC (w/o space) part of the line
			float                                     dashSymbolWidth;          // 34 - [in] Supplementary member, width of the hyphen symbol, in pixels. It might be used to calculate hyphenation
			stl::enumeration<Alignment, std::uint8_t> alignment;                // 38 - [in] Alignment of the line
			std::uint8_t                              pad39;                    // 39
			std::uint16_t                             pad3A;                    // 3A
			std::uint32_t                             pad3C;                    // 3C
			UPInt                                     proposedWordWrapPoint;    // 40 - [in,out] An index in the line of the proposed word wrap position. For example, if the line text is "ABC DEF" and only "ABC DE" fits in visibleRectWidth then the proposedWordWrapPoint will be equal to 3. Note, this is the index in line, not in text (paraText), not in line. Use lineStartPos to calculate the proposed word wrapping position in the text. The user's OnWordWrapping method should change this member if it is necessary to change the word wrapping position according to custom rules
			bool                                      useHyphenation;           // 48 - [out] The OnWordWrapping method may set this to true to indicate to put hyphen symbol at the word-wrapping position. This might be useful for implementing hyphenation
			std::uint8_t                              pad49;                    // 49
			std::uint16_t                             pad4A;                    // 4A
			std::uint32_t                             pad4C;                    // 4C
		};
		static_assert(sizeof(LineFormatDesc) == 0x50);

		GFxTranslator();
		explicit GFxTranslator(WordWrappingType a_wwMode);
		~GFxTranslator() override = default;  // 00

		// add
		[[nodiscard]] virtual TranslateCap GetCaps() const;                            // 01 - { return TranslateCap::kNone; } - Specifies capabilities of the Translate implementation
		virtual void                       Translate(TranslateInfo* a_translateInfo);  // 02 - { return; } - Translate method implements a UTF-8/UCS-2 translation interface and performs lookup of 'a_translateInfo->GetKey()' string for language translation, filling in the destination buffer by calling TranslateInfo::SetResult or TranslateInfo::SetResultHTML method. 'a_translateInfo' is guaranteed to be not null. If neither TranslateInfo::SetResult nor TranslateInfo::SetResultHTML is called then original text will not be changed
		virtual bool                       OnWordWrapping(LineFormatDesc* a_desc);     // 03 - OnWordWrapping is a virtual method, a callback, which is invoked once a necessity of word-wrapping for any text field is determined. This method is invoked only if custom word-wrapping is turned on by using the Translator(a_wwMode) constructor

		[[nodiscard]] bool CanReceiveHTML() const;
		[[nodiscard]] bool NeedStripNewLines() const;
		[[nodiscard]] bool HandlesCustomWordWrapping() const;

		// members
		stl::enumeration<WordWrappingType, std::uint32_t> wwMode;  // 18
		std::uint32_t                                     pad1C;   // 1C
	};
	static_assert(sizeof(GFxTranslator) == 0x20);
}


===============================================
File: include/RE/G/GFxValue.h
===============================================
#pragma once

#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GMatrix2D.h"
#include "RE/G/GMatrix3D.h"
#include "RE/G/GMemory.h"
#include "RE/G/GNewOverrideBase.h"
#include "RE/G/GRenderer.h"
#include "RE/G/GStats.h"
#include "RE/G/GString.h"

namespace RE
{
	class GFxMovieRoot;

	namespace GFxValueImpl
	{
		template <class>
		struct _is_integer :
			std::false_type
		{};

		template <>
		struct _is_integer<unsigned char> :
			std::true_type
		{};

		template <>
		struct _is_integer<char> :
			std::true_type
		{};

		template <>
		struct _is_integer<signed char> :
			std::true_type
		{};

		template <>
		struct _is_integer<unsigned short> :
			std::true_type
		{};

		template <>
		struct _is_integer<signed short> :
			std::true_type
		{};

		template <>
		struct _is_integer<unsigned int> :
			std::true_type
		{};

		template <>
		struct _is_integer<signed int> :
			std::true_type
		{};

		template <>
		struct _is_integer<unsigned long> :
			std::true_type
		{};

		template <>
		struct _is_integer<signed long> :
			std::true_type
		{};

		template <>
		struct _is_integer<unsigned long long> :
			std::true_type
		{};

		template <>
		struct _is_integer<signed long long> :
			std::true_type
		{};

		template <class T>
		struct is_integer :
			std::conditional_t<
				std::is_enum_v<T>,
				std::true_type,
				_is_integer<
					std::remove_cv_t<T>>>
		{};

		template <class T>
		inline constexpr bool is_integer_v = is_integer<T>::value;
	}

	class GFxValue
	{
	private:
		friend class GFxMovieRoot;

	public:
		enum class ValueType
		{
			kUndefined = 0x00,
			kNull = 0x01,
			kBoolean = 0x02,
			kNumber = 0x03,
			kString = 0x04,
			kStringW = 0x05,
			kObject = 0x06,
			kArray = 0x07,
			kDisplayObject = 0x08,

			kManagedBit = 1 << 6,
			kConvertBit = 1 << 7,
			kValueMask = 0x0F,
			kTypeMask = kConvertBit | kValueMask,

			kConvertBoolean = kConvertBit | kBoolean,
			kConvertNumber = kConvertBit | kNumber,
			kConvertString = kConvertBit | kString,
			kConvertStringW = kConvertBit | kStringW
		};

		// DisplayInfo is a structure to modify display properties of a display object (MovieClips, TextField, Button). This structure is used in conjunction with GetDisplayInfo/SetDisplayInfo.
		class DisplayInfo
		{
		public:
			// Flags set to define the display properties of display objects.
			enum class Flag
			{
				kNone = 0,
				kX = 1 << 0,
				kY = 1 << 1,
				kRotation = 1 << 2,
				kXScale = 1 << 3,
				kYScale = 1 << 4,
				kAlpha = 1 << 5,
				kVisible = 1 << 6,
				kZ = 1 << 7,
				kXRotation = 1 << 8,
				kYRotation = 1 << 9,
				kZScale = 1 << 10,
				kFOV = 1 << 11,
				kPerspMatrix3D = 1 << 12,
				kViewMatrix3D = 1 << 13
			};

			DisplayInfo() = default;              // Initializes the DisplayInfo structure.
			DisplayInfo(double a_x, double a_y);  // Initializes the DisplayInfo structure.
			DisplayInfo(double a_rotation);       // Initializes the DisplayInfo structure.
			DisplayInfo(bool a_visible);          // Initializes the DisplayInfo structure.

			void                           Clear();                                                                                                                                                                                                                                                                          // Clears all properties from the DisplayInfo object.
			[[nodiscard]] double           GetAlpha() const;                                                                                                                                                                                                                                                                 // Retrieves the alpha transparency of the display object.
			[[nodiscard]] double           GetFOV() const;                                                                                                                                                                                                                                                                   // Retrieves the perspective Field of View angle on the object.
			[[nodiscard]] double           GetRotation() const;                                                                                                                                                                                                                                                              // Retrieves the rotation of the display object.
			[[nodiscard]] bool             GetVisible() const;                                                                                                                                                                                                                                                               // Retrieves the Boolean value to indicate the visibility of the display object.
			[[nodiscard]] const GMatrix3D* GetPerspectiveMatrix3D() const;                                                                                                                                                                                                                                                   // Returns a temporary pointer to the 3D perspective matrix set on a 3D movie clip.
			[[nodiscard]] const GMatrix3D* GetViewMatrix3D() const;                                                                                                                                                                                                                                                          // Returns a temporary pointer to the 3D view matrix set on the 3D movie clip.
			[[nodiscard]] double           GetX() const;                                                                                                                                                                                                                                                                     // Retrieves the x coordinate of the display object relative to the parent movie clip.
			[[nodiscard]] double           GetY() const;                                                                                                                                                                                                                                                                     // Retrieves the y coordinate of the display object relative to the parent movie clip.
			[[nodiscard]] double           GetZ() const;                                                                                                                                                                                                                                                                     // Retrieves the z coordinate of the display object relative to the parent movie clip.
			[[nodiscard]] double           GetXRotation() const;                                                                                                                                                                                                                                                             // Returns the rotation of the object around the X axis.
			[[nodiscard]] double           GetYRotation() const;                                                                                                                                                                                                                                                             // Returns the rotation of the object around the Y axis.
			[[nodiscard]] double           GetXScale() const;                                                                                                                                                                                                                                                                // Retrieves the horizontal scale of the display object.
			[[nodiscard]] double           GetYScale() const;                                                                                                                                                                                                                                                                // Retrieves the vertical scale of the display object.
			[[nodiscard]] double           GetZScale() const;                                                                                                                                                                                                                                                                // Retrieves the scale of the object along the Z axis.
			[[nodiscard]] bool             IsFlagSet(Flag a_flag) const;                                                                                                                                                                                                                                                     // Determines if a property of the DisplayInfo object is set
			void                           Initialize(Flag a_varsSet, double a_x, double a_y, double a_rotation, double a_xScale, double a_yScale, double a_alpha, bool a_visible, double a_z, double a_xRotation, double a_yRotation, double a_zScale, double a_fov, const GMatrix3D* a_viewM, const GMatrix3D* a_perspM);  // Initializes the display properties of a display object.
			void                           SetVisible(bool a_visible);                                                                                                                                                                                                                                                       // Sets the visibility of the display object.
			void                           SetPerspectiveMatrix3D(const GMatrix3D* a_mat);                                                                                                                                                                                                                                   // Sets the erspective matrix for a 3D movie clip.
			void                           Set(double a_x, double a_y, double a_rotation, double a_xScale, double a_yScale, double a_alpha, bool a_visible);                                                                                                                                                                 // Sets the values in Flag structure indicating the display properties of objects on stage.
			void                           Set(double a_x, double a_y, double a_rotation, double a_xScale, double a_yScale, double a_alpha, bool a_visible, double a_z, double a_xRotation, double a_yRotation, double a_zScale);                                                                                            // Sets the values in Flags structure indicating the display properties of objects on stage.
			void                           SetViewMatrix3D(const GMatrix3D* a_mat);                                                                                                                                                                                                                                          // Sets the view matrix for a 3D movie clip.
			void                           SetAlpha(double a_alpha);                                                                                                                                                                                                                                                         // Sets the alpha transparency of the display object.
			void                           SetFOV(double a_fov);                                                                                                                                                                                                                                                             // Sets the perspective Field of View angle in degrees.
			void                           SetPosition(double a_x, double a_y);                                                                                                                                                                                                                                              // Sets the coordinate position of the display object.
			void                           SetRotation(double a_degrees);                                                                                                                                                                                                                                                    // Sets the rotation of the display object.
			void                           SetScale(double a_xScale, double a_yScale);                                                                                                                                                                                                                                       // Sets the scaling factor of the display object.
			void                           SetX(double a_x);                                                                                                                                                                                                                                                                 // Sets the x coordinate of the display object relative to the parent movie clip.
			void                           SetXRotation(double a_degrees);                                                                                                                                                                                                                                                   // Sets the rotation of the object around the X axis.
			void                           SetXScale(double a_xScale);                                                                                                                                                                                                                                                       // Sets the horizontal scale of the display object.
			void                           SetY(double a_y);                                                                                                                                                                                                                                                                 // Sets the y coordinate of the display object relative to the parent movie clip.
			void                           SetYRotation(double a_degrees);                                                                                                                                                                                                                                                   // Sets the rotation of the object around the Y axis.
			void                           SetYScale(double a_yScale);                                                                                                                                                                                                                                                       // Sets the vertical scale of the display object.
			void                           SetZ(double a_z);                                                                                                                                                                                                                                                                 // Sets the z coordinate of the display object relative to the parent movie clip.
			void                           SetZScale(double a_zScale);                                                                                                                                                                                                                                                       // Sets the scale of the object along the Z axis

		protected:
			void SetFlags(Flag a_flags);
			void ClearFlags(Flag a_flags);

			// members
			double                                _x = 0.0;              // 00
			double                                _y = 0.0;              // 08
			double                                _rotation = 0.0;       // 10
			double                                _xScale = 0.0;         // 18
			double                                _yScale = 0.0;         // 20
			double                                _alpha = 0.0;          // 28
			bool                                  _visible = false;      // 30
			std::uint8_t                          _pad31 = 0;            // 31
			std::uint16_t                         _pad32 = 0;            // 32
			std::uint32_t                         _pad34 = 0;            // 34
			double                                _z = 0.0;              // 38
			double                                _xRotation = 0.0;      // 40
			double                                _yRotation = 0.0;      // 48
			double                                _zScale = 0.0;         // 50
			double                                _fov = 0.0;            // 58
			GMatrix3D                             _viewMatrix3D;         // 60
			GMatrix3D                             _perspMatrix3D;        // A0
			stl::enumeration<Flag, std::uint16_t> _flags = Flag::kNone;  // E0
			std::uint16_t                         _padD2 = 0;            // E2
			std::uint32_t                         _padD4 = 0;            // E4
		};
		static_assert(sizeof(DisplayInfo) == 0xE8);

		class ObjectInterface : public GNewOverrideBase<GFxStatMovieViews::kGFxStatMV_Other_Mem>
		{
		public:
			class ObjVisitor
			{
			public:
				virtual ~ObjVisitor();  // 00

				// add
				virtual void Visit(const char* a_name, const GFxValue& a_val) = 0;  // 01
			};

			class ArrVisitor
			{
			public:
				virtual ~ArrVisitor();  // 00

				// add
				virtual void Visit(std::uint32_t a_idx, const GFxValue& a_val) = 0;  // 01
			};

			ObjectInterface(GFxMovieRoot* a_movieRoot);

			void ObjectAddRef(GFxValue* a_val, void* a_obj);
			void ObjectRelease(GFxValue* a_val, void* a_obj);

			bool HasMember(void* a_data, const char* a_name, bool a_isDObj) const;
			bool GetMember(void* a_data, const char* a_name, GFxValue* a_val, bool a_isDObj) const;
			bool SetMember(void* a_data, const char* a_name, const GFxValue& a_value, bool a_isDObj);
			bool Invoke(void* a_data, GFxValue* a_result, const char* a_name, const GFxValue* a_args, UPInt a_numArgs, bool a_isDObj);
			bool DeleteMember(void* a_data, const char* a_name, bool a_isDObj);
			void VisitMembers(void* a_data, ObjVisitor* a_visitor, bool a_isDObj) const;

			std::uint32_t GetArraySize(void* a_data) const;
			bool          SetArraySize(void* a_data, std::uint32_t a_size);
			bool          GetElement(void* a_data, std::uint32_t a_idx, GFxValue* a_val) const;
			bool          SetElement(void* a_data, std::uint32_t a_idx, const GFxValue& a_val);
			bool          PushBack(void* a_data, const GFxValue& a_value);
			bool          RemoveElements(void* a_data, std::uint32_t a_idx, std::int32_t a_count);

			bool GetDisplayInfo(void* a_data, DisplayInfo* a_info) const;
			bool SetDisplayInfo(void* a_data, const DisplayInfo& a_info);
			bool GetDisplayMatrix(void* a_data, GMatrix2D* a_mat) const;
			bool SetDisplayMatrix(void* a_data, const GMatrix2D& a_mat);
			bool GetCxform(void* a_data, GRenderer::Cxform* a_cx) const;
			bool SetCxform(void* a_data, const GRenderer::Cxform& a_cx);

			bool SetText(void* a_data, const char* a_text, bool a_isHTML);

			bool AttachMovie(void* a_data, GFxValue* a_movieClip, const char* a_symbolName, const char* a_instanceName, std::int32_t a_depth, const GFxValue* a_initObj);
			bool GotoAndPlay(void* a_data, const char* a_frame, bool a_stop);

			bool IsSameContext(const ObjectInterface* a_rhs) const;

		protected:
			// members
			GFxMovieRoot* _movieRoot;  // 0
		};
		static_assert(sizeof(ObjectInterface) == 0x8);

		using ObjectVisitor = ObjectInterface::ObjVisitor;
		using ArrayVisitor = ObjectInterface::ArrVisitor;

		using ObjectVisitFn = std::function<void(const char*, const RE::GFxValue&)>;

		GFxValue();
		GFxValue(ValueType a_rhs);
		GFxValue(std::nullptr_t);
		GFxValue(double a_rhs);
		GFxValue(bool a_rhs);
		GFxValue(const char* a_rhs);
		GFxValue(std::string_view a_rhs);
		GFxValue(const wchar_t* a_rhs);
		GFxValue(std::wstring_view a_rhs);
		GFxValue(const GFxValue& a_rhs);
		GFxValue(GFxValue&& a_rhs);

		template <
			class T,
			std::enable_if_t<
				GFxValueImpl::is_integer_v<T>,
				int> = 0>
		inline GFxValue(T a_val) :
			GFxValue(static_cast<double>(a_val))
		{}

		~GFxValue();

		GFxValue& operator=(std::nullptr_t);
		GFxValue& operator=(double a_rhs);
		GFxValue& operator=(bool a_rhs);
		GFxValue& operator=(const char* a_rhs);
		GFxValue& operator=(std::string_view a_rhs);
		GFxValue& operator=(const wchar_t* a_rhs);
		GFxValue& operator=(std::wstring_view a_rhs);
		GFxValue& operator=(const GFxValue& a_rhs);
		GFxValue& operator=(GFxValue&& a_rhs);

		template <
			class T,
			std::enable_if_t<
				GFxValueImpl::is_integer_v<T>,
				int> = 0>
		inline GFxValue& operator=(T a_val)
		{
			return *this = static_cast<double>(a_val);
		}

		bool operator==(const GFxValue& a_rhs) const;

		[[nodiscard]] GString ToString() const;

		[[nodiscard]] ValueType      GetType() const;
		[[nodiscard]] bool           IsUndefined() const;
		[[nodiscard]] bool           IsNull() const;
		[[nodiscard]] bool           IsBool() const;
		[[nodiscard]] bool           IsNumber() const;
		[[nodiscard]] bool           IsString() const;
		[[nodiscard]] bool           IsStringW() const;
		[[nodiscard]] bool           IsObject() const;
		[[nodiscard]] bool           IsArray() const;
		[[nodiscard]] bool           IsDisplayObject() const;
		[[nodiscard]] bool           GetBool() const;
		[[nodiscard]] double         GetNumber() const;
		[[nodiscard]] std::ptrdiff_t GetSInt() const;
		[[nodiscard]] std::size_t    GetUInt() const;
		[[nodiscard]] const char*    GetString() const;
		[[nodiscard]] const wchar_t* GetStringW() const;

		void SetUndefined();
		void SetNull();
		void SetBoolean(bool a_val);
		void SetNumber(double a_val);
		void SetString(const char* a_str);
		void SetString(std::string_view a_str);
		void SetStringW(const wchar_t* a_str);
		void SetStringW(std::wstring_view a_str);

		void SetConvertBoolean();
		void SetConvertNumber();
		void SetConvertString();
		void SetConvertStringW();

		// AS Object support. Valid for Object, Array and DisplayObject types
		bool HasMember(const char* a_name) const;
		bool GetMember(const char* a_name, GFxValue* a_val) const;
		bool SetMember(const char* a_name, const GFxValue& a_val);
		bool Invoke(const char* a_name, GFxValue* a_result, const GFxValue* a_args, UPInt a_numArgs);
		bool Invoke(const char* a_name, GFxValue* a_result = nullptr);
		bool DeleteMember(const char* a_name);
		void VisitMembers(ObjectVisitor* a_visitor) const;
		void VisitMembers(ObjectVisitFn&& a_visitor) const;

		template <std::size_t N>
		inline bool Invoke(const char* a_name, const std::array<GFxValue, N>& a_args)
		{
			return Invoke(a_name, nullptr, a_args);
		}

		template <std::size_t N>
		inline bool Invoke(const char* a_name, GFxValue* a_result, const std::array<GFxValue, N>& a_args)
		{
			return Invoke(a_name, a_result, a_args.data(), a_args.size());
		}

		// AS Array support. Valid for Array type
		[[nodiscard]] std::uint32_t GetArraySize() const;
		bool                        SetArraySize(std::uint32_t a_size);
		bool                        GetElement(std::uint32_t a_idx, GFxValue* a_val) const;
		bool                        SetElement(std::uint32_t a_idx, const GFxValue& a_val);
		bool                        PushBack(const GFxValue& a_val);
		bool                        RemoveElements(std::uint32_t a_idx, std::int32_t a_count = -1);
		bool                        RemoveElement(std::uint32_t a_idx);
		bool                        ClearElements();

		// AS MovieClips, Buttons, TextFields support. Valid for DisplayObject type
		bool GetDisplayInfo(DisplayInfo* a_info) const;
		bool SetDisplayInfo(const DisplayInfo& a_info);
		bool GetDisplayMatrix(GMatrix2D* a_mat) const;
		bool SetDisplayMatrix(const GMatrix2D& a_mat);
		bool GetCxform(GRenderer::Cxform* a_cx) const;
		bool SetCxform(const GRenderer::Cxform& a_cx);

		// AS TextField support. Valid for DisplayObject type.
		bool SetText(const char* a_text);
		bool SetTextHTML(const char* a_html);

		// AS MovieClip support. Valid for MovieClips.
		bool AttachMovie(GFxValue* a_movieClip, const char* a_symbolName, const char* a_instanceName, std::int32_t a_depth = -1, const GFxValue* a_initObj = nullptr);
		bool GotoAndPlay(const char* a_frame);
		bool GotoAndStop(const char* a_frame);

		GFC_MEMORY_REDEFINE_NEW(GFxValue, GStatGroups::kGStatGroup_Default);

	protected:
		[[nodiscard]] bool IsManagedValue() const;
		void               AcquireManagedValue(const GFxValue& a_rhs);
		void               ReleaseManagedValue();
		void               ChangeType(ValueType a_type);

		union ValueUnion
		{
			constexpr ValueUnion() :
				obj(nullptr)
			{}

			double          number;
			bool            boolean;
			const char*     string;
			const char**    managedString;
			const wchar_t*  wideString;
			const wchar_t** managedWideString;
			void*           obj;
		};
		static_assert(sizeof(ValueUnion) == 0x8);

		// members
		ObjectInterface*                           _objectInterface;  // 00
		stl::enumeration<ValueType, std::uint32_t> _type;             // 08
		std::uint32_t                              _pad0C;            // 0C
		ValueUnion                                 _value;            // 10
	};
	static_assert(sizeof(GFxValue) == 0x18);
}


===============================================
File: include/RE/G/GFxWStringBuffer.h
===============================================
#pragma once

namespace RE
{
	class GFxWStringBuffer
	{
	public:
		using value_type = wchar_t;
		using size_type = UPInt;
		using reference = value_type&;
		using const_reference = const value_type&;

		struct ReserveHeader
		{
			ReserveHeader();
			ReserveHeader(const ReserveHeader& a_rhs);
			ReserveHeader(ReserveHeader&& a_rhs);
			ReserveHeader(wchar_t* a_buffer, UPInt a_size);
			~ReserveHeader() = default;

			ReserveHeader& operator=(const ReserveHeader& a_rhs);
			ReserveHeader& operator=(ReserveHeader&& a_rhs);

			// members
			wchar_t* buffer;  // 00
			UPInt    size;    // 08
		};
		static_assert(sizeof(ReserveHeader) == 0x10);

		template <std::uint32_t SIZE>
		struct Reserve : public ReserveHeader
		{
			Reserve() :
				ReserveHeader(buffer, SIZE)
			{}

			// members
			wchar_t buffer[SIZE];  // 10
		};

		// (constructor)
		GFxWStringBuffer();
		GFxWStringBuffer(const GFxWStringBuffer& a_rhs);
		GFxWStringBuffer(GFxWStringBuffer&& a_rhs);
		GFxWStringBuffer(const ReserveHeader& a_reserve);
		GFxWStringBuffer(ReserveHeader&& a_reserve);

		// (destructor)
		~GFxWStringBuffer();

		// operator=
		GFxWStringBuffer& operator=(const GFxWStringBuffer& a_rhs);
		GFxWStringBuffer& operator=(GFxWStringBuffer&& a_rhs);
		GFxWStringBuffer& operator=(const wchar_t* a_rhs);
		GFxWStringBuffer& operator=(const std::wstring_view& a_rhs);

		// element access
		reference       operator[](size_type a_pos);
		const_reference operator[](size_type a_pos) const;

		wchar_t&                     front();
		[[nodiscard]] const wchar_t& front() const;

		wchar_t&                     back();
		[[nodiscard]] const wchar_t& back() const;

		[[nodiscard]] const wchar_t* data() const noexcept;
		wchar_t*                     data() noexcept;

		[[nodiscard]] const wchar_t* c_str() const noexcept;

		operator std::wstring_view() const noexcept;

		// Capacity
		[[nodiscard]] bool empty() const noexcept;

		[[nodiscard]] size_type size() const noexcept;

		[[nodiscard]] size_type length() const noexcept;

		// Operations
		void clear() noexcept;

		void resize(size_type a_count);

	protected:
		wchar_t* alloc(size_type a_count);
		void     release();

		// members
		wchar_t*      _text;      // 00
		UPInt         _length;    // 08
		ReserveHeader _reserved;  // 10
	};
	static_assert(sizeof(GFxWStringBuffer) == 0x20);
}


===============================================
File: include/RE/G/GFxWWHelper.h
===============================================
#pragma once

namespace RE
{
	class GFxWWHelper
	{
	public:
		enum class BreakInfoFlags
		{
			kNone = 0,
			kNonStartingChar = 1 << 0,
			kNonTerminatingChar = 1 << 1,
			kAll = kNonStartingChar | kNonTerminatingChar
		};

		// An enumeration that describes bits in word-wrapping mode bit mask parameter of the Translator constructor.
		enum class WordWrappingType
		{
			kNone = 0,
			kDefault = static_cast<std::underlying_type_t<WordWrappingType>>(kNone),  // - Custom word-wrapping is off, OnWordWrapping will not be invoked
			kAsian = 1 << 0,                                                          // - Turns on Chinese word-wrapping rules
			kProhibition = 1 << 1,                                                    // - Prohibits certain chars at start/end of line (turns on Japanese prohibition rule)
			kNoHangulWrap = 1 << 2,                                                   // - Turns on Korean-specific word-wrapping rules
			kCustom = 1 << 7,
			kLast = static_cast<std::underlying_type_t<WordWrappingType>>(kNoHangulWrap),
			kHyphenation = kLast < 1,
			kKorean = kProhibition | kNoHangulWrap,
			kJapanese = static_cast<std::underlying_type_t<WordWrappingType>>(kProhibition),
			kChinese = kProhibition | kAsian,
			kAll = kAsian | kProhibition | kNoHangulWrap
		};

		struct CharBreakInfo
		{
			wchar_t                                        ch;     // 0
			stl::enumeration<BreakInfoFlags, std::uint8_t> flags;  // 2
			std::uint8_t                                   pad3;   // 3
		};
		static_assert(sizeof(CharBreakInfo) == 0x4);

		static bool  FindCharWithFlags(WordWrappingType a_wwMode, wchar_t a_ch, BreakInfoFlags a_charBreakFlags);
		static bool  IsAsianChar(WordWrappingType a_wwMode, wchar_t a_ch);
		static bool  IsNonStartingChar(WordWrappingType a_wwMode, wchar_t a_ch);
		static bool  IsNonTerminatingChar(WordWrappingType a_wwMode, wchar_t a_ch);
		static bool  IsWhiteSpaceChar(wchar_t a_ch);
		static bool  IsLineFeedChar(wchar_t a_ch);
		static bool  IsLineBreakOpportunityAt(WordWrappingType a_wwMode, const wchar_t* a_wstr, UPInt a_index);
		static bool  IsLineBreakOpportunityAt(WordWrappingType a_wwMode, wchar_t a_prevChar, wchar_t a_curChar);
		static UPInt FindNextNonWhiteSpace(const wchar_t* a_wstr, UPInt a_pos, UPInt a_maxPos);
		static UPInt FindPrevNonWhiteSpace(const wchar_t* a_wstr, UPInt a_pos);
		static bool  IsVowel(wchar_t a_ch);
		static UPInt FindWordWrapPos(WordWrappingType a_wwMode, UPInt a_wordWrapPos, const wchar_t* a_paraText, UPInt a_paraLen, UPInt a_lineStartPos, UPInt a_lineLen);

		static inline CharBreakInfo charBreakInfoArray[] = {
			{ 0x2010, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2012, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2013, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2014, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2018, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x2019, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x201C, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x201D, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2024, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2025, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2026, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2027, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2032, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2033, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2035, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x20A7, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x2103, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2109, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2116, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x2212, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x2213, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x2122, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x2574, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x266F, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x3001, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3002, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3005, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3008, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x3009, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x300A, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x300B, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x300C, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x300D, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x300E, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x300F, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3010, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x3011, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3012, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x3014, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x3015, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x301C, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x301D, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x301E, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x301F, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3041, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3043, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3045, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3047, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3049, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3063, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3083, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3085, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x3087, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x308E, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x309B, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x309C, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x309D, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x309E, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30A1, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30A3, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30A5, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30A7, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30A9, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30C3, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30E3, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30E5, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30E7, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30EE, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30F5, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30F6, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30FB, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30FC, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30FD, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x30FE, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FDFC, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE50, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE51, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE52, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE54, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE55, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE56, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE57, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE59, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FE5A, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE5B, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FE5C, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE5D, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FE5E, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FE6A, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF01, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF04, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FF05, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF08, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FF09, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF0C, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF0E, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF1A, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF1B, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF1F, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF20, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FF3B, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FF3D, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF5B, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FF5D, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF61, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FF64, BreakInfoFlags::kNonStartingChar, 0 },
			{ 0x0FFE0, BreakInfoFlags::kAll, 0 },
			{ 0x0FFE1, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FFE5, BreakInfoFlags::kNonTerminatingChar, 0 },
			{ 0x0FFE6, BreakInfoFlags::kNonTerminatingChar, 0 }
		};
	};
	static_assert(sizeof(GFxWWHelper) == 0x1);
}


===============================================
File: include/RE/G/GHash.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GFixedSizeHash.h"
#include "RE/G/GHashNode.h"
#include "RE/G/GHashSet.h"
#include "RE/G/GHashsetCachedNodeEntry.h"
#include "RE/G/GMemory.h"

namespace RE
{
	template <
		class C,
		class U,
		class HashF = GFixedSizeHash<C>,
		class Allocator = GAllocatorGH<C>,
		class HashNode = GHashNode<C, U, HashF>,
		class Entry = GHashsetCachedNodeEntry<HashNode, typename HashNode::NodeHashF>,
		class Container = GHashSet<HashNode, typename HashNode::NodeHashF, typename HashNode::NodeAltHashF, Allocator, Entry>>
	class GHash
	{
	public:
		using SelfType = GHash<C, U, HashF, Allocator, HashNode, Entry, Container>;
		using const_iterator = typename Container::const_iterator;
		using iterator = typename Container::iterator;

		GHash()
		{}

		GHash(std::int32_t a_sizeHint) :
			hash(a_sizeHint)
		{}

		explicit GHash(void* a_heap) :
			hash(a_heap)
		{}

		GHash(void* a_heap, std::int32_t a_sizeHint) :
			hash(a_heap, a_sizeHint)
		{}

		GHash(const SelfType& a_src) :
			hash(a_src.hash)
		{}

		~GHash()
		{}

		GFC_MEMORY_REDEFINE_NEW(GHash, Allocator::kStatID);

		void operator=(const SelfType& a_src)
		{
			hash = a_src.hash;
		}

		inline void Clear()
		{
			hash.Clear();
		}

		[[nodiscard]] inline bool IsEmpty() const
		{
			return hash.IsEmpty();
		}

		inline void Set(const C& a_key, const U& a_value)
		{
			typename HashNode::NodeRef entry(a_key, a_value);
			hash.Set(entry);
		}

		inline void Add(const C& a_key, const U& a_value)
		{
			typename HashNode::NodeRef entry(a_key, a_value);
			hash.Add(entry);
		}

		inline void Remove(const C& a_key)
		{
			hash.RemoveAlt(a_key);
		}

		template <class K>
		inline void RemoveAlt(const K& a_key)
		{
			hash.RemoveAlt(a_key);
		}

		bool Get(const C& a_key, U* a_value) const
		{
			const HashNode* ptr = hash.GetAlt(a_key);
			if (ptr) {
				if (a_value) {
					*a_value = ptr->second;
				}
				return true;
			}
			return false;
		}

		template <class K>
		bool GetAlt(const K& a_key, U* a_value) const
		{
			const HashNode* ptr = hash.GetAlt(a_key);
			if (ptr) {
				if (a_value) {
					*a_value = ptr->second;
				}
				return true;
			}
			return false;
		}

		inline U* Get(const C& a_key)
		{
			HashNode* ptr = hash.GetAlt(a_key);
			return ptr ? &ptr->second : nullptr;
		}

		inline const U* Get(const C& a_key) const
		{
			const HashNode* ptr = hash.GetAlt(a_key);
			return ptr ? &ptr->second : nullptr;
		}

		template <class K>
		inline U* GetAlt(const K& a_key)
		{
			HashNode* ptr = hash.GetAlt(a_key);
			return ptr ? &ptr->second : nullptr;
		}

		template <class K>
		inline const U* GetAlt(const K& a_key) const
		{
			const HashNode* ptr = hash.GetAlt(a_key);
			return ptr ? &ptr->second : nullptr;
		}

		[[nodiscard]] inline UPInt GetSize() const
		{
			return hash.GetSize();
		}

		inline void Resize(UPInt a_size)
		{
			hash.Resize(a_size);
		}

		inline void SetCapacity(UPInt a_newSize)
		{
			hash.SetCapacity(a_newSize);
		}

		inline iterator begin()
		{
			return hash.begin();
		}

		inline iterator end()
		{
			return hash.end();
		}

		inline const_iterator begin() const
		{
			return hash.begin();
		}

		inline const_iterator end() const
		{
			return hash.end();
		}

		iterator Find(const C& a_key)
		{
			return hash.FindAlt(a_key);
		}

		const_iterator Find(const C& a_key) const
		{
			return hash.FindAlt(a_key);
		}

		template <class K>
		iterator FindAlt(const K& a_key)
		{
			return hash.FindAlt(a_key);
		}

		template <class K>
		const_iterator FindAlt(const K& a_key) const
		{
			return hash.FindAlt(a_key);
		}

		// members
		Container hash;  // 00
	};
}


===============================================
File: include/RE/G/GHashNode.h
===============================================
#pragma once

namespace RE
{
	template <class C, class U, class Hash>
	struct GHashNode
	{
		using SelfType = GHashNode<C, U, Hash>;
		using FirstType = C;
		using SecondType = U;

		struct NodeRef
		{
			const C* first;   // 00
			const U* second;  // 08

			NodeRef(const C& a_first, const U& a_second) :
				first(&a_first),
				second(&a_second)
			{}

			NodeRef(const NodeRef& a_src) :
				first(a_src.first),
				second(a_src.second)
			{}

			[[nodiscard]] inline UPInt GetHash() const
			{
				return Hash()(*first);
			}

			operator const C&() const
			{
				return *first;
			}
		};
		static_assert(sizeof(NodeRef) == 0x10);

		struct NodeHashF
		{
			template <class K>
			UPInt operator()(const K& a_data) const
			{
				return a_data.GetHash();
			}
		};
		static_assert(sizeof(NodeHashF) == 0x1);

		struct NodeAltHashF
		{
			template <class K>
			UPInt operator()(const K& a_data) const
			{
				return GHashNode<C, U, Hash>::CalcHash(a_data);
			}
		};
		static_assert(sizeof(NodeAltHashF) == 0x1);

		GHashNode(const NodeRef& a_src) :
			first(*a_src.first),
			second(*a_src.second)
		{}

		void operator=(const NodeRef& a_src)
		{
			first = *a_src.first;
			second = *a_src.second;
		}

		template <class K>
		bool operator==(const K& a_src) const
		{
			return (first == a_src);
		}

		template <class K>
		static UPInt CalcHash(const K& a_data)
		{
			return Hash()(a_data);
		}

		[[nodiscard]] inline UPInt GetHash() const
		{
			return Hash()(first);
		}

		// members
		C first;   // 00
		U second;  // ??
	};
}


===============================================
File: include/RE/G/GHashSet.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GFixedSizeHash.h"
#include "RE/G/GHashSetBase.h"
#include "RE/G/GHashsetCachedEntry.h"

namespace RE
{
	template <
		class C,
		class HashF = GFixedSizeHash<C>,
		class AltHashF = HashF,
		class Allocator = GAllocatorGH<C>,
		class Entry = GHashsetCachedEntry<C, HashF>>
	class GHashSet :
		public GHashSetBase<C, HashF, AltHashF, Allocator, Entry>
	{
	public:
		using BaseType = GHashSetBase<C, HashF, AltHashF, Allocator, Entry>;
		using SelfType = GHashSet<C, HashF, AltHashF, Allocator, Entry>;

		GHashSet()
		{}

		GHashSet(std::int32_t a_sizeHint) :
			BaseType(a_sizeHint)
		{}

		explicit GHashSet(void* a_heap) :
			BaseType(a_heap)
		{}

		GHashSet(void* a_heap, std::int32_t a_sizeHint) :
			BaseType(a_heap, a_sizeHint)
		{}

		GHashSet(const SelfType& a_src) :
			BaseType(a_src)
		{}

		~GHashSet()
		{}

		void operator=(const SelfType& a_src)
		{
			Assign(this, a_src);
		}

		template <class CRef>
		void Set(const CRef& a_key)
		{
			BaseType::Set(this, a_key);
		}

		template <class CRef>
		inline void Add(const CRef& a_key)
		{
			BaseType::Add(this, a_key);
		}

		void CheckExpand()
		{
			BaseType::CheckExpand(this);
		}

		void Resize(UPInt a_size)
		{
			BaseType::SetCapacity(this, a_size);
		}

		void SetCapacity(UPInt a_newSize)
		{
			BaseType::SetCapacity(this, a_newSize);
		}
	};
}


===============================================
File: include/RE/G/GHashSetBase.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GFixedSizeHash.h"
#include "RE/G/GHashsetCachedEntry.h"
#include "RE/G/GMath.h"
#include "RE/G/GMemory.h"

namespace RE
{
	template <
		class C,
		class HashF = GFixedSizeHash<C>,
		class AltHashF = HashF,
		class Allocator = GAllocatorGH<C>,
		class Entry = GHashsetCachedEntry<C, HashF>>
	class GHashSetBase
	{
	public:
		using SelfType = GHashSetBase<C, HashF, AltHashF, Allocator, Entry>;

		struct const_iterator
		{
		public:
			const_iterator() :
				hash(nullptr),
				index(0)
			{}

			const C& operator*() const
			{
				assert(index >= 0 && index <= (SPInt)hash->table->sizeMask);
				return hash->E(index).value;
			}

			const C* operator->() const
			{
				assert(index >= 0 && index <= (SPInt)hash->table->sizeMask);
				return &hash->E(index).value;
			}

			void operator++()
			{
				if (index <= (SPInt)hash->table->sizeMask) {
					++index;
					while ((UPInt)index <= hash->table->sizeMask && hash->E(index).IsEmpty()) {
						++index;
					}
				}
			}

			bool operator==(const const_iterator& a_it) const
			{
				if (IsEnd() && a_it.IsEnd()) {
					return true;
				} else {
					return (hash == a_it.hash) && (index == a_it.index);
				}
			}

			bool operator!=(const const_iterator& a_it) const
			{
				return !(*this == a_it);
			}

			[[nodiscard]] bool IsEnd() const
			{
				return (!hash) || (!hash->table) || (index > (SPInt)hash->table->sizeMask);
			}

		protected:
			friend class GHashSetBase<C, HashF, AltHashF, Allocator, Entry>;

			const_iterator(const SelfType* a_hash, SPInt a_index) :
				hash(a_hash),
				index(a_index)
			{}

			const SelfType* hash;   // 00
			SPInt           index;  // 08
		};
		static_assert(sizeof(const_iterator) == 0x10);

		friend struct const_iterator;

		struct iterator : public const_iterator
		{
		public:
			iterator() :
				const_iterator(nullptr, 0)
			{}

			C& operator*() const
			{
				assert(const_iterator::index >= 0 && const_iterator::index <= (SPInt)const_iterator::hash->table->sizeMask);
				return const_cast<SelfType*>(const_iterator::hash)->E(const_iterator::index).value;
			}

			C* operator->() const
			{
				return &(operator*());
			}

			void Remove()
			{
				SelfType* theHash = const_cast<SelfType*>(const_iterator::hash);
				Entry*    ee = &theHash->E(const_iterator::index);
				const C&  key = ee->value;

				UPInt hashValue = AltHashF()(key);
				SPInt index = hashValue & hash->table->sizeMask;

				Entry* entry = &hash->E(index);

				if (entry->IsEmpty() || (entry->GetCachedHash(hash->table->sizeMask) != (UPInt)index)) {
					return;
				}

				SPInt naturalIndex = index;
				SPInt prevIndex = -1;

				while ((entry->GetCachedHash(hash->table->sizeMask) != (UPInt)naturalIndex) || !(entry->value == key)) {
					prevIndex = index;
					index = entry->nextInChain;
					if (index == -1) {
						return;
					}
					entry = &hash->E(index);
				}

				if (index == (SPInt)const_iterator::index) {
					if (naturalIndex == index) {
						if (!entry->IsEndOfChain()) {
							Entry* nextEntry = &hash->E(entry->nextInChain);
							entry->Clear();
							new (entry) Entry(*nextEntry);
							entry = nextEntry;
							--const_iterator::index;
						}
					} else {
						hash->E(prevIndex).nextInChain = entry->nextInChain;
					}

					entry->Clear();
					--(hash->table->entryCount);
				} else {
					assert(false);
				}
			}

		private:
			friend class GHashSetBase<C, HashF, AltHashF, Allocator, Entry>;

			using base = const_iterator;
			using base::hash;
			using base::index;

			iterator(SelfType* a_hash, SPInt a_idx) :
				const_iterator(a_hash, a_idx)
			{}
		};

		friend struct iterator;

		GHashSetBase() :
			table(nullptr)
		{}

		GHashSetBase(std::int32_t a_sizeHint) :
			table(0)
		{
			SetCapacity(this, a_sizeHint);
		}

		explicit GHashSetBase([[maybe_unused]] void* a_memAddr) :
			table(0)
		{}

		GHashSetBase(void* a_memAddr, std::int32_t a_sizeHint) :
			table(0)
		{
			SetCapacity(a_memAddr, a_sizeHint);
		}

		GHashSetBase(const SelfType& a_src) :
			table(0)
		{
			Assign(this, a_src);
		}

		~GHashSetBase()
		{
			if (table) {
				// Delete the entries.
				for (UPInt i = 0, n = table->sizeMask; i <= n; i++) {
					Entry* entry = std::addressof(E(i));
					if (!entry->IsEmpty()) {
						entry->Free();
					}
				}

				Allocator::Free(table);
				table = nullptr;
			}
		}

		GFC_MEMORY_REDEFINE_NEW(GHashSetBase, Allocator::kStatID);

		void Assign(void* a_memAddr, const SelfType& a_src)
		{
			Clear();
			if (a_src.IsEmpty() == false) {
				SetCapacity(a_memAddr, a_src.GetSize());
				for (const_iterator it = a_src.Begin(); it != a_src.End(); ++it) {
					Add(a_memAddr, *it);
				}
			}
		}

		void Clear()
		{
			if (table) {
				for (UPInt i = 0, n = table->sizeMask; i <= n; i++) {
					Entry* entry = std::addressof(E(i));
					if (!entry->IsEmpty()) {
						entry->Clear();
					}
				}

				Allocator::Free(table);
				table = nullptr;
			}
		}

		[[nodiscard]] bool IsEmpty() const
		{
			return !table || table->entryCount == 0;
		}

		template <class CRef>
		void Set(void* a_memAddr, const CRef& a_key)
		{
			UPInt hashValue = HashF()(a_key);
			SPInt index = static_cast<SPInt>(-1);

			if (table) {
				index = FindIndexCore(a_key, hashValue & table->sizeMask);
			}

			if (index >= 0) {
				E(index).value = a_key;
			} else {
				Add(a_memAddr, a_key, hashValue);
			}
		}

		template <class CRef>
		inline void Add(void* a_memAddr, const CRef& a_key)
		{
			const UPInt hashValue = HashF()(a_key);
			Add(a_memAddr, a_key, hashValue);
		}

		template <class K>
		void RemoveAlt(const K& a_key)
		{
			if (!table) {
				return;
			}

			const UPInt hashValue = AltHashF()(a_key);
			SPInt       index = hashValue & table->sizeMask;

			Entry* entry = std::addressof(E(index));

			if (entry->IsEmpty() || (entry->GetCachedHash(table->sizeMask) != (UPInt)index)) {
				return;
			}

			// Save index
			const SPInt naturalIndex = index;
			SPInt       prevIndex = -1;

			while ((entry->GetCachedHash(table->sizeMask) != (UPInt)naturalIndex) || !(entry->value == a_key)) {
				prevIndex = index;
				index = entry->nextInChain;
				if (index == -1) {
					return;
				}
				entry = std::addressof(E(index));
			}

			if (naturalIndex == index) {
				if (!entry->IsEndOfChain()) {
					Entry* nextEntry = std::addressof(E(entry->nextInChain));
					entry->Clear();
					new (entry) Entry(*nextEntry);
					entry = nextEntry;
				}
			} else {
				E(prevIndex).nextInChain = entry->nextInChain;
			}

			entry->Clear();
			--(table->entryCount);
		}

		template <class CRef>
		void Remove(const CRef& a_key)
		{
			RemoveAlt(a_key);
		}

		template <class K>
		C* Get(const K& a_key)
		{
			const SPInt index = FindIndex(a_key);
			if (index >= 0) {
				return std::addressof(E(index).value);
			} else {
				return 0;
			}
		}

		template <class K>
		const C* Get(const K& key) const
		{
			const SPInt index = FindIndex(key);
			if (index >= 0) {
				return std::addressof(E(index).value);
			} else {
				return 0;
			}
		}

		template <class K>
		C* GetAlt(const K& a_key)
		{
			const SPInt index = FindIndexAlt(a_key);
			if (index >= 0)
				return std::addressof(E(index).value);
			return nullptr;
		}

		template <class K>
		const C* GetAlt(const K& a_key) const
		{
			const SPInt index = FindIndexAlt(a_key);
			if (index >= 0) {
				return std::addressof(E(index).value);
			} else {
				return nullptr;
			}
		}

		template <class K>
		bool GetAlt(const K& a_key, C* a_val) const
		{
			const SPInt index = FindIndexAlt(a_key);
			if (index >= 0) {
				if (a_val) {
					*a_val = E(index).value;
				}
				return true;
			} else {
				return false;
			}
		}

		[[nodiscard]] UPInt GetSize() const
		{
			return table ? 0 : (UPInt)table->entryCount;
		}

		void CheckExpand(void* a_memAddr)
		{
			if (!table) {
				SetRawCapacity(a_memAddr, HashMinSize);
			} else if (table->entryCount * 5 > (table->sizeMask + 1) * 4) {
				SetRawCapacity(a_memAddr, (table->sizeMask + 1) * 2);
			}
		}

		void Resize(void* a_memAddr, UPInt a_count)
		{
			SetCapacity(a_memAddr, a_count);
		}

		void SetCapacity(void* a_memAddr, UPInt a_newSize)
		{
			UPInt newRawSize = (a_newSize * 5) / 4;
			if (newRawSize <= GetSize()) {
				return;
			}
			SetRawCapacity(a_memAddr, newRawSize);
		}

		iterator begin()
		{
			if (table == 0) {
				return iterator(0, 0);
			}

			UPInt idx = 0;
			while (idx <= table->sizeMask && E(idx).IsEmpty()) {
				++idx;
			}
			return iterator(this, idx);
		}

		iterator end()
		{
			return iterator(0, 0);
		}

		const_iterator begin() const
		{
			return const_cast<SelfType*>(this)->begin();
		}

		const_iterator end() const
		{
			return const_cast<SelfType*>(this)->end();
		}

		template <class K>
		iterator Find(const K& a_key)
		{
			SPInt index = FindIndex(a_key);
			if (index >= 0) {
				return iterator(this, index);
			}
			return iterator(0, 0);
		}

		template <class K>
		iterator FindAlt(const K& a_key)
		{
			SPInt index = FindIndexAlt(a_key);
			if (index >= 0) {
				return iterator(this, index);
			}
			return iterator(0, 0);
		}

		template <class K>
		const_iterator Find(const K& a_key) const
		{
			return const_cast<SelfType*>(this)->Find(a_key);
		}

		template <class K>
		const_iterator FindAlt(const K& a_key) const
		{
			return const_cast<SelfType*>(this)->FindAlt(a_key);
		}

	private:
		enum
		{
			HashMinSize = 8
		};

		struct TableType
		{
			UPInt entryCount;  // 00
			UPInt sizeMask;    // 08
							   //Entry	entries[0];	// 10
		};
		static_assert(sizeof(TableType) == 0x10);

		template <class K>
		SPInt FindIndex(const K& a_key) const
		{
			if (!table) {
				return -1;
			}
			UPInt hashValue = HashF()(a_key) & table->sizeMask;
			return FindIndexCore(a_key, hashValue);
		}

		template <class K>
		SPInt FindIndexAlt(const K& a_key) const
		{
			if (!table) {
				return -1;
			}
			const UPInt hashValue = AltHashF()(a_key) & table->sizeMask;
			return FindIndexCore(a_key, hashValue);
		}

		template <class K>
		SPInt FindIndexCore(const K& a_key, UPInt a_hashValue) const
		{
			assert(table);
			assert((a_hashValue & ~table->sizeMask) == 0);

			UPInt        index = a_hashValue;
			const Entry* entry = std::addressof(E(index));

			if (entry->IsEmpty() || (entry->GetCachedHash(table->sizeMask) != index)) {
				return -1;
			}

			for (;;) {
				assert(entry->GetCachedHash(table->sizeMask) == a_hashValue);
				if (entry->GetCachedHash(table->sizeMask) == a_hashValue && entry->value == a_key) {
					return index;
				}
				assert(!(entry->value == a_key));

				index = entry->nextInChain;
				if (index == (UPInt)-1) {
					break;
				}

				entry = std::addressof(E(index));
				assert(!entry->IsEmpty());
			}
			return -1;
		}

		template <class CRef>
		void Add(void* a_memAddr, const CRef& a_key, UPInt a_hashValue)
		{
			CheckExpand(a_memAddr);
			a_hashValue &= table->sizeMask;

			++(table->entryCount);

			const SPInt index = a_hashValue;
			Entry*      naturalEntry = &(E(index));

			if (naturalEntry->IsEmpty()) {
				new (naturalEntry) Entry(a_key, -1);
			} else {
				SPInt blankIndex = index;
				do {
					blankIndex = (blankIndex + 1) & table->sizeMask;
				} while (!E(blankIndex).IsEmpty());

				Entry* blankEntry = std::addressof(E(blankIndex));

				if (naturalEntry->GetCachedHash(table->sizeMask) == (UPInt)index) {
					new (blankEntry) Entry(*naturalEntry);
					naturalEntry->value = a_key;
					naturalEntry->nextInChain = blankIndex;
				} else {
					SPInt collidedIndex = naturalEntry->GetCachedHash(table->sizeMask);
					assert(collidedIndex >= 0 && collidedIndex <= (SPInt)table->sizeMask);
					for (;;) {
						Entry* entry = std::addressof(E(collidedIndex));
						if (entry->nextInChain == index) {
							new (blankEntry) Entry(*naturalEntry);
							entry->nextInChain = blankIndex;
							break;
						}
						collidedIndex = entry->nextInChain;
						assert(collidedIndex >= 0 && collidedIndex <= (SPInt)table->sizeMask);
					}

					naturalEntry->value = a_key;
					naturalEntry->nextInChain = -1;
				}
			}

			naturalEntry->SetCachedHash(a_hashValue);
		}

		Entry& E(UPInt a_index)
		{
			assert(a_index <= table->sizeMask);
			return *(((Entry*)(table + 1)) + a_index);
		}

		const Entry& E(UPInt a_index) const
		{
			assert(a_index <= table->sizeMask);
			return *(((Entry*)(table + 1)) + a_index);
		}

		void SetRawCapacity(void* a_heapAddr, UPInt a_newSize)
		{
			if (a_newSize == 0) {
				Clear();
				return;
			}

			if (a_newSize < HashMinSize) {
				a_newSize = HashMinSize;
			} else {
				const auto bits = gfchop(glog2f((float)(a_newSize - 1)) + 1);
				a_newSize = UPInt(1) << bits;
			}

			SelfType newHash;
			newHash.table = static_cast<TableType*>(Allocator::Alloc(a_heapAddr, sizeof(TableType) + sizeof(Entry) * a_newSize));
			assert(newHash.table);

			newHash.table->entryCount = 0;
			newHash.table->sizeMask = a_newSize - 1;
			UPInt i;
			UPInt n;

			for (i = 0; i < a_newSize; i++) {
				newHash.E(i).nextInChain = -2;
			}

			if (table) {
				for (i = 0, n = table->sizeMask; i <= n; ++i) {
					Entry* entry = std::addressof(E(i));
					if (entry->IsEmpty() == false) {
						newHash.Add(a_heapAddr, entry->value);
						entry->Clear();
					}
				}
				Allocator::Free(table);
			}

			// Steal newHash's data.
			table = newHash.table;
			newHash.table = nullptr;
		}

		// members
		TableType* table;  // 00
	};
	// size == 0x8
}


===============================================
File: include/RE/G/GHashSetUncached.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GFixedSizeHash.h"
#include "RE/G/GHashSet.h"
#include "RE/G/GHashsetEntry.h"

namespace RE
{
	template <
		class C,
		class HashF = GFixedSizeHash<C>,
		class AltHashF = HashF,
		class Allocator = GAllocatorGH<C>>
	class GHashSetUncached :
		public GHashSet<C, HashF, AltHashF, Allocator, GHashsetEntry<C, HashF>>
	{
	public:
		using BaseType = GHashSet<C, HashF, AltHashF, Allocator, GHashsetEntry<C, HashF>>;
		using SelfType = GHashSetUncached<C, HashF, AltHashF, Allocator>;

		GHashSetUncached()
		{}

		GHashSetUncached(std::int32_t a_sizeHint) :
			BaseType(a_sizeHint)
		{}

		GHashSetUncached(const SelfType& a_src) :
			BaseType(a_src)
		{}

		~GHashSetUncached()
		{}

		void operator=(const SelfType& a_src)
		{
			BaseType::operator=(a_src);
		}
	};
}


===============================================
File: include/RE/G/GHashUncached.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GFixedSizeHash.h"
#include "RE/G/GHash.h"
#include "RE/G/GHashNode.h"
#include "RE/G/GHashsetNodeEntry.h"

namespace RE
{
	template <
		class C,
		class U,
		class HashF = GFixedSizeHash<C>,
		class Allocator = GAllocatorGH<C>>
	class GHashUncached :
		public GHash<
			C,
			U,
			HashF,
			Allocator,
			GHashNode<C, U, HashF>,
			GHashsetNodeEntry<GHashNode<C, U, HashF>,
				typename GHashNode<C, U, HashF>::NodeHashF>>
	{
	public:
		using BaseType = GHash<
			C,
			U,
			HashF,
			Allocator,
			GHashNode<C, U, HashF>,
			GHashsetNodeEntry<GHashNode<C, U, HashF>,
				typename GHashNode<C, U, HashF>::NodeHashF>>;
		using SelfType = GHashUncached<C, U, HashF, Allocator>;

		GHashUncached()
		{}

		GHashUncached(std::int32_t a_sizeHint) :
			BaseType(a_sizeHint)
		{}

		GHashUncached(const SelfType& a_src) :
			BaseType(a_src)
		{}

		~GHashUncached()
		{}

		void operator=(const SelfType& a_src)
		{
			BaseType::operator=(a_src);
		}
	};
}


===============================================
File: include/RE/G/GHashsetCachedEntry.h
===============================================
#pragma once

namespace RE
{
	template <class T, class Hash>
	class GHashsetCachedEntry
	{
	public:
		GHashsetCachedEntry() :
			nextInChain(-2),
			hashValue(0),
			value{}
		{}

		GHashsetCachedEntry(const GHashsetCachedEntry& a_entry) :
			nextInChain(a_entry.nextInChain),
			hashValue(a_entry.hashValue),
			value(a_entry.value)
		{}

		GHashsetCachedEntry(const T& a_key, SPInt a_next) :
			nextInChain(a_next),
			hashValue(0),
			value(a_key)
		{}

		[[nodiscard]] bool IsEmpty() const
		{
			return nextInChain == -2;
		}

		[[nodiscard]] bool IsEndOfChain() const
		{
			return nextInChain == -1;
		}

		[[nodiscard]] UPInt GetCachedHash([[maybe_unused]] UPInt a_maskValue) const
		{
			return hashValue;
		}

		void SetCachedHash(UPInt a_hashValue)
		{
			hashValue = a_hashValue;
		}

		void Clear()
		{
			value.~C();
			nextInChain = -2;
		}

		void Free()
		{
			Clear();
		}

		// members
		SPInt nextInChain;  // 00
		UPInt hashValue;    // 08
		T     value;        // 10
	};
	// size == 0x10 + sizeof(T)
}


===============================================
File: include/RE/G/GHashsetCachedNodeEntry.h
===============================================
#pragma once

namespace RE
{
	template <class T, class Hash>
	class GHashsetCachedNodeEntry
	{
	public:
		GHashsetCachedNodeEntry() :
			nextInChain(-2),
			hashValue(0),
			value{}
		{}

		GHashsetCachedNodeEntry(const GHashsetCachedNodeEntry& a_entry) :
			nextInChain(a_entry.nextInChain),
			hashValue(a_entry.hashValue),
			value(a_entry.value)
		{}

		GHashsetCachedNodeEntry(const T& a_key, SPInt a_next) :
			nextInChain(a_next),
			hashValue(0),
			value(a_key)
		{}

		GHashsetCachedNodeEntry(const typename T::NodeRef& a_keyRef, SPInt a_next) :
			nextInChain(a_next),
			hashValue(0),
			value(a_keyRef)
		{}

		[[nodiscard]] bool IsEmpty() const
		{
			return nextInChain == -2;
		}

		[[nodiscard]] bool IsEndOfChain() const
		{
			return nextInChain == -1;
		}

		[[nodiscard]] UPInt GetCachedHash([[maybe_unused]] UPInt a_maskValue) const
		{
			return hashValue;
		}

		void SetCachedHash(UPInt a_hashValue)
		{
			hashValue = a_hashValue;
		}

		void Clear()
		{
			value.~T();
			nextInChain = -2;
		}

		void Free()
		{
			Clear();
		}

		// members
		SPInt nextInChain;  // 00
		UPInt hashValue;    // 08
		T     value;        // 10
	};
	// size == 0x10 + sizeof(T)
}


===============================================
File: include/RE/G/GHashsetEntry.h
===============================================
#pragma once

namespace RE
{
	template <class T, class HashF>
	class GHashsetEntry
	{
	public:
		GHashsetEntry() :
			nextInChain(-2)
		{}

		GHashsetEntry(const GHashsetEntry& a_entry) :
			nextInChain(a_entry.nextInChain),
			value(a_entry.value)
		{}

		GHashsetEntry(const T& a_key, SPInt a_next) :
			nextInChain(a_next),
			value(a_key)
		{}

		[[nodiscard]] bool IsEmpty() const
		{
			return nextInChain == -2;
		}

		[[nodiscard]] bool IsEndOfChain() const
		{
			return nextInChain == -1;
		}

		[[nodiscard]] UPInt GetCachedHash(UPInt a_maskValue) const
		{
			return HashF()(value) & a_maskValue;
		}

		void SetCachedHash([[maybe_unused]] UPInt a_hashValue)
		{}

		void Clear()
		{
			value.~T();
			nextInChain = -2;
		}

		void Free()
		{
			Clear();
		}

		// members
		SPInt nextInChain;  // 00
		T     value;        // 08
	};
	// size == 0x8 + sizeof(T)
}


===============================================
File: include/RE/G/GHashsetNodeEntry.h
===============================================
#pragma once

namespace RE
{
	template <class T, class Hash>
	class GHashsetNodeEntry
	{
	public:
		GHashsetNodeEntry() :
			nextInChain(-2)
		{}

		GHashsetNodeEntry(const GHashsetNodeEntry& a_entry) :
			nextInChain(a_entry.nextInChain),
			value(a_entry.value)
		{}

		GHashsetNodeEntry(const T& a_key, SPInt a_next) :
			nextInChain(a_next),
			value(a_key)
		{}

		GHashsetNodeEntry(const typename T::NodeRef& a_keyRef, SPInt a_next) :
			nextInChain(a_next),
			value(a_keyRef)
		{}

		[[nodiscard]] bool IsEmpty() const
		{
			return nextInChain == -2;
		}

		[[nodiscard]] bool IsEndOfChain() const
		{
			return nextInChain == -1;
		}

		[[nodiscard]] UPInt GetCachedHash(UPInt a_maskValue) const
		{
			return Hash()(value) & a_maskValue;
		}

		void SetCachedHash([[maybe_unused]] UPInt a_hashValue)
		{}

		void Clear()
		{
			value.~T();
			nextInChain = -2;
		}

		void Free()
		{
			Clear();
		}

		// members
		SPInt nextInChain;  // 00
		T     value;        // 08
	};
	// size == 0x8 + sizeof(T)
}


===============================================
File: include/RE/G/GImage.h
===============================================
#pragma once

#include "RE/G/GImageBase.h"
#include "RE/G/GRefCountBaseNTS.h"

namespace RE
{
	class GImage :
		public GRefCountBaseNTS<GImage, GStatGroup::kGStat_Image_Mem>,
		public GImageBase
	{
	public:
		~GImage() override;  // 00
	};
	static_assert(sizeof(GImage) == 0x48);
}


===============================================
File: include/RE/G/GImageBase.h
===============================================
#pragma once

#include "RE/G/GArray.h"
#include "RE/G/GColor.h"

namespace RE
{
	class GImageBase
	{
	public:
		enum class ImageFormat
		{
			kNone = 0,
			kARGB_8888 = 1,
			kRGB_888 = 2,
			kL_8 = 8,
			kA_8 = 9,
			kDXT1 = 10,
			kDXT3 = 11,
			kDXT5 = 12,

			kP_8 = 100,

			kYUV_822 = 200,
			kYUVA_8228 = 201,
		};

		stl::enumeration<ImageFormat, std::uint32_t> format;       // 00
		std::uint32_t                                width;        // 04
		std::uint32_t                                height;       // 08
		std::uint32_t                                pitch;        // 0C
		std::uint8_t*                                data;         // 10
		std::uint32_t                                dataSize;     // 18
		std::uint32_t                                mipMapCount;  // 1C
		GArray<GColor>                               colorMap;     // 20
	};
	static_assert(sizeof(GImageBase) == 0x38);
}


===============================================
File: include/RE/G/GList.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	struct GListNode
	{
	public:
		GListNode() :
			prev{ 0 },
			next{ 0 }
		{}

		void Remove()
		{
			prev->next = next;
			next->prev = prev;
		}

		GListNode<T>* prev;  // 00
		GListNode<T>* next;  // 08
	};
	static_assert(sizeof(GListNode<void*>) == 0x10);

	// circular doubly-linked list
	// classes must derive from GListNode
	template <class T>
	class GList
	{
	private:
		using Node = GListNode<T>;

	public:
		using value_type = T;
		using size_type = std::size_t;
		using difference_type = std::ptrdiff_t;
		using reference = value_type&;
		using const_reference = const value_type&;
		using pointer = value_type*;
		using const_pointer = typename std::pointer_traits<pointer>::template rebind<const value_type>;

		template <class U>
		struct iterator_traits
		{
			using difference_type = std::ptrdiff_t;
			using value_type = U;
			using pointer = U*;
			using reference = U&;
			using iterator_category = std::bidirectional_iterator_tag;
		};

		template <class U>
		class iterator_base : public iterator_traits<U>
		{
		private:
			friend class GList<T>;

			using Traits = iterator_traits<U>;

		public:
			using difference_type = typename Traits::difference_type;
			using value_type = typename Traits::value_type;
			using pointer = typename Traits::pointer;
			using reference = typename Traits::reference;
			using iterator_category = typename Traits::iterator_category;

			iterator_base() :
				_cur{ 0 }
			{}

			iterator_base(Node* a_node)
			{
				_cur = a_node;
			}

			iterator_base(const iterator_base& a_rhs) :
				_cur(a_rhs._cur)
			{}

			iterator_base(iterator_base&& a_rhs) :
				_cur(std::move(a_rhs._cur))
			{
				a_rhs._cur = 0;
			}

			static void swap(iterator_base& a_lhs, iterator_base& a_rhs)
			{
				std::swap(a_lhs._cur, a_rhs._cur);
			}

			iterator_base& operator=(const iterator_base& a_rhs)
			{
				iterator_base tmp(a_rhs);
				swap(*this, tmp);
			}

			iterator_base& operator=(iterator_base&& a_rhs)
			{
				_cur = std::move(a_rhs._cur);
				a_rhs._cur = 0;
			}

			[[nodiscard]] reference operator*() const
			{
				return (reference)*_cur;
			}

			[[nodiscard]] pointer operator->() const
			{
				return std::pointer_traits<pointer>::pointer_to(operator*());
			}

			[[nodiscard]] bool operator==(const iterator_base& a_rhs) const
			{
				return _cur == a_rhs._cur;
			}

			[[nodiscard]] bool operator!=(const iterator_base& a_rhs) const
			{
				return !operator==(a_rhs);
			}

			// prefix
			iterator_base& operator++()
			{
				_cur = _cur->next;
				return *this;
			}

			// postfix
			iterator_base operator++(int)
			{
				iterator_base tmp{ *this };
							  operator++();
				return tmp;
			}

			// prefix
			iterator_base& operator--()
			{
				_cur = _cur->prev;
				return *this;
			}

			// postifx
			iterator_base operator--(int)
			{
				iterator_base tmp{ *this };
							  operator--();
				return tmp;
			}

		protected:
			Node* _cur;
		};

		using iterator = iterator_base<T>;
		using const_iterator = iterator_base<const T>;
		using reverse_iterator = std::reverse_iterator<iterator>;
		using const_reverse_iterator = std::reverse_iterator<const_iterator>;

		GList() :
			_root{}
		{
			_root.next = _root.prev = &_root;
		}

		reference front()
		{
			return (reference)_root.next;
		}

		[[nodiscard]] const_reference front() const
		{
			return (const_reference)_root.next;
		}

		reference back()
		{
			return (reference)_root.prev;
		}

		[[nodiscard]] const_reference back() const
		{
			return (const_reference)_root.prev;
		}

		iterator begin() noexcept
		{
			return iterator(_root.next);
		}

		[[nodiscard]] const_iterator begin() const noexcept
		{
			return const_iterator(_root.next);
		}

		[[nodiscard]] const_iterator cbegin() const noexcept
		{
			return const_iterator(_root.next);
		}

		iterator end() noexcept
		{
			return iterator(&_root);
		}

		[[nodiscard]] const_iterator end() const noexcept
		{
			return const_iterator(const_cast<GListNode<value_type>*>(&_root));
		}

		[[nodiscard]] const_iterator cend() const noexcept
		{
			return const_iterator(const_cast<GListNode<value_type>*>(&_root));
		}

		reverse_iterator rbegin() noexcept
		{
			return reverse_iterator(_root.prev);
		}

		[[nodiscard]] const_reverse_iterator rbegin() const noexcept
		{
			return const_reverse_iterator(_root.prev);
		}

		[[nodiscard]] const_reverse_iterator crbegin() const noexcept
		{
			return const_reverse_iterator(_root.prev);
		}

		reverse_iterator rend() noexcept
		{
			return reverse_iterator(&_root);
		}

		[[nodiscard]] const_reverse_iterator rend() const noexcept
		{
			return const_reverse_iterator(const_cast<GListNode<value_type>*>(&_root));
		}

		[[nodiscard]] const_reverse_iterator crend() const noexcept
		{
			return const_reverse_iterator(const_cast<GListNode<value_type>*>(&_root));
		}

		[[nodiscard]] bool empty() const noexcept
		{
			return _root.next == &_root;
		}

		[[nodiscard]] size_type size() const noexcept
		{
			size_type size = 0;
			for (auto it = begin(); it != end(); ++it) {
				++size;
			}
			return size;
		}

		void clear() noexcept
		{
			_root.next = _root.prev = &_root;
		}

		iterator insert(const_iterator a_pos, const T& a_value)
		{
			Node* node = (Node*)&a_value;
			node->prev = a_pos._cur->prev;
			a_pos._cur->prev->next = node;
			node->next = a_pos._cur;
			a_pos._cur->prev = node;
			return { node };
		}

		iterator erase(const_iterator a_pos)
		{
			a_pos._cur->prev->next = a_pos._cur->next;
			a_pos._cur->next->prev = a_pos._cur->prev;
		}

		iterator erase(const_iterator a_first, const_iterator a_last)
		{
			a_first._cur->prev->next = a_last._cur->next;
			a_last._cur->next->prev = a_first._cur->prev;
		}

		void push_back(const T& a_value)
		{
			Node* node = (Node*)&a_value;
			node->next = &_root;
			node->prev = _root.prev;
			_root.prev->next = node;
			_root.prev = node;
		}

		void pop_back()
		{
			_root.prev = _root.prev->prev;
			_root.prev->next = &_root;
		}

		void push_front(const T& a_value)
		{
			Node* node = (Node*)&a_value;
			node->next = _root.next;
			node->prev = &_root;
			_root.next->prev = node;
			_root.next = node;
		}

		void pop_front()
		{
			_root.next = _root.next->next;
			_root.next->prev = &_root;
		}

		void merge(GList& a_other)
		{
			while (!a_other.empty()) {
				push_front(a_other.front());
			}
		}

	protected:
		// members
		GListNode<value_type> _root;  // 00
	};
	static_assert(sizeof(GList<void*>) == 0x10);
}


===============================================
File: include/RE/G/GMath.h
===============================================
#pragma once

namespace RE
{
	constexpr double GFC_MATH_LN2 = 0.69314718055994530942;

	constexpr std::int32_t gfchop(float a_val)
	{
		return static_cast<std::int32_t>(a_val);
	}

	inline float glog2f(float a_val)
	{
		return std::logf(a_val) / static_cast<float>(GFC_MATH_LN2);
	}
}


===============================================
File: include/RE/G/GMatrix2D.h
===============================================
#pragma once

namespace RE
{
	class GMatrix2D
	{
	public:
		GMatrix2D()
		{
			SetIdentity();
		}

		GMatrix2D(float a_v0, float a_v1, float a_v2, float a_v3, float a_v4, float a_v5)
		{
			SetMatrix(a_v0, a_v1, a_v2, a_v3, a_v4, a_v5);
		}

		GMatrix2D& operator=(const GMatrix2D& a_rhs)
		{
			for (std::size_t i = 0; i < std::extent<decltype(data), 0>::value; ++i) {
				for (std::size_t j = 0; j < std::extent<decltype(data), 1>::value; ++j) {
					data[i][j] = a_rhs.data[i][j];
				}
			}
			return *this;
		}

		inline void SetMatrix(const GMatrix2D& a_matrix)
		{
			data[0][0] = a_matrix.data[0][0];
			data[0][1] = a_matrix.data[0][1];
			data[0][2] = a_matrix.data[0][2];
			data[1][0] = a_matrix.data[1][0];
			data[1][1] = a_matrix.data[1][1];
			data[1][2] = a_matrix.data[1][2];
		}

		inline void SetMatrix(float a_v0, float a_v1, float a_v2, float a_v3, float a_v4, float a_v5)
		{
			data[0][0] = a_v0;
			data[0][1] = a_v1;
			data[0][2] = a_v4;
			data[1][0] = a_v2;
			data[1][1] = a_v3;
			data[1][2] = a_v5;
		}

		void SetIdentity()
		{
			data[0][0] = 1.0f;
			data[0][1] = 0.0f;
			data[0][2] = 0.0f;
			data[1][0] = 0.0f;
			data[1][1] = 1.0f;
			data[1][2] = 0.0f;
		}

		float data[2][3];  // 00
	};
	static_assert(sizeof(GMatrix2D) == 0x18);
}


===============================================
File: include/RE/G/GMatrix3D.h
===============================================
#pragma once

namespace RE
{
	class GMatrix3D
	{
	public:
		GMatrix3D() :
			data{
				{ 0.0, 0.0, 0.0, 0.0 },
				{ 0.0, 0.0, 0.0, 0.0 },
				{ 0.0, 0.0, 0.0, 0.0 },
				{ 0.0, 0.0, 0.0, 0.0 }
			}
		{}

		GMatrix3D& operator=(const GMatrix3D& a_rhs)
		{
			for (std::size_t i = 0; i < std::extent<decltype(data), 0>::value; ++i) {
				for (std::size_t j = 0; j < std::extent<decltype(data), 1>::value; ++j) {
					data[i][j] = a_rhs.data[i][j];
				}
			}
			return *this;
		}

		float data[4][4];  // 00
	};
	static_assert(sizeof(GMatrix3D) == 0x40);
}


===============================================
File: include/RE/G/GMemory.h
===============================================
#pragma once

#include "RE/G/GMemoryHeap.h"

namespace RE
{
	class GMemory
	{
	public:
		static void         SetGlobalHeap(GMemoryHeap* a_heap);
		static GMemoryHeap* GetGlobalHeap();
		static void         CreateArena(UPInt a_arena, GSysAllocPaged* a_sysAlloc);
		static void         DestroyArena(UPInt a_arena);
		static bool         ArenaIsEmpty(UPInt a_arena);
		static void*        Alloc(UPInt a_count);
		static void*        Alloc(UPInt a_count, UPInt a_al);
		static void*        AllocAutoHeap(const void* a_ptr, UPInt a_count);
		static void*        AllocAutoHeap(const void* a_ptr, UPInt a_count, UPInt a_al);
		static void*        AllocInHeap(GMemoryHeap* a_heap, UPInt a_count);
		static void*        AllocInHeap(GMemoryHeap* a_heap, UPInt a_count, UPInt a_al);
		static void*        Realloc(void* a_ptr, UPInt a_newCount);
		static void         Free(void* a_ptr);
		static void         FreeInHeap(GMemoryHeap* a_heap, void* a_ptr);
		static GMemoryHeap* GetHeapByAddress(const void* a_ptr);
		static bool         DetectMemoryLeaks();

	protected:
		static GMemoryHeap*& GetGlobalHeapRef();
	};
}

// Global heap
#define GALLOC(a_count) RE::GMemory::Alloc((a_count))
#define GMEMALIGN(a_sz, a_al) RE::GMemory::Alloc((a_count), (a_al))
#define GREALLOC(a_ptr, a_count) RE::GMemory::Realloc((a_ptr), (a_count))
#define GFREE(a_ptr) RE::GMemory::Free((a_ptr))
#define GFREE_ALIGN(a_count) RE::GMemory::Free((a_count))

// Local heap
#define GHEAP_ALLOC(a_heap, a_count) RE::GMemory::AllocInHeap((a_heap), (a_count))
#define GHEAP_MEMALIGN(a_heap, a_count, a_al) RE::GMemory::AllocInHeap((a_heap), (a_count), (a_al))
#define GHEAP_AUTO_ALLOC(a_addr, a_count) RE::GMemory::AllocAutoHeap((a_addr), (a_count))
#define GHEAP_FREE(a_heap, a_ptr) RE::GMemory::FreeInHeap((a_heap), (a_ptr))

#define GFC_MEMORY_REDEFINE_NEW_IMPL(a_className, a_check_delete, a_statType)                                   \
	void* operator new(std::size_t a_count) { return GALLOC(a_count); }                                         \
	void* operator new[](std::size_t a_count) { return GALLOC(a_count); }                                       \
	void* operator new([[maybe_unused]] std::size_t a_count, void* a_plcmnt) { return a_plcmnt; }               \
	void* operator new[]([[maybe_unused]] std::size_t a_count, void* a_plcmnt) { return a_plcmnt; }             \
	void* operator new(std::size_t a_count, RE::GMemoryHeap* a_heap) { return GHEAP_ALLOC(a_heap, a_count); }   \
	void* operator new[](std::size_t a_count, RE::GMemoryHeap* a_heap) { return GHEAP_ALLOC(a_heap, a_count); } \
	void  operator delete(void* a_ptr) { GFREE(a_ptr); }                                                        \
	void  operator delete[](void* a_ptr) { GFREE(a_ptr); }                                                      \
	void  operator delete([[maybe_unused]] void* a_ptr, [[maybe_unused]] void* a_plcmnt) {}                     \
	void  operator delete[]([[maybe_unused]] void* a_ptr, [[maybe_unused]] void* a_plcmnt) {}                   \
	void  operator delete(void* a_ptr, RE::GMemoryHeap* a_heap) { GHEAP_FREE(a_heap, a_ptr); }

#define GFC_MEMORY_CHECK_DELETE_NONE(a_className, a_ptr)
#define GFC_MEMORY_REDEFINE_NEW(a_className, a_statType) GFC_MEMORY_REDEFINE_NEW_IMPL(a_className, GFC_MEMORY_CHECK_DELETE_NONE, a_statType)


===============================================
File: include/RE/G/GMemoryHeap.h
===============================================
#pragma once

#include "RE/G/GAtomic.h"
#include "RE/G/GList.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GHeapMemVisitor;
	class GHeapSegVisitor;
	class GStatBag;
	class GSysAllocPaged;
	struct GAllocDebugInfo;

	class GMemoryHeap : public GListNode<GMemoryHeap>
	{
	private:
		friend class GMemoryHeapPT;
		friend class GMemoryHeapMH;
		friend class GHeapRoot;
		friend class GHeapRootMH;

	public:
		enum class MemReportType
		{
			kBrief,
			kSummary,
			kMedium,
			kFull,
			kSimple,
			kSimpleBrief,
			kFileSummary,
			kHeapsOnly
		};

		enum class HeapFlags
		{
			kNone = 0,
			kThreadUnsafe = 1 << 0,
			kFastTinyBlocks = 1 << 1,
			kFixedGranularity = 1 << 2,
			kRoot = 1 << 3,
			kNoDebugInfo = 1 << 4,
			kUserDebug = 1 << 12
		};

		struct RootHeapParameters
		{
			enum RootHeapParameter : UPInt
			{
				kMinAlign = 16,
				kGranularity = 16 * 1024,
				kReserve = 16 * 1024,
				kThreshold = 256 * 1024,
				kLimit = 0
			};
		};

		struct HeapDesc
		{
		public:
			HeapDesc(HeapFlags a_flags = HeapFlags::kNone,
				UPInt          a_minAlign = 16,
				UPInt          a_granularity = 8 * 1024,
				UPInt          a_reserve = 8 * 1024,
				UPInt          a_threshold = UPINT_MAX,
				UPInt          a_limit = 0,
				GHeapID        a_heapID = GHeapID::kReserved,
				UPInt          a_arena = 0);

			void Clear();

			// members
			stl::enumeration<HeapFlags, std::uint32_t> flags;        // 00
			std::uint32_t                              pad04;        // 04
			UPInt                                      minAlign;     // 08
			UPInt                                      granularity;  // 10
			UPInt                                      reserve;      // 18
			UPInt                                      threshold;    // 20
			UPInt                                      limit;        // 28
			GHeapID                                    heapID;       // 30
			UPInt                                      arena;        // 38
		};
		static_assert(sizeof(HeapDesc) == 0x40);

		struct RootHeapDesc : public HeapDesc
		{
		public:
			RootHeapDesc();
		};
		static_assert(sizeof(RootHeapDesc) == 0x40);

		struct HeapInfo
		{
		public:
			// members
			HeapDesc     desc;    // 00
			GMemoryHeap* parent;  // 40 - NULL == root heap
			char*        name;    // 48
		};
		static_assert(sizeof(HeapInfo) == 0x50);

		struct HeapVisitor
		{
		public:
			virtual ~HeapVisitor();  // 00

			// add
			virtual void Visit(GMemoryHeap* a_parentHeap, GMemoryHeap* a_childHeap) = 0;  // 01
		};
		static_assert(sizeof(HeapVisitor) == 0x8);

		struct LimitHandler
		{
		public:
			virtual ~LimitHandler();  // 00

			// add
			virtual bool OnExceedLimit(GMemoryHeap* a_heap, UPInt a_overLimit) = 0;    // 01
			virtual void OnFreeSegment(GMemoryHeap* a_heap, UPInt a_freeingSize) = 0;  // 02
		};
		static_assert(sizeof(LimitHandler) == 0x8);

		struct HeapTracer
		{
		public:
			virtual ~HeapTracer();  // 00

			// add
			virtual void OnCreateHeap(const GMemoryHeap* a_heap) = 0;                                                             // 01
			virtual void OnDestroyHeap(const GMemoryHeap* a_heap) = 0;                                                            // 02
			virtual void OnAlloc(const GMemoryHeap* a_heap, UPInt a_size, UPInt a_align, unsigned a_sID, const void* a_ptr) = 0;  // 03
			virtual void OnRealloc(const GMemoryHeap* a_heap, const void* a_oldPtr, UPInt a_newSize, const void* a_newPtr) = 0;   // 04
			virtual void OnFree(const GMemoryHeap* a_heap, const void* a_ptr) = 0;                                                // 05
		};
		static_assert(sizeof(HeapTracer) == 0x8);

		struct RootStats
		{
		public:
			// members
			UPInt sysMemFootprint;       // 00
			UPInt sysMemUsedSpace;       // 08
			UPInt pageMapFootprint;      // 10
			UPInt pageMapUsedSpace;      // 18
			UPInt bookkeepingFootprint;  // 20
			UPInt bookkeepingUsedSpace;  // 28
			UPInt debugInfoFootprint;    // 30
			UPInt debugInfoUsedSpace;    // 38
			UPInt userDebugFootprint;    // 40
			UPInt userDebugUsedSpace;    // 48
		};
		static_assert(sizeof(RootStats) == 0x50);

	protected:
		virtual ~GMemoryHeap();  // 00

	public:
		// add
		virtual void         CreateArena(UPInt a_arena, GSysAllocPaged* a_sysAlloc) = 0;          // 01
		virtual void         DestroyArena(UPInt a_arena) = 0;                                     // 02
		virtual bool         ArenaIsEmpty(UPInt a_arena) = 0;                                     // 03
		virtual GMemoryHeap* CreateHeap(const char* a_name, const HeapDesc& a_desc) = 0;          // 04
		virtual void         SetLimitHandler(LimitHandler* handler) = 0;                          // 05
		virtual void         SetLimit(UPInt newLimit) = 0;                                        // 06
		virtual void         AddRef() = 0;                                                        // 07
		virtual void         Release() = 0;                                                       // 08
		virtual void*        Alloc(UPInt a_size) = 0;                                             // 09
		virtual void*        Alloc(UPInt a_size, UPInt a_align) = 0;                              // 0A
		virtual void*        Realloc(void* a_oldPtr, UPInt a_newSize) = 0;                        // 0B
		virtual void         Free(void* a_ptr) = 0;                                               // 0C
		virtual void*        AllocAutoHeap(const void* a_this, UPInt a_size) = 0;                 // 0D
		virtual void*        AllocAutoHeap(const void* a_this, UPInt a_size, UPInt a_align) = 0;  // 0E
		virtual GMemoryHeap* GetAllocHeap(const void* a_this) = 0;                                // 0F
		virtual UPInt        GetUsableSize(const void* a_ptr) = 0;                                // 10
		virtual void*        AllocSysDirect(UPInt a_size) = 0;                                    // 11
		virtual void         FreeSysDirect(void* a_ptr, UPInt a_size) = 0;                        // 12
		virtual bool         GetStats(GStatBag* a_bag) = 0;                                       // 13
		virtual UPInt        GetFootprint() const = 0;                                            // 14
		virtual UPInt        GetTotalFootprint() const = 0;                                       // 15
		virtual UPInt        GetUsedSpace() const = 0;                                            // 16
		virtual UPInt        GetTotalUsedSpace() const = 0;                                       // 17
		virtual void         GetRootStats(RootStats* a_stats) = 0;                                // 18
		virtual void         VisitMem(GHeapMemVisitor* a_visitor, std::uint32_t a_flags) = 0;     // 19
		virtual void         VisitRootSegments(GHeapSegVisitor* a_visitor) = 0;                   // 1A
		virtual void         VisitHeapSegments(GHeapSegVisitor* a_visitor) const = 0;             // 1B
		virtual void         SetTracer(HeapTracer* a_tracer) = 0;                                 // 1C - { return; }

	protected:
		virtual void DestroyItself() = 0;                              // 1D
		virtual void UltimateCheck_Internal() = 0;                     // 1E - { return; }
		virtual void ReleaseCachedMem() = 0;                           // 1F
		virtual bool DumpMemoryLeaks_Internal() = 0;                   // 20 - { return false; }
		virtual void CheckIntegrity_Internal() const = 0;              // 21
		virtual void GetUserDebugStats(RootStats* a_stats) const = 0;  // 22

	public:
		GMemoryHeap* CreateHeap(const char* a_name,
			HeapFlags                       a_flags = HeapFlags::kNone,
			UPInt                           a_minAlign = 16,
			UPInt                           a_granularity = 16 * 1024,
			UPInt                           a_reserve = 16 * 1024,
			UPInt                           a_threshold = UPINT_MAX,
			UPInt                           a_limit = 0,
			GHeapID                         a_heapID = GHeapID::kReserved,
			UPInt                           a_arena = 0);

		void         GetHeapInfo(HeapInfo* a_info) const;
		const char*  GetName() const;
		GHeapID      GetID() const;
		GMemoryHeap* GetParentHeap() const;
		HeapFlags    GetFlags() const;
		UPInt        GetGranularity() const;
		UPInt        GetLimit() const;
		bool         IsThreadSafe() const;
		void         ReleaseOnFree(void* a_ptr);
		void         AssignToCurrentThread();
		bool         DumpMemoryLeaks();
		void         UltimateCheck();
		void         CheckIntegrity();

	protected:
		using ChildListType = GList<GMemoryHeap>;

		// members
		UPInt                  _selfSize;        // 18
		volatile std::uint32_t _refCount;        // 20
		std::uint32_t          _pad24;           // 24
		UPInt                  _ownerThreadID;   // 28
		void*                  _autoRelease;     // 30 - auto frees heap when freed
		HeapInfo               _info;            // 38
		ChildListType          _childHeaps;      // 88
		mutable GLock          _heapLock;        // 98
		bool                   _useLocks;        // C0
		bool                   _trackDebugInfo;  // C1
		std::uint16_t          _padC2;           // C2
		std::uint32_t          _padC4;           // C4
	};
	static_assert(sizeof(GMemoryHeap) == 0xC8);

	class GHeapAllocEngine;
	class GHeapDebugStorage;

	class GMemoryHeapPT : public GMemoryHeap
	{
	private:
		// members
		[[maybe_unused]] GHeapAllocEngine*  _engine;        // C8
		[[maybe_unused]] GHeapDebugStorage* _debugStorage;  // D0
	};
	static_assert(sizeof(GMemoryHeapPT) == 0xD8);
}


===============================================
File: include/RE/G/GMutex.h
===============================================
#pragma once

#include "RE/G/GAcquireInterface.h"
#include "RE/G/GWaitable.h"

namespace RE
{
	class GMutexImpl;

	class GMutex :
		public GWaitable,         // 00
		public GAcquireInterface  // 18
	{
	public:
		GMutexImpl* impl;  // 20
	};
	static_assert(sizeof(GMutex) == 0x28);
}


===============================================
File: include/RE/G/GNewOverrideBase.h
===============================================
#pragma once

#include "RE/G/GMemory.h"

namespace RE
{
	template <std::uint32_t Stat>
	class GNewOverrideBase
	{
	public:
		enum
		{
			kStatType = Stat
		};

		GFC_MEMORY_REDEFINE_NEW(GNewOverrideBase, Stat);
	};
}


===============================================
File: include/RE/G/GPoint.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class GPoint
	{
	public:
		enum class BoundsType
		{
			kMin,
			kMax
		};

		// members
		T x;  // 00
		T y;  // ??
	};

	using GPointF = GPoint<float>;
	static_assert(sizeof(GPointF) == 0x8);

	using GPointD = GPoint<double>;
	static_assert(sizeof(GPointD) == 0x10);
}


===============================================
File: include/RE/G/GPtr.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class GPtr
	{
	public:
		using element_type = T;

		// 1
		inline constexpr GPtr() noexcept :
			_ptr(nullptr)
		{}

		// 2
		inline constexpr GPtr(std::nullptr_t) noexcept :
			_ptr(nullptr)
		{}

		// 3
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline explicit GPtr(Y* a_rhs) :
			_ptr(a_rhs)
		{
			TryAttach();
		}

		// 9a
		inline GPtr(const GPtr& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 9b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline GPtr(const GPtr<Y>& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 10a
		inline GPtr(GPtr&& a_rhs) noexcept :
			_ptr(std::move(a_rhs._ptr))
		{
			a_rhs._ptr = nullptr;
		}

		// 10b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline GPtr(GPtr<Y>&& a_rhs) noexcept :
			_ptr(std::move(a_rhs._ptr))
		{
			a_rhs._ptr = nullptr;
		}

		inline ~GPtr()
		{
			TryDetach();
		}

		// 1a
		inline GPtr& operator=(const GPtr& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = a_rhs._ptr;
				TryAttach();
			}
			return *this;
		}

		// 1b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline GPtr& operator=(const GPtr<Y>& a_rhs)
		{
			TryDetach();
			_ptr = a_rhs._ptr;
			TryAttach();
			return *this;
		}

		// 2a
		inline GPtr& operator=(GPtr&& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = std::move(a_rhs._ptr);
				a_rhs._ptr = nullptr;
			}
			return *this;
		}

		// 2b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline GPtr& operator=(GPtr<Y>&& a_rhs)
		{
			TryDetach();
			_ptr = std::move(a_rhs._ptr);
			a_rhs._ptr = nullptr;
			return *this;
		}

		inline void reset()
		{
			TryDetach();
		}

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline void reset(Y* a_ptr)
		{
			if (_ptr != a_ptr) {
				TryDetach();
				_ptr = a_ptr;
				TryAttach();
			}
		}

		[[nodiscard]] constexpr element_type* get() const noexcept
		{
			return _ptr;
		}

		[[nodiscard]] explicit constexpr operator bool() const noexcept
		{
			return static_cast<bool>(_ptr);
		}

		[[nodiscard]] constexpr element_type& operator*() const noexcept
		{
			assert(static_cast<bool>(*this));
			return *_ptr;
		}

		[[nodiscard]] constexpr element_type* operator->() const noexcept
		{
			assert(static_cast<bool>(*this));
			return _ptr;
		}

	protected:
		template <class>
		friend class GPtr;

		inline void TryAttach()
		{
			if (_ptr) {
				_ptr->AddRef();
			}
		}

		inline void TryDetach()
		{
			if (_ptr) {
				_ptr->Release();
				_ptr = nullptr;
			}
		}

		// members
		element_type* _ptr;  // 0
	};
	//static_assert(sizeof(GPtr<void*>) == 0x8);

	template <class T, class... Args>
	[[nodiscard]] inline GPtr<T> make_gptr(Args&&... a_args)
	{
		auto ptr = GPtr<T>{ new T(std::forward<Args>(a_args)...) };
		if (ptr) {
			ptr->Release();  // ensure lifetime ends with smart pointer
		}
		return ptr;
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator==(const GPtr<T1>& a_lhs, const GPtr<T2>& a_rhs)
	{
		return a_lhs.get() == a_rhs.get();
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator!=(const GPtr<T1>& a_lhs, const GPtr<T2>& a_rhs)
	{
		return !(a_lhs == a_rhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(const GPtr<T>& a_lhs, std::nullptr_t) noexcept
	{
		return !a_lhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(std::nullptr_t, const GPtr<T>& a_rhs) noexcept
	{
		return !a_rhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(const GPtr<T>& a_lhs, std::nullptr_t) noexcept
	{
		return static_cast<bool>(a_lhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(std::nullptr_t, const GPtr<T>& a_rhs) noexcept
	{
		return static_cast<bool>(a_rhs);
	}

	template <class T>
	GPtr(T*) -> GPtr<T>;
}


===============================================
File: include/RE/G/GRect.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class GRect
	{
	public:
		// members
		T left;    // 00
		T top;     // ??
		T right;   // ??
		T bottom;  // ??
	};

	using GRectF = GRect<float>;
	static_assert(sizeof(GRectF) == 0x10);

	using GRectD = GRect<double>;
	static_assert(sizeof(GRectD) == 0x20);
}


===============================================
File: include/RE/G/GRefCountBase.h
===============================================
#pragma once

#include "RE/G/GMemory.h"
#include "RE/G/GRefCountBaseStatImpl.h"
#include "RE/G/GRefCountImpl.h"

namespace RE
{
	// Overrides new/delete operators to use MemoryHeap
	template <class T, std::uint32_t STAT>
	class GRefCountBase : public GRefCountBaseStatImpl<GRefCountImpl, STAT>
	{
	public:
		enum
		{
			kStatType = STAT
		};
	};
}


===============================================
File: include/RE/G/GRefCountBaseGC.h
===============================================
#pragma once

#include "RE/G/GNewOverrideBase.h"

namespace RE
{
	template <std::uint32_t STAT>
	class GRefCountBaseGC : public GNewOverrideBase<STAT>
	{
	public:
		enum
		{
			kStatType = STAT
		};

		// add
		virtual void Unk_00(void);  // 00
		virtual void Unk_01(void);  // 01 - pure

		virtual ~GRefCountBaseGC();  // 02

		// members
		void*         unk08;     // 08
		std::uint32_t refCount;  // 10
		std::uint32_t pad14;     // 14
		std::uint64_t unk18;     // 18 - union
	};
	// size == 0x20
}


===============================================
File: include/RE/G/GRefCountBaseNTS.h
===============================================
#pragma once

#include "RE/G/GRefCountBaseStatImpl.h"
#include "RE/G/GRefCountNTSImpl.h"

namespace RE
{
	template <class C, std::uint32_t Stat>
	class GRefCountBaseNTS : public GRefCountBaseStatImpl<GRefCountNTSImpl, Stat>
	{
	public:
		enum
		{
			kStatType = Stat
		};

		GRefCountBaseNTS() = default;
	};
}


===============================================
File: include/RE/G/GRefCountBaseStatImpl.h
===============================================
#pragma once

#include "RE/G/GMemory.h"

#define GFC_REFCOUNTALLOC_CHECK_DELETE(class_name, p)

namespace RE
{
	// Adds new/delete overrides
	// Base must be one of RefCountImpl classes
	template <class Base, std::uint32_t StatType>
	class GRefCountBaseStatImpl : public Base
	{
	public:
		GFC_MEMORY_REDEFINE_NEW_IMPL(Base, GFC_REFCOUNTALLOC_CHECK_DELETE, StatType);
	};
}


===============================================
File: include/RE/G/GRefCountBaseWeakSupport.h
===============================================
#pragma once

#include "RE/G/GMemory.h"
#include "RE/G/GRefCountBaseStatImpl.h"
#include "RE/G/GRefCountWeakSupportImpl.h"

namespace RE
{
	template <class T, std::uint32_t STAT>
	class GRefCountBaseWeakSupport : public GRefCountBaseStatImpl<GRefCountWeakSupportImpl, STAT>
	{
	public:
		enum
		{
			kStatType = STAT
		};
	};
}


===============================================
File: include/RE/G/GRefCountImpl.h
===============================================
#pragma once

#include "RE/G/GRefCountImplCore.h"

namespace RE
{
	class GRefCountImpl : GRefCountImplCore
	{
	public:
		inline static constexpr auto RTTI = RTTI_GRefCountImpl;

		~GRefCountImpl() override = default;  // 00

		void AddRef();
		void Release();
	};
	static_assert(sizeof(GRefCountImpl) == 0x10);
}


===============================================
File: include/RE/G/GRefCountImplCore.h
===============================================
#pragma once

namespace RE
{
	class GRefCountImplCore
	{
	public:
		inline static constexpr auto RTTI = RTTI_GRefCountImplCore;

		virtual ~GRefCountImplCore() = default;  // 00

		static void CheckInvalidDelete(GRefCountImplCore*) {}

		[[nodiscard]] constexpr std::uint32_t GetRefCount() const noexcept { return _refCount; }

	protected:
		// members
		volatile std::uint32_t _refCount{ 1 };  // 08
		std::uint32_t          _pad0C{ 0 };     // 0C
	};
	static_assert(sizeof(GRefCountImplCore) == 0x10);
}


===============================================
File: include/RE/G/GRefCountNTSImpl.h
===============================================
#pragma once

#include "RE/G/GRefCountImplCore.h"

namespace RE
{
	class GRefCountNTSImpl : public GRefCountImplCore
	{
	public:
		void AddRef();
		void Release();
	};
	static_assert(sizeof(GRefCountNTSImpl) == 0x10);
}


===============================================
File: include/RE/G/GRefCountWeakSupportImpl.h
===============================================
#pragma once

#include "RE/G/GRefCountNTSImpl.h"

namespace RE
{
	class GWeakPtrProxy;

	class GRefCountWeakSupportImpl : public GRefCountNTSImpl
	{
	public:
		GRefCountWeakSupportImpl()
		{
			weakProxy = nullptr;
		}

		virtual ~GRefCountWeakSupportImpl();

		GWeakPtrProxy* CreateWeakProxy() const;

		// members
		mutable GWeakPtrProxy* weakProxy;
	};
	static_assert(sizeof(GRefCountWeakSupportImpl) == 0x18);
}


===============================================
File: include/RE/G/GRenderer.h
===============================================
#pragma once

#include "RE/G/GColor.h"
#include "RE/G/GMatrix2D.h"
#include "RE/G/GPoint.h"
#include "RE/G/GRect.h"
#include "RE/G/GRefCountBase.h"
#include "RE/G/GRendererEventHandler.h"
#include "RE/G/GTexture.h"

namespace RE
{
	class GImageBase;
	class GMatrix3D;
	class GRenderTarget;
	class GViewport;

	class GRenderer : public GRefCountBase<GRenderer, GStatRenderer::kMem>
	{
	public:
		using Handle = void*;
		using Matrix = GMatrix2D;
		using Point = GPointF;
		using Rect = GRectF;

		enum class BlendType
		{
			kNone = 0,
			kNormal = 1,
			kLayer = 2,
			kMultiply = 3,
			kScreen = 4,
			kLighten = 5,
			kDarken = 6,
			kDifference = 7,
			kAdd = 8,
			kSubtract = 9,
			kInvert = 10,
			kAlpha = 11,
			kErase = 12,
			kOverlay = 13,
			kHardLight = 14
		};

		enum class ResizeImageType
		{
			kRGBToRGB,
			kRGBAToRGBA,
			kRGBToRGBA,
			kGray
		};

		enum class VertexFormat
		{
			kNone = 0,
			kXY16i = 1 << 1,
			kXY32f = 1 << 2,
			kXY16iC32 = 1 << 3,
			kXY16iCF32 = 1 << 4
		};

		enum class IndexFormat
		{
			kNone = 0,
			k16 = 1,
			k32 = 2
		};

		enum class RenderCapBits
		{
			kNone = 0,

			kCacheDataUse = 1 << 0,

			kIndex16 = 1 << 2,
			kIndex32 = 1 << 3,
			kRenderStats = 1 << 4,
			kRenderTargets = 1 << 5,
			kRenderTargetPrePass = 1 << 6,
			kRenderTargetNonPow2 = 1 << 7,
			kFillGouraud = 1 << 8,
			kFillGouraudTex = 1 << 9,

			kCxformAdd = 1 << 12,
			kNestedMasks = 1 << 13,
			kTexNonPower2 = 1 << 14,
			kTexNonPower2Wrap = 1 << 15,
			kCanLoseData = 1 << 16,
			kKeepVertexData = 1 << 17,
			kNoTexOverwrite = 1 << 18,
			kTexNonPower2Mip = 1 << 19,
			kThreadedTextureCreation = 1 << 20,
			kRenderTargetMip = 1 << 21,
			kFilter_Blurs = 1 << 22,
			kFilter_ColorMatrix = 1 << 23,
		};

		enum class StereoDisplay
		{
			kStereoCenter,
			kStereoLeft,
			kStereoRight
		};

		enum class CachedDataType
		{
			kVertex = 1,
			kIndex = 2,
			kBitmapList = 3
		};

		enum class UserDataPropertyFlag
		{
			kNone,
			kHasString,
			kHasFloat,
			kHasMatrix
		};

		enum class BitmapWrapMode
		{
			kRepeat,
			kClamp
		};

		enum class BitmapSampleMode
		{
			kPoint,
			kLinear
		};

		enum class GouraudFillType
		{
			kColor,
			k1Texture,
			k1TextureColor,
			k2Texture,
			k2TextureColor,
			k3Texture
		};

		enum class SubmitMaskMode
		{
			kClear,
			kIncrement,
			kDecrement
		};

		enum class FilterModes
		{
			kBlur = 1 << 0,
			kShadow = 1 << 1,
			kHighlight = 1 << 2,

			Filter_Knockout = 1 << 8,
			Filter_Inner = 1 << 9,
			Filter_HideObject = 1 << 10,

			Filter_UserModes = 0xFFFF,
			Filter_SkipLastPass = 1 << 16,
			Filter_LastPassOnly = 1 << 17
		};

		enum class FilterSupport
		{
			kNone = 0,
			kOk = 1 << 0,
			kMultipass = 1 << 1,
			kSlow = 1 << 2,
		};

		class Stats
		{
		public:
			Stats();

			void Clear();

			// members
			std::uint32_t triangles;   // 00
			std::uint32_t lines;       // 04
			std::uint32_t primitives;  // 08
			std::uint32_t masks;       // 0C
			std::uint32_t filters;     // 10
		};
		static_assert(sizeof(Stats) == 0x14);

		class CachedData
		{
		public:
			CachedData();
			~CachedData();

			[[nodiscard]] GRenderer* GetRenderer() const;
			[[nodiscard]] Handle     GetRendererData() const;
			void                     SetRendererData(Handle a_handle);
			void                     ReleaseData(CachedDataType a_type);
			void                     ReleaseDataByRenderer();

			// members
			GRenderer* renderer;  // 00
			Handle     data;      // 08
		};
		static_assert(sizeof(CachedData) == 0x10);

		class CacheProvider
		{
		public:
			CacheProvider(CachedData* a_cache);
			~CacheProvider() = default;

			CachedData* GetCachedData(GRenderer* a_renderer);
			CachedData* CreateCachedData(CachedDataType a_type, GRenderer* a_renderer, bool a_keepSharedData = true);
			bool        CanDiscardData();

			// members
			CachedData*   data;               // 00
			bool          discardSharedData;  // 10
			std::uint8_t  pad11;              // 11
			std::uint16_t pad12;              // 12
			std::uint32_t pad14;              // 14
		};
		static_assert(sizeof(CacheProvider) == 0x10);

		class Cxform
		{
		public:
			static Cxform Identity;

			enum
			{
				kR,
				kG,
				kB,
				kA,
				kRGBA
			};

			enum
			{
				kMult,
				kAdd,
				kMultAdd
			};

			Cxform();

			void SetIdentity();

			bool IsIdentity() const;

			bool operator==(const Cxform& a_rhs) const;

			// members
			float matrix[kRGBA][kMultAdd];  // 00
		};
		static_assert(sizeof(Cxform) == 0x20);

		struct StereoParams
		{
		public:
			StereoParams();

			// members
			float displayWidthCm;      // 00
			float distortion;          // 04
			float displayDiagInches;   // 08
			float displayAspectRatio;  // 0C
			float eyeSeparationCm;     // 10
		};
		static_assert(sizeof(StereoParams) == 0x14);

		struct RenderCaps
		{
		public:
			// members
			stl::enumeration<RenderCapBits, std::uint32_t> capBits;         // 00
			std::uint32_t                                  vertexFormats;   // 04
			std::uint32_t                                  blendModes;      // 08
			std::uint32_t                                  maxTextureSize;  // 0C
		};
		static_assert(sizeof(RenderCaps) == 0x10);

		struct UserData
		{
		public:
			UserData();

			// members
			const char*                                          string;      // 00
			float*                                               flt;         // 08
			float*                                               matrix;      // 10
			std::uint32_t                                        matrixSize;  // 18
			stl::enumeration<UserDataPropertyFlag, std::uint8_t> propFlags;   // 1C
			std::uint8_t                                         pad1D;       // 1D
			std::uint16_t                                        pad1E;       // 1E
		};
		static_assert(sizeof(UserData) == 0x20);

		struct FillTexture
		{
		public:
			// members
			GTexture*                                         texture;        // 00
			Matrix                                            textureMatrix;  // 08
			stl::enumeration<BitmapWrapMode, std::uint32_t>   wrapMode;       // 20
			stl::enumeration<BitmapSampleMode, std::uint32_t> sampleMode;     // 24
		};
		static_assert(sizeof(FillTexture) == 0x28);

		struct VertexXY16i
		{
		public:
			// members
			std::int16_t x;  // 0
			std::int16_t y;  // 2
		};
		static_assert(sizeof(VertexXY16i) == 0x4);

		struct VertexXY16iC32
		{
		public:
			enum
			{
				kVFormat = static_cast<std::underlying_type_t<VertexFormat>>(VertexFormat::kXY16iC32)
			};

			// members
			std::int16_t  x;      // 0
			std::int16_t  y;      // 2
			std::uint32_t color;  // 4
		};
		static_assert(sizeof(VertexXY16iC32) == 0x8);

		struct VertexXY16iCF32
		{
		public:
			enum
			{
				kVFormat = static_cast<std::underlying_type_t<VertexFormat>>(VertexFormat::kXY16iCF32)
			};

			// members
			std::int16_t  x;        // 0
			std::int16_t  y;        // 2
			std::uint32_t color;    // 4
			std::uint32_t factors;  // 8
		};
		static_assert(sizeof(VertexXY16iCF32) == 0xC);

		struct BitmapDesc
		{
		public:
			// members
			Rect   Coords;         // 00
			Rect   TextureCoords;  // 10
			GColor Color;          // 20
		};
		static_assert(sizeof(BitmapDesc) == 0x24);

		struct DistanceFieldParams
		{
		public:
			// members
			float   width;         // 00
			float   shadowWidth;   // 04
			GColor  shadowColor;   // 08
			GPointF shadowOffset;  // 0C
			GColor  glowColor;     // 14
			float   glowSize[2];   // 18
		};
		static_assert(sizeof(DistanceFieldParams) == 0x20);

		struct BlurFilterParams
		{
		public:
			// members
			std::uint32_t mode;      // 00
			float         blurX;     // 04
			float         blurY;     // 08
			std::uint32_t passes;    // 0C
			GPointF       offset;    // 10
			GColor        color;     // 18
			GColor        color2;    // 1C
			float         strength;  // 20
			Cxform        cxform;    // 24
		};
		static_assert(sizeof(BlurFilterParams) == 0x44);

		~GRenderer() override;  // 00

		// add
		virtual bool           GetRenderCaps(RenderCaps* a_caps) = 0;                                                                                                                                                                                                             // 01
		virtual GTexture*      CreateTexture() = 0;                                                                                                                                                                                                                               // 02
		virtual GTexture*      CreateTextureYUV() = 0;                                                                                                                                                                                                                            // 03
		virtual void           BeginFrame();                                                                                                                                                                                                                                      // 04
		virtual void           EndFrame();                                                                                                                                                                                                                                        // 05
		virtual GRenderTarget* CreateRenderTarget() = 0;                                                                                                                                                                                                                          // 06
		virtual void           SetDisplayRenderTarget(GRenderTarget* a_renderTarget, bool a_setstate = true) = 0;                                                                                                                                                                 // 07
		virtual void           PushRenderTarget(const GRectF& a_frameRect, GRenderTarget* a_renderTarget) = 0;                                                                                                                                                                    // 08
		virtual void           PopRenderTarget() = 0;                                                                                                                                                                                                                             // 09
		virtual GTexture*      PushTempRenderTarget(const GRectF& a_frameRect, std::uint32_t a_targetW, std::uint32_t a_targetH) = 0;                                                                                                                                             // 0A
		virtual void           ReleaseTempRenderTargets(std::uint32_t a_keepArea);                                                                                                                                                                                                // 0B
		virtual void           BeginDisplay(GColor a_backgroundColor, const GViewport& a_viewport, float a_x0, float a_x1, float a_y0, float a_y1) = 0;                                                                                                                           // 0C
		virtual void           EndDisplay() = 0;                                                                                                                                                                                                                                  // 0D
		virtual void           SetMatrix(const Matrix& a_matrix) = 0;                                                                                                                                                                                                             // 0E
		virtual void           SetUserMatrix(const Matrix& a_matrix) = 0;                                                                                                                                                                                                         // 0F
		virtual void           SetCxform(const Cxform& a_cxForm) = 0;                                                                                                                                                                                                             // 10
		virtual void           PushBlendMode(BlendType a_mode) = 0;                                                                                                                                                                                                               // 11
		virtual void           PopBlendMode() = 0;                                                                                                                                                                                                                                // 12
		virtual bool           PushUserData(UserData* a_data);                                                                                                                                                                                                                    // 13
		virtual void           PopUserData();                                                                                                                                                                                                                                     // 14
		virtual void           SetPerspective3D(const GMatrix3D& a_projMatIn) = 0;                                                                                                                                                                                                // 15
		virtual void           SetView3D(const GMatrix3D& a_viewMatIn) = 0;                                                                                                                                                                                                       // 16
		virtual void           SetWorld3D(const GMatrix3D* a_worldMatIn) = 0;                                                                                                                                                                                                     // 17
		virtual void           MakeViewAndPersp3D(const GRectF& a_visFrameRectInTwips, GMatrix3D& a_matView, GMatrix3D& a_matPersp, float a_perspFOV, bool a_InvertY = false);                                                                                                    // 18
		virtual void           SetStereoParams(StereoParams a_params);                                                                                                                                                                                                            // 19
		virtual void           SetStereoDisplay(StereoDisplay a_display, bool a_setstate = false);                                                                                                                                                                                // 1A
		virtual void           SetVertexData(const void* a_vertices, std::int32_t a_numVertices, VertexFormat a_vtxFmt, CacheProvider* a_cache = 0) = 0;                                                                                                                          // 1B
		virtual void           SetIndexData(const void* a_indices, std::int32_t a_numIndices, IndexFormat a_idxFmt, CacheProvider* a_cache = 0) = 0;                                                                                                                              // 1C
		virtual void           ReleaseCachedData(CachedData* a_data, CachedDataType a_type) = 0;                                                                                                                                                                                  // 1D
		virtual void           DrawIndexedTriList(std::int32_t a_baseVertexIndex, std::int32_t a_minVertexIndex, std::int32_t a_numVertices, std::int32_t a_startIndex, std::int32_t a_triangleCount) = 0;                                                                        // 1E
		virtual void           DrawLineStrip(std::int32_t a_baseVertexIndex, std::int32_t a_lineCount) = 0;                                                                                                                                                                       // 1F
		virtual void           LineStyleDisable() = 0;                                                                                                                                                                                                                            // 20
		virtual void           LineStyleColor(GColor a_color) = 0;                                                                                                                                                                                                                // 21
		virtual void           FillStyleDisable() = 0;                                                                                                                                                                                                                            // 22
		virtual void           FillStyleColor(GColor a_color) = 0;                                                                                                                                                                                                                // 23
		virtual void           FillStyleBitmap(const FillTexture* a_fill) = 0;                                                                                                                                                                                                    // 24
		virtual void           FillStyleGouraud(GouraudFillType a_fillType, const FillTexture* a_texture0 = 0, const FillTexture* a_texture1 = 0, const FillTexture* a_texture2 = 0) = 0;                                                                                         // 25
		virtual void           DrawBitmaps(BitmapDesc* a_bitmapList, std::int32_t a_listSize, std::int32_t a_startIndex, std::int32_t a_count, const GTexture* a_texture, const Matrix& a_matrix, CacheProvider* a_cache = 0) = 0;                                                // 26
		virtual void           DrawDistanceFieldBitmaps(BitmapDesc* a_bitmapList, std::int32_t a_listSize, std::int32_t a_startIndex, std::int32_t a_count, const GTexture* a_texture, const Matrix& a_matrix, const DistanceFieldParams& a_params, CacheProvider* a_cache = 0);  // 27
		virtual void           BeginSubmitMask(SubmitMaskMode a_maskMode = SubmitMaskMode::kClear) = 0;                                                                                                                                                                           // 28
		virtual void           EndSubmitMask() = 0;                                                                                                                                                                                                                               // 29
		virtual void           DisableMask() = 0;                                                                                                                                                                                                                                 // 2A
		virtual std::uint32_t  CheckFilterSupport(const BlurFilterParams& a_params) = 0;                                                                                                                                                                                          // 2B
		virtual void           DrawBlurRect(GTexture* a_srcIn, const GRectF& a_inSrcRect, const GRectF& a_inDstRect, const BlurFilterParams& a_params) = 0;                                                                                                                       // 2C
		virtual void           DrawColorMatrixRect(GTexture* a_srcIn, const GRectF& a_inSrcRect, const GRectF& a_dstRect, const float* a_matrix) = 0;                                                                                                                             // 2D
		virtual void           GetRenderStats(Stats* a_stats, bool a_resetStats = 0) = 0;                                                                                                                                                                                         // 2E
		virtual void           GetStats(GStatBag* a_bag, bool a_reset = true) = 0;                                                                                                                                                                                                // 2F
		virtual void           ReleaseResources() = 0;                                                                                                                                                                                                                            // 30
		virtual bool           AddEventHandler(GRendererEventHandler* a_handler);                                                                                                                                                                                                 // 31
		virtual void           RemoveEventHandler(GRendererEventHandler* a_handler);                                                                                                                                                                                              // 32

		void FillStyleBitmap(GTexture* a_texture, const Matrix& a_matrix, BitmapWrapMode a_wrapMode, BitmapSampleMode a_sampleMode);

		// members
		GList<GRendererEventHandler>                   handlers;    // 10
		StereoParams                                   s3DParams;   // 20
		stl::enumeration<StereoDisplay, std::uint32_t> s3DDisplay;  // 34
	};
	static_assert(sizeof(GRenderer) == 0x38);
}


===============================================
File: include/RE/G/GRendererEventHandler.h
===============================================
#pragma once

#include "RE/G/GList.h"
#include "RE/G/GNewOverrideBase.h"

namespace RE
{
	class GRenderer;

	class GRendererEventHandler :
		public GListNode<GRendererEventHandler>,
		public GNewOverrideBase<GStatGroup::kGStat_Default_Mem>
	{
	public:
		enum class EventType
		{
			kEndFrame,
			kRendererReleased
		};

		virtual ~GRendererEventHandler() = default;  // 00

		// add
		virtual void OnEvent(GRenderer* a_renderer, EventType a_changeType);  // 01

		// members
		GRenderer* renderer;  // 18
	};
	static_assert(sizeof(GRendererEventHandler) == 0x20);
}


===============================================
File: include/RE/G/GStats.h
===============================================
#pragma once

namespace RE
{
	struct GStatGroups
	{
		// _Mem for GMemoryStat.
		// _Tks for GTimerStat.
		// _Cnt for GCounterStat.
		enum GStatGroup : std::uint32_t
		{
			kGStatGroup_Default = 0,

			kGStatGroup_Core = 16,
			kGStatGroup_Renderer = 1 << 6,
			kGStatGroup_RenderGen = 2 << 6,

			kGStatGroup_GFxFontCache = 3 << 6,
			kGStatGroup_GFxMovieData = 4 << 6,
			kGStatGroup_GFxMovieView = 5 << 6,
			kGStatGroup_GFxRenderCache = 6 << 6,
			kGStatGroup_GFxPlayer = 7 << 6,
			kGStatGroup_GFxIME = 8 << 6,

			// General memory
			kGStat_Mem = kGStatGroup_Default + 1,
			kGStat_Default_Mem,
			kGStat_Image_Mem,
			kGStat_Sound_Mem,
			kGStat_String_Mem,
			kGStat_Video_Mem,

			// Memory allocated for debugging purposes.
			kGStat_Debug_Mem,
			kGStat_DebugHUD_Mem,
			kGStat_DebugTracker_Mem,
			kGStat_StatBag_Mem,

			// Core entries
			kGStatHeap_Start = kGStatGroup_Core,
			// 16 slots for HeapSummary

			// How many entries we support by default
			kGStat_MaxId = 64 << 6,  // 64 * 64 = 4096
			kGStat_EntryCount = 512
		};
	};
	using GStatGroup = GStatGroups::GStatGroup;

	struct GStatRenderers
	{
		enum GStatRenderer
		{
			kDefault = GStatGroup::kGStatGroup_Renderer,

			kMem,

			// Video Memory.
			kVMem,
			kTextureVMem,
			kBufferVMem,

			// Counts
			kCounters,
			kTextureUploadCnt,
			kTextureUpdateCnt,
			kDPCnt,
			kDPLineCnt,
			kDPTriangleCnt,
			kTriangleCnt,
			kLineCnt,
			kMaskCnt,
			kFilterCnt,
		};
	};
	using GStatRenderer = GStatRenderers::GStatRenderer;

	enum class GHeapID : UPInt
	{
		kReserved = 0,
		kGlobal = 1,
		kMovieDef = 2,
		kMovieView = 3,
		kMovieData = 4,
		kMeshCache = 5,
		kFontCache = 6,
		kImages = 7,
		kOtherHeaps = 8,
		kHUDHeaps = 9,
	};
}


===============================================
File: include/RE/G/GStd.h
===============================================
#pragma once

namespace RE
{
	wchar_t G_towlower(wchar_t a_ch);
}


===============================================
File: include/RE/G/GString.h
===============================================
#pragma once

namespace RE
{
	class GStringBuffer;

	class GString
	{
	public:
		class HashFunctor
		{
		public:
			UPInt operator()(const GString& a_data) const
			{
				return BernsteinHashFunction(a_data.data(), a_data.size());
			}
		};

		class NoCaseHashFunctor
		{
		public:
			UPInt operator()(const GString& a_data) const
			{
				return BernsteinHashFunctionCIS(a_data.data(), a_data.size());
			}
		};

		using value_type = char;  // can also be wchar_t
		using size_type = UPInt;
		using reference = value_type&;
		using const_reference = const value_type&;

		enum class HeapType
		{
			kGlobal = 0,   // Global
			kLocal = 1,    // Address-based
			kDynamic = 2,  // Part of class
			kMask = 3
		};

		struct FlagConstants
		{
			enum FlagConstant : UPInt
			{
				kReserveIsSizeShift = static_cast<UPInt>((sizeof(UPInt) * 8 - 1))  // indicates reserve == size
			};
		};
		using FlagConstant = FlagConstants::FlagConstant;

		struct DataDesc
		{
			enum : UPInt
			{
				kFullFlag = 1ull << FlagConstant::kReserveIsSizeShift
			};

			DataDesc();
			~DataDesc();

			void                AddRef();
			void                Release();
			[[nodiscard]] UPInt GetCapacity() const;
			[[nodiscard]] bool  IsFull() const;
			void                SetFull(bool a_set);

			// members
			UPInt                 capacity;  // 00
			volatile std::int32_t refCount;  // 08
			char                  data[1];   // 0C
		};
		static_assert(sizeof(DataDesc) == 0x10);

		union DataDescUnion
		{
			DataDescUnion();

			DataDesc*                         data;
			stl::enumeration<HeapType, UPInt> heapType;
		};
		static_assert(sizeof(DataDescUnion) == 0x8);

		// (constructor)
		GString();
		GString(const GString& a_rhs);
		GString(GString&& a_rhs);
		GString(const char* a_rhs);
		GString(const std::string_view& a_rhs);

		// (destructor)
		~GString();

		// operator=
		GString& operator=(const GString& a_rhs);
		GString& operator=(GString&& a_rhs);
		GString& operator=(const char* a_rhs);
		GString& operator=(const std::string_view& a_rhs);

		// element access
		reference       operator[](size_type a_pos);
		const_reference operator[](size_type a_pos) const;

		char&                     front();
		[[nodiscard]] const char& front() const;

		char&                     back();
		[[nodiscard]] const char& back() const;

		[[nodiscard]] const char* data() const noexcept;
		char*                     data() noexcept;

		[[nodiscard]] const char* c_str() const noexcept;

		operator std::string_view() const noexcept;

		// Capacity
		[[nodiscard]] bool empty() const noexcept;

		[[nodiscard]] size_type size() const noexcept;

		[[nodiscard]] size_type length() const noexcept;

		// Operations
		void clear() noexcept;

		inline friend bool operator==(const GString& a_lhs, const char* a_rhs) { return (a_lhs.data() == a_rhs || std::strcmp(a_lhs.data(), a_rhs) == 0); }
		inline friend bool operator!=(const GString& a_lhs, const char* a_rhs) { return !(a_lhs == a_rhs); }
		inline friend bool operator==(const char* a_lhs, const GString& a_rhs) { return a_rhs == a_lhs; }
		inline friend bool operator!=(const char* a_lhs, const GString& a_rhs) { return !(a_lhs == a_rhs); }
		inline friend bool operator==(const GString& a_lhs, const GString& a_rhs) { return a_lhs == a_rhs.c_str(); }
		inline friend bool operator!=(const GString& a_lhs, const GString& a_rhs) { return !(a_lhs == a_rhs); }
		inline friend bool operator==(const GString& a_lhs, const std::string_view& a_rhs) { return a_lhs == a_rhs.data(); }
		inline friend bool operator!=(const GString& a_lhs, const std::string_view& a_rhs) { return !(a_lhs == a_rhs); }
		inline friend bool operator==(const std::string_view& a_lhs, const GString& a_rhs) { return a_rhs == a_lhs; }
		inline friend bool operator!=(const std::string_view& a_lhs, const GString& a_rhs) { return !(a_lhs == a_rhs); }

		static UPInt BernsteinHashFunction(const void* a_dataIn, UPInt a_size, UPInt a_seed = 5381);

		static UPInt BernsteinHashFunctionCIS(const void* a_dataIn, UPInt a_size, UPInt a_seed = 5381);

	protected:
		GString*                ctor(const char* a_str);
		[[nodiscard]] HeapType  heap_type() const;
		[[nodiscard]] DataDesc* get_desc() const;
		void                    set_desc(DataDesc* a_desc);

		// members
		DataDescUnion _dataDesc;  // 0
	};
	static_assert(sizeof(GString) == 0x8);
}


===============================================
File: include/RE/G/GStringDH.h
===============================================
#pragma once

#include "RE/G/GMemory.h"
#include "RE/G/GMemoryHeap.h"
#include "RE/G/GString.h"

namespace RE
{
	class GStringDH : public GString
	{
	public:
		GStringDH(GMemoryHeap* a_heap = GMemory::GetGlobalHeap()) :
			heap(a_heap)
		{}

		GStringDH(GMemoryHeap* a_heap, const char* a_data) :
			GString(a_data),
			heap(a_heap)
		{}

		// members
		GMemoryHeap* heap;  // 08
	};
	static_assert(sizeof(GStringDH) == 0x10);
}


===============================================
File: include/RE/G/GStringHash.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GHash.h"
#include "RE/G/GString.h"

namespace RE
{
	template <class U, class Allocator = GAllocatorGH<U>>
	class GStringHash : public GHash<GString, U, GString::NoCaseHashFunctor, Allocator>
	{
	public:
		using BaseType = GHash<GString, U, GString::NoCaseHashFunctor, Allocator>;
		using SelfType = GStringHash<U, Allocator>;
	};
}


===============================================
File: include/RE/G/GSysAllocBase.h
===============================================
#pragma once

namespace RE
{
	class GSysAllocBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_GSysAllocBase;

		virtual ~GSysAllocBase() = default;  // 00

		// add
		virtual bool InitHeapEngine([[maybe_unused]] const void* a_heapDesc) { return false; }  // 01
		virtual void ShutdownHeapEngine() { return; }                                           // 02
	};
	static_assert(sizeof(GSysAllocBase) == 0x8);
}


===============================================
File: include/RE/G/GSysAllocPaged.h
===============================================
#pragma once

#include "RE/G/GSysAllocBase.h"

namespace RE
{
	class GHeapMemVisitor;
	class GHeapSegVisitor;

	class GSysAllocPaged : public GSysAllocBase
	{
	public:
		inline static constexpr auto RTTI{ RTTI_GSysAllocPaged };

		struct Info
		{
		public:
			// members
			std::size_t minAlign;            // 00
			std::size_t maxAlign;            // 08
			std::size_t granularity;         // 10
			std::size_t sysDirectThreshold;  // 18
			std::size_t maxHeapGranularity;  // 20
			bool        hasRealloc;          // 28
		};
		static_assert(sizeof(Info) == 0x30);

		// override (GSysAllocBase)
		bool InitHeapEngine(const void* a_heapDesc) override  // 01
		{
			using func_t = decltype(&GSysAllocPaged::InitHeapEngine);
			REL::Relocation<func_t> func{ RELOCATION_ID(82462, 84557) };
			return func(this, a_heapDesc);
		}

		void ShutdownHeapEngine() override  // 02
		{
			using func_t = decltype(&GSysAllocPaged::ShutdownHeapEngine);
			REL::Relocation<func_t> func{ RELOCATION_ID(82464, 84559) };
			return func(this);
		}

		// add
		virtual void  GetInfo(Info* a_info) const = 0;                                 // 03
		virtual void* Alloc(std::size_t a_size, std::size_t a_align) = 0;              // 04
		virtual bool  Free(void* a_ptr, std::size_t a_size, std::size_t a_align) = 0;  // 05
		virtual bool  ReallocInPlace(
			 [[maybe_unused]] void*       a_oldPtr,
			 [[maybe_unused]] std::size_t a_oldSize,
			 [[maybe_unused]] std::size_t a_newSize,
			 [[maybe_unused]] std::size_t a_align) { return false; }  // 06
		virtual void* AllocSysDirect(
			[[maybe_unused]] std::size_t  a_size,
			[[maybe_unused]] std::size_t  a_alignment,
			[[maybe_unused]] std::size_t* a_actualSize,
			[[maybe_unused]] std::size_t* a_actualAlign) { return nullptr; }  // 07
		virtual bool FreeSysDirect(
			[[maybe_unused]] void*       a_ptr,
			[[maybe_unused]] std::size_t a_size,
			[[maybe_unused]] std::size_t a_alignment) { return false; }                                            // 08
		[[nodiscard]] virtual std::size_t GetBase() const { return 0; }                                            // 09
		[[nodiscard]] virtual std::size_t GetSize() const { return 0; }                                            // 0A
		[[nodiscard]] virtual std::size_t GetFootprint() const { return 0; }                                       // 0B
		[[nodiscard]] virtual std::size_t GetUsedSpace() const { return 0; }                                       // 0C
		virtual void                      VisitMem([[maybe_unused]] GHeapMemVisitor* a_visitor) const { return; }  // 0D
		virtual void                      VisitSegments(
								 [[maybe_unused]] GHeapSegVisitor* a_visitor,
								 [[maybe_unused]] std::size_t      a_catSeg,
								 [[maybe_unused]] std::size_t      a_catUnused) const { return; }  // 0E
	};
	static_assert(sizeof(GSysAllocPaged) == 0x8);
}


===============================================
File: include/RE/G/GTexture.h
===============================================
#pragma once

#include "RE/G/GAtomic.h"
#include "RE/G/GImage.h"
#include "RE/G/GNewOverrideBase.h"
#include "RE/G/GPoint.h"
#include "RE/G/GRect.h"

namespace RE
{
	class GImageBase;
	class GRenderer;

	class GTexture : public GNewOverrideBase<GStatRenderer::kMem>
	{
	public:
		using Handle = void*;

		enum class MapFlags
		{
			kNone = 0,
			kKeepOld = 1
		};

		enum class ImageTexUsage
		{
			kWrap = 1 << 0,
			kUpdate = 1 << 4,
			kMap = 1 << 5,
			kRenderTarget = 1 << 6
		};

		struct UpdateRect
		{
		public:
			// members
			GPoint<std::int32_t> dest;  // 00
			GRect<std::int32_t>  src;   // 08
		};
		static_assert(sizeof(UpdateRect) == 0x18);

		struct MapRect
		{
		public:
			// members
			std::uint32_t width;   // 00
			std::uint32_t height;  // 04
			std::uint8_t* data;    // 08
			std::uint32_t pitch;   // 10
			std::uint32_t pad14;   // 14
		};
		static_assert(sizeof(MapRect) == 0x18);

		class ChangeHandler
		{
		public:
			enum class EventType
			{
				kDataChange,
				kDataLost,
				kRendererReleased
			};

			virtual ~ChangeHandler() = default;  // 00

			// add
			virtual void OnChange(GRenderer* a_renderer, EventType a_changeType);  // 01
			virtual bool Recreate(GRenderer* a_renderer);                          // 02
		};
		static_assert(sizeof(ChangeHandler) == 0x8);

		virtual ~GTexture() = default;  // 00

		// add
		virtual bool                     InitTexture(GImageBase* a_im, ImageTexUsage a_usage = ImageTexUsage::kWrap) = 0;                                                                   // 01
		virtual bool                     InitDynamicTexture(std::int32_t a_width, std::int32_t a_height, GImage::ImageFormat a_format, std::int32_t a_mipmaps, ImageTexUsage a_usage) = 0;  // 02
		virtual void                     Update(std::int32_t a_level, std::int32_t a_num, const UpdateRect* a_rects, const GImageBase* a_im) = 0;                                           // 03
		virtual std::int32_t             Map(std::int32_t a_level, std::int32_t a_num, MapRect* a_maps, MapFlags a_flags = MapFlags::kNone) = 0;                                            // 04
		virtual bool                     Unmap(std::int32_t a_level, std::int32_t a_num, MapRect* a_maps, MapFlags a_flags = MapFlags::kNone) = 0;                                          // 05
		[[nodiscard]] virtual GRenderer* GetRenderer() const = 0;                                                                                                                           // 06
		[[nodiscard]] virtual bool       IsDataValid() const = 0;                                                                                                                           // 07
		[[nodiscard]] virtual Handle     GetUserData() const = 0;                                                                                                                           // 08
		virtual void                     SetUserData(Handle a_data) = 0;                                                                                                                    // 09
		virtual void                     AddChangeHandler(ChangeHandler* a_handler) = 0;                                                                                                    // 0A
		virtual void                     RemoveChangeHandler(ChangeHandler* a_handler) = 0;                                                                                                 // 0B

		// members
		GAtomicInt<std::int32_t> refCount;  // 08
	};
}


===============================================
File: include/RE/G/GViewport.h
===============================================
#pragma once

namespace RE
{
	class GViewport
	{
	public:
		enum Flag
		{
			kNone = 0,
			kIsRenderTexture = 1,
			kAlphaComposite = 2,
			kUseScissorRect = 4,
			kNoSetState = 8,
			kRenderTextureAlpha = kIsRenderTexture | kAlphaComposite
		};

		GViewport();
		GViewport(const GViewport& a_rhs);
		GViewport(std::int32_t a_bufW, std::int32_t a_bufH, std::int32_t a_left, std::int32_t a_top, std::int32_t a_width, std::int32_t a_height, std::int32_t a_scLeft, std::int32_t a_scTop, std::int32_t a_scW, std::int32_t a_scH, Flag a_flags = Flag::kNone);
		GViewport(std::int32_t a_bufW, std::int32_t a_bufH, std::int32_t a_left, std::int32_t a_top, std::int32_t a_width, std::int32_t a_height, std::int32_t a_scLeft, std::int32_t a_scTop, std::int32_t a_scW, std::int32_t a_scH, float a_scale, float a_ratio, Flag a_flags = Flag::kNone);
		GViewport(std::int32_t a_bufW, std::int32_t a_bufH, std::int32_t a_left, std::int32_t a_top, std::int32_t a_width, std::int32_t a_height, Flag a_flags = Flag::kNone);

		void SetViewport(std::int32_t a_bufW, std::int32_t a_bufH, std::int32_t a_left, std::int32_t a_top, std::int32_t a_width, std::int32_t a_height, Flag a_flags = Flag::kNone);
		void SetScissorRect(std::int32_t a_scLeft, std::int32_t a_scTop, std::int32_t a_scW, std::int32_t a_scH);

		// members
		std::int32_t                          bufferWidth;    // 00
		std::int32_t                          bufferHeight;   // 04
		std::int32_t                          left;           // 08
		std::int32_t                          top;            // 0C
		std::int32_t                          width;          // 10
		std::int32_t                          height;         // 14
		std::int32_t                          scissorLeft;    // 18
		std::int32_t                          scissorTop;     // 1C
		std::int32_t                          scissorWidth;   // 20
		std::int32_t                          scissorHeight;  // 24
		float                                 scale;          // 28
		float                                 aspectRatio;    // 2C
		stl::enumeration<Flag, std::uint32_t> flags;          // 30
		std::uint32_t                         pad34;          // 34
	};
	static_assert(sizeof(GViewport) == 0x38);
}


===============================================
File: include/RE/G/GWaitCondition.h
===============================================
#pragma once

namespace RE
{
	class GWaitConditionImpl;

	class GWaitCondition
	{
	public:
		GWaitConditionImpl* impl;  // 00
	};
	static_assert(sizeof(GWaitCondition) == 0x8);
}


===============================================
File: include/RE/G/GWaitable.h
===============================================
#pragma once

#include "RE/G/GArray.h"
#include "RE/G/GArrayConstPolicy.h"
#include "RE/G/GAtomic.h"
#include "RE/G/GNewOverrideBase.h"
#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class GWaitable : public GRefCountBase<GWaitable, GStatGroups::kGStat_Default_Mem>
	{
	public:
		using WaitHandler = void (*)(void* a_data);

		class HandlerStruct
		{
		public:
			// members
			WaitHandler handler;
			void*       userData;
		};

		struct HandlerArray : public GNewOverrideBase<GStatGroups::kGStat_Default_Mem>
		{
			using SizePolicyType = GArrayConstPolicy<0, 16, true>;
			using HandlerArrayType = GArray<HandlerStruct, GStatGroups::kGStat_Default_Mem, SizePolicyType>;

			// members
			GAtomicInt<std::int32_t> refCount;
			HandlerArrayType         handlers;
			GLock                    handlersLock;
		};

		~GWaitable() override;

		HandlerArray* handlers;
	};
	static_assert(sizeof(GWaitable) == 0x18);
}


===============================================
File: include/RE/G/GameSettingCollection.h
===============================================
#pragma once

#include "RE/S/Setting.h"
#include "RE/S/SettingCollectionMap.h"

namespace RE
{
	class GameSettingCollection : public SettingCollectionMap<Setting>
	{
	public:
		inline static constexpr auto RTTI = RTTI_GameSettingCollection;

		~GameSettingCollection() override;  // 00

		// override (SettingCollectionMap<Setting>)
		bool WriteSetting(Setting* a_setting) override;  // 03 - { return false; }
		bool ReadSetting(Setting* a_setting) override;   // 04
		bool OpenHandle(bool a_create) override;         // 05 - { return handle != 0; }
		bool CloseHandle() override;                     // 06 - { handle = 0; return true; }

		// add
		virtual void Unk_0A(void);  // 0A

		static GameSettingCollection* GetSingleton();

		Setting* GetSetting(const char* a_name);
	};
	static_assert(sizeof(GameSettingCollection) == 0x140);
}


===============================================
File: include/RE/G/GiftMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	struct ItemCard;
	struct ItemList;

	// menuDepth = 3
	// flags = kPausesGame | kUsesMenuContext | kDisablePauseMenu | kUpdateUsesCursor | kInventoryItemMenu | kCustomRendering
	// context = kItemMenu
	class GiftMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_GiftMenu;
		constexpr static std::string_view MENU_NAME = "GiftMenu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                              \
	GFxValue        root;            /* 00 - "Menu_mc" */ \
	ItemList*       itemList;        /* 18 */             \
	ItemCard*       itemCard;        /* 20 */             \
	BSTArray<void*> unk58;           /* 28 */             \
	std::uint64_t   unk70;           /* 40 */             \
	bool            pcControlsReady; /* 48 */             \
	std::uint8_t    pad79;           /* 49 */             \
	std::uint16_t   pad7A;           /* 4A */             \
	std::uint32_t   pad7C;           /* 4C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x50);

		~GiftMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04
		void               PostDisplay() override;                           // 06

		[[nodiscard]] static RefHandle GetTargetRefHandle();

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(GiftMenu) == 0x80);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(GiftMenu) == 0x90);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/G/GlobalLocations.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTSingleton.h"
#include "RE/L/Location.h"

namespace RE
{
	namespace BSResource
	{
		class GlobalLocations :
			public Location,                         // 00
			public BSTSingletonSDM<GlobalLocations>  // 10
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource____GlobalLocations;

			struct Entry
			{
			public:
				// members
				Entry*        next;      // 00
				Location*     location;  // 08
				std::uint32_t priority;  // 10
				std::uint32_t pad14;     // 14
			};
			static_assert(sizeof(Entry) == 0x18);

			~GlobalLocations() override;  // 00

			// override (Location)
			ErrorCode DoMount() override;                                                                                                             // 01
			void      DoUnmount() override;                                                                                                           // 02
			ErrorCode DoCreateStream(const char* a_path, BSTSmartPointer<Stream>& a_stream, Location*& a_location, bool a_readOnly) override;         // 03
			ErrorCode DoCreateAsyncStream(const char* a_path, BSTSmartPointer<AsyncStream>& a_out, Location*& a_location, bool a_readOnly) override;  // 04
			ErrorCode DoTraversePrefix(const char* a_path, LocationTraverser& a_traverser) override;                                                  // 05
			ErrorCode DoGetInfo1(const char* a_path, Info& a_info, Location*& a_location) override;                                                   // 06
			ErrorCode DoGetInfo2(const char* a_path, Info& a_info, LocationTraverser* a_traverser) override;                                          // 07
			ErrorCode DoDelete(const char* a_path) override;                                                                                          // 08

			// members
			std::uint8_t       pad11;         // 11
			std::uint16_t      pad12;         // 12
			mutable BSSpinLock lock;          // 14
			std::uint32_t      pad1C;         // 1C
			Entry*             head;          // 20
			Entry*             pendingMount;  // 28
			Entry*             free;          // 30
		};
		static_assert(sizeof(GlobalLocations) == 0x38);
	}
}


===============================================
File: include/RE/G/GlobalPaths.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/L/Location.h"

namespace RE
{
	namespace BSResource
	{
		class GlobalPaths :
			public Location,                     // 00
			public BSTSingletonSDM<GlobalPaths>  // 10
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource____GlobalPaths;

			~GlobalPaths() override;  // 00

			// override (Location)
			ErrorCode DoCreateStream(const char* a_path, BSTSmartPointer<Stream>& a_stream, Location*& a_location, bool a_readOnly) override;         // 03
			ErrorCode DoCreateAsyncStream(const char* a_path, BSTSmartPointer<AsyncStream>& a_out, Location*& a_location, bool a_readOnly) override;  // 04
			ErrorCode DoTraversePrefix(const char* a_path, LocationTraverser& a_traverser) override;                                                  // 05
			ErrorCode DoGetInfo1(const char* a_path, Info& a_info, Location*& a_location) override;                                                   // 06
			ErrorCode DoGetInfo2(const char* a_path, Info& a_info, LocationTraverser* a_traverser) override;                                          // 07
			ErrorCode DoDelete(const char* a_path) override;                                                                                          // 08

			// members
			std::uint8_t            pad11;         // 11
			std::uint16_t           pad12;         // 12
			std::uint32_t           pad14;         // 14
			BSTArray<BSFixedString> names;         // 18
			Location*               rootLocation;  // 30
		};
		static_assert(sizeof(GlobalPaths) == 0x38);
	}
}


===============================================
File: include/RE/G/GrabActorEffect.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class GrabActorEffect : public ValueModifierEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_GrabActorEffect;
		inline static constexpr auto VTABLE = VTABLE_GrabActorEffect;

		// override (ValueModifierEffect)
		void Update(float a_delta) override;               // 04
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 08

		~GrabActorEffect() override;  // 13

		void Start() override;                                                                   // 14
		void Finish() override;                                                                  // 15
		void ModifyActorValue(Actor* a_actor, float a_value, ActorValue a_actorValue) override;  // 20

		// members
		void*         unk98;         // 98 - smart ptr
		ActorHandle   grabbedActor;  // A0
		std::uint32_t unkA4;         // A4
		bool          unkA8;         // A8
		bool          grabbed;       // A9
		std::uint16_t unkAA;         // AA
		std::uint32_t unkAC;         // AC
	};
	static_assert(sizeof(GrabActorEffect) == 0xB0);
}


===============================================
File: include/RE/G/GrassParam.h
===============================================
#pragma once

namespace RE
{
	struct GrassParam
	{
	public:
		// members
		const char*   modelName;          // 00
		FormID        grassFormID;        // 08
		float         positionRange;      // 0C
		float         heightRange;        // 10
		float         colorRange;         // 14
		std::uint32_t waveOffsetRange;    // 18
		float         wavePeriod;         // 1C
		bool          hasVertexLighting;  // 20
		bool          hasUniformScaling;  // 21
		bool          fitsToSlope;        // 22
		std::uint8_t  pad23;              // 23
		std::uint32_t pad24;              // 24
		float         unk28;              // 28
		float         unk2C;              // 2C
		float         unk30;              // 30
		float         unk34;              // 34
		float         unk38;              // 38
		float         unk3C;              // 3C
		float         unk40;              // 40
		float         unk44;              // 44
		float         unk48;              // 48
	};
	static_assert(sizeof(GrassParam) == 0x50);
}


===============================================
File: include/RE/G/GrenadeProjectile.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/P/Projectile.h"

namespace RE
{
	struct BGSDecalGroup;

	class GrenadeProjectile : public Projectile
	{
	public:
		inline static constexpr auto RTTI = RTTI_GrenadeProjectile;
		inline static constexpr auto VTABLE = VTABLE_GrenadeProjectile;
		inline static constexpr auto FORMTYPE = FormType::ProjectileGrenade;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~GrenadeProjectile() override;  // 00

		// override (Projectile)
		void SaveGame(BGSSaveFormBuffer* a_buf) override;        // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;        // 0F
		void InitLoadGame(BGSLoadFormBuffer* a_buf) override;    // 10
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 11
		void Revert(BGSLoadFormBuffer* a_buf) override;          // 12
#ifndef SKYRIM_CROSS_VR
		// Override functions past where Skyrim VR breaks compatibility.
		[[nodiscard]] BGSDecalGroup* GetDecalGroup() const override;       // 9F - { return decalGroup; }
		bool           IsGrenadeProjectile() override;                // A3 - { return 1; }
		void           OnKill() override;                // A8
		void           Process3D() override;                // A9
		void                         UpdateImpl(float a_delta) override;   // AB
		void                         Unk_AE(void) override;                // AE
		void           ReportHavokDeactivation() override;                // B2
		bool           TurnOff(Actor* a_owner, bool a_noDeactivateSound) override;                                                                                                                 // B3
		[[nodiscard]] bool           IsPermanent() const override;
		bool           TargetsWholeBody() override;                // BA - { return 1; }
		std::uint32_t  GetCollisionGroup() override;                // BB
		void           AddImpact(TESObjectREFR* a_ref, const NiPoint3& a_targetLoc, const NiPoint3& a_velocity, hkpCollidable* a_collidable, std::int32_t a_arg6, std::uint32_t a_arg7) override;                // BD
		void           OnTriggerEnter() override;                // BF - { flags |= 1 << 30; }
		void                         Handle3DLoaded() override;            // C0
#endif

		struct GRENADE_RUNTIME_DATA
		{
#define GRENADE_RUNTIME_DATA_CONTENT \
			BGSDecalGroup* decalGroup;           /* 1D8 */ \
			bool           collisionGroupReset;  /* 1E0 */ \
			std::uint8_t   pad1E1;               /* 1E1 */ \
			std::uint16_t  pad1E2;               /* 1E2 */ \
			std::uint32_t  pad1E4;               /* 1E4 */

			GRENADE_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline GRENADE_RUNTIME_DATA& GetGrenadeRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<GRENADE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		[[nodiscard]] inline const GRENADE_RUNTIME_DATA& GetGrenadeRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<GRENADE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		GRENADE_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(GrenadeProjectile) == 0x1E8);
#endif
}
#undef GRENADE_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/G/GridArray.h
===============================================
#pragma once

namespace RE
{
	class GridArray
	{
	public:
		inline static constexpr auto RTTI = RTTI_GridArray;

		virtual ~GridArray();  // 00

		// add
		virtual void DetachAll();                                                                                           // 01
		virtual void KillAll();                                                                                             // 02
		virtual bool SetCenter(std::int32_t a_x, std::int32_t a_y);                                                         // 03
		virtual void Shift(std::int32_t a_x, std::int32_t a_y);                                                             // 04
		virtual void Detach(std::uint32_t a_x, std::uint32_t a_y) = 0;                                                      // 05
		virtual void ClearItem(std::uint32_t a_x, std::uint32_t a_y) = 0;                                                   // 06
		virtual void MoveItem(std::uint32_t a_fromX, std::uint32_t a_fromY, std::uint32_t a_toX, std::uint32_t a_toY) = 0;  // 07
		virtual void SwapItem(std::uint32_t a_fromX, std::uint32_t a_fromY, std::uint32_t a_toX, std::uint32_t a_toY) = 0;  // 08

		// members
		std::uint32_t unk08;   // 08 - 1000
		std::uint32_t unk0C;   // 0C - 1000
		std::uint32_t length;  // 10 - takes value from uGridsToLoad
		std::uint32_t pad14;   // 14
	};
	static_assert(sizeof(GridArray) == 0x18);
};


===============================================
File: include/RE/G/GridCellArray.h
===============================================
#pragma once

#include "RE/G/GridArray.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class TESObjectCELL;

	class GridCellArray : public GridArray
	{
	public:
		inline static constexpr auto RTTI = RTTI_GridCellArray;

		~GridCellArray() override;  // 00

		// override (GridArray)
		void KillAll() override;                                                                                         // 02
		bool SetCenter(std::int32_t a_x, std::int32_t a_y) override;                                                     // 03
		void Detach(std::uint32_t a_x, std::uint32_t a_y) override;                                                      // 05
		void ClearItem(std::uint32_t a_x, std::uint32_t a_y) override;                                                   // 06
		void MoveItem(std::uint32_t a_fromX, std::uint32_t a_fromY, std::uint32_t a_toX, std::uint32_t a_toY) override;  // 07
		void SwapItem(std::uint32_t a_fromX, std::uint32_t a_fromY, std::uint32_t a_toX, std::uint32_t a_toY) override;  // 08

		[[nodiscard]] TESObjectCELL* GetCell(std::uint32_t a_x, std::uint32_t a_y) const noexcept
		{
			return (a_x < length && a_y < length) ?
                       cells[(a_x * length) + a_y] :
                       nullptr;
		};

		// members
		TESObjectCELL** cells;           // 18 - (memory allocated using 0x8 * numGrids * numGrids)
		NiPoint3        unk20;           // 20
		bool            land3DAttached;  // 2C
	};
	static_assert(sizeof(GridCellArray) == 0x30);
};


===============================================
File: include/RE/G/GuideEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	class TESQuest;
	class TESQuestTarget;

	class GuideEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_GuideEffect;
		inline static constexpr auto VTABLE = VTABLE_GuideEffect;

		// override (ActiveEffect)
		virtual ~GuideEffect();          // 13
		virtual void Start() override;   // 14
		virtual void Finish() override;  // 15

		// members
		TESQuest*                 quest;        // 90
		TESQuestTarget*           questTarget;  // 98
		BSTArray<ObjectRefHandle> hazards;      // A0
	};
	static_assert(sizeof(GuideEffect) == 0xB8);
}


===============================================
File: include/RE/H/HUDChargeMeter.h
===============================================
#pragma once

#include "RE/H/HUDObject.h"

namespace RE
{
	class HUDChargeMeter : public HUDObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_HUDChargeMeter;
		inline static constexpr auto VTABLE = VTABLE_HUDChargeMeter;

		virtual ~HUDChargeMeter();  // 00

		// override (HUDObject)
		void Update() override;                                        // 01
		bool ProcessMessage(UIMessage* a_message) override;            // 02
		void RegisterHUDComponent(FxDelegateArgs& a_params) override;  // 03

		// members
		float unk28;  // 28 - 100.0
		float unk2C;  // 2C - 100.0
	};
	static_assert(sizeof(HUDChargeMeter) == 0x30);
}


===============================================
File: include/RE/H/HUDData.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/I/IUIMessageData.h"

namespace RE
{
	class HUDData : public IUIMessageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_HUDData;
		inline static constexpr auto VTABLE = VTABLE_HUDData;

		enum class Type
		{
			kUnk0 = 0,
			kNotification = 1,
			kActivate = 2,
			kActivateNoLabel = 3,
			kCenter = 4,
			kSubtitle = 5,
			kSetBlinking = 11,
			kSetFadeOut = 12,
			kSetPct = 13,
			kQuestStarted = 14,
			kQuestComplete = 15,
			kQuestFailed = 16,
			kObjectiveStarted = 17,
			kObjectiveComplete = 18,
			kObjectiveFailed = 19,
			kSkillIncrease = 20,
			kWordOfPower1 = 21,
			kWordOfPower2 = 22,
			kCrosshairHide = 23,
			kCrosshairSneak = 24,
		};

		enum class Discovery
		{
			kCity = 1,
			kTown = 2,
			kDungeon4 = 4,
			kDungeon7 = 7,
			kDungeon8 = 8,
			kDungeon12 = 12,
			kDungeon15 = 15
		};

		~HUDData() override;  // 00

		// members
		stl::enumeration<Type, std::uint32_t>      type;          // 10
		std::uint32_t                              pad14;         // 14
		BSString                                   text;          // 18
		ObjectRefHandle                            crossHairRef;  // 28
		std::uint32_t                              pad2C;         // 2C
		void*                                      unk30;         // 30
		std::uint64_t                              unk38;         // 38
		std::uint8_t                               unk40;         // 40
		std::uint8_t                               pad41;         // 41
		std::uint16_t                              pad42;         // 42
		stl::enumeration<Discovery, std::uint32_t> discovery;     // 44
	};
	static_assert(sizeof(HUDData) == 0x48);
}


===============================================
File: include/RE/H/HUDMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"
#include "RE/W/WorldSpaceMenu.h"

namespace RE
{
	class ActorValueMeter;
	class HudModeChangeEvent;
	class HUDObject;
	class ShoutMeter;
	class UserEventEnabledEvent;
	struct BSRemoteGamepadEvent;

	// menuDepth = 2
	// flags = kAlwaysOpen | kRequiresUpdate | kAllowSaving | kCustomRendering | kAssignCursorToRenderer
	// context = kNone
	class HUDMenu :
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		public WorldSpaceMenu,                       // 00
		public BSTEventSink<UserEventEnabledEvent>,  // 58
		public BSTEventSink<BSRemoteGamepadEvent>    // 60
#elif !defined(ENABLE_SKYRIM_VR)
		public IMenu,                                // 00
		public BSTEventSink<UserEventEnabledEvent>,  // 30
		public BSTEventSink<BSRemoteGamepadEvent>    // 38
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_HUDMenu;
		inline static constexpr auto      VTABLE = VTABLE_HUDMenu;
		constexpr static std::string_view MENU_NAME = "HUD Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                                 \
	BSTArray<HUDObject*> objects; /* 00 */                                                   \
	ActorValueMeter*     health;  /* 18 */                                                   \
	ActorValueMeter*     stamina; /* 20 */                                                   \
	ActorValueMeter*     magicka; /* 28 */                                                   \
	ShoutMeter*          shout;   /* 30 */                                                   \
	GFxValue             root;    /* 38 - kDisplayObject - "_level0.HUDMovieBaseInstance" */ \
	std::uint64_t        unk90;   /* 50 */

			RUNTIME_DATA_CONTENT
		};

		~HUDMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;                       // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05
		void               RefreshPlatform() override;                                            // 08

#ifndef SKYRIM_CROSS_VR
		// override (BSTEventSink<UserEventEnabledEvent>)
		BSEventNotifyControl ProcessEvent(const UserEventEnabledEvent* a_event, BSTEventSource<UserEventEnabledEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BSRemoteGamepadEvent>)
		BSEventNotifyControl ProcessEvent(const BSRemoteGamepadEvent* a_event, BSTEventSource<BSRemoteGamepadEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] WorldSpaceMenu* AsWorldSpaceMenu() noexcept
		{
			if SKYRIM_REL_CONSTEXPR (!REL::Module::IsVR()) {
				return nullptr;
			}
			return &REL::RelocateMember<WorldSpaceMenu>(this, 0, 0);
		}

		[[nodiscard]] const WorldSpaceMenu* AsWorldSpaceMenu() const noexcept
		{
			return const_cast<HUDMenu*>(this)->AsWorldSpaceMenu();
		}

		[[nodiscard]] BSTEventSink<UserEventEnabledEvent>* AsUserEventEnabledEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<UserEventEnabledEvent>>(this, 0x30, 0x58);
		}

		[[nodiscard]] const BSTEventSink<UserEventEnabledEvent>* AsUserEventEnabledEventSink() const noexcept
		{
			return const_cast<HUDMenu*>(this)->AsUserEventEnabledEventSink();
		}

		[[nodiscard]] BSTEventSink<BSRemoteGamepadEvent>* AsBSRemoteGamepadEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BSRemoteGamepadEvent>>(this, 0x38, 0x60);
		}

		[[nodiscard]] const BSTEventSink<BSRemoteGamepadEvent>* AsBSRemoteGamepadEventSink() const noexcept
		{
			return const_cast<HUDMenu*>(this)->AsBSRemoteGamepadEventSink();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x70);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x70);
		}

		static void UpdateCrosshairMagicTarget(bool a_valid)
		{
			using func_t = decltype(&HUDMenu::UpdateCrosshairMagicTarget);
			REL::Relocation<func_t> func{ RELOCATION_ID(50738, 51633) };
			return func(a_valid);
		}

		// members
#ifndef SKYRIM_CROSS_VR
#	if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		std::uint64_t pad68;  // 68
#	endif
		RUNTIME_DATA_CONTENT  // 40, 70
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(HUDMenu) == 0x98);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(HUDMenu) == 0xC8);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/H/HUDMeter.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/H/HUDObject.h"

namespace RE
{
	class HUDMeter : public HUDObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_HUDMeter;
		inline static constexpr auto VTABLE = VTABLE_HUDMeter;

		HUDMeter(GFxMovieView* a_view);
		~HUDMeter() override = default;  // 00

		// override (HUDObject)
		void Update() override;                              // 01
		bool ProcessMessage(UIMessage* a_message) override;  // 02 - { return false; }

		// add
		virtual float GetFillPct();  // 05 - { return 100.0; }

		void SetFillPct(bool a_forceUpdate);

		// members
		BSFixedString setPctName;       // 28
		BSFixedString setBlinkingName;  // 30
		BSFixedString fadeOutName;      // 38
		float         fillPct;          // 40
		std::uint32_t pad44;            // 44
	};
	static_assert(sizeof(HUDMeter) == 0x48);
}


===============================================
File: include/RE/H/HUDNotifications.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSString.h"
#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/H/HUDObject.h"

namespace RE
{
	class TESQuest;
	class TESWordOfPower;

	class HUDNotifications : public HUDObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_HUDNotifications;
		inline static constexpr auto VTABLE = VTABLE_HUDNotifications;

		struct Notification
		{
		public:
			// members
			BSString                text;              // 00
			BSString                status;            // 10
			BSFixedString           sound;             // 20
			BSTArray<BSFixedString> objectives;        // 28
			std::uint32_t           type{ 0 };         // 40
			std::uint32_t           pad44{ 0 };        // 44
			TESQuest*               quest{ nullptr };  // 48
			TESWordOfPower*         word{ nullptr };   // 50
			std::uint32_t           time{ 0 };         // 58 - gameTime + iObjectivesWaitTime
			std::uint32_t           pad5C{ 0 };        // 5C
		};
		static_assert(sizeof(Notification) == 0x60);

		~HUDNotifications() override;  // 00

		// override (HUDObject)
		void Update() override;                                        // 01
		bool ProcessMessage(UIMessage* a_message) override;            // 02
		void RegisterHUDComponent(FxDelegateArgs& a_params) override;  // 03
		void CleanUp() override;                                       // 04

		// members
		BSTArray<Notification> queue;        // 28
		GFxValue               root;         // 40 - "HUDMovieBaseInstance.QuestUpdateBaseInstance"
		GFxValue               objectives;   // 58 - "QuestNotification.ObjectivesA"
		std::uint32_t          time;         // 70 - last meter update time
		float                  levelPoints;  // 74 - cached meter progress
	};
	static_assert(sizeof(HUDNotifications) == 0x78);
}


===============================================
File: include/RE/H/HUDObject.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"
#include "RE/G/GPtr.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class FxDelegateArgs;
	class GFxMovieView;
	class UIMessage;

	class HUDObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_HUDObject;
		inline static constexpr auto VTABLE = VTABLE_HUDObject;

		struct HudComponents
		{
			enum HudComponent : std::uint32_t
			{
				kThis = 0,
				kHudElements,
				kQuestUpdateBaseInstance,
				kEnemyHealthMeter,
				kStealthMeterInstance,
				kSneakAnimInstance,
				kBracketsInstance,
				kRolloverNameInstance,
				kSneakTextHolder,
				kSneakTextInstance
			};
		};
		using HudComponent = HudComponents::HudComponent;

		HUDObject(GFxMovieView* a_view);
		virtual ~HUDObject();  // 00

		// add
		virtual void Update() = 0;                                    // 01
		virtual bool ProcessMessage(UIMessage* a_message);            // 02 - { return false; }
		virtual void RegisterHUDComponent(FxDelegateArgs& a_params);  // 03 - { root = a_params[0]; }
		virtual void CleanUp();                                       // 04 - { return; }

		TES_HEAP_REDEFINE_NEW();

		// members
		GPtr<GFxMovieView> view;  // 08
		GFxValue           root;  // 10 - kDisplayObject - "_level0.HUDMovieBaseInstance"
	};
	static_assert(sizeof(HUDObject) == 0x28);
}


===============================================
File: include/RE/H/HandleManager.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSPointerHandleManager.h"

namespace RE
{
	class HandleManager : public BSPointerHandleManager<BSUntypedPointerHandle<>>
	{
	public:
	};
	static_assert(std::is_empty_v<HandleManager>);
}


===============================================
File: include/RE/H/HandlePolicy.h
===============================================
#pragma once

#include "RE/B/BSTHashMap.h"
#include "RE/I/IObjectHandlePolicy.h"

namespace RE
{
	namespace SkyrimScript
	{
		class HandlePolicy : public BSScript::IObjectHandlePolicy
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript__HandlePolicy;
			inline static constexpr auto VTABLE = VTABLE_SkyrimScript__HandlePolicy;

			~HandlePolicy() override;  // 00

			// override (BSScript::IObjectHandlePolicy)
			bool     HandleIsType(VMTypeID a_typeID, VMHandle a_handle) const override;                 // 01
			bool     IsHandleObjectAvailable(VMHandle a_handle) const override;                         // 02
			VMHandle EmptyHandle() const override;                                                      // 03
			VMHandle GetHandleForObject(VMTypeID a_typeID, const void* a_srcData) const override;       // 04
			bool     HasParent(VMHandle a_handle) const override;                                       // 05
			VMHandle GetParentHandle(VMHandle a_handle) const override;                                 // 06
			VMHandle GetHandleScriptsMovedFrom(VMHandle a_handle) const override;                       // 07
			void*    GetObjectForHandle(VMTypeID a_typeID, VMHandle a_handle) const override;           // 08
			void     PersistHandle(VMHandle a_handle) override;                                         // 09
			void     ReleaseHandle(VMHandle a_handle) override;                                         // 0A
			void     ConvertHandleToString(VMHandle a_handle, BSFixedString& a_strOut) const override;  // 0B

			// members
			std::uint64_t                unk08;  // 08
			BSTHashMap<UnkKey, UnkValue> unk10;  // 10
			BSTHashMap<UnkKey, UnkValue> unk40;  // 40
		};
		static_assert(sizeof(HandlePolicy) == 0x70);
	}
}


===============================================
File: include/RE/H/Hazard.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESObjectREFR.h"

namespace RE
{
	class BGSHazard;
	class NiLight;

	class Hazard : public TESObjectREFR
	{
	public:
		inline static constexpr auto RTTI = RTTI_Hazard;
		inline static constexpr auto VTABLE = VTABLE_Hazard;
		inline static constexpr auto FORMTYPE = FormType::PlacedHazard;

		enum class Flags
		{
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~Hazard() override;  // 00

		// override (TESObjectREFR)
		void SaveGame(BGSSaveFormBuffer* a_buf) override;        // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;        // 0F
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 11
		void Revert(BGSLoadFormBuffer* a_buf) override;          // 12
		void InitItemImpl() override;                            // 13
		void SetActorCause(ActorCause* a_cause) override;        // 50
		void Release3DRelatedData() override;                    // 6B
#ifndef SKYRIM_CROSS_VR
		// Override functions past where Skyrim VR breaks compatibility.
		bool OnAddCellPerformQueueReference(TESObjectCELL& a_cell) const override;  // 90 - { return false; }
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void Initialize();         // A2
		SKYRIM_REL_VR_VIRTUAL void Unk_A3(void);         // A3 - { return; }
		SKYRIM_REL_VR_VIRTUAL bool IsPermanent() const;  // A4 - { return TESDataHandler::GetSingleton()->IsGeneratedFormID(formID) == 0; }

		struct HAZARD_RUNTIME_DATA
		{
#define HAZARD_RUNTIME_DATA_CONTENT                                     \
	void*                                  hazardDBHandle; /* 98, A0 */ \
	ActorHandle                            ownerActor;     /* A0 */     \
	float                                  age;            /* A4 */     \
	float                                  lifetime;       /* A8 */     \
	float                                  targetTimer;    /* AC */     \
	float                                  radius;         /* B0 */     \
	float                                  magnitude;      /* B4 */     \
	BGSHazard*                             hazard;         /* B8 */     \
	NiPointer<NiLight>                     light;          /* C0 */     \
	BSSoundHandle                          sound;          /* C8 */     \
	stl::enumeration<Flags, std::uint32_t> flags;          /* D4 */

			HAZARD_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline HAZARD_RUNTIME_DATA& GetHazardRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<HAZARD_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		[[nodiscard]] inline const HAZARD_RUNTIME_DATA& GetHazardRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<HAZARD_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		HAZARD_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(Hazard) == 0xD8);
#endif
}
#undef HAZARD_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/H/HeapBlock.h
===============================================
#pragma once

namespace RE
{
	class HeapBlock
	{
	public:
		struct Free
		{
		public:
			// members
			HeapBlock* prevFree;  // 0
		};
		static_assert(sizeof(Free) == 0x8);

		struct Used
		{
		public:
			[[nodiscard]] std::uint32_t GetCheckPoint() const;
			[[nodiscard]] std::uint32_t GetMemContext() const;
			[[nodiscard]] std::uint32_t GetStackTrace() const;

			// members
			bool memContext1: 1;   // 0 - 0
			bool memContext2: 1;   // 0 - 1
			bool memContext3: 1;   // 0 - 2
			bool memContext4: 1;   // 0 - 3
			bool memContext5: 1;   // 0 - 4
			bool memContext6: 1;   // 0 - 5
			bool memContext7: 1;   // 0 - 6
			bool memContext8: 1;   // 0 - 7
			bool stackTrace1: 1;   // 1 - 0
			bool stackTrace2: 1;   // 1 - 1
			bool stackTrace3: 1;   // 1 - 2
			bool stackTrace4: 1;   // 1 - 3
			bool stackTrace5: 1;   // 1 - 4
			bool stackTrace6: 1;   // 1 - 5
			bool stackTrace7: 1;   // 1 - 6
			bool stackTrace8: 1;   // 1 - 7
			bool stackTrace9: 1;   // 2 - 0
			bool stackTrace10: 1;  // 2 - 1
			bool stackTrace11: 1;  // 2 - 2
			bool stackTrace12: 1;  // 2 - 3
			bool stackTrace13: 1;  // 2 - 4
			bool stackTrace14: 1;  // 2 - 5
			bool stackTrace15: 1;  // 2 - 6
			bool stackTrace16: 1;  // 2 - 7
			bool stackTrace17: 1;  // 3 - 0
			bool stackTrace18: 1;  // 3 - 1
			bool stackTrace19: 1;  // 3 - 2
			bool stackTrace20: 1;  // 3 - 3
			bool stackTrace21: 1;  // 3 - 4
			bool stackTrace22: 1;  // 3 - 5
			bool checkPoint1: 1;   // 3 - 6
			bool checkPoint2: 1;   // 3 - 7
		};
		static_assert(sizeof(Used) == 0x4);

		union FreeOrUsed
		{
			Free free;
			Used used;
		};
		static_assert(sizeof(FreeOrUsed) == 0x8);

		// members
		std::size_t memSize;     // 00
		HeapBlock*  previous;    // 08
		FreeOrUsed  freeOrUsed;  // 10
		HeapBlock*  nextFree;    // 18
	};
	static_assert(sizeof(HeapBlock) == 0x20);
}


===============================================
File: include/RE/H/HeapBlockFreeHead.h
===============================================
#pragma once

#include "RE/H/HeapBlock.h"

namespace RE
{
	class HeapBlockFreeHead : public HeapBlock
	{
	public:
		// members
		std::size_t         parentPtrAndBlackBit;  // 20
		HeapBlockFreeHead*  leftChild;             // 28
		HeapBlockFreeHead*  rightChild;            // 30
		HeapBlockFreeHead** root;                  // 38
	};
	static_assert(sizeof(HeapBlockFreeHead) == 0x40);
}


===============================================
File: include/RE/H/HeldStateHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	class HeldStateHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_HeldStateHandler;
		inline static constexpr auto VTABLE = VTABLE_HeldStateHandler;

		~HeldStateHandler() override;  // 00

		// add
		virtual void UpdateHeldStateActive(const ButtonEvent* a_event);  // 05
		virtual void SetHeldStateActive(bool a_flag);                    // 06 - { heldStateActive = a_flag; }

		// members
		bool          heldStateActive;      // 10
		bool          triggerReleaseEvent;  // 11
		std::uint16_t pad12;                // 12
		std::uint32_t pad14;                // 14
	};
	static_assert(sizeof(HeldStateHandler) == 0x18);
}


===============================================
File: include/RE/H/HighProcessData.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/B/BGSAnimationSequencer.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BSTTuple.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/P/PlayerCharacter.h"
#include "RE/T/TESShout.h"

namespace RE
{
	class ActorKnowledge;
	class BGSAttackData;
	class BGSProjectile;
	class DialogueItem;
	class IAnimationSetCallbackFunctor;
	class MagicItem;
	class NiBillboardNode;
	class NiAVObject;
	class NiPointLight;
	class NiRefObject;
	class TESObjectREFR;
	class TESObjectWEAP;
	class StandardDetectionListener;
	struct Crime;
	struct QueuedDialogueType;

	enum class VOICE_STATE
	{
		kNone = 0,
		kRequest = 1,
		kStart = 2,
		kContinue = 3,
		kPrecast = 4,
		kPostcast = 5,
		kFail = 6
	};

	struct DetectionEvent
	{
	public:
		// members
		std::uint32_t   actionValue;  // 00
		NiPoint3        location;     // 00
		AITimeStamp     timeStamp;    // 10
		ObjectRefHandle ref;          // 10
	};
	static_assert(sizeof(DetectionEvent) == 0x18);

	struct HighProcessData
	{
	public:
		enum class FADE_STATE
		{
			kNormal = 0,
			kIn = 1,
			kOut = 2,
			kTeleportIn = 3,
			kTeleportOut = 4,
			kOutDisable = 5,
			kOutDelete = 6
		};

		enum class BUMP_TYPE
		{
			kNone = static_cast<std::underlying_type_t<BUMP_TYPE>>(-1),
			kSmall = 0,
			kBig = 1
		};

		struct HEAD_TRACK_TYPES
		{
			enum HEAD_TRACK_TYPE : std::uint32_t
			{
				kDefault = 0,
				kAction,
				kScript,
				kCombat,
				kDialogue,
				kProcedure,

				kTotal = 6
			};
		};
		using HEAD_TRACK_TYPE = HEAD_TRACK_TYPES::HEAD_TRACK_TYPE;

		struct Data190 : public BSIntrusiveRefCounted
		{
		public:
			struct Data
			{
			public:
				struct UnkData
				{
					std::uint64_t unk00;  // 00
					std::uint64_t unk08;  // 08
					std::uint64_t unk10;  // 10
					std::uint64_t unk18;  // 18
					std::uint64_t unk20;  // 20
					std::uint64_t unk28;  // 28
					std::uint64_t unk30;  // 30
					std::uint64_t unk38;  // 38
					std::uint64_t unk40;  // 40
					std::uint64_t unk48;  // 48
					std::uint64_t unk50;  // 50
					std::uint64_t unk58;  // 58
					std::uint64_t unk60;  // 60
					std::uint64_t unk68;  // 68
					std::uint64_t unk70;  // 70
					std::uint64_t unk78;  // 78
				};
				static_assert(sizeof(UnkData) == 0x80);

				// members
				UnkData*      unk00;  // 00
				std::uint64_t unk08;  // 08
			};
			static_assert(sizeof(Data) == 0x10);

			// members
			std::uint32_t       unk04;  // 00
			BSTSmallArray<Data> unk08;  // 08
			std::uint64_t       unk28;  // 28
		};
		static_assert(sizeof(Data190) == 0x30);

		struct Data208
		{
		public:
			// members
			std::uint64_t unk00;  // 00
			std::uint64_t unk08;  // 08
			std::uint64_t unk10;  // 10
			std::uint64_t unk18;  // 18
			std::uint64_t unk20;  // 20
			std::uint64_t unk28;  // 28
			Data208*      next;   // 30
		};
		static_assert(sizeof(Data208) == 0x38);

		struct MuzzleFlash
		{
		public:
			// members
			bool                    unk00;                // 00
			bool                    unk01;                // 01
			bool                    unk02;                // 02
			bool                    unk03;                // 03
			float                   unk04;                // 04
			float                   muzzleFlashDuration;  // 08
			std::uint32_t           unk0C;                // 0C
			NiPointer<NiAVObject>   projectile3D;         // 10
			NiPointer<NiAVObject>   projectileNode;       // 18
			NiPointer<NiPointLight> attachedLight;        // 20
			BGSProjectile*          baseProjectile;       // 28
			TESObjectWEAP*          weaponSource;         // 30
			ActorHandle             shooterHandle;        // 38
			std::uint32_t           unk3C;                // 3C
		};
		static_assert(sizeof(MuzzleFlash) == 0x40);

		void ClearHeadtrackTarget(HEAD_TRACK_TYPE a_headtrackType, bool a_defaultHold)
		{
			using func_t = decltype(&HighProcessData::ClearHeadtrackTarget);
			REL::Relocation<func_t> func{ RELOCATION_ID(38726, 39756) };
			return func(this, a_headtrackType, a_defaultHold);
		}

		void SetHeadtrackTarget(HEAD_TRACK_TYPE a_headtrackType, TESObjectREFR* a_target)
		{
			using func_t = decltype(&HighProcessData::SetHeadtrackTarget);
			REL::Relocation<func_t> func{ RELOCATION_ID(38760, 39783) };
			return func(this, a_headtrackType, a_target);
		}

		// members
		stl::enumeration<VOICE_STATE, std::uint32_t>          voiceState;                                // 000
		std::uint32_t                                         pad004;                                    // 004
		TESShout*                                             currentShout;                              // 008
		TESShout::VariationID                                 currentShoutVariation;                     // 010
		float                                                 voiceTimeElapsed;                          // 014
		float                                                 voiceRecoveryTime;                         // 018
		float                                                 healthRegenDelay;                          // 01C
		float                                                 staminaRegenDelay;                         // 020
		float                                                 magickaRegenDelay;                         // 024
		float                                                 unk028;                                    // 028
		std::uint32_t                                         unk02C;                                    // 02C
		BSTArray<ActorHandle>                                 lastSpokenToArray;                         // 030
		std::uint64_t                                         unk048;                                    // 048
		BGSAnimationSequencer                                 animSequencer;                             // 050
		NiPoint3                                              pathingCurrentMovementSpeed;               // 088
		NiPoint3                                              pathingCurrentRotationSpeed;               // 094
		NiPoint3                                              pathingDesiredPosition;                    // 0A0
		NiPoint3                                              pathingDesiredOrientation;                 // 0AC
		NiPoint3                                              pathingDesiredMovementSpeed;               // 0B8
		NiPoint3                                              pathingDesiredRotationSpeed;               // 0C4
		std::uint32_t                                         unk0D0;                                    // 0D0
		float                                                 lastBumpDirection;                         // 0D4
		ObjectRefHandle                                       lastExtDoorActivated;                      // 0D8
		float                                                 activationHeight;                          // 0DC
		ActorHandle                                           reanimateCaster;                           // 0E0
		std::uint32_t                                         unk0E4;                                    // 0E4
		MagicItem*                                            reanimateSpell;                            // 0E8
		BSFixedString                                         voiceSubtitle;                             // 0F0
		float                                                 unk0F8;                                    // 0F8
		float                                                 unk0FC;                                    // 0FC
		float                                                 unk100;                                    // 100
		float                                                 unk104;                                    // 104
		float                                                 unk108;                                    // 108
		float                                                 unk10C;                                    // 10C
		float                                                 unk110;                                    // 110
		float                                                 unk114;                                    // 114
		float                                                 unk118;                                    // 118
		float                                                 unk11C;                                    // 11C
		float                                                 unk120;                                    // 120
		float                                                 unk124;                                    // 124
		float                                                 unk128;                                    // 128
		float                                                 unk12C;                                    // 12C
		stl::enumeration<FADE_STATE, std::uint32_t>           fadeState;                                 // 130
		float                                                 unk134;                                    // 134
		TESObjectREFR*                                        fadeTrigger;                               // 138
		ObjectRefHandle                                       headTrackTarget[HEAD_TRACK_TYPE::kTotal];  // 140
		bool                                                  headTracked[HEAD_TRACK_TYPE::kTotal];      // 158
		std::uint16_t                                         unk15E;                                    // 15E
		float                                                 headTrackTargetTimer;                      // 160
		NiPoint3                                              headTrackTargetOffset;                     // 164
		float                                                 headTrackHoldOffsetHoldTimer;              // 170
		float                                                 headTrackTargetOffsetTimer;                // 174
		ObjectRefHandle                                       lastTarget;                                // 178
		ObjectRefHandle                                       pathLookAtTarget;                          // 17C
		void*                                                 unk180;                                    // 180 - smart ptr
		void*                                                 unk188;                                    // 188 - smart ptr
		BSTSmartPointer<Data190>                              unk190;                                    // 190
		BSTSmartPointer<Data190>                              unk198;                                    // 198
		float                                                 unk1A0;                                    // 1A0
		float                                                 unk1A4;                                    // 1A4
		float                                                 unk1A8;                                    // 1A8
		std::uint32_t                                         unk1AC;                                    // 1AC
		std::uint64_t                                         unk1B0;                                    // 1B0
		std::uint64_t                                         unk1B8;                                    // 1B8
		std::uint64_t                                         unk1C0;                                    // 1C0
		std::uint64_t                                         unk1C8;                                    // 1C8
		std::uint64_t                                         unk1D0;                                    // 1D0
		std::uint64_t                                         unk1D8;                                    // 1D8
		float                                                 unk1E0;                                    // 1E0
		float                                                 cachedActorHeight;                         // 1E4
		NiPointer<NiRefObject>                                unk1E8;                                    // 1E8
		std::uint32_t                                         unk1F0;                                    // 1F0
		AITimeStamp                                           bumpTimer;                                 // 1F4
		AITimeStamp                                           unk1F8;                                    // 1F8
		BUMP_TYPE                                             bumpedState;                               // 1FC
		float                                                 takeBackTimer;                             // 200
		std::uint32_t                                         pad204;                                    // 204
		Data208*                                              unk208;                                    // 208
		std::uint32_t                                         unk210;                                    // 210
		PLAYER_ACTION                                         playerActionReaction;                      // 214
		BSFixedString                                         subtitle;                                  // 218
		BSTArray<BSTTuple<FormID, NiPointer<ActorKnowledge>>> knowledgeArray;                            // 220
		mutable BSReadWriteLock                               knowledgeLock;                             // 238
		BSTArray<QueuedDialogueType*>                         queueofGreetings;                          // 240
		NiPointer<BGSAttackData>                              attackData;                                // 258
		NiPoint3                                              locationOffsetByWaterPoint;                // 260
		std::uint32_t                                         unk26C;                                    // 26C
		std::uint64_t                                         unk270;                                    // 270
		float                                                 unk278;                                    // 278
		NiPoint3                                              deathForceDirection;                       // 27C
		float                                                 deathForce;                                // 288
		float                                                 unk28C;                                    // 28C
		float                                                 unk290;                                    // 290
		float                                                 unk294;                                    // 294
		float                                                 unk298;                                    // 298
		float                                                 clearTalkToListTimer;                      // 29C
		float                                                 maxAlpha;                                  // 2A0
		float                                                 unk2A4;                                    // 2A4
		std::uint64_t                                         unk2A8;                                    // 2A8
		float                                                 unk2B0;                                    // 2B0 - fAISocialTimerForConversationsMin
		std::uint32_t                                         unk2B4;                                    // 2B4
		std::uint64_t                                         unk2B8;                                    // 2B8
		std::uint64_t                                         unk2C0;                                    // 2C0
		std::uint64_t                                         unk2C8;                                    // 2C8
		std::uint64_t                                         unk2D0;                                    // 2D0
		std::uint32_t                                         animAction;                                // 2D8
		NiPoint3                                              leftWeaponLastPos;                         // 2DC
		NiPoint3                                              rightWeaponLastPos;                        // 2E8
		ObjectRefHandle                                       greetActor;                                // 2F4
		float                                                 soundDelay;                                // 2F8
		BSSoundHandle                                         soundHandles[2];                           // 2FC
		float                                                 greetingTimer;                             // 314
		float                                                 exclusiveTimer;                            // 318
		float                                                 idleTimer;                                 // 31C
		float                                                 detectGreetTimer;                          // 320
		float                                                 breathTimer;                               // 324
		float                                                 voiceTimer;                                // 328
		float                                                 dyingTimer;                                // 32C
		std::uint64_t                                         unk330;                                    // 330
		std::uint64_t                                         unk338;                                    // 338
		float                                                 closeDialogueTimer;                        // 340
		std::uint32_t                                         unk344;                                    // 344
		TESIdleForm*                                          currentProcessIdle;                        // 348
		RefHandle                                             unk350;                                    // 350
		std::uint32_t                                         unk354;                                    // 354
		std::uint64_t                                         unk358;                                    // 358
		BSTSmartPointer<DialogueItem>                         greetTopic;                                // 360
		std::uint32_t                                         unk368;                                    // 368
		RefHandle                                             unk36C;                                    // 36C
		void*                                                 unk370;                                    // 370
		std::uint64_t                                         unk378;                                    // 378
		NiPointer<NiBillboardNode>                            healthBarNode;                             // 380
		float                                                 unk388;                                    // 388
		std::uint32_t                                         unk38C;                                    // 38C
		std::uint32_t                                         numberGuardsPursuing;                      // 390
		float                                                 reEquipArmorTimer;                         // 394
		BSSimpleList<SpellItem*>*                             leveledSpellList;                          // 398
		float                                                 detectionModifier;                         // 3A0
		float                                                 detectionModifierTimer;                    // 3A4
		float                                                 lightLevel;                                // 3A8
		float                                                 sceneHeadTrackTimer;                       // 3AC
		float                                                 pCapVoiceFailsafeTimer;                    // 3B0
		std::uint32_t                                         pad3B4;                                    // 3B4
		void*                                                 unk3B8;                                    // 3B8
		std::uint64_t                                         unk3C0;                                    // 3C0
		MuzzleFlash*                                          muzzleFlash;                               // 3C8
		std::uint32_t                                         unk3D0;                                    // 3D0
		std::uint32_t                                         pad3D4;                                    // 3D4
		DetectionEvent*                                       actorsGeneratedDetectionEvent;             // 3D8
		NiPointer<StandardDetectionListener>                  detectionListener;                         // 3E0
		std::uint64_t                                         unk3E8;                                    // 3E8
		void*                                                 unk3F0;                                    // 3F0 - smart ptr
		std::uint64_t                                         unk3F8;                                    // 3F8
		BSTSmallArray<std::uint64_t>                          unk400;                                    // 400
		NiPoint3                                              animationDelta;                            // 418
		NiPoint3                                              animationAngleMod;                         // 424
		BSTSmartPointer<IAnimationSetCallbackFunctor>         unk430;                                    // 430
		float                                                 absorbTimer;                               // 438
		float                                                 unk43C;                                    // 43C
		Crime*                                                crimeToReactTo;                            // 440
		std::uint64_t                                         unk448;                                    // 448
		bool                                                  unk450;                                    // 450
		std::uint8_t                                          unk451;                                    // 451
		std::uint8_t                                          unk452;                                    // 452
		std::uint8_t                                          unk453;                                    // 453
		bool                                                  greetingPlayer;                            // 454
		std::uint8_t                                          unk455;                                    // 455
		std::uint8_t                                          unk456;                                    // 456
		bool                                                  detectAlert;                               // 457
		bool                                                  talkingToPC;                               // 458
		bool                                                  inCommandState;                            // 459
		std::uint8_t                                          unk45A;                                    // 45A
		std::uint8_t                                          unk45B;                                    // 45B
		std::uint8_t                                          unk45C;                                    // 45C
		std::uint8_t                                          unk45D;                                    // 45D
		std::uint8_t                                          unk45E;                                    // 45E
		bool                                                  isDualCasting;                             // 45F
		bool                                                  getPlantedExplosive;                       // 460
		bool                                                  approachingAutoTeleportDoor;               // 461
		bool                                                  arrested;                                  // 462
		bool                                                  unk463;                                    // 463
		bool                                                  unk464;                                    // 464
		bool                                                  unk465;                                    // 465
		bool                                                  unk466;                                    // 466
		bool                                                  unk467;                                    // 467
		bool                                                  farGeometry;                               // 468
		bool                                                  unk469;                                    // 469
		bool                                                  unk46A;                                    // 46A
		bool                                                  deathDialogue;                             // 46B
		bool                                                  fistsDrawn;                                // 46C
		bool                                                  unk46D;                                    // 46D
		bool                                                  unk46E;                                    // 46E
		bool                                                  unk46F;                                    // 46F
		bool                                                  unk470;                                    // 470
		bool                                                  unk471;                                    // 471
		bool                                                  aggroRadiusStarted;                        // 472
		std::uint8_t                                          pad473;                                    // 473
		std::uint32_t                                         pad474;                                    // 474
	};
	static_assert(sizeof(HighProcessData) == 0x478);
}


===============================================
File: include/RE/H/HitData.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSAttackData;
	class InventoryEntryData;
	class MagicItem;
	class TESObjectWEAP;
	class VATSCommand;

	class HitData
	{
	public:
		enum class Flag
		{
			kBlocked = 1 << 0,
			kBlockWithWeapon = 1 << 1,
			kBlockCandidate = 1 << 2,
			kCritical = 1 << 3,
			kCriticalOnDeath = 1 << 4,
			kFatal = 1 << 5,
			kDismemberLimb = 1 << 6,
			kExplodeLimb = 1 << 7,
			kCrippleLimb = 1 << 8,
			kDisarm = 1 << 9,
			kDisableWeapon = 1 << 10,
			kSneakAttack = 1 << 11,
			kIgnoreCritical = 1 << 12,
			kPredictDamage = 1 << 13,
			//kPredictBaseDamage = 1 << 14,
			kBash = 1 << 14,
			kTimedBash = 1 << 15,
			kPowerAttack = 1 << 16,
			kMeleeAttack = 1 << 18,
			kRicochet = 1 << 19,
			kExplosion = 1 << 20
		};

		void Populate(Actor* a_aggressor, Actor* a_target, InventoryEntryData* a_weapon)
		{
			using func_t = decltype(&HitData::Populate);
			REL::Relocation<func_t> func(RELOCATION_ID(42832, 44001));
			return func(this, a_aggressor, a_target, a_weapon);
		}

		// members
		NiPoint3                              hitPosition;             // 00
		NiPoint3                              hitDirection;            // 0C
		ActorHandle                           aggressor;               // 18
		ActorHandle                           target;                  // 1C
		ObjectRefHandle                       sourceRef;               // 20
		std::uint32_t                         pad24;                   // 24
		NiPointer<BGSAttackData>              attackData;              // 28
		TESObjectWEAP*                        weapon;                  // 30
		MagicItem*                            criticalEffect;          // 38
		SpellItem*                            attackDataSpell;         // 40
		VATSCommand*                          VATSCommand;             // 48
		float                                 totalDamage;             // 50
		float                                 physicalDamage;          // 54
		float                                 targetedLimbDamage;      // 58
		float                                 percentBlocked;          // 5C
		float                                 resistedPhysicalDamage;  // 60
		float                                 resistedTypedDamage;     // 64
		std::uint32_t                         stagger;                 // 68
		float                                 sneakAttackBonus;        // 6C
		float                                 bonusHealthDamageMult;   // 70
		float                                 pushBack;                // 74
		float                                 reflectedDamage;         // 78
		float                                 criticalDamageMult;      // 7C
		stl::enumeration<Flag, std::uint32_t> flags;                   // 80
		std::uint32_t                         equipIndex;              // 84
		ActorValue                            skill;                   // 88
		std::uint32_t                         damageLimb;              // 8C
	};
	static_assert(sizeof(HitData) == 0x90);
}


===============================================
File: include/RE/H/HorseCameraState.h
===============================================
#pragma once

#include "RE/T/ThirdPersonState.h"

namespace RE
{
	class NiNode;

	class HorseCameraState : public ThirdPersonState
	{
	public:
		inline static constexpr auto RTTI = RTTI_HorseCameraState;
		inline static constexpr auto VTABLE = VTABLE_HorseCameraState;

		~HorseCameraState() override;  // 00

		// override (ThirdPersonState)
		void Begin() override;                                     // 01
		void End() override;                                       // 02
		void SaveGame(BGSSaveFormBuffer* a_buf) override;          // 06
		void LoadGame(BGSLoadFormBuffer* a_buf) override;          // 07
		void Revert(BGSLoadFormBuffer* a_buf) override;            // 08
		void SetCameraHandle(RefHandle& a_handle) override;        // 09 - { return; }
		void Unk_0A(void) override;                                // 0A - { return; }
		void ProcessWeaponDrawnChange(bool a_drawn) override;      // 0B
		bool GetFreeRotationMode() const override;                 // 0C
		void SetFreeRotationMode(bool a_weaponSheathed) override;  // 0D
		void HandleLookInput(const NiPoint2& a_input) override;    // 0F

		// members
		ObjectRefHandle horseRefHandle;         // E8
		float           horseCurrentDirection;  // EC
		std::uint64_t   unkF0;                  // F0
	};
	static_assert(sizeof(HorseCameraState) == 0xF8);
}


===============================================
File: include/RE/H/hkAabb.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	class hkAabb
	{
	public:
		// members
		hkVector4 min;  // 00
		hkVector4 max;  // 10
	};
	static_assert(sizeof(hkAabb) == 0x20);
}


===============================================
File: include/RE/H/hkArray.h
===============================================
#pragma once

#include "RE/H/hkContainerAllocators.h"

namespace RE
{
	template <class T>
	class hkArrayBase
	{
	public:
		using value_type = T;
		using size_type = std::int32_t;
		using reference = value_type&;
		using const_reference = const value_type&;
		using iterator = T*;
		using const_iterator = const T*;

		reference operator[](size_type a_pos)
		{
			assert(a_pos >= 0 && a_pos < size());
			return data()[a_pos];
		}

		const_reference operator[](size_type a_pos) const
		{
			assert(a_pos >= 0 && a_pos < size());
			return data()[a_pos];
		}

		T* data()
		{
			return _data;
		}

		[[nodiscard]] const T* data() const
		{
			return _data;
		}

		reference front()
		{
			return operator[](0);
		}

		[[nodiscard]] const_reference front() const
		{
			return operator[](0);
		}

		reference back()
		{
			return operator[](size() - 1);
		}

		[[nodiscard]] const_reference back() const
		{
			return operator[](size() - 1);
		}

		iterator begin()
		{
			return empty() ? iterator{} : std::addressof(data()[0]);
		}

		[[nodiscard]] const_iterator begin() const
		{
			return empty() ? const_iterator{} : std::addressof(data()[0]);
		}

		[[nodiscard]] const_iterator cbegin() const
		{
			return begin();
		}

		iterator end()
		{
			return empty() ? iterator{} : std::addressof(data()[size()]);
		}

		[[nodiscard]] const_iterator end() const
		{
			return empty() ? const_iterator{} : std::addressof(data()[size()]);
		}

		[[nodiscard]] const_iterator cend() const
		{
			return end();
		}

		[[nodiscard]] bool empty() const
		{
			return size() == 0;
		}

		[[nodiscard]] size_type size() const noexcept
		{
			return _size;
		}

		void reserve(size_type a_newCap)
		{
			assert(a_newCap <= kCapacityMask);
			if (a_newCap <= capacity()) {
				return;
			}

			auto      allocator = hkContainerHeapAllocator::GetSingleton();
			size_type newSize = a_newCap * sizeof(T);
			T*        newMem = static_cast<T*>(allocator->BufAlloc(newSize));
			if (_data) {
				size_type oldSize = size() * sizeof(T);
				std::memcpy(newMem, _data, oldSize);
				if ((_capacityAndFlags & kDontDeallocFlag) == 0) {
					allocator->BufFree(_data, oldSize);
				}
			}

			_data = newMem;
			_capacityAndFlags &= ~kCapacityMask;
			_capacityAndFlags |= a_newCap & kCapacityMask;
		}

		[[nodiscard]] size_type capacity() const noexcept
		{
			return _capacityAndFlags & kCapacityMask;
		}

		void push_back(const T& a_value)
		{
			if (size() == capacity()) {
				reserve(static_cast<size_type>(std::ceil(size() * GROWTH_FACTOR)));
			}
			_data[_size++] = a_value;
		}

		void resize(size_type a_count)
		{
			assert(a_count > 0 && a_count <= kCapacityMask);
			if (a_count == size()) {
				return;
			}

			if (a_count < size()) {  // if shrink
				for (size_type i = a_count; i < size(); ++i) {
					_data[i].~T();
				}
			}

			auto      allocator = hkContainerHeapAllocator::GetSingleton();
			size_type newSize = a_count * sizeof(T);
			T*        newMem = static_cast<T*>(allocator->BufAlloc(newSize));
			if (_data) {
				size_type oldSize = size() * sizeof(T);
				std::memcpy(newMem, _data, (std::min)(oldSize, newSize));
				if ((_capacityAndFlags & kDontDeallocFlag) == 0) {
					allocator->BufFree(_data, oldSize);
				}
			}

			if (a_count > size()) {  // if grow
				for (size_type i = size(); i < a_count; ++i) {
					new (&newMem[i]) T{};
				}
			}

			_data = newMem;
			_size = a_count;
			_capacityAndFlags &= ~kCapacityMask;
			_capacityAndFlags |= a_count & kCapacityMask;
		}

		enum : std::uint32_t
		{
			kCapacityMask = 0x3FFFFFFF,
			kFlagMask = 0xC0000000,
			kDontDeallocFlag = (std::uint32_t)1 << 31
		};

		static constexpr float GROWTH_FACTOR = 1.5;  // NOT PART OF NATIVE TYPE

		T*           _data;              // 00
		std::int32_t _size;              // 08
		std::int32_t _capacityAndFlags;  // 0C
	};
	static_assert(sizeof(hkArrayBase<void*>) == 0x10);

	template <class T, class Allocator = void>
	class hkArray : public hkArrayBase<T>
	{
	public:
	};
	static_assert(sizeof(hkArray<void*>) == 0x10);

	template <class T, std::size_t N, class Allocator = void>
	class hkInplaceArray : public hkArray<T, Allocator>
	{
	public:
		T storage[N];  // 10
	};
}


===============================================
File: include/RE/H/hkBaseObject.h
===============================================
#pragma once

namespace RE
{
	class hkBaseObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkBaseObject;
		inline static constexpr auto VTABLE = VTABLE_hkBaseObject;

		virtual ~hkBaseObject() = default;  // 00
	};
	static_assert(sizeof(hkBaseObject) == 0x8);
}


===============================================
File: include/RE/H/hkBaseTypes.h
===============================================
#pragma once

namespace RE
{
	using hkObjectIndex = std::uint16_t;
	using hkTime = float;

	enum class hkResult
	{
		kSuccess = 0,
		kFailure = 1
	};

	// 16-bit float with 7-bit precision
	class hkHalf
	{
	public:
		hkHalf();
		explicit hkHalf(const float& a_val);

		hkHalf& operator=(const float& a_val);
				operator float() const;

	protected:
		void                SetFloat(const float& a_val);
		[[nodiscard]] float GetFloat() const;

		// members
		std::int16_t _value;  // 0
	};
	static_assert(sizeof(hkHalf) == 0x2);

	// 8-bit float ranging [0.01, 1000000.0]
	// value is an index in a lookup table
	class hkUFloat8
	{
	public:
		// members
		std::uint8_t value;  // 0
	};
	static_assert(sizeof(hkUFloat8) == 0x1);
}


===============================================
File: include/RE/H/hkContactPoint.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	class hkContactPoint
	{
	public:
		hkVector4 position;          // 00
		hkVector4 separatingNormal;  // 10
	};
	static_assert(sizeof(hkContactPoint) == 0x20);
}


===============================================
File: include/RE/H/hkContainerAllocators.h
===============================================
#pragma once

#include "RE/H/hkMemoryAllocator.h"

namespace RE
{
	struct hkContainerHeapAllocator
	{
		struct Allocator : public hkMemoryAllocator
		{
			inline static constexpr auto RTTI = RTTI_hkContainerHeapAllocator__Allocator;
			inline static constexpr auto VTABLE = VTABLE_hkContainerHeapAllocator__Allocator;

			~Allocator() override;  // 00

			void*        BlockAlloc(std::int32_t a_numBytes) override;                           // 01
			void         BlockFree(void* a_ptr, std::int32_t a_numBytes) override;               // 02
			void*        BufAlloc(std::int32_t& a_reqNumBytesInOut) override;                    // 03
			void         BufFree(void* a_ptr, std::int32_t a_numBytes) override;                 // 04
			void         GetMemoryStatistics(MemoryStatistics& a_usage) override;                // 08
			std::int32_t GetAllocatedSize(const void* a_obj, std::int32_t a_numBytes) override;  // 09
		};
		static_assert(sizeof(Allocator) == 0x8);

		[[nodiscard]] static Allocator* GetSingleton()
		{
			REL::Relocation<hkContainerHeapAllocator::Allocator*> singleton{ RELOCATION_ID(510713, 383828) };
			return singleton.get();
		}
	};
	static_assert(sizeof(hkContainerHeapAllocator) == 0x1);
}


===============================================
File: include/RE/H/hkFinishLoadedObjectFlag.h
===============================================
#pragma once

namespace RE
{
	struct hkFinishLoadedObjectFlag
	{
		// members
		std::int32_t finishing{ 0 };
	};
}


===============================================
File: include/RE/H/hkMatrix3.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	class hkMatrix3
	{
	public:
		hkVector4 col0;  // 00
		hkVector4 col1;  // 10
		hkVector4 col2;  // 20
	};
	static_assert(sizeof(hkMatrix3) == 0x30);
}


===============================================
File: include/RE/H/hkMemoryAllocator.h
===============================================
#pragma once

#include "RE/H/hkBaseTypes.h"

namespace RE
{
	class hkMemoryAllocator
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkMemoryAllocator;
		inline static constexpr auto VTABLE = VTABLE_hkMemoryAllocator;

		using MemoryWalkCallback = void(void* a_start, std::size_t a_size, bool a_allocated, std::int32_t a_pool, void* a_param);

		enum class MemoryState
		{
			kOK,
			kOutOfMemory
		};

		struct MemoryStatistics
		{
		public:
			static constexpr std::int64_t INFINITE_SIZE = -1;

			// members
			std::int64_t allocated;       // 00
			std::int64_t inUse;           // 08
			std::int64_t peakInUse;       // 10
			std::int64_t available;       // 18
			std::int64_t totalAvailable;  // 20
			std::int64_t largestBlock;    // 28
		};
		static_assert(sizeof(MemoryStatistics) == 0x30);

		struct ExtendedInterface
		{
		public:
			virtual ~ExtendedInterface();  // 00

			// add
			virtual void                      GarbageCollect() = 0;                                           // 01
			virtual void                      IncrementalGarbageCollect(std::int32_t a_numBlocks) = 0;        // 02
			virtual hkResult                  SetMemorySoftLimit(std::size_t a_maxMemory) = 0;                // 03
			[[nodiscard]] virtual std::size_t GetMemorySoftLimit() const = 0;                                 // 04
			virtual bool                      CanAllocTotal(std::int32_t a_numBytes) = 0;                     // 05
			virtual hkResult                  WalkMemory(MemoryWalkCallback* a_callback, void* a_param) = 0;  // 06
		};
		static_assert(sizeof(ExtendedInterface) == 0x8);

		virtual ~hkMemoryAllocator();  // 00

		// add
		virtual void*        BlockAlloc(std::int32_t a_numBytes) = 0;                                                   // 01
		virtual void         BlockFree(void* a_ptr, std::int32_t a_numBytes) = 0;                                       // 02
		virtual void*        BufAlloc(std::int32_t& a_reqNumBytesInOut);                                                // 03
		virtual void         BufFree(void* a_ptr, std::int32_t a_numBytes);                                             // 04
		virtual void*        BufRealloc(void* a_ptrOld, std::int32_t a_oldNumBytes, std::int32_t& a_reqNumBytesInOut);  // 05
		virtual void         BlockAllocBatch(void** a_ptrsOut, std::int32_t a_numPtrs, std::int32_t a_blockSize);       // 06
		virtual void         BlockFreeBatch(void** a_ptrsIn, std::int32_t a_numPtrs, std::int32_t a_blockSize);         // 07
		virtual void         GetMemoryStatistics(MemoryStatistics& a_usage) = 0;                                        // 08
		virtual std::int32_t GetAllocatedSize(const void* a_obj, std::int32_t a_numBytes) = 0;                          // 09
		virtual void         ResetPeakMemoryStatistics();                                                               // 0A - { return; }
	};
	static_assert(sizeof(hkMemoryAllocator) == 0x8);
}


===============================================
File: include/RE/H/hkMoppBvTreeShapeBase.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkpBvTreeShape.h"

namespace RE
{
	class hkpMoppCode;
	class hkTransform;

	class hkMoppBvTreeShapeBase : public hkpBvTreeShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkMoppBvTreeShapeBase;
		inline static constexpr auto VTABLE = VTABLE_hkMoppBvTreeShapeBase;

		~hkMoppBvTreeShapeBase() override;  // 00

		// override (hkpBvTreeShape)
		void          CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override = 0;  // 02
		void          QueryAabb(const hkAabb& a_aabb, hkArray<hkpShapeKey>& a_hits) const override;                          // 0B
		std::uint32_t QueryAabbImpl(const hkAabb& a_aabb, hkpShapeKey* a_hits, std::int32_t a_maxNumKeys) const override;    // 0C

		// add
		virtual void QueryObb(const hkTransform& a_obbToMopp, const hkVector4& a_extent, float tolerance, hkArray<hkpShapeKey>& a_hits) const;  // 0E

		// members
		const hkpMoppCode*  code;          // 28
		const std::uint8_t* moppData;      // 30
		std::uint32_t       moppDataSize;  // 38
		std::uint32_t       pad3C;         // 3C
		hkVector4           codeInfoCopy;  // 40
	};
	static_assert(sizeof(hkMoppBvTreeShapeBase) == 0x50);
}


===============================================
File: include/RE/H/hkMotionState.h
===============================================
#pragma once

#include "RE/H/hkBaseTypes.h"
#include "RE/H/hkSweptTransform.h"
#include "RE/H/hkTransform.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkMotionState
	{
	public:
		// members
		hkTransform      transform;           // 00
		hkSweptTransform sweptTransform;      // 40
		hkVector4        deltaAngle;          // 90
		float            objectRadius;        // A0
		hkHalf           linearDamping;       // A4
		hkHalf           angularDamping;      // A6
		hkHalf           timeFactor;          // A8
		hkUFloat8        maxLinearVelocity;   // AA
		hkUFloat8        maxAngularVelocity;  // AB
		std::uint8_t     deactivationClass;   // AC
		std::uint8_t     padAD;               // AD
		std::uint16_t    padAE;               // AE
	};
	static_assert(sizeof(hkMotionState) == 0xB0);
}


===============================================
File: include/RE/H/hkMultiThreadCheck.h
===============================================
#pragma once

namespace RE
{
	class hkMultiThreadCheck
	{
	public:
		enum class AccessType
		{
			kIgnore = 0,
			kReadOnly = 1,
			kReadWrite = 2
		};

		enum class ReadMode
		{
			kThisObjOnly,
			kRecursive
		};

		enum class MarkedState : std::uint32_t
		{
			kReadOnly = 0xFFFFFFE1,
			kReadOnly_SelfOnly = 0xFFFFFFC1,
			kUnMarked = 0xFFFFFFF1
		};

		std::uint32_t threadId;      // 0
		std::int32_t  stackTraceId;  // 4
		std::uint16_t markCount;     // 8
		std::uint16_t markBitStack;  // A
	};
	static_assert(sizeof(hkMultiThreadCheck) == 0xC);
}


===============================================
File: include/RE/H/hkQsTransform.h
===============================================
#pragma once

#include "RE/H/hkQuaternion.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkQsTransform
	{
	public:
		// members
		hkVector4    translation;  // 00
		hkQuaternion rotation;     // 10
		hkVector4    scale;        // 20
	};
	static_assert(sizeof(hkQsTransform) == 0x30);
}


===============================================
File: include/RE/H/hkQuaternion.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	class hkQuaternion
	{
	public:
		hkVector4 vec;  // 00
	};
	static_assert(sizeof(hkQuaternion) == 0x10);
}


===============================================
File: include/RE/H/hkRefPtr.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class hkRefPtr
	{
	public:
		using element_type = T;

		// 1
		inline constexpr hkRefPtr() noexcept :
			_ptr(nullptr)
		{}

		// 2
		inline constexpr hkRefPtr(std::nullptr_t) noexcept :
			_ptr(nullptr)
		{}

		// 3
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline explicit hkRefPtr(Y* a_rhs) :
			_ptr(a_rhs)
		{
			TryAttach();
		}

		// 9a
		inline hkRefPtr(const hkRefPtr& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 9b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline hkRefPtr(const hkRefPtr<Y>& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 10a
		inline hkRefPtr(hkRefPtr&& a_rhs) noexcept :
			_ptr(std::move(a_rhs._ptr))
		{
			a_rhs._ptr = nullptr;
		}

		// 10b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline hkRefPtr(hkRefPtr<Y>&& a_rhs) noexcept :
			_ptr(std::move(a_rhs._ptr))
		{
			a_rhs._ptr = nullptr;
		}

		inline ~hkRefPtr()
		{
			TryDetach();
		}

		// 1a
		inline hkRefPtr& operator=(const hkRefPtr& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = a_rhs._ptr;
				TryAttach();
			}
			return *this;
		}

		// 1b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline hkRefPtr& operator=(const hkRefPtr<Y>& a_rhs)
		{
			TryDetach();
			_ptr = a_rhs._ptr;
			TryAttach();
			return *this;
		}

		// 2a
		inline hkRefPtr& operator=(hkRefPtr&& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = std::move(a_rhs._ptr);
				a_rhs._ptr = nullptr;
			}
			return *this;
		}

		// 2b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline hkRefPtr& operator=(hkRefPtr<Y>&& a_rhs)
		{
			TryDetach();
			_ptr = std::move(a_rhs._ptr);
			a_rhs._ptr = nullptr;
			return *this;
		}

		inline void reset()
		{
			TryDetach();
		}

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline void reset(Y* a_ptr)
		{
			if (_ptr != a_ptr) {
				TryDetach();
				_ptr = a_ptr;
				TryAttach();
			}
		}

		[[nodiscard]] constexpr element_type* get() const noexcept
		{
			return _ptr;
		}

		[[nodiscard]] explicit constexpr operator bool() const noexcept
		{
			return static_cast<bool>(_ptr);
		}

		[[nodiscard]] constexpr element_type& operator*() const noexcept
		{
			assert(static_cast<bool>(*this));
			return *_ptr;
		}

		[[nodiscard]] constexpr element_type* operator->() const noexcept
		{
			assert(static_cast<bool>(*this));
			return _ptr;
		}

	protected:
		template <class>
		friend class hkRefPtr;

		void TryAttach()
		{
			if (_ptr) {
				_ptr->AddReference();
			}
		}

		void TryDetach()
		{
			if (_ptr) {
				_ptr->RemoveReference();
				_ptr = nullptr;
			}
		}

		// members
		element_type* _ptr;  // 0
	};
	static_assert(sizeof(hkRefPtr<void*>) == 0x8);

	template <class T, class... Args>
	[[nodiscard]] inline hkRefPtr<T> make_hkref(Args&&... a_args)
	{
		return hkRefPtr<T>{ new T(std::forward<Args>(a_args)...) };
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator==(const hkRefPtr<T1>& a_lhs, const hkRefPtr<T2>& a_rhs)
	{
		return a_lhs.get() == a_rhs.get();
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator!=(const hkRefPtr<T1>& a_lhs, const hkRefPtr<T2>& a_rhs)
	{
		return !(a_lhs == a_rhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(const hkRefPtr<T>& a_lhs, std::nullptr_t) noexcept
	{
		return !a_lhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(std::nullptr_t, const hkRefPtr<T>& a_rhs) noexcept
	{
		return !a_rhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(const hkRefPtr<T>& a_lhs, std::nullptr_t) noexcept
	{
		return static_cast<bool>(a_lhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(std::nullptr_t, const hkRefPtr<T>& a_rhs) noexcept
	{
		return static_cast<bool>(a_rhs);
	}

	template <class T>
	hkRefPtr(T*) -> hkRefPtr<T>;
}


===============================================
File: include/RE/H/hkRefVariant.h
===============================================
#pragma once

#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkRefVariant : public hkRefPtr<hkReferencedObject>
	{
	public:
	};
	static_assert(sizeof(hkRefVariant) == 0x8);
}


===============================================
File: include/RE/H/hkReferencedObject.h
===============================================
#pragma once

#include "RE/H/hkBaseObject.h"

namespace RE
{
	class hkClass;
	class hkStatisticsCollector;

	class hkReferencedObject : public hkBaseObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkReferencedObject;
		inline static constexpr auto VTABLE = VTABLE_hkReferencedObject;

		enum class LockMode
		{
			kNone = 0,
			kAuto,
			kManual
		};

		enum
		{
			kMemSize = 0x7FFF
		};

		hkReferencedObject();
		~hkReferencedObject() override = default;  // 00

		// add
		virtual const hkClass* GetClassType() const;                                                                     // 01 - { return 0; }
		virtual void           CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const;  // 02

		void         AddReference() const;
		std::int32_t GetAllocatedSize() const;
		std::int32_t GetReferenceCount() const;
		void         RemoveReference() const;

		// members
		std::uint16_t                 memSizeAndFlags;  // 08
		volatile mutable std::int16_t referenceCount;   // 0A
		std::uint32_t                 pad0C;            // 0C
	};
	static_assert(sizeof(hkReferencedObject) == 0x10);
}


===============================================
File: include/RE/H/hkRotation.h
===============================================
#pragma once

#include "RE/H/hkMatrix3.h"

namespace RE
{
	class alignas(0x10) hkRotation : public hkMatrix3
	{
	public:
	};
	static_assert(sizeof(hkRotation) == 0x30);
}


===============================================
File: include/RE/H/hkSmallArray.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class hkSmallArray
	{
		enum class CapacityAndFlags
		{
			kCapacityMask = 0x3FFF,
			kFlagMask = 0xC000,
			kNoDealloc = 0x8000,
			kLocked = 0x4000,
			kForceSigned = static_cast<std::underlying_type_t<CapacityAndFlags>>(-1)
		};

		T*                                                data;              // 00
		std::uint16_t                                     size;              // 08
		stl::enumeration<CapacityAndFlags, std::uint16_t> capacityAndFlags;  // 0A
		std::uint32_t                                     pad0C;             // 0C
	};
	static_assert(sizeof(hkSmallArray<void*>) == 0x10);
}


===============================================
File: include/RE/H/hkSseMathTypes.h
===============================================
#pragma once

#include <xmmintrin.h>

namespace RE
{
	using hkQuadReal = __m128;
	static_assert(sizeof(hkQuadReal) == 0x10);

	class hkVector4Comparison
	{
	public:
		enum class Mask
		{
			kNone = 0,

			kX = 1,
			kY = 2,
			kXY = 3,

			kZ = 4,
			kXZ = 5,
			kYZ = 6,
			kXYZ = 7,

			kW = 8,
			kXW = 9,
			kYW = 10,
			kXYW = 11,

			kZW = 12,
			kXZW = 13,
			kYZW = 14,
			kXYZW = 15
		};

		// members
		hkQuadReal mask;  // 00
	};
	static_assert(sizeof(hkVector4Comparison) == 0x10);
}


===============================================
File: include/RE/H/hkStepInfo.h
===============================================
#pragma once

#include "RE/H/hkBaseTypes.h"

namespace RE
{
	class hkStepInfo
	{
	public:
		alignas(0x10) hkTime startTime;  // 00
		hkTime endTime;                  // 04
		float  deltaTime;                // 08
		float  invDeltaTime;             // 0C
	};
	static_assert(sizeof(hkStepInfo) == 0x10);
}


===============================================
File: include/RE/H/hkStringPtr.h
===============================================
#pragma once

namespace RE
{
	class hkStringPtr
	{
	public:
		// member types
		using size_type = std::int32_t;

		// members access
		[[nodiscard]] const char* data() const noexcept;
		[[nodiscard]] const char* c_str() const noexcept;

		// capacity
		[[nodiscard]] bool      empty() const noexcept;
		[[nodiscard]] size_type size() const;
		[[nodiscard]] size_type length() const;

	protected:
		enum
		{
			kManaged = 1 << 0
		};

		const char* _data;  // 0
	};
	static_assert(sizeof(hkStringPtr) == 0x8);
}


===============================================
File: include/RE/H/hkSweptTransform.h
===============================================
#pragma once

#include "RE/H/hkQuaternion.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkSweptTransform
	{
	public:
		hkVector4    centerOfMass0;      // 00
		hkVector4    centerOfMass1;      // 10
		hkQuaternion rotation0;          // 20
		hkQuaternion rotation1;          // 30
		hkVector4    centerOfMassLocal;  // 40
	};
	static_assert(sizeof(hkSweptTransform) == 0x50);
}


===============================================
File: include/RE/H/hkTransform.h
===============================================
#pragma once

#include "RE/H/hkRotation.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkTransform
	{
	public:
		hkRotation rotation;     // 00
		hkVector4  translation;  // 30
	};
	static_assert(sizeof(hkTransform) == 0x40);
}


===============================================
File: include/RE/H/hkVector4.h
===============================================
#pragma once

#include "RE/H/hkSseMathTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class hkVector4
	{
	public:
		hkVector4() :
			quad(_mm_set1_ps(0.0f))
		{}

		hkVector4(const float& a_x) :
			quad(_mm_set1_ps(a_x))
		{}

		hkVector4(const float& a_x, const float& a_y, const float& a_z, const float& a_w) :
			quad(_mm_setr_ps(a_x, a_y, a_z, a_w))
		{}

		hkVector4(const hkVector4& a_rhs) :
			quad(a_rhs.quad)
		{}

		hkVector4(const hkQuadReal& a_rhs) :
			quad(a_rhs)
		{}

		hkVector4(const NiPoint3& a_point) :
			quad(_mm_setr_ps(a_point.x, a_point.y, a_point.z, 0.0f))
		{}

		hkVector4& operator=(const hkVector4& a_rhs);
		hkVector4  operator+(const hkVector4& a_rhs) const;
		hkVector4  operator-(const hkVector4& a_rhs) const;
		hkVector4  operator*(const hkVector4& a_rhs) const;
		hkVector4  operator/(const hkVector4& a_rhs) const;

		[[nodiscard]] bool      IsEqual(const hkVector4& a_pt, float a_epsilon = 1e-3f) const;
		[[nodiscard]] hkVector4 Cross(const hkVector4& a_pt) const;
		[[nodiscard]] float     Dot3(const hkVector4& a_pt) const;
		[[nodiscard]] float     Dot4(const hkVector4& a_pt) const;
		[[nodiscard]] float     GetDistance3(const hkVector4& a_pt) const noexcept;
		[[nodiscard]] float     GetSquaredDistance3(const hkVector4& a_pt) const noexcept;
		[[nodiscard]] float     Length3() const;
		[[nodiscard]] float     SqrLength3() const;
		[[nodiscard]] float     Length4() const;
		[[nodiscard]] float     SqrLength4() const;

		// members
		hkQuadReal quad{};  // 00
	};
	static_assert(sizeof(hkVector4) == 0x10);
}


===============================================
File: include/RE/H/hkaAnimatedReferenceFrame.h
===============================================
#pragma once

#include "RE/H/hkQsTransform.h"
#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkaAnimatedReferenceFrame : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkaAnimatedReferenceFrame;
		inline static constexpr auto VTABLE = VTABLE_hkaAnimatedReferenceFrame;

		// add
		virtual void  GetReferenceFrame(float a_time, hkQsTransform& a_motionOut) const = 0;                                                                                           // 03
		virtual void  GetDeltaReferenceFrame(float a_time, float a_nextTime, int a_loops, hkQsTransform& a_deltaMotionOut, float a_cropStartAmount, float a_cropEndAmount) const = 0;  // 04
		virtual float GetDuration() const = 0;                                                                                                                                         // 05
	};
	static_assert(sizeof(hkaAnimatedReferenceFrame) == 0x10);
}


===============================================
File: include/RE/H/hkaAnimation.h
===============================================
#pragma once

#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkaAnimatedReferenceFrame.h"
#include "RE/H/hkaAnnotationTrack.h"

namespace RE
{
	class hkaChunkCache;

	class hkaAnimation : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkaAnimation;
		inline static constexpr auto VTABLE = VTABLE_hkaAnimation;

		enum class AnimationType
		{
			kUnknownAnimation = 0,
			kInterleavedAnimation,
			kDeltaCompressedAnimation,
			kWaveletCompressedAnimation,
			kMirroredAnimation,
			kSplineCompressedAnimation,
			kQuantizedCompressedAnimation,
		};

		struct DataChunk
		{
			const void*   data;    // 00
			std::uint32_t size;    // 08
			std::uint8_t  offset;  // 0C
		};

		struct TrackAnnotation
		{
			// The bone ID which is annotated
			std::uint16_t                  trackID;
			hkaAnnotationTrack::Annotation annotation;
		};

		// add
		virtual void          SampleTracks(float a_time, hkQsTransform* a_transformTracksOut, float* a_floatTracksOut, hkaChunkCache* cache) const = 0;                                                                                 // 03
		virtual void          SamplePartialTracks(float a_time, std::uint32_t a_maxNumTransformTracks, hkQsTransform* a_transformTracksOut, std::uint32_t a_maxNumFloatTracks, float* a_floatTracksOut, hkaChunkCache* a_cache) const;  // 04
		virtual void          ClearAllCacheKeys(hkaChunkCache* a_cache) const;                                                                                                                                                          // 05
		virtual void          SampleIndividualTransformTracks(float a_time, const std::uint16_t* a_tracks, std::uint32_t a_numTracks, hkQsTransform* a_transformOut) const = 0;                                                         // 06
		virtual void          SampleIndividualFloatTracks(float a_time, const std::uint16_t* a_tracks, std::uint32_t a_numTracks, float* a_out) const = 0;                                                                              // 07
		virtual std::int32_t  GetNumOriginalFrames() const = 0;                                                                                                                                                                         // 08
		virtual std::int32_t  GetNumDataChunks(std::uint32_t a_frame, float a_delta) const;                                                                                                                                             // 09
		virtual void          GetDataChunks(std::uint32_t a_frame, float a_delta, DataChunk* a_dataChunks, std::int32_t a_numDataChunks) const;                                                                                         // 0A
		virtual std::int32_t  GetMaxSizeOfCombinedDataChunks() const;                                                                                                                                                                   // 0B
		virtual void          GetExtractedMotionReferenceFrame(float a_time, hkQsTransform& a_motionOut) const;                                                                                                                         // 0C
		virtual void          GetExtractedMotionDeltaReferenceFrame(float a_time, float a_nextTime, std::int32_t a_loops, hkQsTransform& a_deltaMotionOut, float a_cropStartAmount, float a_cropEndAmount) const;                       // 0D
		virtual std::uint32_t GetNumAnnotations(float a_startTime, float a_deltaTime) const;                                                                                                                                            // 0E
		virtual std::uint32_t GetAnnotations(float a_startTime, float a_deltaTime, TrackAnnotation* a_annotationsOut, std::uint32_t a_maxAnnotations) const;                                                                            // 0F

		// members
		stl::enumeration<AnimationType, std::uint32_t> type;                     // 10
		float                                          duration;                 // 14
		std::int32_t                                   numberOfTransformTracks;  // 18
		std::int32_t                                   numberOfFloatTracks;      // 1C
		hkRefPtr<hkaAnimatedReferenceFrame>            extractedMotion;          // 20
		hkArray<hkaAnnotationTrack>                    annotationTracks;         // 28
	};
	static_assert(sizeof(hkaAnimation) == 0x38);
}


===============================================
File: include/RE/H/hkaAnimationBinding.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkStringPtr.h"
#include "RE/H/hkaAnimation.h"

namespace RE
{
	class hkaAnimationBinding : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkaAnimationBinding;
		inline static constexpr auto VTABLE = VTABLE_hkaAnimationBinding;

		enum class BlendHint
		{
			kNormal = 0,
			kAdditive
		};

		// members
		hkStringPtr                               originalSkeletonName;          // 10
		hkRefPtr<hkaAnimation>                    animation;                     // 18
		hkArray<std::int16_t>                     transformTrackToBoneIndices;   // 20
		hkArray<std::int16_t>                     floatTrackToFloatSlotIndices;  // 30
		stl::enumeration<BlendHint, std::uint8_t> blendHint;                     // 40
		char                                      pad41[7];                      // 41
	};
	static_assert(sizeof(hkaAnimationBinding) == 0x48);
}


===============================================
File: include/RE/H/hkaAnimationControl.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkaAnimationBinding.h"

namespace RE
{
	class hkaAnimationControlListener;
	class hkaChunkCache;

	class hkaAnimationControl : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkaAnimationControl;
		inline static constexpr auto VTABLE = VTABLE_hkaAnimationControl;

		~hkaAnimationControl() override;  // 00

		// add
		virtual void                Update(float a_stepDelta) = 0;                                                                                                                                                              // 03
		virtual void                GetFutureTime(float a_stepDelta, float& a_localTimeOut, std::int32_t& a_loopsOut) const = 0;                                                                                                // 04
		virtual void                SampleTracks(hkQsTransform* a_transformTracksOut, float* a_floatTracksOut, hkaChunkCache* a_cache) const;                                                                                   // 05
		virtual void                SamplePartialTracks(std::uint32_t a_maxNumTransformTracks, hkQsTransform* a_transformTracksOut, std::uint32_t a_maxNumFloatTracks, float* a_floatTracksOut, hkaChunkCache* a_cache) const;  // 06
		virtual void                GetExtractedMotionDeltaReferenceFrame(float a_deltaTime, hkQsTransform& a_deltaMotionOut) const;                                                                                            // 07
		virtual std::int32_t        GetNumberOfTransformTracks() const;                                                                                                                                                         // 08
		virtual std::int32_t        GetNumberOfFloatTracks() const;                                                                                                                                                             // 09
		virtual std::int32_t        GetNumTransformTrackToBoneIndices() const;                                                                                                                                                  // 0A
		virtual const std::int16_t* GetTransformTrackToBoneIndices() const;                                                                                                                                                     // 0B
		virtual std::int32_t        GetNumFloatTrackToFloatSlotIndices() const;                                                                                                                                                 // 0C
		virtual const std::int16_t* GetFloatTrackToFloatSlotIndices() const;                                                                                                                                                    // 0D

		// members
		float                                localTime;              // 10
		float                                weight;                 // 14
		hkArray<std::uint8_t>                transformTrackWeights;  // 18
		hkArray<std::uint8_t>                floatTrackWeights;      // 28
		hkaAnimationBinding*                 binding;                // 38
		hkArray<hkaAnimationControlListener> listeners;              // 40
		float                                motionTrackWeight;      // 50
		std::uint32_t                        pad54;                  // 54
	};
	static_assert(sizeof(hkaAnimationControl) == 0x58);
}


===============================================
File: include/RE/H/hkaAnnotationTrack.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkStringPtr.h"

namespace RE
{
	class hkaAnnotationTrack
	{
	public:
		struct Annotation
		{
			float         time;   // 00
			std::uint32_t pad04;  // 04
			hkStringPtr   text;   // 08
		};

		hkStringPtr         trackName;    // 00
		hkArray<Annotation> annotations;  // 08
	};
	static_assert(sizeof(hkaAnnotationTrack) == 0x18);
}


===============================================
File: include/RE/H/hkaDefaultAnimationControl.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"
#include "RE/H/hkaAnimationControl.h"

namespace RE
{
	class hkaDefaultAnimationControlMapperData;
	class hkaDefaultAnimationControlListener;

	class hkaDefaultAnimationControl : public hkaAnimationControl
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkaDefaultAnimationControl;
		inline static constexpr auto VTABLE = VTABLE_hkaDefaultAnimationControl;

		enum class EaseStatus
		{
			kEasingIn = 0,
			kEasedIn,
			kEasingOut,
			kEasedOut
		};

		~hkaDefaultAnimationControl() override;  // 00

		// override (hkaAnimationControl)
		void                Update(float a_stepDelta) override;                                                                                                                                                                  // 03
		void                GetFutureTime(float a_stepDelta, float& a_localTimeOut, std::int32_t& a_loopsOut) const override;                                                                                                    // 04
		void                SampleTracks(hkQsTransform* a_transformTracksOut, float* a_floatTracksOut, hkaChunkCache* a_cache) const override;                                                                                   // 05
		void                SamplePartialTracks(std::uint32_t a_maxNumTransformTracks, hkQsTransform* a_transformTracksOut, std::uint32_t a_maxNumFloatTracks, float* a_floatTracksOut, hkaChunkCache* a_cache) const override;  // 06
		void                GetExtractedMotionDeltaReferenceFrame(float a_deltaTime, hkQsTransform& a_deltaMotionOut) const override;                                                                                            // 07
		std::int32_t        GetNumberOfTransformTracks() const override;                                                                                                                                                         // 08
		std::int32_t        GetNumberOfFloatTracks() const override;                                                                                                                                                             // 09
		std::int32_t        GetNumTransformTrackToBoneIndices() const override;                                                                                                                                                  // 0A
		const std::int16_t* GetTransformTrackToBoneIndices() const override;                                                                                                                                                     // 0B

		// members
		float                                       masterWeight;              // 58
		float                                       playbackSpeed;             // 5C
		std::uint32_t                               overflowCount;             // 60
		std::uint32_t                               underflowCount;            // 64
		std::int32_t                                maxCycles;                 // 68
		std::uint32_t                               pad6C;                     // 6C
		hkVector4                                   easeInCurve;               // 70
		hkVector4                                   easeOutCurve;              // 80
		float                                       easeInvDuration;           // 90
		float                                       easeT;                     // 94
		EaseStatus                                  easeStatus;                // 98
		float                                       cropStartAmountLocalTime;  // 9C
		float                                       cropEndAmountLocalTime;    // A0
		std::uint32_t                               padA4;                     // A4
		hkArray<hkaDefaultAnimationControlListener> defaultListeners;          // A8
		hkaDefaultAnimationControlMapperData*       mapper;                    // B8
	};
}


===============================================
File: include/RE/H/hkaRagdollInstance.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkaSkeleton;
	class hkpConstraintInstance;

	class hkaRagdollInstance : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkaRagdollInstance;
		inline static constexpr auto VTABLE = VTABLE_hkaRagdollInstance;

		~hkaRagdollInstance() override;  // 00

		// members
		hkArray<hkpRigidBody*>          rigidBodies;         // 10
		hkArray<hkpConstraintInstance*> constraints;         // 20
		hkArray<int>                    boneToRigidBodyMap;  // 30
		hkRefPtr<const hkaSkeleton>     skeleton;            // 40
	};
	static_assert(sizeof(hkaRagdollInstance) == 0x48);
}


===============================================
File: include/RE/H/hkbAnimationBindingSet.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkReferencedObject.h"

namespace RE
{
	template <class T>
	class hkRefPtr;

	class hkbAnimationBindingWithTriggers;
	class hkbAssetBundle;

	class hkbAnimationBindingSet : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbAnimationBindingSet;
		inline static constexpr auto VTABLE = VTABLE_hkbAnimationBindingSet;

		// members
		hkArray<hkbAnimationBindingWithTriggers*> bindings;      // 10
		hkArray<hkRefPtr<hkbAssetBundle>>         assetBundles;  // 20
	};
	static_assert(sizeof(hkbAnimationBindingSet) == 0x30);
}


===============================================
File: include/RE/H/hkbAssetBundleStringData.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkStringPtr.h"

namespace RE
{
	struct hkbAssetBundleStringData
	{
		// members
		hkStringPtr          bundleName;  // 00
		hkArray<hkStringPtr> assetNames;  // 08 - skyrim doesn't use these
	};
}


===============================================
File: include/RE/H/hkbBehaviorGraph.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkRefVariant.h"
#include "RE/H/hkbGenerator.h"

namespace RE
{
	class hkbBehaviorGraphData;

	class hkbBehaviorGraph : public hkbGenerator
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbBehaviorGraph;
		inline static constexpr auto VTABLE = VTABLE_hkbBehaviorGraph;

		enum class VariableMode
		{
			kDiscardWhenActive = 0,
			kMaintainValuesWhenInactive = 1,
		};

		~hkbBehaviorGraph() override;  // 00

		// override (hkbGenerator)
		hkClass* GetClassType() const override;                                                                     // 01
		void     CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02
		void     Activate(const hkbContext& a_context) override;                                                    // 04
		void     Update(const hkbContext& a_context, float a_timestep) override;                                    // 05
		void     Unk_06(void) override;                                                                             // 06
		void     Deactivate(const hkbContext& a_context) override;                                                  // 07
		void     Unk_09(void) override;                                                                             // 09
		void     Unk_0C(void) override;                                                                             // 0C
		void     Unk_16(void) override;                                                                             // 16 - { return 1; }
		void     Generate(const hkbContext& a_context) override;                                                    // 17
		void     Unk_18(void) override;                                                                             // 18 - { return 1; }
		void     UpdateSync(const hkbContext& a_context) override;                                                  // 19

		// members
		stl::enumeration<VariableMode, std::uint8_t> variableMode;                     // 048
		std::uint8_t                                 pad49;                            // 049
		std::uint16_t                                pad4A;                            // 04A
		std::uint32_t                                pad4C;                            // 04C
		hkArray<hkRefVariant>                        uniqueIDPool;                     // 050
		hkRefVariant                                 idToStateMachineTemplateMap;      // 060
		hkArray<hkRefVariant>                        mirroredExternalIDMap;            // 068
		hkRefVariant                                 pseudoRandomGenerator;            // 078
		hkRefPtr<hkbGenerator>                       rootGenerator;                    // 080
		hkRefPtr<hkbBehaviorGraphData>               data;                             // 088
		hkRefVariant                                 rootGeneratorClone;               // 090
		hkRefVariant                                 activeNodes;                      // 098
		hkRefVariant                                 activeNodeTemplateToIndexMap;     // 0A0
		hkRefVariant                                 activeNodesChildrenIndices;       // 0A8
		hkRefVariant                                 globalTransitionData;             // 0B0
		hkRefVariant                                 eventIDMap;                       // 0B8
		hkRefVariant                                 attributeIDMap;                   // 0C0
		hkRefVariant                                 variableIDMap;                    // 0C8
		hkRefVariant                                 characterPropertyIDMap;           // 0D0
		hkRefVariant                                 variableValueSet;                 // 0D8
		hkRefVariant                                 nodeTemplateToCloneMap;           // 0E0
		hkRefVariant                                 nodeCloneToTemplateMap;           // 0E8
		hkRefVariant                                 stateListenerTemplateToCloneMap;  // 0F0
		hkRefVariant                                 nodePartitionInfo;                // 0F8
		std::int32_t                                 numIntermediateOutputs;           // 100
		std::uint32_t                                pad104;                           // 104
		hkArray<hkRefVariant>                        jobs;                             // 108
		hkArray<hkRefVariant>                        allPartitionMemory;               // 118
		std::int16_t                                 numStaticNodes;                   // 128
		std::int16_t                                 nextUniqueID;                     // 12A
		bool                                         isActive;                         // 12C
		bool                                         isLinked;                         // 12D
		bool                                         updateActiveNodes;                // 12E
		bool                                         stateOrTransitionChanged;         // 12F
	};
	static_assert(sizeof(hkbBehaviorGraph) == 0x130);
}


===============================================
File: include/RE/H/hkbBehaviorGraphData.h
===============================================
#pragma once

#include "RE/H/hkbBehaviorGraphStringData.h"

namespace RE
{
	class hkbVariableInfo;
	class hkbEventInfo;
	class hkbVariableBounds;
	class hkbVariableValueSet;

	class hkbBehaviorGraphData : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbBehaviorGraphData;
		inline static constexpr auto VTABLE = VTABLE_hkbBehaviorGraphData;

		virtual ~hkbBehaviorGraphData() = default;  // 00

		// members
		hkArray<float>                       attributeDefaults;       // 10
		hkArray<hkbVariableInfo>             variableInfos;           // 20
		hkArray<hkbVariableInfo>             characterPropertyInfos;  // 30
		hkArray<hkbVariableInfo>             eventInfos;              // 40
		hkArray<hkbVariableBounds>           variableBounds;          // 50
		uint64_t                             unk60;                   // 60
		uint64_t                             unk68;                   // 68
		hkbVariableValueSet*                 variableInitialValues;   // 70
		hkRefPtr<hkbBehaviorGraphStringData> stringData;              // 78
	};
	static_assert(sizeof(hkbBehaviorGraphData) == 0x80);
}


===============================================
File: include/RE/H/hkbBehaviorGraphStringData.h
===============================================
#pragma once

namespace RE
{
	class hkbBehaviorGraphStringData : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbBehaviorGraphStringData;
		inline static constexpr auto VTABLE = VTABLE_hkbBehaviorGraphStringData;

		virtual ~hkbBehaviorGraphStringData() = default;  // 00

		// members
		hkArray<hkStringPtr> eventNames;              // 10
		hkArray<hkStringPtr> attributeNames;          // 20
		hkArray<hkStringPtr> variableNames;           // 30
		hkArray<hkStringPtr> characterPropertyNames;  // 40
	};
	static_assert(sizeof(hkbBehaviorGraphStringData) == 0x50);
}


===============================================
File: include/RE/H/hkbBindable.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkRefVariant;
	class hkbVariableBindingSet;

	class hkbBindable : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbBindable;
		inline static constexpr auto VTABLE = VTABLE_hkbBindable;

		~hkbBindable() override;  // 00

		// add
		virtual void Unk_03(void);  // 03

		// members
		hkRefPtr<hkbVariableBindingSet> variableBindingSet;  // 10
		hkArray<hkRefVariant>           cachedBindables;     // 18
		bool                            areBindablesCached;  // 28
		std::uint8_t                    pad29;               // 29
		std::uint16_t                   pad2A;               // 2A
		std::uint32_t                   pad2C;               // 2C
	};
	static_assert(sizeof(hkbBindable) == 0x30);
}


===============================================
File: include/RE/H/hkbCharacter.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkRefVariant.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkStringPtr.h"

namespace RE
{
	class hkbBehaviorGraph;
	class hkbCharacterSetup;
	class hkbProjectData;
	class hkbRagdollDriver;

	class hkbCharacter : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbCharacter;
		inline static constexpr auto VTABLE = VTABLE_hkbCharacter;

		~hkbCharacter() override;  // 00

		// add
		virtual void Unk_03(void);  // 03
		virtual void Unk_04(void);  // 04

		// members
		hkArray<hkbCharacter*>      nearbyCharacters;           // 10
		std::int16_t                currentLOD;                 // 20
		std::int16_t                numTracksInLOD;             // 22
		std::uint32_t               pad24;                      // 24
		hkStringPtr                 name;                       // 28
		hkRefPtr<hkbRagdollDriver>  ragdollDriver;              // 30
		hkRefVariant                characterControllerDriver;  // 38
		hkRefVariant                footIkDriver;               // 40
		hkRefVariant                handIkDriver;               // 48
		hkRefPtr<hkbCharacterSetup> setup;                      // 50
		hkRefPtr<hkbBehaviorGraph>  behaviorGraph;              // 58
		hkRefPtr<hkbProjectData>    projectData;                // 60
		hkRefVariant                animationBindingSet;        // 68
		hkRefVariant                raycastInterface;           // 70
		hkRefVariant                world;                      // 78
		hkRefVariant                eventQueue;                 // 80
		hkRefVariant                worldFromModel;             // 88
		const void**                poseLocal;                  // 90 - hkSimpleArray<hkRefVariant>
		std::int32_t                numPoseLocal;               // 98
		bool                        deleteWorldFromModel;       // 9C
		bool                        deletePoseLocal;            // 9D
		std::uint16_t               pad9E;                      // 9E
	};
	static_assert(sizeof(hkbCharacter) == 0xA0);
}


===============================================
File: include/RE/H/hkbCharacterControllerSetup.h
===============================================
#pragma once

#include "RE/H/hkbRigidBodySetup.h"

namespace RE
{
	class hkReferencedObject;

	struct hkbCharacterControllerSetup
	{
		// members
		hkbRigidBodySetup   rigidBodySetup;   // 00
		hkReferencedObject* controllerCInfo;  // 20
	};
	static_assert(sizeof(hkbCharacterControllerSetup) == 0x28);
}


===============================================
File: include/RE/H/hkbCharacterData.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkbCharacterControllerSetup.h"

namespace RE
{
	class hkbCharacterStringData;
	class hkbFootIkDriverInfo;
	class hkbHandIkDriverInfo;
	class hkbVariableInfo;
	class hkbVariableValueSet;

	class hkbCharacterData : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbCharacterData;
		inline static constexpr auto VTABLE = VTABLE_hkbCharacterData;

		// members
		std::uint8_t                     characterControllerSetup[24];  // 10 (hkbCharacterControllerSetup)
		float                            modelUpMS[4];                  // 28 (hkVector4)
		float                            modelForwardMS[4];             // 38 (hkVector4)
		float                            modelRightMS[4];               // 48 (hkVector4)
		hkArray<hkbVariableInfo>         characterPropertyInfos;        // 58
		hkArray<std::int32_t>            numBonesPerLod;                // 68
		hkRefPtr<hkbVariableValueSet>    characterPropertyValues;       // 78
		hkRefPtr<hkbFootIkDriverInfo>    footIkDriverInfo;              // 80
		hkRefPtr<hkbHandIkDriverInfo>    handIkDriverInfo;              // 88
		hkRefPtr<hkReferencedObject>     aiControlDriverInfo;           // 90
		hkRefPtr<hkbCharacterStringData> stringData;                    // 98
	};
	static_assert(sizeof(hkbCharacterData) == 0xA0);  // B0?
}


===============================================
File: include/RE/H/hkbCharacterSetup.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkaMirroredSkeleton;
	class hkaSkeleton;
	class hkaSkeletonMapper;
	class hkbAnimationBindingSet;
	class hkbCharacterData;
	class hkbSymbolIdMap;
	class hkCriticalSection;

	class hkbCharacterSetup : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbCharacterSetup;
		inline static constexpr auto VTABLE = VTABLE_hkbCharacterSetup;

		// members
		hkArray<hkRefPtr<const hkaSkeletonMapper>> retargetingSkeletonMappers;        // 10
		hkRefPtr<const hkaSkeleton>                animationSkeleton;                 // 20
		hkRefPtr<const hkaSkeletonMapper>          ragdollToAnimationSkeletonMapper;  // 28
		hkRefPtr<const hkaSkeletonMapper>          animationToRagdollSkeletonMapper;  // 30
		hkRefPtr<hkbAnimationBindingSet>           animationBindingSet;               // 38
		hkRefPtr<hkbCharacterData>                 data;                              // 40
		hkRefPtr<const hkaSkeleton>                unscaledAnimationSkeleton;         // 48
		mutable hkRefPtr<hkaMirroredSkeleton>      mirroredSkeleton;                  // 50
		hkRefPtr<hkbSymbolIdMap>                   characterPropertyIdMap;            // 58
		mutable hkCriticalSection*                 criticalSection;                   // 60
	};
	static_assert(sizeof(hkbCharacterSetup) == 0x68);
}


===============================================
File: include/RE/H/hkbCharacterStringData.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkStringPtr.h"

namespace RE
{
	struct hkbAssetBundleStringData;

	class hkbCharacterStringData : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbCharacterStringData;
		inline static constexpr auto VTABLE = VTABLE_hkbCharacterStringData;

		struct FileNameMeshNamePair
		{
			hkStringPtr fileName;
			hkStringPtr meshName;
		};

		// members
		hkArray<FileNameMeshNamePair>     deformableSkinNames;                 // 10
		hkArray<FileNameMeshNamePair>     rigidSkinNames;                      // 20
		hkArray<hkbAssetBundleStringData> animationNames;                      // 30
		hkArray<hkbAssetBundleStringData> animationBundleFilenameData;         // 40 - unused by Skyrim?
		hkArray<hkStringPtr>              characterPropertyNames;              // 50
		hkArray<hkStringPtr>              retargetingSkeletonMapperFilenames;  // 60
		hkArray<hkStringPtr>              lodNames;                            // 70
		hkArray<hkStringPtr>              mirroredSyncPointSubstringsA;        // 80
		hkArray<hkStringPtr>              mirroredSyncPointSubstringsB;        // 90
		hkStringPtr                       name;                                // A0
		hkStringPtr                       rigName;                             // A8
		hkStringPtr                       ragdollName;                         // B0
		hkStringPtr                       behaviorFilename;                    // B8
	};
	static_assert(sizeof(hkbCharacterStringData) == 0xC0);
}


===============================================
File: include/RE/H/hkbClipGenerator.h
===============================================
#pragma once

#include "RE/H/hkQsTransform.h"
#include "RE/H/hkaDefaultAnimationControl.h"
#include "RE/H/hkbContext.h"
#include "RE/H/hkbEventBase.h"
#include "RE/H/hkbGenerator.h"

namespace RE
{
	class hkbEventProperty : public hkbEventBase
	{
	};

	class hkClipTrigger
	{
	public:
		float            localTime;
		hkbEventProperty event;
		bool             relativeToEndOfClip;
		bool             acyclic;
		bool             isAnnotation;
	};

	class hkbClipTriggerArray : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbClipTriggerArray;
		inline static constexpr auto VTABLE = VTABLE_hkbClipTriggerArray;

		~hkbClipTriggerArray() override;  // 00

		// members
		hkArray<hkClipTrigger> triggers;  // 10
	};
	static_assert(sizeof(hkbClipTriggerArray) == 0x20);

	class hkbClipGenerator : public hkbGenerator
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbClipGenerator;
		inline static constexpr auto VTABLE = VTABLE_hkbClipGenerator;

		enum PlaybackMode
		{
			kModeSinglePlay = 0,
			kModeLooping = 1,
			kModeUserControlled = 2,
			kModePingPong = 3,
			kModeCount = 4
		};

		~hkbClipGenerator() override;  // 00

		// override (hkbNode)
		void Activate(const hkbContext& a_context) override;                  // 04
		void Update(const hkbContext& a_context, float a_timestep) override;  // 05
		void Deactivate(const hkbContext& a_context) override;                // 07

		// override (hkbGenerator)
		void Generate(const hkbContext& a_context) override;    // 17
		void UpdateSync(const hkbContext& a_context) override;  // 19

		// members
		hkStringPtr                             animationName;                       // 048
		hkRefPtr<hkbClipTriggerArray>           triggers;                            // 050
		float                                   cropStartAmountLocalTime;            // 058
		float                                   cropEndAmountLocalTime;              // 05C
		float                                   startTime;                           // 060
		float                                   playbackSpeed;                       // 064
		float                                   enforcedDuration;                    // 068
		float                                   userControlledTimeFraction;          // 06C
		std::uint16_t                           animationBindingIndex;               // 070
		stl::enumeration<PlaybackMode, uint8_t> mode;                                // 072
		std::uint8_t                            flags;                               // 073
		std::uint32_t                           unk74;                               // 074
		hkArray<hkRefVariant>                   animDatas;                           // 078
		hkRefPtr<hkaDefaultAnimationControl>    animationControl;                    // 088
		hkRefPtr<hkbClipTriggerArray>           originalTriggers;                    // 090
		hkaDefaultAnimationControlMapperData*   mapperData;                          // 098
		hkaAnimationBinding*                    binding;                             // 0A0
		hkRefVariant                            mirroredAnimation;                   // 0A8
		hkQsTransform                           extractedMotion;                     // 0B0
		hkArray<hkRefVariant>                   echos;                               // 0E0
		float                                   localTime;                           // 0F0
		float                                   time;                                // 0F4
		float                                   previousUserControlledTimeFraction;  // 0F8
		std::int32_t                            bufferSize;                          // 0FC
		std::int32_t                            echoBufferSize;                      // 100
		bool                                    atEnd;                               // 104
		bool                                    ignoreStartTime;                     // 105
		bool                                    pingPongBackward;                    // 106
		std::uint8_t                            pad107[9];                           // 107
	};
	static_assert(sizeof(hkbClipGenerator) == 0x110);
}


===============================================
File: include/RE/H/hkbContext.h
===============================================
#pragma once

#include "RE/H/hkbCharacter.h"

namespace RE
{
	class hkaDefaultAnimationControlMapperData;
	class hkbGeneratorOutputListener;
	class hkbEventQueue;
	class hkbAttachmentManager;

	class hkbContext
	{
	public:
		// members
		hkbCharacter*                         character;                 // 00
		hkbBehaviorGraph*                     behavior;                  // 08
		hkRefVariant                          nodeToIndexMap;            // 10 hkPointerMap<const hkbNode*, int>
		hkbEventQueue*                        eventQueue;                // 18
		hkaDefaultAnimationControlMapperData* sharedEventQueue;          // 20
		hkRefPtr<hkbGeneratorOutputListener>  generatorOutputListener;   // 28
		bool                                  eventTriggeredTransition;  // 30
		std::uint8_t                          pad31[7];                  // 31
		hkRefVariant                          world;                     // 38
		hkbAttachmentManager*                 attachmentManager;         // 40
		hkRefVariant                          animationCache;            // 48
	};
	static_assert(sizeof(hkbContext) == 0x50);
}


===============================================
File: include/RE/H/hkbEvent.h
===============================================
#pragma once

#include "RE/H/hkRefVariant.h"
#include "RE/H/hkbEventBase.h"

namespace RE
{
	class hkbEvent : public hkbEventBase
	{
	public:
		// members
		hkRefVariant sender;  // 10
	};
	static_assert(sizeof(hkbEvent) == 0x18);
}


===============================================
File: include/RE/H/hkbEventBase.h
===============================================
#pragma once

#include "RE/H/hkRefPtr.h"

namespace RE
{
	class hkbEventPayload;

	class hkbEventBase
	{
	public:
		enum SystemEventIDs : std::uint32_t
		{
			kNull = static_cast<std::underlying_type_t<SystemEventIDs>>(-1)
		};

		// members
		SystemEventIDs            id;       // 00
		std::uint32_t             pad04;    // 04
		hkRefPtr<hkbEventPayload> payload;  // 08
	};
	static_assert(sizeof(hkbEventBase) == 0x10);
}


===============================================
File: include/RE/H/hkbGenerator.h
===============================================
#pragma once

#include "RE/H/hkbNode.h"

namespace RE
{
	class hkbGenerator : public hkbNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbGenerator;
		inline static constexpr auto VTABLE = VTABLE_hkbGenerator;

		~hkbGenerator() override;  // 00

		// override (hkbNode)
		void Unk_15(void) override;  // 15 - { return 1; }

		// add
		virtual void Generate(const hkbContext& a_context) = 0;  // 17
		virtual void Unk_18(void);                               // 18 - { return 0; }
		virtual void UpdateSync(const hkbContext& a_context);    // 19
		virtual void Unk_1A(void);                               // 1A - { return; }
		virtual void Unk_1B(void);                               // 1B - { return; }
	};
	static_assert(sizeof(hkbGenerator) == 0x48);
}


===============================================
File: include/RE/H/hkbNode.h
===============================================
#pragma once

#include "RE/H/hkStringPtr.h"
#include "RE/H/hkbBindable.h"
#include "RE/H/hkbContext.h"

namespace RE
{
	class hkbNode : public hkbBindable
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbNode;
		inline static constexpr auto VTABLE = VTABLE_hkbNode;

		~hkbNode() override;  // 00

		// add
		virtual void Activate(const hkbContext& a_context);                  // 04 - { return; }
		virtual void Update(const hkbContext& a_context, float a_timestep);  // 05 - { userData |= 1; }
		virtual void Unk_06(void);                                           // 06 - { return; }
		virtual void Deactivate(const hkbContext& a_context);                // 07 - { return; }
		virtual void Unk_08(void);                                           // 08 - { return 2; }
		virtual void Unk_09(void);                                           // 09 - { return; }
		virtual void Unk_0A(void);                                           // 0A - { return 1; }
		virtual void Unk_0B(void);                                           // 0B - { return; }
		virtual void Unk_0C(void);                                           // 0C
		virtual void Unk_0D(void);                                           // 0D - { return 0; }
		virtual void Unk_0E(void);                                           // 0E - { return; }
		virtual void Unk_0F(void);                                           // 0F - { return; }
		virtual void Unk_10(void);                                           // 10 - { return; }
		virtual void Unk_11(void);                                           // 11 - { return; }
		virtual void Unk_12(void);                                           // 12 - { return; }
		virtual void Unk_13(void);                                           // 13 - { return 0; }
		virtual void Unk_14(void);                                           // 14 - { return; }
		virtual void Unk_15(void);                                           // 15 - { return 0; }
		virtual void Unk_16(void);                                           // 16 - { return 0; }

		enum class GetChildrenFlagBits
		{
			kActiveOnly = 1 << 0,
			kGeneratorsOnly = 1 << 1,
			kIgnoreReferencedBehaviour = 1 << 2
		};

		enum class CloneState
		{
			kDefault = 0,
			kTemplate = 1,
			kClone = 2,
			kShareable = 3
		};

		// members
		std::uint64_t                              userData;    // 30
		hkStringPtr                                name;        // 38
		std::uint16_t                              id;          // 40
		stl::enumeration<CloneState, std::uint8_t> cloneState;  // 42
		std::uint8_t                               pad43;       // 43
		std::uint32_t                              pad44;       // 44
	};
	static_assert(sizeof(hkbNode) == 0x48);
}


===============================================
File: include/RE/H/hkbProjectData.h
===============================================
#pragma once

#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkbProjectStringData;

	class hkbProjectData : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbProjectData;
		inline static constexpr auto VTABLE = VTABLE_hkbProjectData;

		// members
		hkVector4                      worldUpWS;         // 10
		hkRefPtr<hkbProjectStringData> stringData;        // 20
		std::uint8_t                   defaultEventNode;  // 28 (hkEnum<hkbTransitionEffect::EventMode, hkInt8>)
	};
	static_assert(sizeof(hkbProjectData) == 0x30);
}


===============================================
File: include/RE/H/hkbProjectStringData.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkStringPtr.h"

namespace RE
{
	class hkbProjectStringData : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbProjectStringData;
		inline static constexpr auto VTABLE = VTABLE_hkbProjectStringData;

		// members
		hkArray<hkStringPtr> animationFilenames;  // 10
		hkArray<hkStringPtr> behaviorFilenames;   // 20
		hkArray<hkStringPtr> characterFilenames;  // 30
		hkArray<hkStringPtr> eventNames;          // 40
		hkStringPtr          animationPath;       // 50
		hkStringPtr          behaviorPath;        // 58
		hkStringPtr          characterPath;       // 60
		hkStringPtr          scriptsPath;         // 68
		hkStringPtr          fullPathToSource;    // 70
		hkStringPtr          rootPath;            // 78
	};
	static_assert(sizeof(hkbProjectStringData) == 0x80);
}


===============================================
File: include/RE/H/hkbRagdollDriver.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkbRagdollDriver : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbRagdollDriver;
		inline static constexpr auto VTABLE = VTABLE_hkbRagdollDriver;

		~hkbRagdollDriver() override;  // 00

		// members
		std::uint64_t       unk10;                   // 10
		std::uint64_t       unk18;                   // 18
		std::uint64_t       unk20;                   // 20
		std::uint64_t       unk28;                   // 28
		std::uint64_t       unk30;                   // 30
		std::uint64_t       unk38;                   // 38
		std::uint64_t       unk40;                   // 40
		std::uint64_t       unk48;                   // 48
		std::uint64_t       unk50;                   // 50
		hkArray<int32_t>    reportingWhenKeyframed;  // 58
		std::uint64_t       unk68;                   // 68
		std::uint64_t       unk70;                   // 70
		std::uint64_t       unk78;                   // 78
		hkbCharacter*       character;               // 80
		hkaRagdollInstance* ragdoll;                 // 88
		std::uint64_t       unk90;                   // 90
		std::uint64_t       unk98;                   // 98
		std::uint64_t       unkA0;                   // A0
		std::uint64_t       unkA8;                   // A8
		std::uint64_t       unkB0;                   // B0
		std::uint32_t       unkB8;                   // B8
		float               unkBC;                   // BC
		float               unkC0;                   // C0
		std::uint32_t       unkC4;                   // C4
		std::uint64_t       unkC8;                   // C8
	};
	static_assert(sizeof(hkbRagdollDriver) == 0xD0);
}


===============================================
File: include/RE/H/hkbRigidBodySetup.h
===============================================
#pragma once

#include "RE/H/hkbShapeSetup.h"

namespace RE
{
	struct hkbRigidBodySetup
	{
		enum class Type
		{
			kInvalid = -1,
			kKeyframed,
			kDynamic,
			kFixed,
		};

		// members
		std::uint32_t                       collisionFilterInfo;  // 00
		stl::enumeration<Type, std::int8_t> type;                 // 04
		hkbShapeSetup                       shapeSetup;           // 05
	};
	static_assert(sizeof(hkbRigidBodySetup) == 0x20);
}


===============================================
File: include/RE/H/hkbShapeSetup.h
===============================================
#pragma once

#include "RE/H/hkStringPtr.h"

namespace RE
{
	struct hkbShapeSetup
	{
		enum class Type
		{
			kCapsule = 0,
			kFile,
		};

		// members
		float                               capsuleHeight;  // 00
		float                               capsuleRadius;  // 04
		hkStringPtr                         fileName;       // 08
		stl::enumeration<Type, std::int8_t> type;           // 10
	};
	static_assert(sizeof(hkbShapeSetup) == 0x18);
}


===============================================
File: include/RE/H/hkbStateMachine.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkbBindable.h"
#include "RE/H/hkbEvent.h"
#include "RE/H/hkbGenerator.h"

namespace RE
{
	class hkbStateChooser;

	class hkbStateMachine : public hkbGenerator
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkbStateMachine;
		inline static constexpr auto VTABLE = VTABLE_hkbStateMachine;

		enum class StartStateMode
		{
			kDefault = 0,
			kSync = 1,
			kRandom = 2,
			kChooser = 3
		};

		enum class StateMachineSelfTransitionMode
		{
			kNoTransition = 0,
			kTransitionToStartState = 1,
			kForceTransitionToStartState = 2
		};

		class StateInfo : public hkbBindable
		{
		public:
			inline static constexpr auto RTTI = RTTI_hkbStateMachine__StateInfo;

			~StateInfo() override;  // 00

			// members
			std::uint64_t unk30;  // 30
			std::uint64_t unk38;  // 38
			std::uint64_t unk40;  // 40
			std::uint64_t unk48;  // 48
			std::uint64_t unk50;  // 50
			std::uint64_t unk58;  // 58
			std::uint64_t unk60;  // 60
			std::uint64_t unk68;  // 68
			std::uint64_t unk70;  // 70
		};
		static_assert(sizeof(StateInfo) == 0x78);

		class TransitionInfoArray : public hkReferencedObject
		{
		public:
			inline static constexpr auto RTTI = RTTI_hkbStateMachine__TransitionInfoArray;

			~TransitionInfoArray() override;  // 00

			// members
			std::uint64_t unk10;  // 10
			std::uint64_t unk18;  // 18
		};
		static_assert(sizeof(TransitionInfoArray) == 0x20);

		~hkbStateMachine() override;  // 00

		// override (hkbGenerator)
		hkClass* GetClassType() const override;                                                                     // 01
		void     CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02
		void     Unk_03(void) override;                                                                             // 03
		void     Activate(const hkbContext& a_context) override;                                                    // 04
		void     Update(const hkbContext& a_context, float a_timestep) override;                                    // 05
		void     Unk_06(void) override;                                                                             // 06
		void     Deactivate(const hkbContext& a_context) override;                                                  // 07
		void     Unk_08(void) override;                                                                             // 08
		void     Unk_09(void) override;                                                                             // 09
		void     Unk_0A(void) override;                                                                             // 0A
		void     Unk_0C(void) override;                                                                             // 0C
		void     Unk_0D(void) override;                                                                             // 0D
		void     Unk_0E(void) override;                                                                             // 0E
		void     Unk_0F(void) override;                                                                             // 0F
		void     Unk_10(void) override;                                                                             // 10
		void     Unk_11(void) override;                                                                             // 11
		void     Unk_12(void) override;                                                                             // 12
		void     Unk_14(void) override;                                                                             // 14
		void     Generate(const hkbContext& a_context) override;                                                    // 17
		void     Unk_18(void) override;                                                                             // 18 - { return 1; }
		void     UpdateSync(const hkbContext& a_context) override;                                                  // 19
		void     Unk_1B(void) override;                                                                             // 1B - { echoNextUpdate = true; }

		// members
		hkbEvent                                                       eventToSendWhenStateOrTransitionChanges;  // 048
		hkRefPtr<hkbStateChooser>                                      startStateChooser;                        // 060
		std::int32_t                                                   startStateID;                             // 068
		std::int32_t                                                   returnToPreviousStateEventID;             // 06C
		std::int32_t                                                   randomTransitionEventID;                  // 070
		std::int32_t                                                   transitionToNextHigherStateEventID;       // 074
		std::int32_t                                                   transitionToNextLowerStateEventID;        // 078
		std::int32_t                                                   syncVariableIndex;                        // 07C
		std::int32_t                                                   currentStateID;                           // 080
		bool                                                           wrapAroundStateID;                        // 084
		std::int8_t                                                    maxSimultaneousTransitions;               // 085
		stl::enumeration<StartStateMode, std::uint8_t>                 startStateMode;                           // 086
		stl::enumeration<StateMachineSelfTransitionMode, std::uint8_t> selfTransitionMode;                       // 087
		bool                                                           isActive;                                 // 088
		std::uint8_t                                                   pad41;                                    // 089
		std::uint16_t                                                  pad42;                                    // 08A
		std::uint32_t                                                  pad44;                                    // 08C
		hkArray<StateInfo*>                                            states;                                   // 090
		hkRefPtr<TransitionInfoArray>                                  wildcardTransitions;                      // 0A0
		hkRefVariant                                                   stateIDToIndexMap;                        // 0A8
		hkArray<hkRefVariant>                                          activeTransitions;                        // 0B0
		hkArray<hkRefVariant>                                          transitionFlags;                          // 0C0
		hkArray<hkRefVariant>                                          wildcardTransitionFlags;                  // 0D0
		hkArray<hkRefVariant>                                          delayedTransitions;                       // 0E0
		float                                                          timeInState;                              // 0F0
		float                                                          lastLocalTime;                            // 0F4
		std::int32_t                                                   previousStateID;                          // 0F8
		std::int32_t                                                   nextStartStateIndexOverride;              // 0FC
		bool                                                           stateOrTransitionChanged;                 // 100
		bool                                                           echoNextUpdate;                           // 101
		std::uint16_t                                                  currentStateIndexAndEntered;              // 102
		std::uint32_t                                                  pad0BC;                                   // 104
	};
	static_assert(sizeof(hkbStateMachine) == 0x108);
}


===============================================
File: include/RE/H/hkp3AxisSweep.h
===============================================
#pragma once

#include "RE/H/hkAabb.h"
#include "RE/H/hkArray.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkpBroadPhase.h"

namespace RE
{
	class hkpBroadPhaseHandle;

	class hkp3AxisSweep : public hkpBroadPhase
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkp3AxisSweep;
		inline static constexpr auto VTABLE = VTABLE_hkp3AxisSweep;

		using BpInt = std::uint16_t;

		enum class MarkerHandling
		{
			kAddNewOverlaps,
			kIgnore,
			kRemoveNewOverlaps
		};

		class hkpBpMarker
		{
		public:
			// members
			BpInt          nodeIndex;           // 00
			BpInt          value;               // 02
			std::uint32_t  pad04;               // 04
			hkArray<BpInt> overlappingObjects;  // 08
		};
		static_assert(sizeof(hkpBpMarker) == 0x18);

		class hkpBpNode
		{
		public:
			// members
			BpInt                minY;    // 00
			BpInt                minZ;    // 02
			BpInt                maxY;    // 04
			BpInt                maxZ;    // 06
			BpInt                minX;    // 08
			BpInt                maxX;    // 0A
			std::uint32_t        pad0C;   // 0C
			hkpBroadPhaseHandle* handle;  // 10
		};
		static_assert(sizeof(hkpBpNode) == 0x18);

		class hkpBpEndPoint
		{
		public:
			// members
			BpInt value;      // 0
			BpInt nodeIndex;  // 2
		};
		static_assert(sizeof(hkpBpEndPoint) == 0x4);

		class hkpBpAxis
		{
		public:
			// members
			hkArray<hkpBpEndPoint> endPoints;  // 00
		};
		static_assert(sizeof(hkpBpAxis) == 0x10);

		~hkp3AxisSweep() override;  // 00

		// override (hkpBroadPhase)
		void           CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;                                                                                                                        // 02
		BroadPhaseType GetType() const override;                                                                                                                                                                                                // 03
		void           AddObject1(hkpBroadPhaseHandle* a_object, const hkAabbUint32& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) override;                                                                                            // 05
		void           AddObject2(hkpBroadPhaseHandle* a_object, const hkAabb& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) override;                                                                                                  // 06
		void           AddObjectBatch(const hkArrayBase<hkpBroadPhaseHandle*>& a_addObjectList, const hkArrayBase<hkAabb>& a_addAabbList, hkArray<hkpBroadPhaseHandlePair>& a_newPairs) override;                                               // 07
		void           RemoveObject(hkpBroadPhaseHandle* a_object, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) override;                                                                                                                      // 08
		void           RemoveObjectBatch(const hkArrayBase<hkpBroadPhaseHandle*>& a_removeObjectList, hkArray<hkpBroadPhaseHandlePair>& a_delPairsOut) override;                                                                                // 09
		std::int32_t   GetNumObjects() const override;                                                                                                                                                                                          // 0A
		void           UpdateAabbs(hkpBroadPhaseHandle* a_objects[], const hkAabb* a_aabbs, std::int32_t a_numObjects, hkArray<hkpBroadPhaseHandlePair>& a_addedPairs, hkArray<hkpBroadPhaseHandlePair>& a_removedPairs) override;              // 0B
		void           UpdateAabbsUInt32(hkpBroadPhaseHandle* a_objects[], const hkAabbUint32* a_aabbs, std::int32_t a_numObjects, hkArray<hkpBroadPhaseHandlePair>& a_addedPairs, hkArray<hkpBroadPhaseHandlePair>& a_removedPairs) override;  // 0C
		void           Defragment() override;                                                                                                                                                                                                   // 0D
		void           CheckDeterminism() override;                                                                                                                                                                                             // 0E - { return; }
		void           GetAllAabbs(hkArray<hkAabb>& a_allAabbs) const override;                                                                                                                                                                 // 0F
		void           GetAabb(const hkpBroadPhaseHandle* a_object, hkAabb& a_aabb) const override;                                                                                                                                             // 10
		void           GetExtents(hkVector4& a_worldMinOut, hkVector4& a_worldMaxOut) const override;                                                                                                                                           // 11
		void           QuerySingleAabb(const hkAabb& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) const override;                                                                                                                      // 12
		void           ReQuerySingleObject(const hkpBroadPhaseHandle* a_object, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) const override;                                                                                                   // 13
		void           QuerySingleAabbWithCollector(const hkAabb& a_aabb, hkpBroadPhaseCastCollector* a_collector) const override;                                                                                                              // 14
		bool           AreAabbsOverlapping(const hkpBroadPhaseHandle* a_bhA, const hkpBroadPhaseHandle* a_bhB) const override;                                                                                                                  // 15
		void           ShiftAllObjects(const hkVector4& a_shiftDistance, hkVector4& a_effectiveShiftDistanceOut, hkArray<hkpBroadPhaseHandlePair>& a_newCollisionPairs) override;                                                               // 16
		void           ShiftBroadPhase(const hkVector4& a_shiftDistance, hkVector4& a_effectiveShiftDistanceOut, hkArray<hkpBroadPhaseHandlePair>& a_newCollisionPairs) override;                                                               // 17
		void           GetOffsetLowHigh32bit(hkVector4& a_offsetLow32bit, hkVector4& a_offsetHigh32bit) const override;                                                                                                                         // 18
		void           CastRay(const hkpCastRayInput& a_input, hkpBroadPhaseCastCollector* a_collectorBase, std::int32_t a_collectorStriding) const override;                                                                                   // 19
		std::int32_t   GetAabbCacheSize() const override;                                                                                                                                                                                       // 1A
		void           CalcAabbCache1(const hkAabb& a_aabb, hkpBroadPhaseAabbCache* a_aabbCacheOut) const override;                                                                                                                             // 1B
		void           CalcAabbCache2(const hkArrayBase<hkpCollidable*>& a_overlappingCollidables, hkpBroadPhaseAabbCache* a_aabbCacheOut) const override;                                                                                      // 1C
		void           CastAabb(const hkpCastAabbInput& a_input, hkpBroadPhaseCastCollector& a_collector) const override;                                                                                                                       // 1D
		void           Set32BitOffsetAndScale(const hkVector4& a_offsetLow, const hkVector4& a_offsetHigh, const hkVector4& a_scale) override;                                                                                                  // 1E

		// members
		hkAabb             aabb;                       // 030
		hkVector4          offsetLow;                  // 050
		hkVector4          offsetHigh;                 // 060
		hkVector4          scale;                      // 070
		hkVector4          offsetLow32bit;             // 080
		hkVector4          offsetHigh32bit;            // 090
		hkVector4          scale32bit;                 // 0A0
		hkArray<hkpBpNode> nodes;                      // 0B0
		hkpBpAxis          axis[3];                    // 0C0
		std::int32_t       numMarkers;                 // 0F0
		std::int32_t       ld2NumMarkers;              // 0F4
		hkpBpMarker*       markers;                    // 0F8
		float              intToFloatFloorCorrection;  // 100
		std::uint32_t      pad104;                     // 104
		std::uint64_t      pad108;                     // 108
	};
	static_assert(sizeof(hkp3AxisSweep) == 0x110);
}


===============================================
File: include/RE/H/hkpAction.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkpAction : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpAction;
		inline static constexpr auto VTABLE = VTABLE_hkpAction;

		virtual ~hkpAction() override;  // 00

		// add
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void);      // 05
		virtual void Unk_06(void) = 0;  // 06
		virtual void Unk_07(void) = 0;  // 07

		// members
		hkpWorld*            world;     // 10
		hkpSimulationIsland* island;    // 18
		std::uint64_t        userData;  // 20
		hkStringPtr          name;      // 28
	};
	static_assert(sizeof(hkpAction) == 0x30);
}


===============================================
File: include/RE/H/hkpAgentNnTrack.h
===============================================
#pragma once

#include "RE/H/hkArray.h"

namespace RE
{
	struct hkpAgentNnSector;

	enum class hkpAgentNnTrackType
	{
		kInvalid = 0,
		kMidPhase = 1,
		kNarrowPhase = 2
	};

	struct hkpAgentNnTrack
	{
	public:
		// members
		std::uint16_t                                       bytesUsedInLastSector;  // 00
		stl::enumeration<hkpAgentNnTrackType, std::uint8_t> nnTrackType;            // 02
		std::uint8_t                                        padding;                // 03
		std::uint32_t                                       pad04;                  // 04
		hkInplaceArray<hkpAgentNnSector*, 1>                sectors;                // 08
	};
	static_assert(sizeof(hkpAgentNnTrack) == 0x20);
}


===============================================
File: include/RE/H/hkpAllCdPointCollector.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkpCdPointCollector.h"
#include "RE/H/hkpRootCdPoint.h"

namespace RE
{
	class hkpAllCdPointCollector : public hkpCdPointCollector
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpAllCdPointCollector;
		inline static constexpr auto VTABLE = VTABLE_hkpAllCdPointCollector;

		~hkpAllCdPointCollector() override;  // 00

		// override (hkpCdPointCollector)
		void AddCdPoint(const hkpCdPoint& a_point) override;  // 01
		void Reset() override;                                // 02 - { hits.size = 0; earlyOutDistance = 0x7F7FFFEE; }

		// members
		hkInplaceArray<hkpRootCdPoint, 8> hits;  // 010
	};
	static_assert(sizeof(hkpAllCdPointCollector) == 0x220);
}


===============================================
File: include/RE/H/hkpArrayAction.h
===============================================
#pragma once

#include "RE/H/hkpAction.h"

namespace RE
{
	class hkpArrayAction : public hkpAction
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpArrayAction;
		inline static constexpr auto VTABLE = VTABLE_hkpArrayAction;

		virtual ~hkpArrayAction() override;  // 00

		// add
		virtual void Unk_04(void) override;  // 04
		virtual void Unk_06(void) override;  // 06

		// members
		hkArray<hkpEntity*> entities;  // 30
	};
	static_assert(sizeof(hkpArrayAction) == 0x40);
}


===============================================
File: include/RE/H/hkpBoxShape.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"
#include "RE/H/hkpConvexShape.h"

namespace RE
{
	class hkpBoxShape : public hkpConvexShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpBoxShape;
		inline static constexpr auto VTABLE = VTABLE_hkpBoxShape;

		~hkpBoxShape() override;  // 00

		// overwrite
		void             CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;     // 02
		std::int32_t     CalcSizeForSpu(const CalcSizeForSpuInput& a_input, std::int32_t a_spuBufferSizeLeft) const override;  // 06 - { return 64; }
		void             GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const override;      // 07
		bool             CastRayImpl(const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output) const override;     // 08
		std::int32_t     GetNumCollisionSpheresImpl() override;                                                                // 0B - { return 8; }
		const hkpSphere* GetCollisionSpheresImpl(hkSphere* a_sphereBuffer) override;                                           // 0C
		void             GetCentreImpl(hkVector4& a_centreOut) override;                                                       // 0D
		void             Unk_0E(void) override;                                                                                // 0E
		void             Unk_0F(void) override;                                                                                // 0F
		void             Unk_11(void) override;                                                                                // 11

		// members
		std::uint32_t pad28;        // 28
		std::uint32_t pad2C;        // 2C
		hkVector4     halfExtents;  // 30
	};
	static_assert(sizeof(hkpBoxShape) == 0x40);
}


===============================================
File: include/RE/H/hkpBroadPhase.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkMultiThreadCheck.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkAabb;
	class hkCriticalSection;
	class hkpBroadPhaseCastCollector;
	class hkpBroadPhaseHandle;
	class hkpBroadPhaseHandlePair;
	class hkpCollidable;
	struct hkAabbUint32;

	using hkpBroadPhaseAabbCache = char;

	class hkpBroadPhase : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpBroadPhase;
		inline static constexpr auto VTABLE = VTABLE_hkpBroadPhase;

		enum class BroadPhaseType
		{
			k16Bit,
			k32Bit,
			kHybrid
		};

		enum class Capabilities
		{
			kNone = 0,
			kRayCast = 1 << 0,
			kLinearCast = 1 << 1,
			kAABBQuery = 1 << 2,
			kClosestPoints = 1 << 3,
			kCharProxyInt = 1 << 4,
			kISASweepAndPrune = 1 << 12
		};

		struct hkpCastRayInput
		{
		public:
			// members
			hkVector4                     from;           // 00
			std::int32_t                  numCasts;       // 10
			std::uint32_t                 pad14;          // 14
			const hkVector4*              toBase;         // 18
			std::int32_t                  toStriding;     // 20
			std::uint32_t                 pad24;          // 24
			const hkpBroadPhaseAabbCache* aabbCacheInfo;  // 28
		};
		static_assert(sizeof(hkpCastRayInput) == 0x30);

		struct hkpCastAabbInput
		{
		public:
			// members
			hkVector4                     from;           // 00
			hkVector4                     to;             // 10
			hkVector4                     halfExtents;    // 20
			const hkpBroadPhaseAabbCache* aabbCacheInfo;  // 30
			std::uint64_t                 pad38;          // 38
		};
		static_assert(sizeof(hkpCastAabbInput) == 0x40);

		~hkpBroadPhase() override;  // 00

		// add
		virtual BroadPhaseType       GetType() const = 0;                                                                                                                                                                                                // 03
		virtual const hkpBroadPhase* GetCapabilityDelegate(Capabilities a_cap) const;                                                                                                                                                                    // 04 - { return caps & a_cap ? this : 0; }
		virtual void                 AddObject1(hkpBroadPhaseHandle* a_object, const hkAabbUint32& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) = 0;                                                                                            // 05
		virtual void                 AddObject2(hkpBroadPhaseHandle* a_object, const hkAabb& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) = 0;                                                                                                  // 06
		virtual void                 AddObjectBatch(const hkArrayBase<hkpBroadPhaseHandle*>& a_addObjectList, const hkArrayBase<hkAabb>& a_addAabbList, hkArray<hkpBroadPhaseHandlePair>& a_newPairs) = 0;                                               // 07
		virtual void                 RemoveObject(hkpBroadPhaseHandle* a_object, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) = 0;                                                                                                                      // 08
		virtual void                 RemoveObjectBatch(const hkArrayBase<hkpBroadPhaseHandle*>& a_removeObjectList, hkArray<hkpBroadPhaseHandlePair>& a_delPairsOut) = 0;                                                                                // 09
		virtual std::int32_t         GetNumObjects() const = 0;                                                                                                                                                                                          // 0A
		virtual void                 UpdateAabbs(hkpBroadPhaseHandle* a_objects[], const hkAabb* a_aabbs, std::int32_t a_numObjects, hkArray<hkpBroadPhaseHandlePair>& a_addedPairs, hkArray<hkpBroadPhaseHandlePair>& a_removedPairs) = 0;              // 0B
		virtual void                 UpdateAabbsUInt32(hkpBroadPhaseHandle* a_objects[], const hkAabbUint32* a_aabbs, std::int32_t a_numObjects, hkArray<hkpBroadPhaseHandlePair>& a_addedPairs, hkArray<hkpBroadPhaseHandlePair>& a_removedPairs) = 0;  // 0C
		virtual void                 Defragment() = 0;                                                                                                                                                                                                   // 0D
		virtual void                 CheckDeterminism();                                                                                                                                                                                                 // 0E - { return; }
		virtual void                 GetAllAabbs(hkArray<hkAabb>& a_allAabbs) const = 0;                                                                                                                                                                 // 0F
		virtual void                 GetAabb(const hkpBroadPhaseHandle* a_object, hkAabb& a_aabb) const = 0;                                                                                                                                             // 10
		virtual void                 GetExtents(hkVector4& a_worldMinOut, hkVector4& a_worldMaxOut) const = 0;                                                                                                                                           // 11
		virtual void                 QuerySingleAabb(const hkAabb& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) const = 0;                                                                                                                      // 12
		virtual void                 ReQuerySingleObject(const hkpBroadPhaseHandle* a_object, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut) const = 0;                                                                                                   // 13
		virtual void                 QuerySingleAabbWithCollector(const hkAabb& a_aabb, hkpBroadPhaseCastCollector* a_collector) const = 0;                                                                                                              // 14
		virtual bool                 AreAabbsOverlapping(const hkpBroadPhaseHandle* a_bhA, const hkpBroadPhaseHandle* a_bhB) const = 0;                                                                                                                  // 15
		virtual void                 ShiftAllObjects(const hkVector4& a_shiftDistance, hkVector4& a_effectiveShiftDistanceOut, hkArray<hkpBroadPhaseHandlePair>& a_newCollisionPairs) = 0;                                                               // 16
		virtual void                 ShiftBroadPhase(const hkVector4& a_shiftDistance, hkVector4& a_effectiveShiftDistanceOut, hkArray<hkpBroadPhaseHandlePair>& a_newCollisionPairs) = 0;                                                               // 17
		virtual void                 GetOffsetLowHigh32bit(hkVector4& a_offsetLow32bit, hkVector4& a_offsetHigh32bit) const = 0;                                                                                                                         // 18
		virtual void                 CastRay(const hkpCastRayInput& a_input, hkpBroadPhaseCastCollector* a_collectorBase, std::int32_t a_collectorStriding) const = 0;                                                                                   // 19
		virtual std::int32_t         GetAabbCacheSize() const = 0;                                                                                                                                                                                       // 1A
		virtual void                 CalcAabbCache1(const hkAabb& a_aabb, hkpBroadPhaseAabbCache* a_aabbCacheOut) const = 0;                                                                                                                             // 1B
		virtual void                 CalcAabbCache2(const hkArrayBase<hkpCollidable*>& a_overlappingCollidables, hkpBroadPhaseAabbCache* a_aabbCacheOut) const = 0;                                                                                      // 1C
		virtual void                 CastAabb(const hkpCastAabbInput& a_input, hkpBroadPhaseCastCollector& a_collector) const = 0;                                                                                                                       // 1D
		virtual void                 Set32BitOffsetAndScale(const hkVector4& a_offsetLow, const hkVector4& a_offsetHigh, const hkVector4& a_scale) = 0;                                                                                                  // 1E

		void AddObject(hkpBroadPhaseHandle* a_object, const hkAabbUint32& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut);
		void AddObject(hkpBroadPhaseHandle* a_object, const hkAabb& a_aabb, hkArray<hkpBroadPhaseHandlePair>& a_pairsOut);
		void CalcAabbCache(const hkAabb& a_aabb, hkpBroadPhaseAabbCache* a_aabbCacheOut) const;
		void CalcAabbCache(const hkArrayBase<hkpCollidable*>& a_overlappingCollidables, hkpBroadPhaseAabbCache* a_aabbCacheOut) const;

		// members
		const stl::enumeration<BroadPhaseType, std::uint16_t> type;              // 10
		const std::uint16_t                                   size{ 0 };         // 12
		const stl::enumeration<Capabilities, std::uint32_t>   caps;              // 14
		mutable hkMultiThreadCheck                            multiThreadCheck;  // 18
		std::uint32_t                                         pad24;             // 24
		hkCriticalSection*                                    criticalSection;   // 28
	};
	static_assert(sizeof(hkpBroadPhase) == 0x30);
}


===============================================
File: include/RE/H/hkpBroadPhaseCastCollector.h
===============================================
#pragma once

namespace RE
{
	class hkpBroadPhaseHandle;

	class hkpBroadPhaseCastCollector
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpBroadPhaseCastCollector;
		inline static constexpr auto VTABLE = VTABLE_hkpBroadPhaseCastCollector;

		virtual ~hkpBroadPhaseCastCollector() = default;  // 00

		// add
		virtual float AddBroadPhaseHandle(const hkpBroadPhaseHandle* a_broadphaseHandle, std::int32_t a_castIndex) = 0;  // 01
	};
	static_assert(sizeof(hkpBroadPhaseCastCollector) == 0x8);
}


===============================================
File: include/RE/H/hkpBroadPhaseHandle.h
===============================================
#pragma once

namespace RE
{
	class hkpBroadPhaseHandle
	{
	public:
		std::uint32_t id;  // 0
	};
	static_assert(sizeof(hkpBroadPhaseHandle) == 0x4);
}


===============================================
File: include/RE/H/hkpBvTreeShape.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkpShape.h"

namespace RE
{
	class hkAabb;
	class hkpShapeContainer;

	class hkpBvTreeShape : public hkpShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpBvTreeShape;
		inline static constexpr auto VTABLE = VTABLE_hkpBvTreeShape;

		enum class BvTreeType
		{
			kMOPP,
			kTriSampledHeightField,
			kUser
		};

		~hkpBvTreeShape() override;  // 00

		// override (hkpShape)
		const hkpShapeContainer* GetContainer() const override = 0;  // 04

		// add
		virtual void          QueryAabb(const hkAabb& a_aabb, hkArray<hkpShapeKey>& a_hits) const = 0;                        // 0B
		virtual std::uint32_t QueryAabbImpl(const hkAabb& a_aabb, hkpShapeKey* a_hits, std::int32_t a_maxNumKeys) const = 0;  // 0C

		// members
		stl::enumeration<BvTreeType, std::uint8_t> bvTreeType;  // 20
		std::uint8_t                               pad21;       // 21
		std::uint16_t                              pad22;       // 22
		std::uint32_t                              pad24;       // 24
	};
	static_assert(sizeof(hkpBvTreeShape) == 0x28);
}


===============================================
File: include/RE/H/hkpCachingShapePhantom.h
===============================================
#pragma once

#include "RE/H/hkpShapePhantom.h"

namespace RE
{
	class hkpCollisionAgent;

	class hkpCachingShapePhantom : public hkpShapePhantom
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCachingShapePhantom;
		inline static constexpr auto VTABLE = VTABLE_hkpCachingShapePhantom;

		class OrderByUid
		{
		public:
		};
		static_assert(sizeof(OrderByUid) == 0x1);

		struct CollisionDetail
		{
			hkpCollisionAgent* agent;       // 00
			hkpCollidable*     collidable;  // 08
		};
		static_assert(sizeof(CollisionDetail) == 0x10);

		using hkpCollisionDetail = CollisionDetail;

		~hkpCachingShapePhantom() override;  // 00

		// override (hkpShapePhantom)
		void           CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;                                                                                    // 02
		hkpPhantomType GetType() const override;                                                                                                                                                            // 06 - { return hkpPhantomType::kCachingShape; }
		void           AddOverlappingCollidable(hkpCollidable* a_collidable) override;                                                                                                                      // 08
		bool           IsOverlappingCollidableAdded(const hkpCollidable* a_collidable) override;                                                                                                            // 09
		void           RemoveOverlappingCollidable(hkpCollidable* a_collidable) override;                                                                                                                   // 0A
		void           EnsureDeterministicOrder() override;                                                                                                                                                 // 0B
		hkpPhantom*    Clone() const override;                                                                                                                                                              // 0C
		void           UpdateShapeCollectionFilter() override;                                                                                                                                              // 0D
		void           DeallocateInternalArrays() override;                                                                                                                                                 // 0E
		void           SetPositionAndLinearCast(const hkVector4& a_position, const hkpLinearCastInput& a_input, hkpCdPointCollector& a_castCollector, hkpCdPointCollector* a_startCollector) override;      // 0F
		void           SetTransformAndLinearCast(const hkTransform& a_transform, const hkpLinearCastInput& a_input, hkpCdPointCollector& a_castCollector, hkpCdPointCollector* a_startCollector) override;  // 10
		void           GetClosestPoints(hkpCdPointCollector& a_collector, const hkpCollisionInput* a_input = 0) override;                                                                                   // 11
		void           GetPenetrations(hkpCdBodyPairCollector& a_collector, const hkpCollisionInput* a_input = 0) override;                                                                                 // 12

		// members
		hkArray<CollisionDetail> collisionDetails;  // 1A0
		bool                     orderDirty;        // 1B0
		OrderByUid               orderRelation;     // 1B1
		std::uint16_t            pad1B2;            // 1B2
		std::uint32_t            pad1B4;            // 1B4
		std::uint64_t            pad1B8;            // 1B8
	};
	static_assert(sizeof(hkpCachingShapePhantom) == 0x1C0);
}


===============================================
File: include/RE/H/hkpCapsuleShape.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"
#include "RE/H/hkpConvexShape.h"

namespace RE
{
	class hkpCapsuleShape : public hkpConvexShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCapsuleShape;
		inline static constexpr auto VTABLE = VTABLE_hkpCapsuleShape;

		~hkpCapsuleShape() override;  // 00

		// override (hkpConvexShape)
		void             CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;     // 02
		std::int32_t     CalcSizeForSpu(const CalcSizeForSpuInput& a_input, std::int32_t a_spuBufferSizeLeft) const override;  // 06 - { return 56; }
		void             GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const override;      // 07
		bool             CastRayImpl(const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output) const override;     // 08
		std::int32_t     GetNumCollisionSpheresImpl() override;                                                                // 0B - { return 8; }
		const hkpSphere* GetCollisionSpheresImpl(hkSphere* a_sphereBuffer) override;                                           // 0C
		void             GetCentreImpl(hkVector4& a_centreOut) override;                                                       // 0D
		void             Unk_0E(void) override;                                                                                // 0E
		void             Unk_0F(void) override;                                                                                // 0F
		void             Unk_11(void) override;                                                                                // 11

		// members
		std::uint32_t pad28;    // 28
		std::uint32_t pad2C;    // 2C
		hkVector4     vertexA;  // 30
		hkVector4     vertexB;  // 40
	};
	static_assert(sizeof(hkpCapsuleShape) == 0x50);
}


===============================================
File: include/RE/H/hkpCdBody.h
===============================================
#pragma once

#include "RE/H/hkpShape.h"

namespace RE
{
	class hkpCdBody
	{
	public:
		[[nodiscard]] const hkpShape* GetShape() const;

		// members
		const hkpShape*  shape;     // 00
		hkpShapeKey      shapeKey;  // 08
		std::uint32_t    pad0C;     // 0C
		const void*      motion;    // 10
		const hkpCdBody* parent;    // 18
	};
	static_assert(sizeof(hkpCdBody) == 0x20);
}


===============================================
File: include/RE/H/hkpCdPoint.h
===============================================
#pragma once

#include "RE/H/hkContactPoint.h"
#include "RE/H/hkpCdBody.h"

namespace RE
{
	struct hkpCdPoint
	{
		hkContactPoint   contact;         // 00
		hkVector4        unweldedNormal;  // 20
		const hkpCdBody* cdBodyA;         // 20
		const hkpCdBody* cdBodyB;         // 38
	};
	static_assert(sizeof(hkpCdPoint) == 0x40);
}


===============================================
File: include/RE/H/hkpCdPointCollector.h
===============================================
#pragma once

namespace RE
{
	struct hkpCdPoint;

	class hkpCdPointCollector
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCdPointCollector;
		inline static constexpr auto VTABLE = VTABLE_hkpCdPointCollector;

		virtual ~hkpCdPointCollector();  // 00

		// add
		virtual void AddCdPoint(const hkpCdPoint& a_point) = 0;  // 01
		virtual void Reset();                                    // 02 - { earlyOutDistance = 0x7F7FFFEE; }

		// members
		float         earlyOutDistance;  // 08
		std::uint32_t pad0C;             // 0C
	};
	static_assert(sizeof(hkpCdPointCollector) == 0x10);
}


===============================================
File: include/RE/H/hkpCharacterContext.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkStepInfo.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkpCharacterControl.h"
#include "RE/H/hkpCharacterState.h"

namespace RE
{
	class hkpCharacterStateManager;

	struct hkpCharacterInput
	{
		float          inputLR;           // 00
		float          inputUD;           // 04
		bool           wantJump;          // 08
		std::uint8_t   pad09;             // 09
		std::uint16_t  pad0A;             // 0A
		std::uint32_t  pad0C;             // 0C
		hkVector4      up;                // 10
		hkVector4      forward;           // 20
		bool           atLadder;          // 30
		hkpSurfaceInfo surfaceInfo;       // 40
		hkStepInfo     stepInfo;          // 80
		hkVector4      position;          // 90
		hkVector4      velocity;          // A0
		hkVector4      characterGravity;  // B0
		std::uint64_t  userData;          // C0
		std::uint64_t  padC8;             // C8
	};
	static_assert(sizeof(hkpCharacterInput) == 0xD0);

	struct hkpCharacterOutput
	{
		hkVector4 velocity;  // 00
	};
	static_assert(sizeof(hkpCharacterOutput) == 0x10);

	class hkpCharacterContext : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCharacterContext;
		inline static constexpr auto VTABLE = VTABLE_hkpCharacterContext;

		enum class CharacterType
		{
			kProxy = 0,
			kRigidBody = 1
		};

		~hkpCharacterContext() override;  // 00

		stl::enumeration<CharacterType, std::uint32_t> characterType;          // 10
		std::uint32_t                                  pad14;                  // 14
		const hkpCharacterStateManager*                stateManager;           // 18
		hkpCharacterStateType                          currentState;           // 20
		hkpCharacterStateType                          previousState;          // 24
		bool                                           filterEnable;           // 28
		std::uint8_t                                   pad29;                  // 29
		std::uint16_t                                  pad2A;                  // 2A
		float                                          maxLinearAcceleration;  // 2C
		float                                          maxLinearVelocity;      // 30
		float                                          gain;                   // 34
	};
	static_assert(sizeof(hkpCharacterContext) == 0x38);
}


===============================================
File: include/RE/H/hkpCharacterControl.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	struct hkpSurfaceInfo
	{
		enum class SupportedState
		{
			kUnsupported = 0,
			kSliding = 1,
			kSupported = 2
		};

		stl::enumeration<SupportedState, std::uint32_t> supportedState;         // 00
		std::uint32_t                                   pad04;                  // 04
		std::uint64_t                                   pad08;                  // 08
		hkVector4                                       surfaceNormal;          // 10
		hkVector4                                       surfaceVelocity;        // 20
		float                                           surfaceDistanceExcess;  // 30
		bool                                            surfaceIsDynamic;       // 34
		std::uint8_t                                    pad35;                  // 35
		std::uint16_t                                   pad36;                  // 36
		std::uint64_t                                   pad38;                  // 38
	};
	static_assert(sizeof(hkpSurfaceInfo) == 0x40);
}


===============================================
File: include/RE/H/hkpCharacterProxy.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkpEntityListener.h"
#include "RE/H/hkpPhantomListener.h"

namespace RE
{
	class hkpAllCdPointCollector;
	class hkpCharacterProxyListener;
	class hkpPhantom;
	class hkpRigidBody;
	class hkpShapePhantom;
	class hkpTriggerVolume;
	struct hkpRootCdPoint;
	struct hkpSurfaceConstraintInfo;

	class hkpCharacterProxy :
		public hkReferencedObject,  // 00
		public hkpEntityListener,   // 10
		public hkpPhantomListener   // 18
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCharacterProxy;
		inline static constexpr auto VTABLE = VTABLE_hkpCharacterProxy;

		~hkpCharacterProxy() override;  // 00

		// override (hkReferencedObject)
		void CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02

		// override (hkpEntityListener)
		void EntityRemovedCallback(hkpEntity* a_entity) override;  // 02

		// override (hkpPhantomListener)
		void PhantomRemovedCallback(hkpPhantom* a_phantom) override;  // 02

		// add
		virtual void UpdateManifold(const hkpAllCdPointCollector& a_startPointCollector, const hkpAllCdPointCollector& a_castCollector, hkArray<hkpRootCdPoint>& a_manifold, hkArray<hkpRigidBody*>& a_bodies, hkArray<hkpPhantom*>& a_phantoms, bool a_isMultithreaded = false);  // 03
		virtual void ExtractSurfaceConstraintInfo(const hkpRootCdPoint& a_hit, hkpSurfaceConstraintInfo& a_surfaceOut, float a_timeTravelled) const;                                                                                                                               // 04

		// members
		hkArray<hkpRootCdPoint>             manifold;                       // 20
		hkArray<hkpRigidBody*>              bodies;                         // 30
		hkArray<hkpPhantom*>                phantoms;                       // 40
		hkArray<hkpTriggerVolume*>          overlappingTriggerVolumes;      // 50
		hkVector4                           velocity;                       // 60
		hkVector4                           oldDisplacement;                // 70
		hkpShapePhantom*                    shapePhantom;                   // 80
		float                               dynamicFriction;                // 88
		float                               staticFriction;                 // 8C
		hkVector4                           up;                             // 90
		float                               extraUpStaticFriction;          // A0
		float                               extraDownStaticFriction;        // A4
		float                               keepDistance;                   // A8
		float                               keepContactTolerance;           // AC
		float                               contactAngleSensitivity;        // B0
		std::int32_t                        userPlanes;                     // B4
		float                               maxCharacterSpeedForSolver;     // B8
		float                               characterStrength;              // BC
		float                               characterMass;                  // C0
		std::uint32_t                       padC4;                          // C4
		hkArray<hkpCharacterProxyListener*> listeners;                      // C8
		float                               maxSlopeCosine;                 // D8
		float                               penetrationRecoverySpeed;       // DC
		std::int32_t                        maxCastIterations;              // E0
		bool                                refreshManifoldInCheckSupport;  // E4
	};
	static_assert(sizeof(hkpCharacterProxy) == 0xF0);
}


===============================================
File: include/RE/H/hkpCharacterProxyListener.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkVector4.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class hkContactPoint;
	class hkpCharacterProxy;
	class hkpRigidBody;
	struct hkpRootCdPoint;
	struct hkpSimplexSolverInput;

	struct hkpCharacterObjectInteractionEvent
	{
	public:
		// members
		hkVector4     position;           // 00
		hkVector4     normal;             // 10
		float         objectImpulse;      // 20
		float         timestep;           // 24
		float         projectedVelocity;  // 28
		float         objectMassInv;      // 2C
		hkpRigidBody* body;               // 30
		std::uint64_t pad38;              // 38
	};
	static_assert(sizeof(hkpCharacterObjectInteractionEvent) == 0x40);

	struct hkpCharacterObjectInteractionResult
	{
	public:
		// members
		hkVector4 objectImpulse;    // 00
		hkVector4 impulsePosition;  // 10
	};
	static_assert(sizeof(hkpCharacterObjectInteractionResult) == 0x20);

	class hkpCharacterProxyListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCharacterProxyListener;
		inline static constexpr auto VTABLE = VTABLE_hkpCharacterProxyListener;

		virtual ~hkpCharacterProxyListener();  // 00

		// add
		virtual void ProcessConstraintsCallback(const hkpCharacterProxy* a_proxy, const hkArray<hkpRootCdPoint>& a_manifold, hkpSimplexSolverInput& a_input);                  // 01 - { return; }
		virtual void ContactPointAddedCallback(const hkpCharacterProxy* a_proxy, const hkpRootCdPoint& a_point);                                                               // 02 - { return; }
		virtual void ContactPointRemovedCallback(const hkpCharacterProxy* a_proxy, const hkpRootCdPoint& a_point);                                                             // 03 - { return; }
		virtual void CharacterInteractionCallback(hkpCharacterProxy* a_proxy, hkpCharacterProxy* a_otherProxy, const hkContactPoint& a_contact);                               // 04 - { return; }
		virtual void ObjectInteractionCallback(hkpCharacterProxy* a_proxy, const hkpCharacterObjectInteractionEvent& a_input, hkpCharacterObjectInteractionResult& a_output);  // 05 - { return; }

		TES_HEAP_REDEFINE_NEW();
	};
	static_assert(sizeof(hkpCharacterProxyListener) == 0x8);
}


===============================================
File: include/RE/H/hkpCharacterState.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkpCharacterContext;
	struct hkpCharacterInput;
	struct hkpCharacterOutput;

	struct hkpCharacterStateTypes
	{
		enum hkpCharacterStateType : std::uint32_t
		{
			kOnGround = 0,
			kJumping,
			kInAir,
			kClimbing,
			kFlying,

			kUserState0,
			kSwimming = kUserState0,

			kUserState1,
			kUserState2,
			kUserState3,
			kUserState4,
			kUserState5,

			kTotal
		};
	};
	using hkpCharacterStateType = hkpCharacterStateTypes::hkpCharacterStateType;

	class hkpCharacterState : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCharacterState;
		inline static constexpr auto VTABLE = VTABLE_hkpCharacterState;

		~hkpCharacterState() override;  // 00

		virtual hkpCharacterStateType GetType() const = 0;                                                                                                                            // 03
		virtual void                  EnterState(hkpCharacterContext& a_context, hkpCharacterStateType a_prevState, const hkpCharacterInput& a_input, hkpCharacterOutput& a_output);  // 04 - { return; }
		virtual void                  LeaveState(hkpCharacterContext& a_context, hkpCharacterStateType a_nextState, const hkpCharacterInput& a_input, hkpCharacterOutput& a_output);  // 05 - { return; }
		virtual void                  Update(hkpCharacterContext& a_context, const hkpCharacterInput& a_input, hkpCharacterOutput& a_output) = 0;                                     // 06
		virtual void                  Change(hkpCharacterContext& a_context, const hkpCharacterInput& a_input, hkpCharacterOutput& a_output) = 0;                                     // 07
	};
	static_assert(sizeof(hkpCharacterState) == 0x10);
}


===============================================
File: include/RE/H/hkpCharacterStateManager.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkpCharacterState.h"

namespace RE
{
	class hkpCharacterStateManager : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCharacterStateManager;
		inline static constexpr auto VTABLE = VTABLE_hkpCharacterStateManager;

		~hkpCharacterStateManager() override;  // 00

		// members
		hkpCharacterState* registeredState[hkpCharacterStateType::kTotal];  // 00
	};
	static_assert(sizeof(hkpCharacterStateManager) == 0x68);
}


===============================================
File: include/RE/H/hkpClosestRayHitCollector.h
===============================================
#pragma once

#include "RE/H/hkpRayHitCollector.h"
#include "RE/H/hkpWorldRayCastOutput.h"

namespace RE
{
	class hkpClosestRayHitCollector : public hkpRayHitCollector
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpClosestRayHitCollector;
		inline static constexpr auto VTABLE = VTABLE_hkpClosestRayHitCollector;

		// override (hkpRayHitCollector)
		void AddRayHit(const hkpCdBody& a_body, const hkpShapeRayCastCollectorOutput& a_hitInfo) override;  // 01

		~hkpClosestRayHitCollector() override;  // 00

		constexpr bool HasHit() noexcept { return rayHit.HasHit(); }

		constexpr void Reset() noexcept
		{
			hkpRayHitCollector::Reset();
			rayHit.Reset();
		}

		// members
		hkpWorldRayCastOutput rayHit;  // 10
	};
	static_assert(sizeof(hkpClosestRayHitCollector) == 0x70);
}


===============================================
File: include/RE/H/hkpCollidable.h
===============================================
#pragma once

#include "RE/C/CollisionLayers.h"
#include "RE/H/hkpCdBody.h"
#include "RE/H/hkpShape.h"
#include "RE/H/hkpTypedBroadPhaseHandle.h"

namespace RE
{
	struct hkAabbUint32;

	class hkpCollidable : public hkpCdBody
	{
	public:
		enum BelongsTo : std::uint32_t
		{
			kTerrain = 1 << 16
		};

		enum CollisionFilterInfo : std::uint32_t
		{
			kBelongsTo = 0xFFFF0000,
			kCollidesWith = 0x0000FFFF
		};

		enum class ForceCollideOntoPpuReasons
		{
			kUserRequest = 1 << 0,
			kShapeRequest = 1 << 1,
			kModifierRequest = 1 << 2,
			kShapeUnchecked = 1 << 3
		};

		struct BoundingVolumeData
		{
		public:
			// members
			std::uint32_t min[3];                   // 00
			std::uint8_t  expansionMin[3];          // 0C
			std::uint8_t  expansionShift;           // 0F
			std::uint32_t max[3];                   // 10
			std::uint8_t  expansionMax[3];          // 1C
			std::uint8_t  pad1F;                    // 1F
			std::uint16_t numChildShapeAabbs;       // 20
			std::uint16_t capacityChildShapeAabbs;  // 22
			std::uint32_t pad24;                    // 24
			hkAabbUint32* childShapeAabbs;          // 28
			hkpShapeKey*  childShapeKeys;           // 30
		};
		static_assert(sizeof(BoundingVolumeData) == 0x38);

		[[nodiscard]] COL_LAYER GetCollisionLayer() const
		{
			return static_cast<COL_LAYER>(broadPhaseHandle.collisionFilterInfo & 0x7F);
		}

		[[nodiscard]] void* GetOwner() const
		{
			return const_cast<void*>(stl::adjust_pointer<const void>(this, ownerOffset));
		}

		template <class T>
		T* GetOwner() const
		{
			return static_cast<T*>(GetOwner());
		}

		// members
		std::int8_t              ownerOffset;              // 20
		std::uint8_t             forceCollideOntoPpu;      // 21
		std::uint16_t            shapeSizeOnSpu;           // 22
		hkpTypedBroadPhaseHandle broadPhaseHandle;         // 24
		BoundingVolumeData       boundingVolumeData;       // 30
		float                    allowedPenetrationDepth;  // 68
		std::uint32_t            pad6C;                    // 6C
	};
	static_assert(sizeof(hkpCollidable) == 0x70);
}


===============================================
File: include/RE/H/hkpCollidableCollidableFilter.h
===============================================
#pragma once

namespace RE
{
	class hkpCollidable;

	class hkpCollidableCollidableFilter
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCollidableCollidableFilter;
		inline static constexpr auto VTABLE = VTABLE_hkpCollidableCollidableFilter;

		virtual ~hkpCollidableCollidableFilter();  // 00

		// add
		virtual bool IsCollisionEnabled(const hkpCollidable& a_collidableA, const hkpCollidable& a_collidableB) const = 0;  // 01
	};
	static_assert(sizeof(hkpCollidableCollidableFilter) == 0x8);
}


===============================================
File: include/RE/H/hkpCollisionEvent.h
===============================================
#pragma once

namespace RE
{
	class hkpRigidBody;
	class hkpSimpleConstraintContactMgr;

	struct hkpCollisionEvent
	{
	public:
		enum class CallbackSource
		{
			kSourceA = 0,
			kSourceB = 1,
			kSourceWorld
		};

		hkpCollisionEvent(CallbackSource a_source, hkpRigidBody* a_bodyA, hkpRigidBody* a_bodyB, hkpSimpleConstraintContactMgr* a_mgr) :
			source(a_source), contactMgr(a_mgr)
		{
			bodies[0] = a_bodyA;
			bodies[1] = a_bodyB;
		}

		// members
		CallbackSource                 source;      // 00
		hkpRigidBody*                  bodies[2];   // 04
		hkpSimpleConstraintContactMgr* contactMgr;  // 14
	};
	static_assert(sizeof(hkpCollisionEvent) == 0x20);
}


===============================================
File: include/RE/H/hkpCollisionFilter.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkpCollidableCollidableFilter.h"
#include "RE/H/hkpRayCollidableFilter.h"
#include "RE/H/hkpRayShapeCollectionFilter.h"
#include "RE/H/hkpShapeCollectionFilter.h"

namespace RE
{
	class hkpBvTreeShape;
	class hkpWorld;

	class hkpCollisionFilter :
		public hkReferencedObject,             // 00
		public hkpCollidableCollidableFilter,  // 08
		public hkpShapeCollectionFilter,       // 10
		public hkpRayShapeCollectionFilter,    // 18
		public hkpRayCollidableFilter          // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCollisionFilter;
		inline static constexpr auto VTABLE = VTABLE_hkpCollisionFilter;

		enum class hkpFilterType
		{
			kUnknown = 0,
			kNull = 1,
			kGroup = 2,
			kList = 3,
			kFilterCustom = 4,
			kFilterPair = 5,
			kFilterConstraint = 6,
		};

		~hkpCollisionFilter() override;  // 00

		// add
		virtual void Init(hkpWorld* world);

		// override (hkpShapeCollectionFilter)
		std::int32_t NumShapeKeyHitsLimitBreached(const hkpCollisionInput& a_input, const hkpCdBody& a_bodyA, const hkpCdBody& a_bodyB, const hkpBvTreeShape* a_shapeB, hkAabb& a_AABB, hkpShapeKey* a_shapeKeysInOut, std::int32_t a_shapeKeysCapacity) const override;  // 02

		// members
		std::uint32_t                                  pad30;  // 30
		std::uint32_t                                  pad34;  // 34
		stl::enumeration<hkpFilterType, std::uint32_t> type;   // 38
		std::uint32_t                                  pad3C;  // 3C
		std::uint32_t                                  pad40;  // 40
		std::uint32_t                                  pad44;  // 44
	};
	static_assert(sizeof(hkpCollisionFilter) == 0x48);
}


===============================================
File: include/RE/H/hkpCollisionInput.h
===============================================
#pragma once

#include "RE/H/hkBaseTypes.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkpCollisionDispatcher;
	class hkpCollisionFilter;
	class hkpConvexListFilter;

	struct hkpCollisionInput
	{
	public:
		struct Aabb32Info
		{
		public:
			// members
			hkVector4 bitOffsetLow;   // 00
			hkVector4 bitOffsetHigh;  // 10
			hkVector4 bitScale;       // 20
		};
		static_assert(sizeof(Aabb32Info) == 0x30);

		// members
		hkpCollisionDispatcher*    dispatcher;                // 00
		std::int32_t               weldClosestPoints;         // 08
		std::int32_t               forceAcceptContactPoints;  // 0C
		float                      tolerance;                 // 10
		std::uint32_t              pad14;                     // 14
		const hkpCollisionFilter*  filter;                    // 18
		const hkpConvexListFilter* convexListFilter;          // 20
		mutable std::int32_t       createPredictiveAgents;    // 28
		std::uint32_t              pad2C;                     // 2C
		Aabb32Info                 aabb32Info;                // 30
	};
	static_assert(sizeof(hkpCollisionInput) == 0x60);
}


===============================================
File: include/RE/H/hkpCompressedMeshShape.h
===============================================
#pragma once

#include "RE/H/hkAabb.h"
#include "RE/H/hkArray.h"
#include "RE/H/hkQsTransform.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkpShapeCollection.h"
#include "RE/H/hkpWeldingUtility.h"

namespace RE
{
	class hkpMeshMaterial;
	class hkpNamedMeshMaterial;

	class hkpCompressedMeshShape : public hkpShapeCollection
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpCompressedMeshShape;
		inline static constexpr auto VTABLE = VTABLE_hkpCompressedMeshShape;

		enum class MaterialType
		{
			MATERIAL_NONE,
			MATERIAL_SINGLE_VALUE_PER_CHUNK,
			MATERIAL_ONE_BYTE_PER_TRIANGLE,
			MATERIAL_TWO_BYTES_PER_TRIANGLE,
			MATERIAL_FOUR_BYTES_PER_TRIANGLE
		};

		class Chunk
		{
		public:
			//members
			hkVector4              offset;          // 00
			hkArray<std::uint16_t> vertices;        // 10
			hkArray<std::uint16_t> indices;         // 20
			hkArray<std::uint16_t> stripLengths;    // 30
			hkArray<std::uint16_t> weldingInfo;     // 40
			std::uint32_t          materialInfo;    // 50
			std::uint16_t          reference;       // 54
			std::uint16_t          transformIndex;  // 56
			std::uint64_t          pad58;           // 58
		};
		static_assert(sizeof(Chunk) == 0x60);

		class BigTriangle
		{
		public:
			//members
			std::uint16_t a;               // 00
			std::uint16_t b;               // 02
			std::uint16_t c;               // 04
			std::uint16_t pad06;           // 06
			std::uint32_t material;        // 08
			std::uint16_t weldingInfo;     // 0C
			std::uint16_t transformIndex;  // 0E
		};
		static_assert(sizeof(BigTriangle) == 0x10);

		class ConvexPiece
		{
		public:
			//members
			hkVector4              offset;          // 00
			hkArray<std::uint16_t> vertices;        // 10
			hkArray<std::uint16_t> faceVertices;    // 20
			hkArray<std::uint16_t> faceOffsets;     // 30
			std::uint16_t          reference;       // 40
			std::uint16_t          transformIndex;  // 42
			std::uint8_t           pad44[12];       // 44
		};
		static_assert(sizeof(ConvexPiece) == 0x50);

		~hkpCompressedMeshShape() override;  // 00

		// override (hkpShapeCollection)
		void         CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;     // 02
		std::int32_t CalcSizeForSpu(const CalcSizeForSpuInput& a_input, std::int32_t a_spuBufferSizeLeft) const override;  // 06
		void         GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const override;      // 07
		void         InitWeldingInfo(hkpWeldingUtility::WeldingType a_weldingType) override;                               // 0B
		void         SetWeldingInfo(hkpShapeKey a_key, std::int16_t a_weldingInfo) override;                               // 0C

		// members
		std::int32_t                                                   bitsPerIndex;                // 030
		std::int32_t                                                   bitsPerWIndex;               // 034
		std::int32_t                                                   wIndexMask;                  // 03C
		std::int32_t                                                   indexMask;                   // 038
		float                                                          radius;                      // 040
		stl::enumeration<hkpWeldingUtility::WeldingType, std::uint8_t> weldingType;                 // 044
		stl::enumeration<MaterialType, std::uint8_t>                   materialType;                // 045
		std::uint16_t                                                  pad46;                       // 046
		hkArray<std::uint32_t>                                         materials;                   // 048
		hkArray<std::uint16_t>                                         materials16;                 // 058
		hkArray<std::uint8_t>                                          materials8;                  // 068
		hkArray<hkQsTransform>                                         transforms;                  // 078
		hkArray<hkVector4>                                             bigVertices;                 // 088
		hkArray<BigTriangle>                                           bigTriangles;                // 098
		hkArray<Chunk>                                                 chunks;                      // 0A8
		hkArray<ConvexPiece>                                           convexPieces;                // 0B8
		float                                                          error;                       // 0C8
		std::uint32_t                                                  padCC;                       // 0CC
		hkAabb                                                         bounds;                      // 0D0
		std::uint32_t                                                  defaultCollisionFilterInfo;  // 0F0
		std::uint32_t                                                  padF4;                       // 0F4
		hkpMeshMaterial*                                               meshMaterials;               // 0F8
		std::uint16_t                                                  materialStriding;            // 100
		std::uint16_t                                                  numMaterials;                // 102
		std::uint32_t                                                  pad104;                      // 104
		hkArray<hkpNamedMeshMaterial>                                  namedMaterials;              // 108
		std::uint64_t                                                  pad118;                      // 118
	};
	static_assert(sizeof(hkpCompressedMeshShape) == 0x120);
}


===============================================
File: include/RE/H/hkpConstraintAtom.h
===============================================
#pragma once

namespace RE
{
	struct hkpConstraintAtom
	{
	public:
		enum AtomType
		{
			kInvalid = 0,

			kBridge,

			kSetLocalTransforms,
			kSetLocalTranslations,
			kSetLocalRotations,

			kBallSocket,
			kStiffSpring,

			kLin,
			kLinSoft,
			kLinLimit,
			kLinFriction,
			kLinMotor,

			k2DAng,

			kAng,
			kAngLimit,
			kTwistLimit,
			kConeLimit,
			kAngFriction,
			kAngMotor,

			kRagdollMotor,

			kPulley,
			kRackAndPinion,
			kCogWheel,

			kSetupStabilization,

			kOverwritePivot,

			kContact,

			// modifiers
			kModifier_SoftContact,
			kModifier_MassChanger,
			kModifier_ViscousSurface,
			kModifier_MovingSurface,
			kModifier_IgnoreConstraint,
			kModifier_CenterOfMassChanger,

			kMAX
		};

		enum SolvingMethod : uint8_t
		{
			kStabilized = 0,
			kOld = 1,
		};

		// members
		stl::enumeration<AtomType, uint16_t> type;
	};
	static_assert(sizeof(hkpConstraintAtom) == 0x2);

	struct hkpSetupStabilizationAtom : public hkpConstraintAtom
	{
		bool     enabled;   // 02
		float    maxAngle;  // 04
		uint64_t pad08;     // 08
	};
	static_assert(sizeof(hkpSetupStabilizationAtom) == 0x10);

	struct hkpBallSocketConstraintAtom : public hkpConstraintAtom
	{
		SolvingMethod solvingMethod;                // 02
		uint8_t       bodiesToNotify;               // 03
		hkUFloat8     velocityStabilizationFactor;  // 04
		float         maxImpulse;                   // 08
		float         inertiaStabilizationFactor;   // 0C
	};
	static_assert(sizeof(hkpBallSocketConstraintAtom) == 0x10);

	struct hkpSetLocalTransformsConstraintAtom : public hkpConstraintAtom
	{
		uint32_t    pad02;       // 02
		hkTransform transformA;  // 10
		hkTransform transformB;  // 50
	};
	static_assert(sizeof(hkpSetLocalTransformsConstraintAtom) == 0x90);

	struct hkp2dAngConstraintAtom : public hkpConstraintAtom
	{
		uint8_t freeRotationAxis;  // 02
	};
	static_assert(sizeof(hkp2dAngConstraintAtom) == 0x4);

	struct hkpAngLimitConstraintAtom : public hkpConstraintAtom
	{
		bool    enabled;                 // 02
		uint8_t limitAxis;               // 03
		float   minAngle;                // 04
		float   maxAngle;                // 08
		float   angularLimitsTauFactor;  // 0C
	};
	static_assert(sizeof(hkpAngLimitConstraintAtom) == 0x10);

	struct hkpTwistLimitConstraintAtom : public hkpConstraintAtom
	{
		bool    enabled;                 // 02
		uint8_t twistAxis;               // 03
		uint8_t refAxis;                 // 04
		float   minAngle;                // 08
		float   maxAngle;                // 0C
		float   angularLimitsTauFactor;  // 10
	};
	static_assert(sizeof(hkpTwistLimitConstraintAtom) == 0x14);

	struct hkpConeLimitConstraintAtom : public hkpConstraintAtom
	{
		enum MeasurementMode : uint8_t
		{
			kZeroWhenVectorsAligned = 0,
			kZeroWhenVectorsPerpendicular = 1
		};

		bool            enabled;                 // 02
		uint8_t         twistAxisInA;            // 03
		uint8_t         refAxisInB;              // 04
		MeasurementMode angleMeasurementMode;    // 05
		uint8_t         memOffsetToAngleOffset;  // 06
		float           minAngle;                // 08
		float           maxAngle;                // 0C
		float           angularLimitsTauFactor;  // 10
	};
	static_assert(sizeof(hkpConeLimitConstraintAtom) == 0x14);

	struct hkpAngFrictionConstraintAtom : public hkpConstraintAtom
	{
		bool    enabled;            // 02
		uint8_t firstFrictionAxis;  // 03
		uint8_t numFrictionAxes;    // 04
		float   maxFrictionTorque;  // 08
	};
	static_assert(sizeof(hkpAngFrictionConstraintAtom) == 0xC);

	struct hkpAngMotorConstraintAtom : public hkpConstraintAtom
	{
		bool      enabled;                                  // 02
		uint8_t   motorAxis;                                // 03
		int16_t   initializedOffset;                        // 04
		int16_t   previousTargetAngleOffset;                // 06
		int16_t   correspondingAngLimitSolverResultOffset;  // 08
		float     targetAngle;                              // 0C
		uintptr_t motor;                                    // 10
	};
	static_assert(sizeof(hkpAngMotorConstraintAtom) == 0x18);

	struct hkpRagdollMotorConstraintAtom : public hkpConstraintAtom
	{
		bool      enabled;                     // 02
		int16_t   initializedOffset;           // 04
		int16_t   previousTargetAnglesOffset;  // 06
		hkMatrix3 target_bRca;                 // 10
		uintptr_t motors[3];                   // 40
	};
	static_assert(sizeof(hkpRagdollMotorConstraintAtom) == 0x60);
}


===============================================
File: include/RE/H/hkpConstraintData.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkpSolverResults;
	class hkpConstraintRuntime;

	class hkpConstraintData : public hkReferencedObject
	{
	public:
		enum ConstraintType
		{
			kBallAndSocket = 0,
			kHinge = 1,
			kLimitedHinge = 2,
			kPointToPath = 3,
			kPrismatic = 6,
			kRagdoll = 7,
			kStiffSpring = 8,
			kWheel = 9,
			kGeneric = 10,
			kContact = 11,
			kBreakable = 12,
			kMalleable = 13,
			kPointToPlane = 14,

			kPulley = 15,

			kRotational = 16,

			kHingeLimits = 18,
			kRagdollLimits = 19,

			kCustom = 20,

			kRackAndPinion = 21,
			kCogWheel = 22,

			kChainTypes = 100,
			kStiffSpringChain = 100,
			kBallSocketChain = 101,
			kPoweredChain = 102
		};

		enum SolvingMethod
		{
			kStabilized = 0,
			kOld = 1
		};

		struct RuntimeInfo
		{
			int32_t sizeOfExternalRuntime;
			int32_t numSolverResults;
		};

		inline static constexpr auto RTTI = RTTI_hkpConstraintData;
		inline static constexpr auto VTABLE = VTABLE_hkpConstraintData;

		~hkpConstraintData() override;  // 00

		// add
		virtual void             SetMaxLinearImpulse(float a_maxImpulse);                                                                              // 03
		virtual float            GetMaxLinearImpulse() const;                                                                                          // 04
		virtual void             SetSolvingMethod(SolvingMethod a_method);                                                                             // 05
		virtual hkResult         GetInertiaStabilizationFactor(float& a_inertiaStabilizationFactorOut) const;                                          // 06
		virtual hkResult         SetInertiaStabilizationFactor(const float a_inertiaStabilizationFactorIn);                                            // 07
		virtual void             SetBodyToNotify(int32_t a_bodyIdx);                                                                                   // 08
		virtual uint8_t          GetNotifiedBodyIndex() const;                                                                                         // 09
		virtual bool             IsValid() const = 0;                                                                                                  // 0A
		virtual int32_t          GetType() const = 0;                                                                                                  // 0B
		virtual void             GetRuntimeInfo(bool bWantRuntime, RuntimeInfo& a_infoOut) const = 0;                                                  // 0C
		virtual hkpSolverResults GetSolverResults(hkpConstraintRuntime* a_runtime);                                                                    // 0D
		virtual void             AddInstance(hkpConstraintInstance* a_constraint, hkpConstraintRuntime* a_runtime, int32_t a_sizeOfRuntime) const;     // 0E
		virtual void             RemoveInstance(hkpConstraintInstance* a_constraint, hkpConstraintRuntime* a_runtime, int32_t a_sizeOfRuntime) const;  // 0F

		// members
		uint64_t userData;  // 10
	};
	static_assert(sizeof(hkpConstraintData) == 0x18);
}


===============================================
File: include/RE/H/hkpConstraintInfo.h
===============================================
#pragma once

namespace RE
{
	struct hkpConstraintInfo
	{
		std::int32_t maxSizeOfSchema;     // 00
		std::int32_t sizeOfSchemas;       // 04
		std::int32_t numSolverResults;    // 08
		std::int32_t numSolverElemTemps;  // 0C
	};
	static_assert(sizeof(hkpConstraintInfo) == 0x10);
}


===============================================
File: include/RE/H/hkpConstraintInstance.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkpConstraintData;
	class hkpConstraintOwner;
	struct hkpModifierConstraintAtom;

	class hkpConstraintInstance : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpConstraintInstance;
		inline static constexpr auto VTABLE = VTABLE_hkpConstraintInstance;

		~hkpConstraintInstance() override;  // 00

		inline hkpRigidBody* GetRigidBodyA() const
		{
			return reinterpret_cast<hkpRigidBody*>(entities[0]);
		}

		inline hkpRigidBody* GetRigidBodyB() const
		{
			return reinterpret_cast<hkpRigidBody*>(entities[1]);
		}

		// members
		hkpConstraintOwner*        owner;                // 10
		hkpConstraintData*         data;                 // 18
		hkpModifierConstraintAtom* constraintModifiers;  // 20
		hkpEntity*                 entities[2];          // 28
	};
	static_assert(sizeof(hkpConstraintInstance) == 0x38);
}


===============================================
File: include/RE/H/hkpConstraintOwner.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkpConstraintInfo.h"

namespace RE
{
	class hkpConstraintInstance;

	class hkpConstraintOwner : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpConstraintOwner;
		inline static constexpr auto VTABLE = VTABLE_hkpConstraintOwner;

		~hkpConstraintOwner() override;  // 00

		// add
		virtual void AddConstraintToCriticalLockedIsland(hkpConstraintInstance* a_constraint);         // 03 - { return; }
		virtual void RemoveConstraintFromCriticalLockedIsland(hkpConstraintInstance* a_constraint);    // 04 - { return; }
		virtual void AddCallbackRequest(hkpConstraintInstance* a_constraint, std::int32_t a_request);  // 05 - { return; }
		virtual void CheckAccessRW();                                                                  // 06 - { return; }

		// members
		hkpConstraintInfo constraintInfo;  // 10
	};
	static_assert(sizeof(hkpConstraintOwner) == 0x20);
}


===============================================
File: include/RE/H/hkpContactListener.h
===============================================
#pragma once

namespace RE
{
	struct hkpCollisionEvent;
	struct hkpContactPointEvent;
	struct hkpContactPointAddedEvent;
	struct hkpContactPointRemovedEvent;
	struct hkpContactProcessEvent;

	class hkpContactListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpContactListener;
		inline static constexpr auto VTABLE = VTABLE_hkpContactListener;

		// add
		virtual void ContactPointCallback(const hkpContactPointEvent&) {}   // 00
		virtual void CollisionAddedCallback(const hkpCollisionEvent&) {}    // 01
		virtual void CollisionRemovedCallback(const hkpCollisionEvent&) {}  // 02

		virtual ~hkpContactListener() = default;  // 04

		virtual void ContactPointAddedCallback(hkpContactPointAddedEvent&) {}      // 05
		virtual void ContactPointRemovedCallback(hkpContactPointRemovedEvent&) {}  // 06
		virtual void ContactProcessCallback(hkpContactProcessEvent&) {}            // 07
	};
	static_assert(sizeof(hkpContactListener) == 0x8);
}


===============================================
File: include/RE/H/hkpContactPointEvent.h
===============================================
#pragma once

#include "RE/H/hkpCollisionEvent.h"
#include "RE/H/hkpRigidBody.h"

namespace RE
{
	class hkContactPoint;
	class hkpContactPointProperties;
	class hkpVelocityAccumulator;

	using hkpShapeKey = std::uint32_t;

	struct hkpContactPointEvent : public hkpCollisionEvent
	{
	public:
		enum class Type
		{
			kTOI,
			kExpandManifold,
			kManifold,

			kManifoldAtEndOfStep,
			kManifoldFromSavedContactPoint
		};

		inline hkpShapeKey* GetShapeKeys(std::uint32_t a_bodyIdx) const
		{
			if (a_bodyIdx == 0 || a_bodyIdx == 1) {
				if (bodies[a_bodyIdx]->numShapeKeysInContactPointProperties > 0) {
					return shapeKeyStorage + (a_bodyIdx * bodies[0]->numShapeKeysInContactPointProperties);
				}
			}
			return nullptr;
		}

		// members
		Type                       type;                            // 20
		std::uint32_t              pad24;                           // 24
		hkContactPoint*            contactPoint;                    // 28
		hkpContactPointProperties* contactPointProperties;          // 30
		bool                       firingCallbacksForFullManifold;  // 38
		bool                       firstCallbackForFullManifold;    // 39
		bool                       lastCallbackForFullManifold;     // 3A
		float*                     separatingVelocity;              // 40
		float*                     rotateNormal;                    // 48
		hkpShapeKey*               shapeKeyStorage;                 // 50
		hkpVelocityAccumulator*    accumulators[2];                 // 58
	};
	static_assert(sizeof(hkpContactPointEvent) == 0x68);
}


===============================================
File: include/RE/H/hkpConvexListFilter.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"

namespace RE
{
	class hkpCdBody;

	struct hkpCollisionInput;

	class hkpConvexListFilter : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpConvexListFilter;
		inline static constexpr auto VTABLE = VTABLE_hkpConvexListFilter;

		enum class ConvexListCollisionType
		{
			kNormal = 0,
			kList,
			kConvex
		};

		~hkpConvexListFilter() override;  // 00

		// add
		virtual ConvexListCollisionType GetConvexListCollisionType(const hkpCdBody& a_convexListBody, const hkpCdBody& a_otherBody, const hkpCollisionInput& a_input) const = 0;  // 03
	};
	static_assert(sizeof(hkpConvexListFilter) == 0x10);
}


===============================================
File: include/RE/H/hkpConvexShape.h
===============================================
#pragma once

#include "RE/H/hkpSphereRepShape.h"

namespace RE
{
	class hkpConvexShape : public hkpSphereRepShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpConvexShape;
		inline static constexpr auto VTABLE = VTABLE_hkpConvexShape;

		~hkpConvexShape() override;  // 00

		// override (hkpSphereRepShape)
		float GetMaximumProjection(const hkVector4& a_direction) const override;                                                                         // 03
		bool  IsConvex() const override;                                                                                                                 // 05 - { return true; }
		void  CastRayWithCollectorImpl(const hkpShapeRayCastInput& a_input, const hkpCdBody& a_cdBody, hkpRayHitCollector& a_collector) const override;  // 09

		// add
		virtual void          GetCentreImpl(hkVector4& a_centreOut) = 0;  // 0D
		virtual void          Unk_0E(void) = 0;                           // 0E
		virtual void          Unk_0F(void) = 0;                           // 0F
		virtual std::uint32_t Unk_10(void);                               // 10 - { return 2; }
		virtual void          Unk_11(void);                               // 11

		// members
		float         radius;  // 20
		std::uint32_t pad1C;   // 24
	};
	static_assert(sizeof(hkpConvexShape) == 0x28);
}


===============================================
File: include/RE/H/hkpEaseConstraintsAction.h
===============================================
#pragma once

#include "RE/H/hkpArrayAction.h"

namespace RE
{
	class hkpEaseConstraintsAction : public hkpArrayAction
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpEaseConstraintsAction;
		inline static constexpr auto VTABLE = VTABLE_hkpEaseConstraintsAction;

		virtual ~hkpEaseConstraintsAction() override;  // 00

		// add
		virtual void Unk_03(void) override;  // 03
		virtual void Unk_07(void) override;  // 07

		// members
		float                           duration;             // 40
		float                           timePassed;           // 44
		hkArray<hkpConstraintInstance*> originalConstraints;  // 48
		hkArray<float>                  originalLimits;       // 58
	};
	static_assert(sizeof(hkpEaseConstraintsAction) == 0x68);
}


===============================================
File: include/RE/H/hkpEntity.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkBaseTypes.h"
#include "RE/H/hkSmallArray.h"
#include "RE/H/hkpFixedRigidMotion.h"
#include "RE/H/hkpMaterial.h"
#include "RE/H/hkpWorldObject.h"

namespace RE
{
	class hkpConstraintInstance;
	class hkLocalFrame;
	class hkSpuCollisionCallbackUtil;
	class hkpAction;
	class hkpBreakableBody;
	class hkpContactListener;
	class hkpEntityActivationListener;
	class hkpEntityListener;
	class hkpSimulationIsland;
	struct hkConstraintInternal;

	class hkpEntity : public hkpWorldObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpEntity;
		inline static constexpr auto VTABLE = VTABLE_hkpEntity;

		enum class SpuCollisionCallbackEventFilter
		{
			kNone = 0,
			kContactPointAdded = 1 << 0,
			kContactPointProcess = 1 << 1,
			kContactPointRemoved = 1 << 2,
			kContactPointAddedOrProcess = kContactPointAdded | kContactPointProcess
		};

		class SmallArraySerializeOverrideType
		{
		public:
			// members
			void*         data;              // 00
			std::uint16_t size;              // 08
			std::uint16_t capacityAndFlags;  // 0A
			std::uint32_t pad0C;             // 0C
		};
		static_assert(sizeof(SmallArraySerializeOverrideType) == 0x10);

		struct SpuCollisionCallback
		{
		public:
			// members
			hkSpuCollisionCallbackUtil*                                     util;         // 00
			std::uint16_t                                                   capacity;     // 08
			stl::enumeration<SpuCollisionCallbackEventFilter, std::uint8_t> eventFilter;  // 0A
			std::uint8_t                                                    userFilter;   // 0B
			std::uint32_t                                                   pad0C;        // 0C
		};
		static_assert(sizeof(SpuCollisionCallback) == 0x10);

		struct ExtendedListeners
		{
		public:
			// members
			hkSmallArray<hkpEntityActivationListener*> activationListeners;  // 00
			hkSmallArray<hkpEntityListener*>           entityListeners;      // 10
		};
		static_assert(sizeof(ExtendedListeners) == 0x20);

		~hkpEntity() override;  // 00

		// override (hkpWorldObject)
		void           CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02
		hkMotionState* GetMotionState() override;                                                                         // 05 - { return 0; }

		// add
		virtual void DeallocateInternalArrays();  // 06

		// members
		hkpMaterial                        material;                              // 0D0
		std::uint32_t                      pad00C;                                // 0DC
		void*                              limitContactImpulseUtilAndFlag;        // 0E0
		float                              damageMultiplier;                      // 0E8
		std::uint32_t                      pad01C;                                // 0EC
		hkpBreakableBody*                  breakableBody;                         // 0F0
		std::uint32_t                      solverData;                            // 0F8
		hkObjectIndex                      storageIndex;                          // 0FC
		std::uint16_t                      contactPointCallbackDelay;             // 0FE
		hkSmallArray<hkConstraintInternal> constraintsMaster;                     // 100
		hkArray<hkpConstraintInstance*>    constraintsSlave;                      // 110
		hkArray<std::uint8_t>              constraintRuntime;                     // 120
		hkpSimulationIsland*               simulationIsland;                      // 130
		std::int8_t                        autoRemoveLevel;                       // 138
		std::uint8_t                       numShapeKeysInContactPointProperties;  // 139
		std::uint8_t                       responseModifierFlags;                 // 13A
		std::uint8_t                       pad13B;                                // 13B
		std::uint32_t                      uid;                                   // 13C
		SpuCollisionCallback               spuCollisionCallback;                  // 140
		hkpMaxSizeMotion                   motion;                                // 150
		hkSmallArray<hkpContactListener*>  contactListeners;                      // 290
		hkSmallArray<hkpAction*>           actions;                               // 2A0
		hkRefPtr<hkLocalFrame>             localFrame;                            // 2B0
		mutable ExtendedListeners*         extendedListeners;                     // 2B8
		std::uint32_t                      npData;                                // 2C0
		std::uint32_t                      pad2C4;                                // 2C4
		std::uint64_t                      pad2C8;                                // 2C8
	};
	static_assert(sizeof(hkpEntity) == 0x2D0);
}


===============================================
File: include/RE/H/hkpEntityListener.h
===============================================
#pragma once

namespace RE
{
	class hkpEntity;

	class hkpEntityListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpEntityListener;
		inline static constexpr auto VTABLE = VTABLE_hkpEntityListener;

		virtual ~hkpEntityListener();  // 00

		// add
		virtual void EntityAddedCallback(hkpEntity* a_entity);          // 01 - { return; }
		virtual void EntityRemovedCallback(hkpEntity* a_entity);        // 02 - { return; }
		virtual void EntityShapeSetCallback(hkpEntity* a_entity);       // 03
		virtual void EntitySetMotionTypeCallback(hkpEntity* a_entity);  // 04 - { return; }
		virtual void EntityDeletedCallback(hkpEntity* a_entity);        // 05 - { return; }
	};
	static_assert(sizeof(hkpEntityListener) == 0x8);
}


===============================================
File: include/RE/H/hkpFixedRigidMotion.h
===============================================
#pragma once

#include "RE/H/hkpKeyframedRigidMotion.h"

namespace RE
{
	class hkpFixedRigidMotion : public hkpKeyframedRigidMotion
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpFixedRigidMotion;
		inline static constexpr auto VTABLE = VTABLE_hkpFixedRigidMotion;

		~hkpFixedRigidMotion() override;  // 00

		// override (hkpKeyframedRigidMotion)
		void SetLinearVelocity(const hkVector4& a_newVel) override;         // 10 - { return; }
		void SetAngularVelocity(const hkVector4& a_newVel) override;        // 11 - { return; }
		void SetStepPosition(float a_position, float a_timestep) override;  // 1A - { return; }

		// add
		virtual void GetPositionAndVelocities(hkpMotion* a_motionOut);  // 1C
	};
	static_assert(sizeof(hkpFixedRigidMotion) == 0x140);
}


===============================================
File: include/RE/H/hkpKeyframedRigidMotion.h
===============================================
#pragma once

#include "RE/H/hkpMotion.h"

namespace RE
{
	class hkpMaxSizeMotion;

	class hkpKeyframedRigidMotion : public hkpMotion
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpKeyframedRigidMotion;
		inline static constexpr auto VTABLE = VTABLE_hkpKeyframedRigidMotion;

		~hkpKeyframedRigidMotion() override;  // 00

		// override (hkpMotion)
		void SetMass(float a_mass) override;                                                                                                           // 03 - { return; }
		void SetMassInv(float a_massInv) override;                                                                                                     // 04 - { return; }
		void GetInertiaLocal(hkMatrix3& a_inertiaOut) const override;                                                                                  // 05
		void GetInertiaWorld(hkMatrix3& a_inertiaOut) const override;                                                                                  // 06
		void SetInertiaLocal(const hkMatrix3& a_inertia) override;                                                                                     // 07 - { return; }
		void SetInertiaInvLocal(const hkMatrix3& a_inertiaInv) override;                                                                               // 08 - { return; }
		void GetInertiaInvLocal(hkMatrix3& a_inertiaInvOut) const override;                                                                            // 09
		void GetInertiaInvWorld(hkMatrix3& a_inertiaInvOut) const override;                                                                            // 0A
		void GetProjectedPointVelocity(const hkVector4& a_point, const hkVector4& a_normal, float& a_velOut, float& a_invVirtMassOut) const override;  // 12
		void ApplyLinearImpulse(const hkVector4& a_impulse) override;                                                                                  // 13 - { return; }
		void ApplyPointImpulse(const hkVector4& a_impulse, const hkVector4& a_point) override;                                                         // 14 - { return; }
		void ApplyAngularImpulse(const hkVector4& a_impulse) override;                                                                                 // 15 - { return; }
		void ApplyForce(const float a_deltaTime, const hkVector4& a_force) override;                                                                   // 16 - { return; }
		void ApplyForce(const float a_deltaTime, const hkVector4& a_force, const hkVector4& a_point) override;                                         // 17 - { return; }
		void ApplyTorque(const float a_deltaTime, const hkVector4& a_torque) override;                                                                 // 18 - { return; }

		// add
		virtual void SetStepPosition(float a_position, float a_timestep);  // 1A - { return; }
		virtual void SetStoredMotion(hkpMaxSizeMotion* a_savedMotion);     // 1B

		hkVector4 GetPointVelocity(const hkVector4& a_point) const
		{
			hkVector4 centerOfMassInWorld = motionState.sweptTransform.centerOfMass1;
			return linearVelocity + angularVelocity.Cross(a_point - centerOfMassInWorld);
		}
	};
	static_assert(sizeof(hkpKeyframedRigidMotion) == 0x140);

	class hkpMaxSizeMotion : public hkpKeyframedRigidMotion
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpMaxSizeMotion;
	};
	static_assert(sizeof(hkpMaxSizeMotion) == 0x140);
}


===============================================
File: include/RE/H/hkpLimitedHingeConstraintData.h
===============================================
#pragma once

#include "RE/H/hkpConstraintAtom.h"
#include "RE/H/hkpConstraintData.h"

namespace RE
{
	class hkpLimitedHingeConstraintData : public hkpConstraintData
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpLimitedHingeConstraintData;
		inline static constexpr auto VTABLE = VTABLE_hkpLimitedHingeConstraintData;

		struct Atoms
		{
			struct hkpSetLocalTransformsConstraintAtom transforms;
			struct hkpSetupStabilizationAtom           setupStabilization;
			struct hkpAngMotorConstraintAtom           angMotor;
			struct hkpAngFrictionConstraintAtom        angFriction;
			struct hkpAngLimitConstraintAtom           angLimit;
			struct hkp2dAngConstraintAtom              twoDAng;
			struct hkpBallSocketConstraintAtom         ballSocket;
		};
		static_assert(sizeof(Atoms) == 0xF0);

		// members
		Atoms atoms;  // 18
	};
	static_assert(sizeof(hkpLimitedHingeConstraintData) == 0x110);
}


===============================================
File: include/RE/H/hkpLinearCastCollisionInput.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"
#include "RE/H/hkpCollisionInput.h"

namespace RE
{
	struct hkpCollisionAgentConfig;

	struct hkpLinearCastCollisionInput : public hkpCollisionInput
	{
	public:
		// members
		hkVector4                path;                 // 60
		float                    maxExtraPenetration;  // 70
		float                    cachedPathLength;     // 74
		hkpCollisionAgentConfig* config;               // 78
	};
	static_assert(sizeof(hkpLinearCastCollisionInput) == 0x80);
}


===============================================
File: include/RE/H/hkpLinearCastInput.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	struct hkpLinearCastInput
	{
	public:
		// members
		hkVector4     to;                   // 00
		float         maxExtraPenetration;  // 10
		float         startPointTolerance;  // 14
		std::uint64_t pad18;                // 18
	};
	static_assert(sizeof(hkpLinearCastInput) == 0x20);
}


===============================================
File: include/RE/H/hkpLinkedCollidable.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkpCollidable.h"

namespace RE
{
	struct hkpAgentNnEntry;

	class hkpLinkedCollidable : public hkpCollidable
	{
	public:
		struct CollisionEntry
		{
		public:
			// members
			hkpAgentNnEntry*     agentEntry;  // 00
			hkpLinkedCollidable* partner;     // 08
		};
		static_assert(sizeof(CollisionEntry) == 0x10);

		// members
		hkArray<CollisionEntry> collisionEntries;  // 70
	};
	static_assert(sizeof(hkpLinkedCollidable) == 0x80);
}


===============================================
File: include/RE/H/hkpListShape.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkpShapeCollection.h"

namespace RE
{
	class hkpListShape : public hkpShapeCollection
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpListShape;
		inline static constexpr auto VTABLE = VTABLE_hkpListShape;

		enum
		{
			kMaxChildrenForSPUMidPhase = 252,
			kMaxDisabledChildren = 256
		};

		enum class ListShapeFlags
		{
			kNone = 0,
			kDisableSPUCacheForListChildInfo = 1 << 0
		};

		struct ChildInfo
		{
		public:
			// members
			alignas(0x10) const hkpShape* shape;       // 00
			std::uint32_t        collisionFilterInfo;  // 08
			mutable std::int32_t shapeSize;            // 0C
			mutable std::int32_t numChildShapes;       // 10
			std::uint32_t        pad14;                // 14
			std::uint64_t        pad18;                // 18
		};
		static_assert(sizeof(ChildInfo) == 0x20);

		~hkpListShape() override;  // 00

		// override (hkpShapeCollection)
		void         CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;                                          // 02
		std::int32_t CalcSizeForSpu(const CalcSizeForSpuInput& a_input, std::int32_t a_spuBufferSizeLeft) const override;                                       // 06
		void         GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const override;                                           // 07
		bool         CastRayImpl(const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output) const override;                                          // 08
		void         CastRayWithCollectorImpl(const hkpShapeRayCastInput& a_input, const hkpCdBody& a_cdBody, hkpRayHitCollector& a_collector) const override;  // 09

		// override (hkpShapeContainer)
		std::int32_t    GetNumChildShapes() const override;                                         // 01 - { return m_childInfo.getSize() - m_numDisabledChildren; }
		hkpShapeKey     GetFirstKey() const override;                                               // 02 - { return hkpListShape::getNextKey(hkpShapeKey(-1)); }
		hkpShapeKey     GetNextKey(hkpShapeKey a_oldKey) const override;                            // 03
		std::uint32_t   GetCollisionFilterInfo(hkpShapeKey a_key) const override;                   // 04
		const hkpShape* GetChildShape(hkpShapeKey a_key, hkpShapeBuffer& a_buffer) const override;  // 05

		// members
		hkArray<ChildInfo> childInfo;            // 30
		std::uint16_t      flags;                // 40
		std::uint16_t      numDisabledChildren;  // 42
		std::uint32_t      pad44;                // 44
		hkVector4          aabbHalfExtents;      // 50
		hkVector4          aabbCenter;           // 60
		std::uint32_t      enabledChildren[8];   // 70
	};
	static_assert(sizeof(hkpListShape) == 0x90);
}


===============================================
File: include/RE/H/hkpMaterial.h
===============================================
#pragma once

#include "RE/H/hkBaseTypes.h"

namespace RE
{
	class hkpMaterial
	{
	public:
		enum class ResponseType
		{
			kInvalid,
			kSimpleContact,
			kReporting,
			kNone,

			kTotal
		};

		[[nodiscard]] ResponseType GetResponseType() const;
		void                       SetResponseType(ResponseType a_type);

		// members
		stl::enumeration<ResponseType, std::uint8_t> responseType;               // 00
		std::uint8_t                                 pad01;                      // 01
		hkHalf                                       rollingFrictionMultiplier;  // 02
		float                                        friction;                   // 04
		float                                        restitution;                // 08
	};
	static_assert(sizeof(hkpMaterial) == 0xC);
}


===============================================
File: include/RE/H/hkpMeshMaterial.h
===============================================
#pragma once

namespace RE
{
	class hkpMeshMaterial
	{
	public:
		//members
		std::uint32_t filterInfo;  // 00
	};
	static_assert(sizeof(hkpMeshMaterial) == 0x4);
}


===============================================
File: include/RE/H/hkpMoppAabbCastVirtualMachine.h
===============================================
#pragma once

namespace RE
{
	class hkMoppBvTreeShapeBase;

	class hkpMoppAabbCastVirtualMachine
	{
	public:
		struct hkpAabbCastInput
		{
		public:
			std::uint64_t           unk00;      // 00
			std::uint64_t           unk08;      // 08
			std::uint64_t           unk10;      // 10
			std::uint64_t           unk18;      // 18
			std::uint64_t           unk20;      // 20
			std::uint64_t           unk28;      // 28
			std::uint64_t           unk30;      // 30
			std::uint64_t           unk38;      // 38
			hkMoppBvTreeShapeBase** treeShape;  // 40
		};
	};
}


===============================================
File: include/RE/H/hkpMoppBvTreeShape.h
===============================================
#pragma once

#include "RE/H/hkMoppBvTreeShapeBase.h"
#include "RE/H/hkpSingleShapeContainer.h"

namespace RE
{
	class hkpMoppBvTreeShape : public hkMoppBvTreeShapeBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpMoppBvTreeShape;
		inline static constexpr auto VTABLE = VTABLE_hkpMoppBvTreeShape;

		~hkpMoppBvTreeShape() override;  // 00

		// override (hkMoppBvTreeShapeBase)
		void                     CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;                                                       // 02
		const hkpShapeContainer* GetContainer() const override;                                                                                                                          // 04
		std::int32_t             CalcSizeForSpu(const CalcSizeForSpuInput& a_input, std::int32_t a_spuBufferSizeLeft) const override;                                                    // 06
		void                     GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const override;                                                        // 07
		bool                     CastRayImpl(const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output) const override;                                                       // 08
		void                     CastRayWithCollectorImpl(const hkpShapeRayCastInput& a_input, const hkpCdBody& a_cdBody, hkpRayHitCollector& a_collector) const override;               // 09
		hkVector4Comparison      CastRayBundleImpl(const hkpShapeRayBundleCastInput& a_input, hkpShapeRayBundleCastOutput& a_output, const hkVector4Comparison& a_mask) const override;  // 0A

		// members
		hkpSingleShapeContainer child;      // 50
		mutable std::int32_t    childSize;  // 60
		std::uint32_t           pad64;      // 64
		std::uint64_t           pad68;      // 68
	};
	static_assert(sizeof(hkpMoppBvTreeShape) == 0x70);
}


===============================================
File: include/RE/H/hkpMoppCode.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkpMoppCode : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpMoppCode;
		inline static constexpr auto VTABLE = VTABLE_hkpMoppCode;

		enum class BuildType
		{
			kBuildWithChunkSubdivision = 0,
			kBuildWithoutChunkSubdivision = 1,
			kBuildNotSet = 2
		};

		struct CodeInfo
		{
		public:
			// members
			hkVector4 offset;  // 00
		};
		static_assert(sizeof(CodeInfo) == 0x10);

		~hkpMoppCode() override;  // 00

		// members
		CodeInfo                                 info;       // 10
		hkArray<std::uint8_t>                    data;       // 20
		stl::enumeration<BuildType, std::int8_t> buildType;  // 30
		std::uint8_t                             pad31;      // 31
		std::uint16_t                            pad32;      // 32
		std::uint32_t                            pad34;      // 34
		std::uint64_t                            pad38;      // 38
	};
	static_assert(sizeof(hkpMoppCode) == 0x40);
}


===============================================
File: include/RE/H/hkpMotion.h
===============================================
#pragma once

#include "RE/H/hkBaseTypes.h"
#include "RE/H/hkMotionState.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkMatrix3;
	class hkQuaternion;
	class hkTransform;
	class hkpMaxSizeMotion;

	class hkpMotion : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpMotion;
		inline static constexpr auto VTABLE = VTABLE_hkpMotion;

		enum
		{
			kNumInactiveFramesToDeactivate = 5
		};

		enum class MotionType
		{
			kInvalid,
			kDynamic,
			kSphereInertia,
			kBoxInertia,
			kKeyframed,
			kFixed,
			kThinBoxInertia,
			kCharacter,

			kTotal
		};

		~hkpMotion() override;  // 00

		// add
		virtual void SetMass(float a_mass);                                                                                                               // 03 - { SetMassInv(a_mass); }
		virtual void SetMassInv(float a_massInv);                                                                                                         // 04 - { inertiaAndMassInv.quad.m128_f32[3] = a_massInv; }
		virtual void GetInertiaLocal(hkMatrix3& a_inertiaOut) const = 0;                                                                                  // 05
		virtual void GetInertiaWorld(hkMatrix3& a_inertiaOut) const = 0;                                                                                  // 06
		virtual void SetInertiaLocal(const hkMatrix3& a_inertia) = 0;                                                                                     // 07
		virtual void SetInertiaInvLocal(const hkMatrix3& a_inertiaInv) = 0;                                                                               // 08
		virtual void GetInertiaInvLocal(hkMatrix3& a_inertiaInvOut) const = 0;                                                                            // 09
		virtual void GetInertiaInvWorld(hkMatrix3& a_inertiaInvOut) const = 0;                                                                            // 0A
		virtual void SetCenterOfMassInLocal(const hkVector4& a_centerOfMass);                                                                             // 0B
		virtual void SetPosition(const hkVector4& a_position);                                                                                            // 0C
		virtual void SetRotation(const hkQuaternion& a_rotation);                                                                                         // 0D
		virtual void SetPositionAndRotation(const hkVector4& a_position, const hkQuaternion& a_rotation);                                                 // 0E
		virtual void SetTransform(const hkTransform& a_transform);                                                                                        // 0F
		virtual void SetLinearVelocity(const hkVector4& a_newVel);                                                                                        // 10 - { linearVelocity = a_newVel; }
		virtual void SetAngularVelocity(const hkVector4& a_newVel);                                                                                       // 11 - { angularVelocity = a_newVel; }
		virtual void GetProjectedPointVelocity(const hkVector4& a_point, const hkVector4& a_normal, float& a_velOut, float& a_invVirtMassOut) const = 0;  // 12
		virtual void ApplyLinearImpulse(const hkVector4& a_impulse);                                                                                      // 13
		virtual void ApplyPointImpulse(const hkVector4& a_impulse, const hkVector4& a_point) = 0;                                                         // 14
		virtual void ApplyAngularImpulse(const hkVector4& a_impulse) = 0;                                                                                 // 15
		virtual void ApplyForce(const float a_deltaTime, const hkVector4& a_force) = 0;                                                                   // 16
		virtual void ApplyForce(const float a_deltaTime, const hkVector4& a_force, const hkVector4& a_point) = 0;                                         // 17
		virtual void ApplyTorque(const float a_deltaTime, const hkVector4& a_torque) = 0;                                                                 // 18
		virtual void GetMotionStateAndVelocitiesAndDeactivationType(hkpMotion* a_motionOut);                                                              // 19

		float GetMass()
		{
			float mass = reinterpret_cast<float*>(&inertiaAndMassInv.quad)[3];
			if (mass != 0.0f) {
				return 1.0f / mass;
			}
			return 0.0f;
		}

		// members
		stl::enumeration<MotionType, std::uint8_t> type;                              // 010
		std::uint8_t                               deactivationIntegrateCounter;      // 011
		std::uint16_t                              deactivationNumInactiveFrames[2];  // 012
		std::uint16_t                              pad016;                            // 016
		std::uint64_t                              pad018;                            // 018
		hkMotionState                              motionState;                       // 020
		hkVector4                                  inertiaAndMassInv;                 // 0D0
		hkVector4                                  linearVelocity;                    // 0E0
		hkVector4                                  angularVelocity;                   // 0F0
		hkVector4                                  deactivationRefPosition[2];        // 100
		std::uint32_t                              deactivationRefOrientation[2];     // 120
		hkpMaxSizeMotion*                          savedMotion;                       // 128
		std::uint16_t                              savedQualityTypeIndex;             // 130
		std::uint16_t                              pad132;                            // 132
		hkHalf                                     gravityFactor;                     // 134
		std::uint64_t                              pad138;                            // 138
	};
	static_assert(sizeof(hkpMotion) == 0x140);
}


===============================================
File: include/RE/H/hkpPhantom.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkpPhantomType.h"
#include "RE/H/hkpWorldObject.h"

namespace RE
{
	class hkAabb;
	class hkpCollidable;
	class hkpPhantomListener;
	class hkpPhantomOverlapListener;

	class hkpPhantom : public hkpWorldObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpPhantom;
		inline static constexpr auto VTABLE = VTABLE_hkpPhantom;

		~hkpPhantom() override;  // 00

		// override (hkpWorldObject)
		void CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02

		// add
		virtual hkpPhantomType GetType() const = 0;                                                  // 06
		virtual void           CalcAabb(hkAabb& a_aabb) = 0;                                         // 07
		virtual void           AddOverlappingCollidable(hkpCollidable* a_collidable) = 0;            // 08
		virtual bool           IsOverlappingCollidableAdded(const hkpCollidable* a_collidable) = 0;  // 09
		virtual void           RemoveOverlappingCollidable(hkpCollidable* a_collidable) = 0;         // 0A
		virtual void           EnsureDeterministicOrder() = 0;                                       // 0B
		virtual hkpPhantom*    Clone() const = 0;                                                    // 0C
		virtual void           UpdateShapeCollectionFilter();                                        // 0D - { return; }
		virtual void           DeallocateInternalArrays();                                           // 0E

		// members
		hkArray<hkpPhantomOverlapListener*> overlapListeners;  // D0
		hkArray<hkpPhantomListener*>        phantomListeners;  // E0
	};
	static_assert(sizeof(hkpPhantom) == 0xF0);
}


===============================================
File: include/RE/H/hkpPhantomListener.h
===============================================
#pragma once

namespace RE
{
	class hkpPhantom;

	class hkpPhantomListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpPhantomListener;
		inline static constexpr auto VTABLE = VTABLE_hkpPhantomListener;

		virtual ~hkpPhantomListener();  // 00

		virtual void PhantomAddedCallback(hkpPhantom* a_phantom);     // 01 - { return; }
		virtual void PhantomRemovedCallback(hkpPhantom* a_phantom);   // 02 - { return; }
		virtual void PhantomShapeSetCallback(hkpPhantom* a_phantom);  // 03
		virtual void PhantomDeletedCallback(hkpPhantom* a_phantom);   // 04 - { return; }
	};
	static_assert(sizeof(hkpPhantomListener) == 0x8);
}


===============================================
File: include/RE/H/hkpPhantomType.h
===============================================
#pragma once

namespace RE
{
	enum class hkpPhantomType
	{
		kAabb = 0,
		kSimpleShape = 1,
		kCachingShape = 2,
		kUser0,
		kUser1,
		kUser2,
		kUser3,
		kUser4,
		kUser5,
		kUser6,
		kUser7,
		kUser8,
		kUser9,

		kTotal
	};
}


===============================================
File: include/RE/H/hkpProperty.h
===============================================
#pragma once

namespace RE
{
	struct hkpPropertyValue
	{
		std::uint64_t data;  // 0
	};
	static_assert(sizeof(hkpPropertyValue) == 0x8);

	class hkpProperty
	{
	public:
		std::uint32_t    key;               // 00
		std::uint32_t    alignmentPadding;  // 04
		hkpPropertyValue value;             // 08
	};
	static_assert(sizeof(hkpProperty) == 0x10);
}


===============================================
File: include/RE/H/hkpRagdollConstraintData.h
===============================================
#pragma once

#include "RE/H/hkpConstraintAtom.h"
#include "RE/H/hkpConstraintData.h"

namespace RE
{
	class hkpRagdollConstraintData : public hkpConstraintData
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpRagdollConstraintData;
		inline static constexpr auto VTABLE = VTABLE_hkpRagdollConstraintData;

		struct Atoms
		{
			struct hkpSetLocalTransformsConstraintAtom transforms;
			struct hkpSetupStabilizationAtom           setupStabilization;
			struct hkpRagdollMotorConstraintAtom       ragdollMotors;
			struct hkpAngFrictionConstraintAtom        angFriction;
			struct hkpTwistLimitConstraintAtom         twistLimit;
			struct hkpConeLimitConstraintAtom          coneLimit;
			struct hkpConeLimitConstraintAtom          planesLimit;
			struct hkpBallSocketConstraintAtom         ballSocket;
		};
		static_assert(sizeof(Atoms) == 0x160);

		// members
		Atoms atoms;  // 18
	};
	static_assert(sizeof(hkpRagdollConstraintData) == 0x180);
}


===============================================
File: include/RE/H/hkpRayCollidableFilter.h
===============================================
#pragma once

namespace RE
{
	class hkpCollidable;

	struct hkpWorldRayCastInput;

	class hkpRayCollidableFilter
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpRayCollidableFilter;
		inline static constexpr auto VTABLE = VTABLE_hkpRayCollidableFilter;

		virtual ~hkpRayCollidableFilter();  // 00

		// add
		virtual bool IsCollisionEnabled(const hkpWorldRayCastInput& a_input, const hkpCollidable& a_collidable) const = 0;  // 01
	};
	static_assert(sizeof(hkpRayCollidableFilter) == 0x08);
}


===============================================
File: include/RE/H/hkpRayHitCollector.h
===============================================
#pragma once

namespace RE
{
	class hkpCdBody;

	struct hkpShapeRayCastCollectorOutput;

	class hkpRayHitCollector
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpRayHitCollector;
		inline static constexpr auto VTABLE = VTABLE_hkpRayHitCollector;

		// add
		virtual void AddRayHit(const hkpCdBody& a_body, const hkpShapeRayCastCollectorOutput& a_hitInfo) = 0;  // 00

		virtual ~hkpRayHitCollector();  // 01

		constexpr void Reset() noexcept { earlyOutHitFraction = 1.0f; }

		// members
		float         earlyOutHitFraction{ 1.0f };  // 08
		std::uint32_t pad0C;                        // 0C
	};
	static_assert(sizeof(hkpRayHitCollector) == 0x10);
}


===============================================
File: include/RE/H/hkpRayShapeCollectionFilter.h
===============================================
#pragma once

#include "RE/H/hkpShape.h"

namespace RE
{
	class hkpShapeContainer;

	struct hkpShapeRayCastInput;

	class hkpRayShapeCollectionFilter
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpRayShapeCollectionFilter;
		inline static constexpr auto VTABLE = VTABLE_hkpRayShapeCollectionFilter;

		// add
		virtual bool IsCollisionEnabled(const hkpShapeRayCastInput& a_input, const hkpShapeContainer& a_container, hkpShapeKey a_key) const = 0;  // 00

		virtual ~hkpRayShapeCollectionFilter();  // 01
	};
	static_assert(sizeof(hkpRayShapeCollectionFilter) == 0x08);
}


===============================================
File: include/RE/H/hkpRigidBody.h
===============================================
#pragma once

#include "RE/H/hkpEntity.h"

namespace RE
{
	class hkpRigidBody : public hkpEntity
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpRigidBody;
		inline static constexpr auto VTABLE = VTABLE_hkpRigidBody;

		~hkpRigidBody() override;  // 00

		// override (hkpEntity)
		hkWorldOperation::Result SetShape(const hkpShape* a_shape) override;               // 03
		hkWorldOperation::Result UpdateShape(hkpShapeModifier* a_shapeModifier) override;  // 04
		hkMotionState*           GetMotionState() override;                                // 05 - { return &motion.motionState; }

		// add
		virtual hkpRigidBody* Clone() const;  // 07
	};
	static_assert(sizeof(hkpRigidBody) == 0x2D0);
}


===============================================
File: include/RE/H/hkpRootCdPoint.h
===============================================
#pragma once

#include "RE/H/hkContactPoint.h"
#include "RE/H/hkpShape.h"

namespace RE
{
	class hkpCollidable;

	struct hkpRootCdPoint
	{
		hkContactPoint       contact;          // 00
		const hkpCollidable* rootCollidableA;  // 20
		hkpShapeKey          shapeKeyA;        // 28
		std::uint32_t        pad2C;            // 2C
		const hkpCollidable* rootCollidableB;  // 30
		hkpShapeKey          shapeKeyB;        // 38
		std::uint32_t        pad3C;            // 3C
	};
	static_assert(sizeof(hkpRootCdPoint) == 0x40);
}


===============================================
File: include/RE/H/hkpShape.h
===============================================
#pragma once

#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkSseMathTypes.h"
#include "RE/H/hkpShapeBuffer.h"
#include "RE/H/hkpShapeType.h"

namespace RE
{
	class bhkShape;
	class hkAabb;
	class hkSphere;
	class hkTransform;
	class hkpCdBody;
	class hkpCdVertex;
	class hkpConvexShape;
	class hkpRayHitCollector;
	class hkpShapeContainer;
	class hkpShapeRayBundleCastInput;
	class hkpShapeRayBundleCastOutput;
	class hkVector4;
	struct hkpShapeRayCastInput;
	struct hkpShapeRayCastOutput;

	using hkpVertexID = std::uint16_t;
	constexpr hkpVertexID HK_INVALID_VERTEX_ID = static_cast<hkpVertexID>(-1);

	using hkpShapeKey = std::uint32_t;
	constexpr hkpShapeKey HK_INVALID_SHAPE_KEY = static_cast<hkpShapeKey>(-1);

	class hkpShape : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpShape;
		inline static constexpr auto VTABLE = VTABLE_hkpShape;

		using GetSupportingVertexFunc = void(const void* a_this, const hkVector4& a_direction, hkpCdVertex& a_supportVertex);
		using ConvertVertexIdsToVerticesFunc = void(const void* a_this, const hkpVertexID* a_ids, std::int32_t a_numIDs, class hkpCdVertex* a_verticesOut);
		using WeldContactPointFunc = std::int32_t(const void* a_this, hkpVertexID* a_featurePoints, std::uint8_t& a_numFeaturePoints, hkVector4& a_contactPointWs, const hkTransform* a_thisTransform, const hkpConvexShape* a_collidingShape, const hkTransform* a_collidingTransform, hkVector4& a_separatingNormalInOut);
		using GetCentreFunc = void(const void* a_this, hkVector4& a_centreOut);
		using GetNumCollisionSpheresFunc = std::int32_t(const void* a_this);
		using GetCollisionSpheresFunc = const hkSphere*(const void* a_this, hkSphere* a_sphereBuffer);
		using GetAabbFunc = void(const void* a_this, const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out);
		using CastRayFunc = bool(const void* a_this, const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output);
		using CastRayWithCollectorFunc = void(const void* a_this, const hkpShapeRayCastInput& a_input, const hkpCdBody& a_cdBody, hkpRayHitCollector& a_collector);
		using CastRayBundleFunc = hkVector4Comparison(const void* a_this, const hkpShapeRayBundleCastInput& a_input, hkpShapeRayBundleCastOutput& a_output, const hkVector4Comparison& a_mask);
		using GetChildShapeFunc = const hkpShape*(const void* a_this, hkpShapeKey a_key, hkpShapeBuffer& a_buffer);
		using GetCollisionFilterInfoFunc = std::uint32_t(const void* a_this, hkpShapeKey a_key);

		struct CalcSizeForSpuInput
		{
		public:
			// members
			bool midphaseAgent3Registered;  // 0
			bool isFixedOrKeyframed;        // 1
			bool hasDynamicMotionSaved;     // 2
		};
		static_assert(sizeof(CalcSizeForSpuInput) == 0x3);

		struct ShapeFuncs
		{
		public:
			// members
			GetSupportingVertexFunc*        getSupportingVertexFunc;     // 00
			ConvertVertexIdsToVerticesFunc* convertVertexIdsToVertices;  // 08
			WeldContactPointFunc*           weldContactPointFunc;        // 10
			GetCentreFunc*                  getCentreFunc;               // 18
			GetNumCollisionSpheresFunc*     getNumCollisionSpheresFunc;  // 20
			GetCollisionSpheresFunc*        getCollisionSpheresFunc;     // 28
			GetAabbFunc*                    getAabbFunc;                 // 30
			CastRayFunc*                    castRay;                     // 38
			CastRayWithCollectorFunc*       castRayWithCollector;        // 40
			CastRayBundleFunc*              castRayBundle;               // 48
			GetChildShapeFunc*              getChildShapeFunc;           // 50
			GetCollisionFilterInfoFunc*     getCollisionFilterInfoFunc;  // 58
		};
		static_assert(sizeof(ShapeFuncs) == 0x60);

		struct ShapeFuncs2
		{
		public:
			// members
			alignas(0x40) GetSupportingVertexFunc* getSupportingVertexFunc;  // 00
			ConvertVertexIdsToVerticesFunc* convertVertexIdsToVertices;      // 08
			WeldContactPointFunc*           weldContactPointFunc;            // 10
			GetCentreFunc*                  getCentreFunc;                   // 18
			GetNumCollisionSpheresFunc*     getNumCollisionSpheresFunc;      // 20
			GetCollisionSpheresFunc*        getCollisionSpheresFunc;         // 28
			GetAabbFunc*                    getAabbFunc;                     // 30
			CastRayFunc*                    castRay;                         // 38
			CastRayWithCollectorFunc*       castRayWithCollector;            // 40
			CastRayBundleFunc*              castRayBundle;                   // 48
			GetChildShapeFunc*              getChildShapeFunc;               // 50
			GetCollisionFilterInfoFunc*     getCollisionFilterInfoFunc;      // 58
			std::uint64_t                   pad60;                           // 60
			std::uint64_t                   pad68;                           // 68
			std::uint64_t                   pad70;                           // 70
			std::uint64_t                   pad78;                           // 78
		};
		static_assert(sizeof(ShapeFuncs2) == 0x80);

		using RegsiterFunc = void(ShapeFuncs& a_sf);

		~hkpShape() override;  // 00

		// add
		virtual float                    GetMaximumProjection(const hkVector4& a_direction) const;                                                                                      // 03
		virtual const hkpShapeContainer* GetContainer() const;                                                                                                                          // 04 - { return 0; }
		virtual bool                     IsConvex() const;                                                                                                                              // 05 - { return false; }
		virtual std::int32_t             CalcSizeForSpu(const CalcSizeForSpuInput& a_input, std::int32_t a_spuBufferSizeLeft) const;                                                    // 06 - { return -1; }
		virtual void                     GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const = 0;                                                    // 07
		virtual bool                     CastRayImpl(const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output) const = 0;                                                   // 08
		virtual void                     CastRayWithCollectorImpl(const hkpShapeRayCastInput& a_input, const hkpCdBody& a_cdBody, hkpRayHitCollector& a_collector) const = 0;           // 09
		virtual hkVector4Comparison      CastRayBundleImpl(const hkpShapeRayBundleCastInput& a_input, hkpShapeRayBundleCastOutput& a_output, const hkVector4Comparison& a_mask) const;  // 0A

		// members
		bhkShape*     userData;  // 10
		hkpShapeType  type;      // 18
		std::uint32_t pad1C;     // 1C
	};
	static_assert(sizeof(hkpShape) == 0x20);
}


===============================================
File: include/RE/H/hkpShapeBuffer.h
===============================================
#pragma once

namespace RE
{
	struct alignas(0x10) hkpShapeBuffer
	{
		constexpr char& operator[](std::size_t a_idx) { return buf[a_idx]; }

		char buf[512];
	};
}


===============================================
File: include/RE/H/hkpShapeCollection.h
===============================================
#pragma once

#include "RE/H/hkpShape.h"
#include "RE/H/hkpShapeContainer.h"
#include "RE/H/hkpWeldingUtility.h"

namespace RE
{
	class hkpShapeCollection :
		public hkpShape,          // 00
		public hkpShapeContainer  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpShapeCollection;
		inline static constexpr auto VTABLE = VTABLE_hkpShapeCollection;

		enum class CollectionType
		{
			kList,
			kExtendedMesh,
			kTrisampledHeightfield,
			kUser,
			kSimpleMesh,
			kMeshShape,
			kCompressedMesh,

			kTotal
		};

		~hkpShapeCollection() override;  // 00

		// override (hkpShape)
		void                     CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;                                          // 02
		float                    GetMaximumProjection(const hkVector4& a_direction) const override;                                                                         // 03
		const hkpShapeContainer* GetContainer() const override;                                                                                                             // 04
		void                     GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const override;                                           // 07
		bool                     CastRayImpl(const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output) const override;                                          // 08
		void                     CastRayWithCollectorImpl(const hkpShapeRayCastInput& a_input, const hkpCdBody& a_cdBody, hkpRayHitCollector& a_collector) const override;  // 09

		// override (hkpShapeContainer)
		bool IsWeldingEnabled() const override;  // 06 - { return !disableWelding; }

		// add
		virtual void InitWeldingInfo(hkpWeldingUtility::WeldingType a_weldingType);  // 0B - { return; }
		virtual void SetWeldingInfo(hkpShapeKey a_key, std::int16_t a_weldingInfo);  // 0C - { return; }

		// members
		bool                                           disableWelding;  // 28
		stl::enumeration<CollectionType, std::uint8_t> collectionType;  // 29
		std::uint16_t                                  pad2A;           // 2A
		std::uint32_t                                  pad2C;           // 2C
	};
	static_assert(sizeof(hkpShapeCollection) == 0x30);
}


===============================================
File: include/RE/H/hkpShapeCollectionFilter.h
===============================================
#pragma once

#include "RE/H/hkAabb.h"
#include "RE/H/hkpShape.h"

namespace RE
{
	class hkpBvTreeShape;
	class hkpCdBody;
	class hkpShapeContainer;

	struct hkpCollisionInput;

	class hkpShapeCollectionFilter
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpShapeCollectionFilter;
		inline static constexpr auto VTABLE = VTABLE_hkpShapeCollectionFilter;

		// add
		virtual bool         IsCollisionEnabled1(const hkpCollisionInput& a_input, const hkpCdBody& a_bodyA, const hkpCdBody& a_bodyB, const hkpShapeContainer& a_shapeB, hkpShapeKey a_key) const = 0;                                                                      // 00
		virtual bool         IsCollisionEnabled2(const hkpCollisionInput& a_input, const hkpCdBody& a_bodyA, const hkpCdBody& a_bodyB, const hkpShapeContainer& a_shapeA, const hkpShapeContainer& a_shapeB, hkpShapeKey a_keyA, hkpShapeKey a_keyB) const = 0;              // 01
		virtual std::int32_t NumShapeKeyHitsLimitBreached(const hkpCollisionInput& a_input, const hkpCdBody& a_bodyA, const hkpCdBody& a_bodyB, const hkpBvTreeShape* a_shapeB, hkAabb& a_AABB, hkpShapeKey* a_shapeKeysInOut, std::int32_t a_shapeKeysCapacity) const = 0;  // 02

		virtual ~hkpShapeCollectionFilter();  // 03
	};
	static_assert(sizeof(hkpShapeCollectionFilter) == 0x08);
}


===============================================
File: include/RE/H/hkpShapeContainer.h
===============================================
#pragma once

namespace RE
{
	class hkpShapeContainer
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpShapeContainer;
		inline static constexpr auto VTABLE = VTABLE_hkpShapeContainer;

		enum class ReferencePolicy
		{
			kIgnore,
			kIncrement
		};

		virtual ~hkpShapeContainer();  // 00

		// add
		[[nodiscard]] virtual std::int32_t  GetNumChildShapes() const;                                             // 01
		[[nodiscard]] virtual hkpShapeKey   GetFirstKey() const = 0;                                               // 02
		[[nodiscard]] virtual hkpShapeKey   GetNextKey(hkpShapeKey a_oldKey) const = 0;                            // 03
		virtual std::uint32_t GetCollisionFilterInfo(hkpShapeKey a_key) const;                       // 04 - { return 0; }
		virtual const hkpShape*             GetChildShape(hkpShapeKey a_key, hkpShapeBuffer& a_buffer) const = 0;  // 05
		[[nodiscard]] virtual bool          IsWeldingEnabled() const;                                              // 06 - { return true; }
	};
	static_assert(sizeof(hkpShapeContainer) == 0x8);
}


===============================================
File: include/RE/H/hkpShapePhantom.h
===============================================
#pragma once

#include "RE/H/hkMotionState.h"
#include "RE/H/hkpPhantom.h"

namespace RE
{
	class hkTransform;
	class hkpCdBodyPairCollector;
	class hkpCdPointCollector;
	struct hkpCollisionInput;
	struct hkpLinearCastInput;

	class hkpShapePhantom : public hkpPhantom
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpShapePhantom;
		inline static constexpr auto VTABLE = VTABLE_hkpShapePhantom;

		~hkpShapePhantom() override;  // 00

		// override (hkpPhantom)
		hkWorldOperation::Result SetShape(const hkpShape* a_shape) override;  // 03
		hkMotionState*           GetMotionState() override;                   // 05 - { return &motionState; }
		void                     CalcAabb(hkAabb& a_aabb) override;           // 07
		void                     DeallocateInternalArrays() override;         // 0E - { hkpPhantom::DeallocateInternalArrays(); }

		// add
		virtual void SetPositionAndLinearCast(const hkVector4& a_position, const hkpLinearCastInput& a_input, hkpCdPointCollector& a_castCollector, hkpCdPointCollector* a_startCollector) = 0;      // 0F
		virtual void SetTransformAndLinearCast(const hkTransform& a_transform, const hkpLinearCastInput& a_input, hkpCdPointCollector& a_castCollector, hkpCdPointCollector* a_startCollector) = 0;  // 10
		virtual void GetClosestPoints(hkpCdPointCollector& a_collector, const hkpCollisionInput* a_input = 0) = 0;                                                                                   // 11
		virtual void GetPenetrations(hkpCdBodyPairCollector& a_collector, const hkpCollisionInput* a_input = 0) = 0;                                                                                 // 12

		// members
		hkMotionState motionState;  // 0F0
	};
	static_assert(sizeof(hkpShapePhantom) == 0x1A0);
}


===============================================
File: include/RE/H/hkpShapeRayCastCollectorOutput.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"
#include "RE/H/hkpShape.h"

namespace RE
{
	struct hkpShapeRayCastCollectorOutput
	{
	public:
		[[nodiscard]] constexpr bool HasHit() const noexcept { return hitFraction < 1.0f; }

		constexpr void Reset() noexcept
		{
			hitFraction = 1.0f;
			shapeKey = HK_INVALID_SHAPE_KEY;
			extraInfo = -1;
		}

		// members
		hkVector4    normal;                            // 00
		float        hitFraction{ 1.0F };               // 10
		std::int32_t extraInfo{ -1 };                   // 14
		hkpShapeKey  shapeKey{ HK_INVALID_SHAPE_KEY };  // 18
		std::int32_t pad1C{ 0 };                        // 1C
	};
	static_assert(sizeof(hkpShapeRayCastCollectorOutput) == 0x20);
}


===============================================
File: include/RE/H/hkpShapeRayCastOutput.h
===============================================
#pragma once

#include "RE/H/hkpShape.h"
#include "RE/H/hkpShapeRayCastCollectorOutput.h"

namespace RE
{
	struct hkpShapeRayCastOutput : public hkpShapeRayCastCollectorOutput
	{
	public:
		enum
		{
			kMaxHierarchyDepth = 8
		};

		constexpr void ChangeLevel(std::int32_t a_delta) noexcept
		{
			assert(shapeKeyIndex + a_delta < kMaxHierarchyDepth);
			shapeKeyIndex += a_delta;
		}

		constexpr void SetKey(hkpShapeKey a_key) noexcept { shapeKeys[shapeKeyIndex] = a_key; }

		constexpr void Reset() noexcept
		{
			hkpShapeRayCastCollectorOutput::Reset();
			shapeKeys[0] = HK_INVALID_SHAPE_KEY;
			shapeKeyIndex = 0;
		}

		// members
		hkpShapeKey   shapeKeys[kMaxHierarchyDepth]{ HK_INVALID_SHAPE_KEY };  // 20
		std::int32_t  shapeKeyIndex{ 0 };                                     // 40
		std::uint32_t pad44;                                                  // 44
		std::uint64_t pad48;                                                  // 48
	};
	static_assert(sizeof(hkpShapeRayCastOutput) == 0x50);
}


===============================================
File: include/RE/H/hkpShapeType.h
===============================================
#pragma once

namespace RE
{
	enum class hkpShapeType
	{
		kInvalid = 0,

		kSphere,
		kFirstType = static_cast<std::underlying_type_t<hkpShapeType>>(kSphere),
		kCylinder,
		kTriangle,
		kBox,
		kCapsule,
		kConvexVertices,
		kCollection,
		kBVTree,
		kList,
		kMOPP,
		kConvexTranslate,
		kConvexTransform,
		kSampledHeightField,
		kExtendedMesh,
		kTransform,
		kCompressedMesh,
		kCompound,

		kTotalSPU = kCompound + 1,

		kConvex,
		kMOPPEmbedded,
		kConvexPiece,
		kMultiSphere,
		kConvexList,
		kTriangleCollection,
		kMultiRay,
		kHeightField,
		kSphereRep,
		kBV,
		kPlane,
		kPhantomCallback,
		kUser0,
		kUser1,
		kUser2,

		kTotal,

		kAll = static_cast<std::underlying_type_t<hkpShapeType>>(-1)
	};
}


===============================================
File: include/RE/H/hkpSimplexSolver.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	struct hkpSurfaceConstraintInfo
	{
		hkVector4     plane;                    // 00
		hkVector4     velocity;                 // 10
		float         staticFriction;           // 20
		float         extraUpStaticFriction;    // 24
		float         extraDownStaticFriction;  // 28
		float         dynamicFriction;          // 2C
		std::int32_t  priority;                 // 30
		std::uint32_t pad34;                    // 34
		std::uint64_t pad38;                    // 38
	};
	static_assert(sizeof(hkpSurfaceConstraintInfo) == 0x40);

	struct hkpSimplexSolverInput
	{
		hkVector4                 position;            // 00
		hkVector4                 velocity;            // 10
		hkVector4                 maxSurfaceVelocity;  // 20
		hkVector4                 upVector;            // 30
		float                     deltaTime;           // 40
		float                     minDeltaTime;        // 44
		hkpSurfaceConstraintInfo* constraints;         // 48
		std::int32_t              numConstraints;      // 50
		std::uint32_t             pad54;               // 54
		std::uint64_t             pad58;               // 58
	};
	static_assert(sizeof(hkpSimplexSolverInput) == 0x60);
}


===============================================
File: include/RE/H/hkpSimulationIsland.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkBaseTypes.h"
#include "RE/H/hkMultiThreadCheck.h"
#include "RE/H/hkpAgentNnTrack.h"
#include "RE/H/hkpConstraintOwner.h"

namespace RE
{
	class hkpAction;
	class hkpEntity;
	class hkpWorld;

	class hkpSimulationIsland : public hkpConstraintOwner
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpSimulationIsland;
		inline static constexpr auto VTABLE = VTABLE_hkpSimulationIsland;

		~hkpSimulationIsland() override;  // 00

		// override (hkpConstraintOwner)
		const hkClass* GetClassType() const override;                                                                     // 01 - { return &hkpSimulationIslandClass; }
		void           CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02
		void           AddConstraintToCriticalLockedIsland(hkpConstraintInstance* a_constraint) override;                 // 03
		void           RemoveConstraintFromCriticalLockedIsland(hkpConstraintInstance* a_constraint) override;            // 04
		void           AddCallbackRequest(hkpConstraintInstance* a_constraint, std::int32_t a_request) override;          // 05

		// members
		hkpWorld*     world;                   // 20
		std::int32_t  numConstraints;          // 28
		hkObjectIndex storageIndex;            // 2C
		hkObjectIndex dirtyListIndex;          // 2E
		std::uint8_t  splitCheckFrameCounter;  // 30

		bool splitCheckRequested: 2;          // 31 - 0
		bool isSparse: 2;                     // 31 - 2
		bool actionListCleanupNeeded: 2;      // 31 - 4
		bool allowIslandLocking: 2;           // 31 - 6
		bool isInActiveIslandsArray: 2;       // 32 - 0
		bool activeMark: 2;                   // 32 - 2
		bool tryToIncreaseIslandSizeMark: 2;  // 32 - 4
		bool inIntegrateJob: 2;               // 32 - 6

		std::uint8_t                  pad33;                            // 33
		mutable hkMultiThreadCheck    multiThreadCheck;                 // 34
		float                         timeSinceLastHighFrequencyCheck;  // 40
		float                         timeSinceLastLowFrequencyCheck;   // 44
		hkArray<hkpAction*>           actions;                          // 48
		hkTime                        timeOfDeactivation;               // 58
		std::uint32_t                 pad5C;                            // 5C
		hkInplaceArray<hkpEntity*, 1> entities;                         // 60
		hkpAgentNnTrack               midphaseAgentTrack;               // 78
		hkpAgentNnTrack               narrowphaseAgentTrack;            // 98
	};
	static_assert(sizeof(hkpSimulationIsland) == 0xB8);
}


===============================================
File: include/RE/H/hkpSingleShapeContainer.h
===============================================
#pragma once

#include "RE/H/hkpShapeContainer.h"

namespace RE
{
	class hkpShape;

	class hkpSingleShapeContainer : public hkpShapeContainer
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpSingleShapeContainer;
		inline static constexpr auto VTABLE = VTABLE_hkpSingleShapeContainer;

		~hkpSingleShapeContainer() override;  // 00

		// override (hkpShapeContainer)
		std::int32_t    GetNumChildShapes() const override;                                         // 01 - { return 1; }
		hkpShapeKey     GetFirstKey() const override;                                               // 02 - { return 0; }
		hkpShapeKey     GetNextKey(hkpShapeKey oldKey) const override;                              // 03 - { return -1; }
		const hkpShape* GetChildShape(hkpShapeKey a_key, hkpShapeBuffer& a_buffer) const override;  // 05 - { return childShape; }

		// members
		const hkpShape* childShape;  // 08
	};
	static_assert(sizeof(hkpSingleShapeContainer) == 0x10);
}


===============================================
File: include/RE/H/hkpSolverInfo.h
===============================================
#pragma once

#include "RE/H/hkBaseTypes.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	struct hkpSolverInfo
	{
		struct DeactivationClasses
		{
			enum DeactivationClass : std::uint32_t
			{
				kInvalid,
				kOff,
				kLow,
				kMedium,
				kHigh,
				kAggressive,

				kTotal
			};
		};
		using DeactivationClass = DeactivationClasses::DeactivationClass;

		struct DeactivationInfo
		{
			float  linearVelocityThresholdInv;      // 00
			float  angularVelocityThresholdInv;     // 04
			float  slowObjectVelocityMultiplier;    // 08
			float  relativeSleepVelocityThreshold;  // 0C
			float  maxDistSqrd[2];                  // 10
			hkHalf maxRotSqrd[2];                   // 18
		};
		static_assert(sizeof(DeactivationInfo) == 0x1C);

		// members
		alignas(0x10) float one;                                       // 000
		float            tau;                                          // 004
		float            damping;                                      // 008
		float            frictionTau;                                  // 00C
		hkVector4        globalAccelerationPerSubStep;                 // 010
		hkVector4        globalAccelerationPerStep;                    // 020
		hkVector4        integrateVelocityFactor;                      // 030
		hkVector4        invIntegrateVelocityFactor;                   // 040
		float            dampDivTau;                                   // 050
		float            tauDivDamp;                                   // 054
		float            dampDivFrictionTau;                           // 058
		float            frictionTauDivDamp;                           // 05C
		float            contactRestingVelocity;                       // 060
		DeactivationInfo deactivationInfo[DeactivationClass::kTotal];  // 064
		float            deltaTime;                                    // 10C
		float            invDeltaTime;                                 // 110
		std::int32_t     numSteps;                                     // 114
		std::int32_t     numMicroSteps;                                // 118
		float            invNumMicroSteps;                             // 11C
		float            invNumSteps;                                  // 120
		bool             forceCoherentConstraintOrderingInSolver;      // 124
		std::uint8_t     deactivationNumInactiveFramesSelectFlag[2];   // 125
		std::uint8_t     deactivationIntegrateCounter;                 // 127
		float            maxConstraintViolationSqrd;                   // 128
		std::uint32_t    pad12C;                                       // 12C
	};
	static_assert(sizeof(hkpSolverInfo) == 0x130);
}


===============================================
File: include/RE/H/hkpSphereRepShape.h
===============================================
#pragma once

#include "RE/H/hkpShape.h"

namespace RE
{
	class hkpSphere;

	class hkpSphereRepShape : public hkpShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpSphereRepShape;
		inline static constexpr auto VTABLE = VTABLE_hkpSphereRepShape;

		virtual ~hkpSphereRepShape();  // 00

		// add
		virtual std::int32_t     GetNumCollisionSpheresImpl() = 0;                       // 0B
		virtual const hkpSphere* GetCollisionSpheresImpl(hkSphere* a_sphereBuffer) = 0;  // 0C
	};
	static_assert(sizeof(hkpSphereRepShape) == 0x20);
}


===============================================
File: include/RE/H/hkpSphereShape.h
===============================================
#pragma once

#include "RE/H/hkpConvexShape.h"

namespace RE
{
	class hkpSphereShape : public hkpConvexShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpSphereShape;
		inline static constexpr auto VTABLE = VTABLE_hkpSphereShape;

		~hkpSphereShape() override;  // 00

		// override (hkpConvexShape)
		void             CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;     // 02
		std::int32_t     CalcSizeForSpu(const CalcSizeForSpuInput& a_input, std::int32_t a_spuBufferSizeLeft) const override;  // 06 - { return 56; }
		void             GetAabbImpl(const hkTransform& a_localToWorld, float a_tolerance, hkAabb& a_out) const override;      // 07
		bool             CastRayImpl(const hkpShapeRayCastInput& a_input, hkpShapeRayCastOutput& a_output) const override;     // 08
		std::int32_t     GetNumCollisionSpheresImpl() override;                                                                // 0B - { return 8; }
		const hkpSphere* GetCollisionSpheresImpl(hkSphere* a_sphereBuffer) override;                                           // 0C
		void             GetCentreImpl(hkVector4& a_centreOut) override;                                                       // 0D
		void             Unk_0E(void) override;                                                                                // 0E
		void             Unk_0F(void) override;                                                                                // 0F
		void             Unk_11(void) override;                                                                                // 11
	};
	static_assert(sizeof(hkpSphereShape) == 0x28);
}


===============================================
File: include/RE/H/hkpTypedBroadPhaseHandle.h
===============================================
#pragma once

#include "RE/H/hkpBroadPhaseHandle.h"

namespace RE
{
	class hkpTypedBroadPhaseHandle : public hkpBroadPhaseHandle
	{
	public:
		enum
		{
			kInvalidOffset = 127
		};

		std::int8_t   type;                 // 4
		std::int8_t   ownerOffset;          // 5
		std::int8_t   objectQualityType;    // 6
		std::int8_t   pad7;                 // 7
		std::uint32_t collisionFilterInfo;  // 8
	};
	static_assert(sizeof(hkpTypedBroadPhaseHandle) == 0xC);
}


===============================================
File: include/RE/H/hkpWeldingUtility.h
===============================================
#pragma once

namespace RE
{
	class hkpWeldingUtility
	{
	public:
		enum
		{
			kNumAngles = 31
		};

		enum class WeldingType
		{
			kAntiClockwise = 0,
			kClockwise = 4,
			kTwoSided = 5,
			kNone = 6
		};

		enum SectorType
		{
			kAccept0 = 1,
			kSnap0 = 0,
			kReject = 2,
			kSnap1 = 4,
			kAccept1 = 3
		};

		struct SinCosTableEntry
		{
		public:
			// members
			float cosAccept0;  // 00
			float sinAccept0;  // 04
			float cosSnap0;    // 08
			float cosSnap1;    // 0C
			float cosAccept1;  // 10
			float sinAccept1;  // 14
		};
		static_assert(sizeof(SinCosTableEntry) == 0x18);
	};
	static_assert(sizeof(hkpWeldingUtility) == 0x1);
}


===============================================
File: include/RE/H/hkpWorld.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkMultiThreadCheck.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkStepInfo.h"
#include "RE/H/hkpSolverInfo.h"
#include "RE/H/hkpWorldCinfo.h"

namespace RE
{
	class hkCriticalSection;
	class hkdWorld;
	class hknpWorld;
	class hkpActionListener;
	class hkpBroadPhase;
	class hkpBroadPhaseBorder;
	class hkpBroadPhaseBorderListener;
	class hkpCollisionDispatcher;
	class hkpCollisionFilter;
	class hkpConstraintListener;
	class hkpContactImpulseLimitBreachedListener;
	class hkpContactListener;
	class hkpConvexListFilter;
	class hkpEntityEntityBroadPhaseListener;
	class hkpEntityListener;
	class hkpIslandActivationListener;
	class hkpIslandPostCollideListener;
	class hkpIslandPostIntegrateListener;
	class hkpPhantom;
	class hkpPhantomBroadPhaseListener;
	class hkpPhantomListener;
	class hkpSimulation;
	class hkpSimulationIsland;
	class hkpTreeWorldManager;
	class hkpTypedBroadPhaseDispatcher;
	class hkpWorldDeletionListener;
	class hkpWorldExtension;
	class hkpWorldMaintenanceMgr;
	class hkpWorldOperationQueue;
	class hkpWorldPostCollideListener;
	class hkpWorldPostIntegrateListener;
	class hkpWorldPostSimulationListener;
	class hkWorldMemoryAvailableWatchDog;
	struct hkpDebugInfoOnPendingOperationQueues;
	struct hkpMtThreadStructure;
	struct hkpProcessCollisionInput;
	struct hkpViolatedConstraintArray;
	struct hkpWorldRayCastInput;
	struct hkpWorldRayCastOutput;

	struct hkpWorldDynamicsStepInfo
	{
	public:
		// members
		hkStepInfo    stepInfo;    // 000
		hkpSolverInfo solverInfo;  // 010
	};
	static_assert(sizeof(hkpWorldDynamicsStepInfo) == 0x140);

	class hkpWorld : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpWorld;
		inline static constexpr auto VTABLE = VTABLE_hkpWorld;

		~hkpWorld() override;  // 00

		// override (hkReferencedObject)
		void CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02

		inline hkpPhantom* AddPhantom(hkpPhantom* a_phantom)
		{
			using func_t = decltype(&hkpWorld::AddPhantom);
			REL::Relocation<func_t> func{ RELOCATION_ID(60502, 61314) };
			return func(this, a_phantom);
		}

		inline void RemovePhantom(hkpPhantom* a_phantom)
		{
			using func_t = decltype(&hkpWorld::RemovePhantom);
			REL::Relocation<func_t> func{ RELOCATION_ID(60504, 61316) };
			return func(this, a_phantom);
		}

		inline void CastRay(const hkpWorldRayCastInput& a_input, hkpWorldRayCastOutput& a_output) const
		{
			using func_t = decltype(&hkpWorld::CastRay);
			REL::Relocation<func_t> func{ RELOCATION_ID(60551, 61399) };
			return func(this, a_input, a_output);
		}

		// members
		hkpSimulation*                                                        simulation;                                                 // 010
		std::uint64_t                                                         pad018;                                                     // 018
		hkVector4                                                             gravity;                                                    // 020
		hkpSimulationIsland*                                                  fixedIsland;                                                // 030
		hkpRigidBody*                                                         fixedRigidBody;                                             // 038
		hkArray<hkpSimulationIsland*>                                         activeSimulationIslands;                                    // 040
		hkArray<hkpSimulationIsland*>                                         inactiveSimulationIslands;                                  // 050
		hkArray<hkpSimulationIsland*>                                         dirtySimulationIslands;                                     // 060
		hkpWorldMaintenanceMgr*                                               maintenanceMgr;                                             // 070
		hkRefPtr<hkWorldMemoryAvailableWatchDog>                              memoryWatchDog;                                             // 078
		bool                                                                  assertOnRunningOutOfSolverMemory;                           // 080
		std::uint8_t                                                          pad081;                                                     // 081
		std::uint16_t                                                         pad082;                                                     // 082
		std::uint32_t                                                         pad084;                                                     // 084
		hkpBroadPhase*                                                        broadPhase;                                                 // 088
		hkpTreeWorldManager*                                                  kdTreeManager;                                              // 090
		bool                                                                  autoUpdateTree;                                             // 098
		std::uint8_t                                                          pad099;                                                     // 099
		std::uint16_t                                                         pad09A;                                                     // 09A
		std::uint32_t                                                         pad09C;                                                     // 09C
		hkpTypedBroadPhaseDispatcher*                                         broadPhaseDispatcher;                                       // 0A0
		hkpPhantomBroadPhaseListener*                                         phantomBroadPhaseListener;                                  // 0A8
		hkpEntityEntityBroadPhaseListener*                                    entityEntityBroadPhaseListener;                             // 0B0
		hkpBroadPhaseBorderListener*                                          broadPhaseBorderListener;                                   // 0B8
		hkpMtThreadStructure*                                                 multithreadedSimulationJobData;                             // 0C0
		hkpProcessCollisionInput*                                             collisionInput;                                             // 0C8
		hkpCollisionFilter*                                                   collisionFilter;                                            // 0D0
		hkpCollisionDispatcher*                                               collisionDispatcher;                                        // 0D8
		hkpConvexListFilter*                                                  convexListFilter;                                           // 0E0
		hkpWorldOperationQueue*                                               pendingOperations;                                          // 0E8
		std::int32_t                                                          pendingOperationsCount;                                     // 0F0
		std::int32_t                                                          pendingBodyOperationsCount;                                 // 0F4
		std::int32_t                                                          criticalOperationsLockCount;                                // 0F8
		std::int32_t                                                          criticalOperationsLockCountForPhantoms;                     // 0FC
		bool                                                                  blockExecutingPendingOperations;                            // 100
		bool                                                                  criticalOperationsAllowed;                                  // 101
		std::uint16_t                                                         pad102;                                                     // 102
		std::uint32_t                                                         pad104;                                                     // 104
		hkpDebugInfoOnPendingOperationQueues*                                 pendingOperationQueues;                                     // 108
		std::int32_t                                                          pendingOperationQueueCount;                                 // 110
		mutable hkMultiThreadCheck                                            multiThreadCheck;                                           // 114
		bool                                                                  processActionsInSingleThread;                               // 120
		bool                                                                  allowIntegrationOfIslandsWithoutConstraintsInASeparateJob;  // 121
		std::uint16_t                                                         pad122;                                                     // 122
		std::uint32_t                                                         minDesiredIslandSize;                                       // 124
		hkCriticalSection*                                                    modifyConstraintCriticalSection;                            // 128
		std::int32_t                                                          isLocked;                                                   // 130
		std::uint32_t                                                         pad134;                                                     // 134
		hkCriticalSection*                                                    islandDirtyListCriticalSection;                             // 138
		hkCriticalSection*                                                    propertyMasterLock;                                         // 140
		bool                                                                  wantSimulationIslands;                                      // 148
		bool                                                                  useHybridBroadphase;                                        // 149
		std::uint16_t                                                         pad14A;                                                     // 14A
		float                                                                 snapCollisionToConvexEdgeThreshold;                         // 14C
		float                                                                 snapCollisionToConcaveEdgeThreshold;                        // 150
		bool                                                                  enableToiWeldRejection;                                     // 154
		bool                                                                  wantDeactivation;                                           // 155
		bool                                                                  shouldActivateOnRigidBodyTransformChange;                   // 156
		std::uint8_t                                                          pad153;                                                     // 157
		float                                                                 deactivationReferenceDistance;                              // 158
		float                                                                 toiCollisionResponseRotateNormal;                           // 15C
		std::int32_t                                                          maxSectorsPerMidphaseCollideTask;                           // 160
		std::int32_t                                                          maxSectorsPerNarrowphaseCollideTask;                        // 164
		bool                                                                  processToisMultithreaded;                                   // 168
		std::uint8_t                                                          pad169;                                                     // 169
		std::uint16_t                                                         pad16A;                                                     // 16A
		std::int32_t                                                          maxEntriesPerToiMidphaseCollideTask;                        // 16C
		std::int32_t                                                          maxEntriesPerToiNarrowphaseCollideTask;                     // 170
		std::int32_t                                                          maxNumToiCollisionPairsSinglethreaded;                      // 174
		stl::enumeration<hkpWorldCinfo::SimulationType, std::uint8_t>         simulationType;                                             // 178
		std::uint8_t                                                          pad179;                                                     // 179
		std::uint16_t                                                         pad17A;                                                     // 17A
		float                                                                 numToisTillAllowedPenetrationSimplifiedToi;                 // 17C
		float                                                                 numToisTillAllowedPenetrationToi;                           // 180
		float                                                                 numToisTillAllowedPenetrationToiHigher;                     // 184
		float                                                                 numToisTillAllowedPenetrationToiForced;                     // 188
		std::uint32_t                                                         lastEntityUID;                                              // 18C
		std::uint32_t                                                         lastIslandUID;                                              // 190
		std::uint32_t                                                         lastConstraintUID;                                          // 194
		hkArray<hkpPhantom*>                                                  phantoms;                                                   // 198
		hkArray<hkpActionListener*>                                           actionListeners;                                            // 1A8
		hkArray<hkpEntityListener*>                                           entityListeners;                                            // 1B8
		hkArray<hkpPhantomListener*>                                          phantomListeners;                                           // 1C8
		hkArray<hkpConstraintListener*>                                       constraintListeners;                                        // 1D8
		hkArray<hkpWorldDeletionListener*>                                    worldDeletionListeners;                                     // 1E8
		hkArray<hkpIslandActivationListener*>                                 islandActivationListeners;                                  // 1F8
		hkArray<hkpWorldPostSimulationListener*>                              worldPostSimulationListeners;                               // 208
		hkArray<hkpWorldPostIntegrateListener*>                               worldPostIntegrateListeners;                                // 218
		hkArray<hkpWorldPostCollideListener*>                                 worldPostCollideListeners;                                  // 228
		hkArray<hkpIslandPostIntegrateListener*>                              islandPostIntegrateListeners;                               // 238
		hkArray<hkpIslandPostCollideListener*>                                islandPostCollideListeners;                                 // 248
		hkArray<hkpContactListener*>                                          contactListeners;                                           // 258
		hkArray<hkpContactImpulseLimitBreachedListener*>                      contactImpulseLimitBreachedListeners;                       // 268
		hkArray<hkpWorldExtension*>                                           worldExtensions;                                            // 278
		hkpViolatedConstraintArray*                                           violatedConstraintArray;                                    // 288
		hkpBroadPhaseBorder*                                                  broadPhaseBorder;                                           // 290
		hkdWorld*                                                             destructionWorld;                                           // 298
		hknpWorld*                                                            npWorld;                                                    // 2A0
		std::uint64_t                                                         pad2A8;                                                     // 2A8
		hkpWorldDynamicsStepInfo                                              dynamicsStepInfo;                                           // 2B0
		hkVector4                                                             broadPhaseExtents[2];                                       // 3F0
		std::int32_t                                                          broadPhaseNumMarkers;                                       // 410
		std::int32_t                                                          sizeOfToiEventQueue;                                        // 414
		std::int32_t                                                          broadPhaseQuerySize;                                        // 418
		std::int32_t                                                          broadPhaseUpdateSize;                                       // 41C
		stl::enumeration<hkpWorldCinfo::ContactPointGeneration, std::uint8_t> contactPointGeneration;                                     // 420
		std::uint8_t                                                          pad421;                                                     // 421
		std::uint16_t                                                         pad422;                                                     // 422
		std::uint32_t                                                         pad424;                                                     // 424
		std::uint64_t                                                         pad428;                                                     // 428
	};
	static_assert(sizeof(hkpWorld) == 0x430);
}


===============================================
File: include/RE/H/hkpWorldCinfo.h
===============================================
#pragma once

#include "RE/H/hkAabb.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkVector4.h"

namespace RE
{
	class hkpCollisionFilter;
	class hkpConvexListFilter;
	class hkWorldMemoryAvailableWatchDog;

	class hkpWorldCinfo : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpWorldCinfo;
		inline static constexpr auto VTABLE = VTABLE_hkpWorldCinfo;

		enum class SolverType
		{
			kInvalid,
			k2Iters_Soft,
			k2Iters_Medium,
			k2Iters_Hard,
			k4Iters_Soft,
			k4Iters_Medium,
			k4Iters_Hard,
			k8Iters_Soft,
			k8Iters_Medium,
			k8Iters_Hard,

			kTotal
		};

		enum class SimulationType
		{
			kInvalid,
			kDiscrete,
			kContinuous,
			kMultithreaded,
		};

		enum class ContactPointGeneration
		{
			kAcceptAlways,
			kRejectDubious,
			kRejectMany
		};

		enum class BroadPhaseBorderBehaviour
		{
			kAssert,
			kFixEntity,
			kRemoveEntity,
			kDoNothing
		};

		enum class TreeUpdateType
		{
			kActive,
			kAll
		};

		~hkpWorldCinfo() override;  // 00

		// members
		hkVector4                                                gravity;                                                    // 010
		std::int32_t                                             broadPhaseQuerySize;                                        // 020
		float                                                    contactRestingVelocity;                                     // 024
		stl::enumeration<BroadPhaseBorderBehaviour, std::int8_t> broadPhaseBorderBehaviour;                                  // 028
		bool                                                     mtPostponeAndSortBroadPhaseBorderCallbacks;                 // 029
		std::uint16_t                                            pad02A;                                                     // 02A
		std::uint32_t                                            pad02C;                                                     // 02C
		hkAabb                                                   broadPhaseWorldAabb;                                        // 030
		bool                                                     useKdTree;                                                  // 050
		bool                                                     useMultipleTree;                                            // 051
		stl::enumeration<TreeUpdateType, std::int8_t>            treeUpdateType;                                             // 052
		bool                                                     autoUpdateKdTree;                                           // 053
		float                                                    collisionTolerance;                                         // 054
		hkRefPtr<hkpCollisionFilter>                             collisionFilter;                                            // 058
		hkRefPtr<hkpConvexListFilter>                            convexListFilter;                                           // 060
		float                                                    expectedMaxLinearVelocity;                                  // 064
		std::int32_t                                             sizeOfToiEventQueue;                                        // 068
		float                                                    expectedMinPsiDeltaTime;                                    // 06C
		hkRefPtr<hkWorldMemoryAvailableWatchDog>                 memoryWatchDog;                                             // 070
		std::int32_t                                             broadPhaseNumMarkers;                                       // 080
		stl::enumeration<ContactPointGeneration, std::int8_t>    contactPointGeneration;                                     // 084
		bool                                                     allowToSkipConfirmedCallbacks;                              // 085
		bool                                                     useHybridBroadphase;                                        // 086
		std::uint8_t                                             pad087;                                                     // 087
		float                                                    solverTau;                                                  // 088
		float                                                    solverDamp;                                                 // 08C
		std::int32_t                                             solverIterations;                                           // 090
		std::int32_t                                             solverMicrosteps;                                           // 094
		float                                                    maxConstraintViolation;                                     // 098
		bool                                                     forceCoherentConstraintOrderingInSolver;                    // 09C
		std::uint8_t                                             pad09D;                                                     // 09D
		std::uint16_t                                            pad09E;                                                     // 09E
		float                                                    snapCollisionToConvexEdgeThreshold;                         // 0A0
		float                                                    snapCollisionToConcaveEdgeThreshold;                        // 0A4
		bool                                                     enableToiWeldRejection;                                     // 0A8
		bool                                                     enableDeprecatedWelding;                                    // 0A9
		std::uint16_t                                            pad0AA;                                                     // 0AA
		float                                                    iterativeLinearCastEarlyOutDistance;                        // 0AC
		std::int32_t                                             iterativeLinearCastMaxIterations;                           // 0B0
		std::uint8_t                                             deactivationNumInactiveFramesSelectFlag0;                   // 0B4
		std::uint8_t                                             deactivationNumInactiveFramesSelectFlag1;                   // 0B5
		std::uint8_t                                             deactivationIntegrateCounter;                               // 0B6
		bool                                                     shouldActivateOnRigidBodyTransformChange;                   // 0B7
		float                                                    deactivationReferenceDistance;                              // 0B8
		float                                                    toiCollisionResponseRotateNormal;                           // 0BC
		std::int32_t                                             maxSectorsPerMidphaseCollideTask;                           // 0C0
		std::int32_t                                             maxSectorsPerNarrowphaseCollideTask;                        // 0C4
		bool                                                     processToisMultithreaded;                                   // 0C8
		std::uint8_t                                             pad0C9;                                                     // 0C9
		std::uint16_t                                            pad0CA;                                                     // 0CA
		std::int32_t                                             maxEntriesPerToiMidphaseCollideTask;                        // 0CC
		std::int32_t                                             maxEntriesPerToiNarrowphaseCollideTask;                     // 0D0
		std::int32_t                                             maxNumToiCollisionPairsSinglethreaded;                      // 0D4
		float                                                    numToisTillAllowedPenetrationSimplifiedToi;                 // 0D8
		float                                                    numToisTillAllowedPenetrationToi;                           // 0DC
		float                                                    numToisTillAllowedPenetrationToiHigher;                     // 0E0
		float                                                    numToisTillAllowedPenetrationToiForced;                     // 0E4
		bool                                                     enableDeactivation;                                         // 0E8
		stl::enumeration<SimulationType, std::int8_t>            simulationType;                                             // 0E9
		bool                                                     enableSimulationIslands;                                    // 0EA
		std::uint8_t                                             pad0EB;                                                     // 0EB
		std::uint32_t                                            minDesiredIslandSize;                                       // 0EC
		bool                                                     processActionsInSingleThread;                               // 0F0
		bool                                                     allowIntegrationOfIslandsWithoutConstraintsInASeparateJob;  // 0F1
		std::uint16_t                                            pad0F2;                                                     // 0F2
		float                                                    frameMarkerPsiSnap;                                         // 0F4
		bool                                                     fireCollisionCallbacks;                                     // 0F8
		std::uint8_t                                             pad0F9;                                                     // 0F9
		std::uint16_t                                            pad0FA;                                                     // 0FA
		std::uint32_t                                            pad0FC;                                                     // 0FC
	};
	static_assert(sizeof(hkpWorldCinfo) == 0x100);
}


===============================================
File: include/RE/H/hkpWorldLinearCaster.h
===============================================
#pragma once

#include "RE/H/hkpBroadPhaseCastCollector.h"
#include "RE/H/hkpLinearCastCollisionInput.h"
#include "RE/H/hkpShapeType.h"

namespace RE
{
	class hkpCdPointCollector;
	class hkpCollidable;
	class hkpCollidableCollidableFilter;
	struct hkpLinearCastInput;

	class hkpWorldLinearCaster : public hkpBroadPhaseCastCollector
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpWorldLinearCaster;
		inline static constexpr auto VTABLE = VTABLE_hkpWorldLinearCaster;

		~hkpWorldLinearCaster() override = default;  // 00

		// override (hkpBroadPhaseCastCollector)
		float AddBroadPhaseHandle(const hkpBroadPhaseHandle* a_broadphaseHandle, std::int32_t a_castIndex) override;  // 01

		// members
		const hkpLinearCastInput*            input;                // 10
		const hkpCollidableCollidableFilter* filter;               // 18
		hkpCdPointCollector*                 castCollector;        // 20
		hkpCdPointCollector*                 startPointCollector;  // 28
		const hkpCollidable*                 collidableA;          // 30
		hkpShapeType                         typeA;                // 38
		std::uint32_t                        pad3C;                // 3C
		hkpLinearCastCollisionInput          shapeInput;           // 40
	};
	static_assert(sizeof(hkpWorldLinearCaster) == 0xC0);
}


===============================================
File: include/RE/H/hkpWorldObject.h
===============================================
#pragma once

#include "RE/H/hkArray.h"
#include "RE/H/hkMultiThreadCheck.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkStringPtr.h"
#include "RE/H/hkpLinkedCollidable.h"
#include "RE/H/hkpProperty.h"

namespace RE
{
	class hkMotionState;
	class hkpCollidable;
	class hkpShapeModifier;
	class hkpWorld;
	class TESObjectREFR;

	namespace hkWorldOperation
	{
		enum class Result
		{
			kPostponed,
			kDone
		};
	}

	class hkpWorldObject : public hkReferencedObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpWorldObject;
		inline static constexpr auto VTABLE = VTABLE_hkpWorldObject;

		enum class MultiThreadingChecks
		{
			kEnable,
			kIgnore
		};

		enum class BroadPhaseType
		{
			kInvalid,
			kEntity,
			kPhantom,
			kPhaseBorder,

			kTotal
		};

		~hkpWorldObject() override;  // 00

		// override (hkReferencedObject)
		void CalcContentStatistics(hkStatisticsCollector* a_collector, const hkClass* a_class) const override;  // 02

		// add
		virtual hkWorldOperation::Result SetShape(const hkpShape* a_shape);               // 03 - { return hkWorldOperation::Result::kDone; }
		virtual hkWorldOperation::Result UpdateShape(hkpShapeModifier* a_shapeModifier);  // 04 - { return hkWorldOperation::Result::kDone; }
		virtual hkMotionState*           GetMotionState() = 0;                            // 05

		const hkpCollidable* GetCollidable() const;
		hkpCollidable*       GetCollidableRW();
		const hkpShape*      GetShape() const;
		TESObjectREFR*       GetUserData() const;

		// members
		hkpWorld*            world;             // 10
		std::uint64_t        userData;          // 18 - bhkWorldObject*?
		hkpLinkedCollidable  collidable;        // 20
		hkMultiThreadCheck   multiThreadCheck;  // A0
		std::uint32_t        padAC;             // AC
		hkStringPtr          name;              // B0
		hkArray<hkpProperty> properties;        // B8
		void*                treeData;          // C8
	};
	static_assert(sizeof(hkpWorldObject) == 0xD0);
}


===============================================
File: include/RE/H/hkpWorldPostSimulationListener.h
===============================================
#pragma once

namespace RE
{
	class hkpWorld;

	class hkpWorldPostSimulationListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_hkpWorldPostSimulationListener;
		inline static constexpr auto VTABLE = VTABLE_hkpWorldPostSimulationListener;

		// add
		virtual ~hkpWorldPostSimulationListener() = default;  // 00

		virtual void PostSimulationCallback(hkpWorld* a_world) = 0;  // 01
		virtual void InactiveEntityMovedCallback(hkpWorld*) {}       // 02
	};
	static_assert(sizeof(hkpWorldPostSimulationListener) == 0x8);
}


===============================================
File: include/RE/H/hkpWorldRayCastInput.h
===============================================
#pragma once

#include "RE/H/hkVector4.h"

namespace RE
{
	struct hkpWorldRayCastInput
	{
	public:
		// members
		hkVector4     from;                                  // 00
		hkVector4     to;                                    // 10
		bool          enableShapeCollectionFilter{ false };  // 20
		std::uint32_t filterInfo{ 0 };                       // 24
	};
	static_assert(sizeof(hkpWorldRayCastInput) == 0x30);
}


===============================================
File: include/RE/H/hkpWorldRayCastOutput.h
===============================================
#pragma once

#include "RE/H/hkpShapeRayCastOutput.h"

namespace RE
{
	class hkpCollidable;

	struct hkpWorldRayCastOutput : public hkpShapeRayCastOutput
	{
	public:
		[[nodiscard]] constexpr bool HasHit() const noexcept { return rootCollidable != nullptr; }

		constexpr void Reset() noexcept
		{
			hkpShapeRayCastOutput::Reset();
			rootCollidable = nullptr;
		}

		// members
		const hkpCollidable* rootCollidable{ nullptr };  // 50
		std::uint64_t        pad58;                      // 58
	};
	static_assert(sizeof(hkpWorldRayCastOutput) == 0x60);
}


===============================================
File: include/RE/I/IAIWorldLocationHandle.h
===============================================
#pragma once

namespace RE
{
	class IAIWorldLocation;
	class PackageLocation;
	class TESObjectREFR;
	struct AIWorldLocationContext;

	class IAIWorldLocationHandle
	{
	public:
		inline static constexpr auto RTTI = RTTI_IAIWorldLocationHandle;

		virtual ~IAIWorldLocationHandle();  // 00

		// add
		virtual const IAIWorldLocation* AllocateLocation(AIWorldLocationContext* a_context) = 0;                       // 01
		virtual PackageLocation*        GetAsPackageLocation();                                                        // 02 - { return 0; }
		virtual bool                    IsRefAtLocation(AIWorldLocationContext* a_context, TESObjectREFR* a_ref) = 0;  // 03
	};
	static_assert(sizeof(IAIWorldLocationHandle) == 0x8);
}


===============================================
File: include/RE/I/IAnimationClipLoaderSingleton.h
===============================================
#pragma once

#include "RE/H/hkbContext.h"

namespace RE
{
	class hkbClipGenerator;

	class IAnimationClipLoaderSingleton
	{
	public:
		inline static auto RTTI = RTTI_IAnimationClipLoaderSingleton;
		inline static auto VTABLE = VTABLE_IAnimationClipLoaderSingleton;

		virtual ~IAnimationClipLoaderSingleton();  // 00

		// add
		virtual void          Unk_01(void);                                                                                // 01
		virtual std::uint64_t Load(const hkbContext& a_context, hkbClipGenerator* a_clipGenerator, std::uint64_t a_arg4);  // 02
		virtual void          Unk_03(void);                                                                                // 03
		virtual void          Unk_04(void);                                                                                // 04
		virtual void          Unk_05(void);                                                                                // 05
	};
}


===============================================
File: include/RE/I/IAnimationGraphManagerHolder.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	class BSAnimationGraphChannel;
	class BSAnimationGraphManager;
	class BShkbAnimationGraph;
	class NiAVObject;
	class NiPoint3;

	struct BSAnimationUpdateData;

	class IAnimationGraphManagerHolder
	{
	public:
		inline static constexpr auto RTTI = RTTI_IAnimationGraphManagerHolder;

		virtual ~IAnimationGraphManagerHolder();  // 00

		// add
		virtual bool                        NotifyAnimationGraph(const BSFixedString& a_eventName);                                                                              // 01
		virtual bool                        GetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_out) const = 0;                                             // 02
		virtual bool                        SetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_in) = 0;                                                    // 03
		virtual bool                        PopulateGraphNodesToTarget(BSScrapArray<NiAVObject*>& a_nodes);                                                                      // 04 - { return false; }
		virtual bool                        ConstructAnimationGraph(BSTSmartPointer<BShkbAnimationGraph>& a_out) = 0;                                                            // 05
		virtual void                        Unk_06(void);                                                                                                                        // 06 - { return 1; }
		virtual void                        Unk_07(void);                                                                                                                        // 07 - { return 1; }
		virtual bool                        SetupAnimEventSinks(const BSTSmartPointer<BShkbAnimationGraph>& a_animGraph);                                                        // 08 - { return true; } - sinks the holder to the the source passed in
		virtual void                        Unk_09(void);                                                                                                                        // 09 - { return; }
		virtual bool                        CreateAnimationChannels(BSScrapArray<BSTSmartPointer<BSAnimationGraphChannel>>& animGraphChannels);                                  // 0A - { return 0; }
		virtual void                        PostCreateAnimationGraphManager(BSTSmartPointer<BSAnimationGraphManager>& a_animGraphMgr);                                           // 0B - { return; }
		virtual void                        Unk_0C(void);                                                                                                                        // 0C - { return; }
		virtual void                        PostChangeAnimationManager(const BSTSmartPointer<BShkbAnimationGraph>& a_arg1, const BSTSmartPointer<BShkbAnimationGraph>& a_arg2);  // 0D - { return; }
		virtual void                        Unk_0E(void);                                                                                                                        // 0E - { return 1; }
		[[nodiscard]] virtual std::uint32_t GetGraphVariableCacheSize() const;                                                                                                   // 0F - { return 0; }
		virtual bool                        GetGraphVariableImpl1(const BSFixedString& a_variableName, float& a_out) const;                                                      // 10
		virtual bool                        GetGraphVariableImpl2(const BSFixedString& a_variableName, std::int32_t& a_out) const;                                               // 11
		virtual bool                        GetGraphVariableImpl3(const BSFixedString& a_variableName, bool& a_out) const;                                                       // 12

		bool GetAnimationGraphManager(BSTSmartPointer<BSAnimationGraphManager>& a_out) const;
		bool GetGraphVariableFloat(const BSFixedString& a_variableName, float& a_out) const;
		bool GetGraphVariableInt(const BSFixedString& a_variableName, std::int32_t& a_out) const;
		bool GetGraphVariableBool(const BSFixedString& a_variableName, bool& a_out) const;
		bool GetGraphVariableNiPoint3(const BSFixedString& a_variableName, NiPoint3& a_out) const;
		bool SetAnimationGraphManager(BSTSmartPointer<BSAnimationGraphManager>& a_in);
		bool SetGraphVariableBool(const BSFixedString& a_variableName, bool a_in);
		bool SetGraphVariableInt(const BSFixedString& a_variableName, std::int32_t a_in);
		bool SetGraphVariableFloat(const BSFixedString& a_variableName, float a_in);
		bool SetGraphVariableNiPoint3(const BSFixedString& a_variableName, NiPoint3& a_in) const;
		bool UpdateAnimationGraphManager(const BSAnimationUpdateData& a_updateData);
	};
	static_assert(sizeof(IAnimationGraphManagerHolder) == 0x8);
}


===============================================
File: include/RE/I/IAnimationSetCallbackFunctor.h
===============================================
#pragma once

namespace RE
{
	class IAnimationSetCallbackFunctor
	{
	public:
		inline static constexpr auto RTTI = RTTI_IAnimationSetCallbackFunctor;

		virtual ~IAnimationSetCallbackFunctor();  // 00

		// add
		virtual void Unk_01(void);  // 01
	};
	static_assert(sizeof(IAnimationSetCallbackFunctor) == 0x8);
}


===============================================
File: include/RE/I/IBSTCreator.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	struct IBSTCreator
	{
	public:
		virtual ~IBSTCreator();  // 00

	protected:
		// add
		[[nodiscard]] virtual T* CreateImpl() const = 0;  // 01

	public:
		virtual void Destroy(const T* a_val) const = 0;  // 02

		[[nodiscard]] inline T* Create() const
		{
			return CreateImpl();
		}
	};
	static_assert(sizeof(IBSTCreator<void*>) == 0x8);
}


===============================================
File: include/RE/I/ICellAttachDetachEventSource.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	struct CellAttachDetachEvent;

	class ICellAttachDetachEventSource :
		public BSTSingletonExplicit<ICellAttachDetachEventSource>,  // 08
		public BSTEventSource<CellAttachDetachEvent>                // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_ICellAttachDetachEventSource;

		virtual ~ICellAttachDetachEventSource();  // 00
	};
	static_assert(sizeof(ICellAttachDetachEventSource) == 0x60);
}


===============================================
File: include/RE/I/ID.h
===============================================
#pragma once

#include "RE/F/FileID.h"

namespace RE
{
	namespace BSResource
	{
		struct ID : public FileID
		{
		public:
			// members
			std::uint32_t dir;  // 0
		};
		static_assert(sizeof(ID) == 0xC);
	}
}


===============================================
File: include/RE/I/IDEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/I/InputEvent.h"

namespace RE
{
	class IDEvent : public InputEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_IDEvent;

		~IDEvent() override;  // 00

		// override
		bool                               HasIDCode() const override;   // 01 - { return true; }
		[[nodiscard]] const BSFixedString& QUserEvent() const override;  // 02 - { return userEvent; }

		[[nodiscard]] constexpr std::uint32_t GetIDCode() const noexcept { return idCode; }

		// members
		BSFixedString userEvent;  // 18
		std::uint32_t idCode;     // 20
		std::uint32_t pad24;      // 24
	};
	static_assert(sizeof(IDEvent) == 0x28);
}


===============================================
File: include/RE/I/IFormFactory.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"

namespace RE
{
	template <class T, FormType>
	class ConcreteFormFactory;

	enum class OBJECT_TYPE
	{
	};

	enum class OBJECT_CATEGORY_TYPE
	{
	};

	class IFormFactory
	{
	public:
		inline static constexpr auto RTTI = RTTI_IFormFactory;

		virtual ~IFormFactory();  // 00

	protected:
		// add
		virtual TESForm* CreateImpl() = 0;  // 01

	public:
		[[nodiscard]] virtual const char*          GetFormName() const = 0;    // 02
		[[nodiscard]] virtual FormType             GetFormType() const = 0;    // 03
		[[nodiscard]] virtual const char*          GetObjectName() const;      // 04 - { return 0; }
		[[nodiscard]] virtual OBJECT_TYPE          GetObjectType() const;      // 05 - { return 106; }
		[[nodiscard]] virtual OBJECT_CATEGORY_TYPE GetObjectCategory() const;  // 06 - { return 9; }

		static std::pair<IFormFactory**, bool> GetFormFactories();
		static IFormFactory*                   GetFormFactoryByType(FormType a_formType);

		template <class T>
		static ConcreteFormFactory<T, T::FORMTYPE>* GetConcreteFormFactoryByType();

		TESForm* Create();
	};
	static_assert(sizeof(IFormFactory) == 0x8);
}


===============================================
File: include/RE/I/IFreezeQuery.h
===============================================
#pragma once

namespace RE
{
	namespace BSScript
	{
		class IFreezeQuery
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IFreezeQuery;

			virtual ~IFreezeQuery();  // 00

			// add
			virtual bool GetIsFrozen();  // 00
		};
		static_assert(sizeof(IFreezeQuery) == 0x8);
	}
}


===============================================
File: include/RE/I/IFuncCallQuery.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	namespace BSScript
	{
		class ObjectTypeInfo;
		class Variable;

		namespace Internal
		{
			class IFuncCallQuery : public BSIntrusiveRefCounted
			{
			public:
				inline static constexpr auto RTTI = RTTI_BSScript__Internal__IFuncCallQuery;

				enum class CallType
				{
					kMember,
					kStatic,
					kGetter,
					kSetter
				};

				virtual ~IFuncCallQuery();  // 00

				// add
				virtual bool GetFunctionCallInfo(CallType& a_callType, BSTSmartPointer<ObjectTypeInfo>& a_arg2, BSFixedString& a_arg3, Variable& a_arg4, BSScrapArray<Variable>& a_arg5) = 0;  // 01

				// members
				std::uint32_t pad0C;  // 0C
			};
			static_assert(sizeof(IFuncCallQuery) == 0x10);
		}
	}
}


===============================================
File: include/RE/I/IFunction.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	namespace BSScript
	{
		namespace Internal
		{
			class VirtualMachine;
		}

		class ErrorLogger;
		class Stack;
		class StackFrame;
		class TypeInfo;
		class VMState;

		class IFunction : public BSIntrusiveRefCounted
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IFunction;

			enum class FunctionType
			{
				kNormal = 0,
				kGetter = 1,
				kSetter = 2
			};

			enum class CallResult
			{
				kCompleted = 0,
				kSetupForVM = 1,
				kInProgress = 2,
				kFailedRetry = 3,
				kFailedAbort = 4
			};

			IFunction();
			virtual ~IFunction() = default;  // 00

			// add
			virtual const BSFixedString& GetName() const = 0;                                                                                                  // 01
			virtual const BSFixedString& GetObjectTypeName() const = 0;                                                                                        // 02
			virtual const BSFixedString& GetStateName() const = 0;                                                                                             // 03
			virtual TypeInfo             GetReturnType() const = 0;                                                                                            // 04
			virtual std::uint32_t        GetParamCount() const = 0;                                                                                            // 05
			virtual void                 GetParam(std::uint32_t a_idx, BSFixedString& a_nameOut, TypeInfo& a_typeOut) const = 0;                               // 06
			virtual std::uint32_t        GetStackFrameSize() const = 0;                                                                                        // 07
			virtual bool                 GetIsNative() const = 0;                                                                                              // 08
			virtual bool                 GetIsStatic() const = 0;                                                                                              // 09
			virtual bool                 GetIsEmpty() const = 0;                                                                                               // 0A
			virtual FunctionType         GetFunctionType() const = 0;                                                                                          // 0B
			virtual std::uint32_t        GetUserFlags() const = 0;                                                                                             // 0C
			virtual const BSFixedString& GetDocString() const = 0;                                                                                             // 0D
			virtual void                 InsertLocals(StackFrame* a_frame) = 0;                                                                                // 0E
			virtual CallResult           Call(const BSTSmartPointer<Stack>& a_stack, ErrorLogger* a_logger, Internal::VirtualMachine* a_vm, bool a_arg4) = 0;  // 0F
			virtual const BSFixedString& GetSourceFilename() const = 0;                                                                                        // 10
			virtual bool                 TranslateIPToLineNumber(std::uint32_t a_indexPtr, std::uint32_t& a_lineNumberOut) const = 0;                          // 11
			virtual bool                 GetVarNameForStackIndex(std::uint32_t a_idx, BSFixedString& a_nameOut) const = 0;                                     // 12
			virtual bool                 CanBeCalledFromTasklets() const = 0;                                                                                  // 13
			virtual void                 SetCallableFromTasklets(bool a_callable) = 0;                                                                         // 14

			// members
			std::uint32_t pad0C;  // 0C
		};
		static_assert(sizeof(IFunction) == 0x10);
	}
}


===============================================
File: include/RE/I/IFunctionArguments.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/M/MemoryManager.h"
#include "RE/V/Variable.h"

namespace RE
{
	namespace BSScript
	{
		class IFunctionArguments
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IFunctionArguments;

			IFunctionArguments() = default;
			virtual ~IFunctionArguments() = default;  // 00

			// add
			virtual bool operator()(BSScrapArray<Variable>& a_dst) const = 0;  // 01

			TES_HEAP_REDEFINE_NEW();
		};
		static_assert(sizeof(IFunctionArguments) == 0x8);
	}
}


===============================================
File: include/RE/I/IHandleReaderWriter.h
===============================================
#pragma once

namespace RE
{
	class BSMemStorage;
	class SaveStorageWrapper;

	namespace BSScript
	{
		class IHandleReaderWriter
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IHandleReaderWriter;
			inline static constexpr auto VTABLE = VTABLE_BSScript__IHandleReaderWriter;

			virtual ~IHandleReaderWriter();  // 0

			// add
			virtual void Unk_08() = 0;
			virtual bool SaveHandle(SaveStorageWrapper* saveWrapper, VMHandle handle) = 0;
			virtual bool LoadHandle(BSMemStorage* loadWrapper, VMHandle* out) = 0;
			virtual bool SaveRefID(SaveStorageWrapper* saveWrapper, uint32_t handleLow);
			virtual bool ParseScriptInstance(BSMemStorage* loadWrapper, uint32_t* scriptInstanceValues);
		};
		static_assert(sizeof(IHandleReaderWriter) == 0x8);
	}
}


===============================================
File: include/RE/I/IHandlerFunctor.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTObjectDictionary.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	template <class Handler, class Parameter>
	class IHandlerFunctor :
		public BSIntrusiveRefCounted  // 08
	{
	public:
		IHandlerFunctor() = default;
		virtual ~IHandlerFunctor() = default;  // 00

		// add
		virtual bool ExecuteHandler(Handler& a_handler, const Parameter& a_parameter) = 0;

		inline bool operator()(Handler& a_handler, const Parameter& a_parameter)
		{
			return ExecuteHandler(a_handler, a_parameter);
		}

		// members
		std::uint32_t pad0C;  // 0C
	};
	//static_assert(sizeof(IHandlerFunctor) == 0x10);

	class Actor;
	using AnimHandler = IHandlerFunctor<Actor, BSFixedString>;
	static_assert(sizeof(AnimHandler) == 0x10);

	template <class T, class Key>
	class HandlerCreationMissPolicy
	{
	public:
		virtual ~HandlerCreationMissPolicy();  // 00
	};
	//static_assert(sizeof(HandlerCreationMissPolicy) == 0x8);

	template <class T, class Key>
	class NoInitializationPolicy
	{
	public:
		virtual ~NoInitializationPolicy();  // 00
	};
	//static_assert(sizeof(NoInitializationPolicy) == 0x8);

	class HandlerDictionary :
		public BSTObjectDictionary<
			BSTSmartPointer<AnimHandler>,
			BSFixedString,
			HandlerCreationMissPolicy,
			NoInitializationPolicy>
	{
	public:
		static HandlerDictionary* GetSingleton();
	};
	static_assert(sizeof(HandlerDictionary) == 0x50);
}


===============================================
File: include/RE/I/ILoader.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/U/UnlinkedTypes.h"

namespace RE
{
	namespace BSScript
	{
		class IStore;

		struct ILoader
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__ILoader;

			virtual ~ILoader();  // 00

			// add
			virtual ILoader* Clone() = 0;                                                        // 01
			virtual void     SetScriptStore(const BSTSmartPointer<IStore>& a_store) = 0;         // 02
			virtual bool     GetClass(const char* a_name, UnlinkedTypes::Object& a_object) = 0;  // 03
		};
		static_assert(sizeof(ILoader) == 0x8);
	}
}


===============================================
File: include/RE/I/IMapCameraCallbacks.h
===============================================
#pragma once

namespace RE
{
	struct IMapCameraCallbacks
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMapCameraCallbacks;

		// add
		virtual void Unk_00(void);  // 00
		virtual void Unk_01(void);  // 01

		virtual ~IMapCameraCallbacks();  // 02
	};
	static_assert(sizeof(IMapCameraCallbacks) == 0x8);
}


===============================================
File: include/RE/I/IMemoryHeap.h
===============================================
#pragma once

#include "RE/I/IMemoryStore.h"

namespace RE
{
	enum class MEM_CONTEXT : std::int32_t;

	struct HeapStats
	{
	public:
		// members
		const char*  heapName;              // 00
		std::size_t  memHeapSize;           // 08
		std::size_t  memHeapCommitted;      // 10
		std::size_t  memAllocatedToBlocks;  // 18
		std::int32_t numBlocks;             // 20
		std::int32_t numFreeBlocks;         // 24
		std::size_t  memFreeInBlocks;       // 28
		std::size_t  memUsedInBlocks;       // 30
		std::size_t  smallestFreeBlock;     // 38
		std::size_t  largestFreeBlock;      // 40
		std::size_t  heapOverhead;          // 48
		std::size_t  freeListOverhead;      // 50
		std::size_t  blockOverhead;         // 58
		std::size_t  totalFree;             // 60
	};
	static_assert(sizeof(HeapStats) == 0x68);

	class IMemoryHeap : public IMemoryStore
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMemoryHeap;

		~IMemoryHeap() override = default;  // 00

		// override (IMemoryStore)
		bool  ContainsBlockImpl(const void* a_block) const override { return PointerInHeap(a_block); }                             // 03
		void* AllocateAlignImpl(std::size_t a_size, std::uint32_t a_alignment) override { return Allocate(a_size, a_alignment); }  // 04
		void  DeallocateAlignImpl(void*& a_block) override { Deallocate(a_block, 0); }                                             // 05

		// add
		[[nodiscard]] virtual const char*   GetName() const = 0;                                                      // 07
		virtual void*                       Allocate(std::size_t a_size, std::uint32_t a_alignment) = 0;              // 08
		virtual void                        Deallocate(void* a_mem, std::uint32_t) = 0;                               // 09
		virtual bool                        PointerInHeap(const void* a_pointer) const = 0;                           // 0A
		virtual std::size_t                 TotalSize(const void* a_pointer) const = 0;                               // 0B
		virtual void                        GetHeapStats(HeapStats* a_stats, bool a_fullBlockInfo) = 0;               // 0C
		virtual bool                        ShouldTrySmallBlockPools(std::size_t a_size, MEM_CONTEXT a_context) = 0;  // 0D
		[[nodiscard]] virtual std::uint32_t GetPageSize() const = 0;                                                  // 0E
	};
	static_assert(sizeof(IMemoryHeap) == 0x8);
}


===============================================
File: include/RE/I/IMemoryPagePolicy.h
===============================================
#pragma once
#include "RE/M/MemoryPage.h"
namespace RE
{
	namespace BSScript
	{
		struct IMemoryPagePolicy
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IMemoryPagePolicy;

			enum class AllocationStatus
			{
				kSuccess,
				kFailed,
				kOutOfMemory
			};

			enum class NewPageStrategy
			{
				kNormal,
				kIgnoreMemoryLimit
			};

			virtual ~IMemoryPagePolicy();  // 00

			// add
			virtual std::uint32_t    MaximumPageSize() = 0;                                                                                         // 01
			virtual AllocationStatus AllocatePage(std::uint32_t a_pageSize, NewPageStrategy a_stategy, BSTAutoPointer<MemoryPage>& a_newPage) = 0;  // 02
			virtual AllocationStatus GetLargestAvailablePage(BSTAutoPointer<MemoryPage>& a_newPage) = 0;                                            // 03
			virtual void             DisposePage(BSTAutoPointer<MemoryPage>& a_oldPage) = 0;                                                        // 04
		};
		static_assert(sizeof(IMemoryPagePolicy) == 0x8);
	}
}


===============================================
File: include/RE/I/IMemoryStore.h
===============================================
#pragma once

#include "RE/I/IMemoryStoreBase.h"

namespace RE
{
	class IMemoryStore : public IMemoryStoreBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMemoryStore;

		~IMemoryStore() override = default;  // 00

		// add
		virtual void* AllocateAlignImpl(std::size_t a_size, std::uint32_t a_alignment) = 0;                                                 // 04
		virtual void  DeallocateAlignImpl(void*& a_block) = 0;                                                                              // 05
		virtual void* TryAllocateImpl([[maybe_unused]] std::size_t a_size, [[maybe_unused]] std::uint32_t a_alignment) { return nullptr; }  // 06

		void* AllocateAlign(std::size_t a_size, std::uint32_t a_alignment);
		void  DeallocateAlign(void*& a_freeBlock);
	};
	static_assert(sizeof(IMemoryStore) == 0x8);
}


===============================================
File: include/RE/I/IMemoryStoreBase.h
===============================================
#pragma once

namespace RE
{
	struct MemoryStats
	{
	public:
		// members
		const char*   name;           // 00
		std::size_t   usedSize;       // 08
		std::size_t   committedSize;  // 10
		std::size_t   reservedSize;   // 18
		std::uint32_t overhead;       // 20
		std::uint32_t pad24;          // 24
		std::size_t   freeSize;       // 28
	};
	static_assert(sizeof(MemoryStats) == 0x30);

	class IMemoryStoreBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMemoryStoreBase;

		virtual ~IMemoryStoreBase() = default;  // 00

		// add
		virtual std::size_t Size(const void* a_mem) const = 0;                 // 01
		virtual void        GetMemoryStats(MemoryStats* a_stats) = 0;          // 02
		virtual bool        ContainsBlockImpl(const void* a_block) const = 0;  // 03
	};
	static_assert(sizeof(IMemoryStoreBase) == 0x8);
}


===============================================
File: include/RE/I/IMenu.h
===============================================
#pragma once

#include "RE/F/FxDelegate.h"
#include "RE/F/FxDelegateHandler.h"
#include "RE/G/GFxMovieView.h"
#include "RE/G/GPtr.h"
#include "RE/U/UserEvents.h"

namespace RE
{
	class CallbackProcessor;
	class UIMessage;

	enum class UI_MENU_FLAGS
	{
		kNone = 0,
		kPausesGame = 1 << 0,
		kAlwaysOpen = 1 << 1,
		kUsesCursor = 1 << 2,
		kUsesMenuContext = 1 << 3,
		kModal = 1 << 4,  // prevents lower movies with this flag from advancing
		kFreezeFrameBackground = 1 << 5,
		kOnStack = 1 << 6,
		kDisablePauseMenu = 1 << 7,
		kRequiresUpdate = 1 << 8,
		kTopmostRenderedMenu = 1 << 9,
		kUpdateUsesCursor = 1 << 10,
		kAllowSaving = 1 << 11,
		kRendersOffscreenTargets = 1 << 12,
		kInventoryItemMenu = 1 << 13,
		kDontHideCursorWhenTopmost = 1 << 14,
		kCustomRendering = 1 << 15,
		kAssignCursorToRenderer = 1 << 16,
		kApplicationMenu = 1 << 17,
		kHasButtonBar = 1 << 18,
		kIsTopButtonBar = 1 << 19,
		kAdvancesUnderPauseMenu = 1 << 20,
		kRendersUnderPauseMenu = 1 << 21,
		kUsesBlurredBackground = 1 << 22,
		kCompanionAppAllowed = 1 << 23,
		kFreezeFramePause = 1 << 24,
		kSkipRenderDuringFreezeFrameScreenshot = 1 << 25,
		kLargeScaleformRenderCacheMode = 1 << 26,
		kUsesMovementToDirection = 1 << 27
	};

	enum class UI_MESSAGE_RESULTS
	{
		kHandled = 0,
		kIgnore = 1,
		kPassOn = 2
	};

	class IMenu : public FxDelegateHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMenu;

		using Context = UserEvents::INPUT_CONTEXT_ID;
		using Flag = UI_MENU_FLAGS;

		~IMenu() override = default;  // 00

		// override (FxDelegateHandler)
		void Accept(CallbackProcessor* a_processor) override;  // 01 - { return; }

		// add
		virtual void               PostCreate();                                                 // 02 - { return; }
		virtual void               Unk_03(void);                                                 // 03 - { return; }
		virtual UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message);                         // 04
		virtual void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime);  // 05
		virtual void               PostDisplay();                                                // 06
		virtual void               PreDisplay();                                                 // 07 - { return; } - only available if kRendersOffscreenTargets is set
		virtual void               RefreshPlatform();                                            // 08

		[[nodiscard]] constexpr bool AdvancesUnderPauseMenu() const noexcept { return menuFlags.all(Flag::kAdvancesUnderPauseMenu); }
		[[nodiscard]] constexpr bool AllowSaving() const noexcept { return menuFlags.all(Flag::kAllowSaving); }
		[[nodiscard]] constexpr bool AlwaysOpen() const noexcept { return menuFlags.all(Flag::kAlwaysOpen); }
		[[nodiscard]] constexpr bool ApplicationMenu() const noexcept { return menuFlags.all(Flag::kApplicationMenu); }
		[[nodiscard]] constexpr bool AssignCursorToRenderer() const noexcept { return menuFlags.all(Flag::kAssignCursorToRenderer); }
		[[nodiscard]] constexpr bool CustomRendering() const noexcept { return menuFlags.all(Flag::kCustomRendering); }
		[[nodiscard]] constexpr bool CompanionAppAllowed() const noexcept { return menuFlags.all(Flag::kCompanionAppAllowed); }
		[[nodiscard]] constexpr bool DisablePauseMenu() const noexcept { return menuFlags.all(Flag::kDisablePauseMenu); }
		[[nodiscard]] constexpr bool DontHideCursorWhenTopmost() const noexcept { return menuFlags.all(Flag::kDontHideCursorWhenTopmost); }
		[[nodiscard]] constexpr bool FreezeFrameBackground() const noexcept { return menuFlags.all(Flag::kFreezeFrameBackground); }
		[[nodiscard]] constexpr bool FreezeFramePause() const noexcept { return menuFlags.all(Flag::kFreezeFramePause); }
		[[nodiscard]] constexpr bool HasButtonBar() const noexcept { return menuFlags.all(Flag::kHasButtonBar); }
		[[nodiscard]] constexpr bool InventoryItemMenu() const noexcept { return menuFlags.all(Flag::kInventoryItemMenu); }
		[[nodiscard]] constexpr bool IsTopButtonBar() const noexcept { return menuFlags.all(Flag::kIsTopButtonBar); }
		[[nodiscard]] constexpr bool LargeScaleformRenderCacheMode() const noexcept { return menuFlags.all(Flag::kLargeScaleformRenderCacheMode); }
		[[nodiscard]] constexpr bool Modal() const noexcept { return menuFlags.all(Flag::kModal); }
		[[nodiscard]] constexpr bool OnStack() const noexcept { return menuFlags.all(Flag::kOnStack); }
		[[nodiscard]] constexpr bool PausesGame() const noexcept { return menuFlags.all(Flag::kPausesGame); }
		[[nodiscard]] constexpr bool RendersOffscreenTargets() const noexcept { return menuFlags.all(Flag::kRendersOffscreenTargets); }
		[[nodiscard]] constexpr bool RendersUnderPauseMenu() const noexcept { return menuFlags.all(Flag::kRendersUnderPauseMenu); }
		[[nodiscard]] constexpr bool RequiresUpdate() const noexcept { return menuFlags.all(Flag::kRequiresUpdate); }
		[[nodiscard]] constexpr bool SkipRenderDuringFreezeFrameScreenshot() const noexcept { return menuFlags.all(Flag::kSkipRenderDuringFreezeFrameScreenshot); }
		[[nodiscard]] constexpr bool TopmostRenderedMenu() const noexcept { return menuFlags.all(Flag::kTopmostRenderedMenu); }
		[[nodiscard]] constexpr bool UpdateUsesCursor() const noexcept { return menuFlags.all(Flag::kUsesBlurredBackground); }
		[[nodiscard]] constexpr bool UsesBlurredBackground() const noexcept { return menuFlags.all(Flag::kUsesCursor); }
		[[nodiscard]] constexpr bool UsesCursor() const noexcept { return menuFlags.all(Flag::kUsesMenuContext); }
		[[nodiscard]] constexpr bool UsesMenuContext() const noexcept { return menuFlags.all(Flag::kUsesMovementToDirection); }
		[[nodiscard]] constexpr bool UsesMovementToDirection() const noexcept { return menuFlags.all(Flag::kUpdateUsesCursor); }

		// members
		GPtr<GFxMovieView>                             uiMovie{ nullptr };              // 10
		std::int8_t                                    depthPriority{ 3 };              // 18
		std::uint8_t                                   pad19{ 0 };                      // 19
		std::uint16_t                                  pad20{ 0 };                      // 1A
		stl::enumeration<UI_MENU_FLAGS, std::uint32_t> menuFlags{ Flag::kNone };        // 1C
		stl::enumeration<Context, std::uint32_t>       inputContext{ Context::kNone };  // 20
		std::uint32_t                                  pad24{ 0 };                      // 24
		GPtr<FxDelegate>                               fxDelegate{ nullptr };           // 28
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		std::int32_t  unk30{ -1 };
		std::int32_t  unk34{ 1 };
		std::uint64_t unk38{ 0 };
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(IMenu) == 0x30);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(IMenu) == 0x40);
#endif
}


===============================================
File: include/RE/I/IMessageBoxCallback.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"

namespace RE
{
	class IMessageBoxCallback : public BSIntrusiveRefCounted
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMessageBoxCallback;

		enum class Message
		{
			kUnk0 = 0,
			kUnk1 = 1,
			kUnk2 = 2
		};

		virtual ~IMessageBoxCallback() = default;  // 00

		// add
		virtual void Run(Message a_msg) = 0;  // 01

		// members
		std::uint32_t unk0C;  // 0C
	};
	static_assert(sizeof(IMessageBoxCallback) == 0x10);
}


===============================================
File: include/RE/I/IMovementControllerRegisterInterface.h
===============================================
#pragma once

namespace RE
{
	class IMovementControllerRegisterInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementControllerRegisterInterface;

		virtual ~IMovementControllerRegisterInterface();  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
	};
	static_assert(sizeof(IMovementControllerRegisterInterface) == 0x8);
}


===============================================
File: include/RE/I/IMovementDirectControl.h
===============================================
#pragma once

#include "RE/I/IMovementInterface.h"

namespace RE
{
	class IMovementDirectControl : public IMovementInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementDirectControl;

		~IMovementDirectControl() override;  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void) = 0;  // 05
		virtual void Unk_06(void) = 0;  // 06
		virtual void Unk_07(void) = 0;  // 07
		virtual void Unk_08(void) = 0;  // 08
	};
	static_assert(sizeof(IMovementDirectControl) == 0x8);
}


===============================================
File: include/RE/I/IMovementInterface.h
===============================================
#pragma once

namespace RE
{
	class IMovementInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementInterface;

		virtual ~IMovementInterface();
	};
	static_assert(sizeof(IMovementInterface) == 0x8);
}


===============================================
File: include/RE/I/IMovementMessageInterface.h
===============================================
#pragma once

#include "RE/I/IMovementInterface.h"

namespace RE
{
	class IMovementMessageInterface : public IMovementInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementMessageInterface;

		~IMovementMessageInterface() override;  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
	};
	static_assert(sizeof(IMovementMessageInterface) == 0x8);
}


===============================================
File: include/RE/I/IMovementMotionDrivenControl.h
===============================================
#pragma once

#include "RE/I/IMovementInterface.h"

namespace RE
{
	class IMovementMotionDrivenControl : public IMovementInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementMotionDrivenControl;

		~IMovementMotionDrivenControl() override;  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void) = 0;  // 05
		virtual void Unk_06(void) = 0;  // 06
		virtual void Unk_07(void) = 0;  // 07
		virtual void Unk_08(void) = 0;  // 08
	};
	static_assert(sizeof(IMovementMotionDrivenControl) == 0x8);
}


===============================================
File: include/RE/I/IMovementPlannerDirectControl.h
===============================================
#pragma once

#include "RE/I/IMovementInterface.h"

namespace RE
{
	class IMovementPlannerDirectControl : public IMovementInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementPlannerDirectControl;

		~IMovementPlannerDirectControl() override;  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void) = 0;  // 05
	};
	static_assert(sizeof(IMovementPlannerDirectControl) == 0x8);
}


===============================================
File: include/RE/I/IMovementSelectIdle.h
===============================================
#pragma once

#include "RE/I/IMovementInterface.h"

namespace RE
{
	class IMovementSelectIdle : public IMovementInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementSelectIdle;

		~IMovementSelectIdle() override;  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void) = 0;  // 05
	};
	static_assert(sizeof(IMovementSelectIdle) == 0x8);
}


===============================================
File: include/RE/I/IMovementState.h
===============================================
#pragma once

#include "RE/I/IMovementInterface.h"

namespace RE
{
	class NiPoint3;

	class IMovementState : public IMovementInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_IMovementState;

		~IMovementState() override;  // 00

		// add
		virtual void  Unk_01(void) = 0;                                 // 01
		virtual void  Unk_02(void) = 0;                                 // 02
		virtual void  Unk_03(void) = 0;                                 // 03
		virtual void  Unk_04(void) = 0;                                 // 04
		virtual float DoGetMovementSpeed() = 0;                         // 05
		virtual void  Unk_06(void) = 0;                                 // 06
		virtual void  Unk_07(void) = 0;                                 // 07
		virtual void  Unk_08(void) = 0;                                 // 08
		virtual void  DoGetMovementRotation(NiPoint3& a_rotation) = 0;  // 09
		virtual void  Unk_0A(void) = 0;                                 // 0A
		virtual void  Unk_0B(void) = 0;                                 // 0B
		virtual void  Unk_0C(void) = 0;                                 // 0C
		virtual void  Unk_0D(void) = 0;                                 // 0D
		virtual void  Unk_0E(void) = 0;                                 // 0E
		virtual void  Unk_0F(void) = 0;                                 // 0F
		virtual void  Unk_10(void) = 0;                                 // 10
		virtual void  Unk_11(void) = 0;                                 // 11
		virtual void  Unk_12(void) = 0;                                 // 12
		virtual void  Unk_13(void) = 0;                                 // 13
	};
	static_assert(sizeof(IMovementState) == 0x8);
}


===============================================
File: include/RE/I/INIPrefSettingCollection.h
===============================================
#pragma once

#include "RE/I/INISettingCollection.h"

namespace RE
{
	class INIPrefSettingCollection : public INISettingCollection
	{
	public:
		inline static constexpr auto RTTI = RTTI_INIPrefSettingCollection;
		inline static constexpr auto VTABLE = VTABLE_INIPrefSettingCollection;

		~INIPrefSettingCollection() override;  // 00

		// override (INISettingCollection)
		void Unk_07(void) override;        // 07 - { return 1; }
		void WriteAllSettings() override;  // 08
		void ReadAllSettings() override;   // 09

		static INIPrefSettingCollection* GetSingleton();
	};
	static_assert(sizeof(INIPrefSettingCollection) == 0x128);
}


===============================================
File: include/RE/I/INISettingCollection.h
===============================================
#pragma once

#include "RE/S/Setting.h"
#include "RE/S/SettingCollectionList.h"

namespace RE
{
	class INISettingCollection : public SettingCollectionList<Setting>
	{
	public:
		inline static constexpr auto RTTI = RTTI_INISettingCollection;
		inline static constexpr auto VTABLE = VTABLE_INISettingCollection;

		~INISettingCollection() override;  // 00

		// override (SettingCollectionList<Setting>)
		bool WriteSetting(Setting* a_setting) override;  // 03
		bool ReadSetting(Setting* a_setting) override;   // 04
		bool OpenHandle(bool a_create) override;         // 05 - { handle = this; return true; }
		bool CloseHandle() override;                     // 06 - { handle = 0; return true; }

		static INISettingCollection* GetSingleton();

		Setting* GetSetting(std::string_view a_name);
	};
	static_assert(sizeof(INISettingCollection) == 0x128);
}


===============================================
File: include/RE/I/IObjectHandlePolicy.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class TESForm;

	namespace BSScript
	{
		struct IObjectHandlePolicy
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IObjectHandlePolicy;

			virtual ~IObjectHandlePolicy();  // 00

			// add
			[[nodiscard]] virtual bool     HandleIsType(VMTypeID a_typeID, VMHandle a_handle) const = 0;                 // 01
			[[nodiscard]] virtual bool     IsHandleObjectAvailable(VMHandle a_handle) const = 0;                         // 02
			[[nodiscard]] virtual VMHandle EmptyHandle() const = 0;                                                      // 03
			virtual VMHandle               GetHandleForObject(VMTypeID a_typeID, const void* a_srcData) const = 0;       // 04
			[[nodiscard]] virtual bool     HasParent(VMHandle a_handle) const = 0;                                       // 05
			[[nodiscard]] virtual VMHandle GetParentHandle(VMHandle a_handle) const = 0;                                 // 06
			[[nodiscard]] virtual VMHandle GetHandleScriptsMovedFrom(VMHandle a_handle) const = 0;                       // 07
			[[nodiscard]] virtual void*    GetObjectForHandle(VMTypeID a_typeID, VMHandle a_handle) const = 0;           // 08
			virtual void                   PersistHandle(VMHandle a_handle) = 0;                                         // 09
			virtual void                   ReleaseHandle(VMHandle a_handle) = 0;                                         // 0A
			virtual void                   ConvertHandleToString(VMHandle a_handle, BSFixedString& a_strOut) const = 0;  // 0B

			bool     HandleIsType(FormType a_typeID, VMHandle a_handle);
			VMHandle GetHandleForObject(FormType a_typeID, const TESForm* a_srcData);
			TESForm* GetObjectForHandle(FormType a_typeID, VMHandle a_handle);
		};
		static_assert(sizeof(IObjectHandlePolicy) == 0x8);
	}
}


===============================================
File: include/RE/I/IObjectProcessor.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	namespace BSScript
	{
		struct ILoader;

		class IObjectProcessor
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IObjectProcessor;

			virtual ~IObjectProcessor();  // 00

			// add
			virtual IObjectProcessor* Clone() = 0;                                    // 01
			virtual void              SetLoader(ILoader* a_loader) = 0;               // 02
			virtual bool              Process(const BSFixedString& a_className) = 0;  // 03
		};
		static_assert(sizeof(IObjectProcessor) == 0x8);
	}
}


===============================================
File: include/RE/I/IPackageData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSString.h"

namespace RE
{
	class BGSLoadFormBuffer;
	class TESFile;

	class IPackageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_IPackageData;

		virtual ~IPackageData();  // 00

		// add
		virtual void                               InitPackage() = 0;                            // 01
		virtual void                               LoadPackage(TESFile* a_mod) = 0;              // 02
		virtual void                               Assign(IPackageData* a_other) = 0;            // 03
		virtual bool                               IsNotEqual(IPackageData* a_other) const = 0;  // 04
		virtual void                               Unk_05(void) = 0;                             // 05
		virtual void                               Unk_06(void);                                 // 06 - { return; }
		virtual void                               Unk_07(void);                                 // 07 - { return; }
		virtual void                               LoadBuffer(BGSLoadFormBuffer* a_buf);         // 08 - { return; }
		virtual void                               Unk_09(void);                                 // 09 - { return; }
		virtual bool                               GetDataAsString(BSString* a_dst) const = 0;   // 0A
		[[nodiscard]] virtual const BSFixedString& GetTypeName() const = 0;                      // 0B
		virtual void                               Unk_0C(void);                                 // 0C - { return 0; }
	};
	static_assert(sizeof(IPackageData) == 0x8);
}


===============================================
File: include/RE/I/IPackageDataAIWorldLocationHandle.h
===============================================
#pragma once

#include "RE/I/IAIWorldLocationHandle.h"
#include "RE/I/IPackageData.h"

namespace RE
{
	class IPackageDataAIWorldLocationHandle :
		public IAIWorldLocationHandle,  // 00
		public IPackageData             // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_IPackageDataAIWorldLocationHandle;

		~IPackageDataAIWorldLocationHandle() override;  // 00
	};
	static_assert(sizeof(IPackageDataAIWorldLocationHandle) == 0x10);
}


===============================================
File: include/RE/I/IPostAnimationChannelUpdateFunctor.h
===============================================
#pragma once

namespace RE
{
	class IPostAnimationChannelUpdateFunctor
	{
	public:
		inline static constexpr auto RTTI = RTTI_IPostAnimationChannelUpdateFunctor;

		virtual ~IPostAnimationChannelUpdateFunctor();  // 00

		// add
		virtual void Unk_01(void);  // 01
	};
	static_assert(sizeof(IPostAnimationChannelUpdateFunctor) == 0x8);
}


===============================================
File: include/RE/I/IProcedureTreeItem.h
===============================================
#pragma once

namespace RE
{
	class TESFile;

	class IProcedureTreeItem
	{
	public:
		inline static constexpr auto RTTI = RTTI_IProcedureTreeItem;

		virtual ~IProcedureTreeItem();  // 00

		// add
		virtual void Unk_01(void) = 0;          // 01
		virtual void Unk_02(void) = 0;          // 02
		virtual void Load(TESFile* a_mod) = 0;  // 03
		virtual void Unk_04(void) = 0;          // 04
		virtual void Unk_05(void) = 0;          // 05
		virtual void Unk_06(void) = 0;          // 06
		virtual void Unk_07(void) = 0;          // 07
		virtual void Unk_08(void);              // 08
		virtual void Unk_09(void);              // 09
		virtual void Unk_0A(void) = 0;          // 0A
		virtual void Unk_0B(void) = 0;          // 0B
		virtual void Unk_0C(void) = 0;          // 0C
		virtual void Unk_0D(void) = 0;          // 0D
		virtual void Unk_0E(void) = 0;          // 0E
		virtual void Unk_0F(void) = 0;          // 0F
		virtual void Unk_10(void) = 0;          // 10
	};
	static_assert(sizeof(IProcedureTreeItem) == 0x8);
}


===============================================
File: include/RE/I/IProfilePolicy.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	namespace BSScript
	{
		namespace Internal
		{
			class IFuncCallQuery;
		}

		class Variable;

		class IProfilePolicy
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IProfilePolicy;

			virtual ~IProfilePolicy();  // 00

			// add
			virtual void StackFramePushQueued(std::uint32_t a_arg1, std::uint32_t a_arg2, const BSTSmartPointer<Internal::IFuncCallQuery>& a_arg3) = 0;                                                       // 01
			virtual void StackFramePushed(std::uint32_t a_arg1, std::uint32_t a_arg2, const Variable& a_arg3, const BSFixedString& a_arg4, const BSFixedString& a_arg5, const BSFixedString& a_arg6) = 0;     // 02
			virtual void StackFramePopQueued(std::uint32_t a_arg1, std::uint32_t a_arg2, const Variable& a_arg3, const BSFixedString& a_arg4, const BSFixedString& a_arg5, const BSFixedString& a_arg6) = 0;  // 03
			virtual void StackFramePopped(std::uint32_t a_arg1, std::uint32_t a_arg2, const Variable& a_arg3, const BSFixedString& a_arg4, const BSFixedString& a_arg5, const BSFixedString& a_arg6) = 0;     // 04
		};
		static_assert(sizeof(IProfilePolicy) == 0x8);
	}
}


===============================================
File: include/RE/I/ISavePatcherInterface.h
===============================================
#pragma once

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
		class StackFrame;

		class ISavePatcherInterface
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__ISavePatcherInterface;

			virtual ~ISavePatcherInterface();  // 00

			// add
			virtual void PatchStackFrame(StackFrame* a_stackFrame, IVirtualMachine* a_vm) = 0;  // 01
		};
		static_assert(sizeof(ISavePatcherInterface) == 0x8);
	}
}


===============================================
File: include/RE/I/IStackCallbackFunctor.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	namespace BSScript
	{
		class Object;
		class Variable;

		class IStackCallbackFunctor : public BSIntrusiveRefCounted
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IStackCallbackFunctor;

			IStackCallbackFunctor();
			virtual ~IStackCallbackFunctor() = default;  // 00

			// add
			virtual void operator()(Variable a_result) = 0;                       // 01
			virtual bool CanSave() const;                                         // 02 - { return false; }
			virtual void SetObject(const BSTSmartPointer<Object>& a_object) = 0;  // 03

			// members
			std::uint32_t pad0C;  // 0C
		};
		static_assert(sizeof(IStackCallbackFunctor) == 0x10);
	}
}


===============================================
File: include/RE/I/IStackCallbackSaveInterface.h
===============================================
#pragma once

namespace RE
{
	namespace BSScript
	{
		class IStackCallbackSaveInterface
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IStackCallbackSaveInterface;

			virtual ~IStackCallbackSaveInterface();  // 00

			// add
			virtual void Unk_01(void) = 0;  // 01
			virtual void Unk_02(void) = 0;  // 02
		};
		static_assert(sizeof(IStackCallbackSaveInterface) == 0x8);
	}
}


===============================================
File: include/RE/I/IStore.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSStorage.h"

namespace RE
{
	namespace BSScript
	{
		class IStore : public BSStorage
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IStore;

			~IStore() override;  // 00

			// override (BSStorage)
			BSStorageDefs::ErrorCode Write(std::size_t a_numBytes, const std::byte* a_bytes) override;  // 05

			// add
			virtual bool                 Open(const char* a_fileName) = 0;  // 06
			virtual void                 Close(void) = 0;                   // 07
			virtual const BSFixedString& GetRelPath() = 0;                  // 08
			virtual bool                 HasOpenFile(void) = 0;             // 09
			virtual bool                 FileIsGood(void) = 0;              // 0A
			virtual void                 Unk_0B(void) = 0;                  // 0B
		};
		static_assert(sizeof(IStore) == 0x20);
	}
}


===============================================
File: include/RE/I/IUIMessageData.h
===============================================
#pragma once

namespace RE
{
	class IUIMessageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_IUIMessageData;

		virtual ~IUIMessageData() = default;  // 00

		// members
		std::uint16_t unk08;  // 08
		std::uint16_t pad0A;  // 0A
		std::uint32_t pad0C;  // 0C
	};
	static_assert(sizeof(IUIMessageData) == 0x10);
}


===============================================
File: include/RE/I/IVMDebugInterface.h
===============================================
#pragma once

namespace RE
{
	namespace BSScript
	{
		class IVMDebugInterface
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IVMDebugInterface;

			virtual ~IVMDebugInterface();  // 00

			// add
			virtual void DumpRunningStacksToLog() = 0;  // 01
		};
		static_assert(sizeof(IVMDebugInterface) == 0x8);
	}
}


===============================================
File: include/RE/I/IVMObjectBindInterface.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	namespace BSScript
	{
		class Object;

		struct IVMObjectBindInterface
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IVMObjectBindInterface;

			virtual ~IVMObjectBindInterface();  // 00

			// add
			[[nodiscard]] virtual VMHandle GetBoundHandle(const BSTSmartPointer<Object>& a_objPtr) const = 0;                                                                   // 01
			virtual bool                   TypeCanBeBound(const BSFixedString& a_className, VMHandle a_handle) = 0;                                                             // 02
			virtual void                   BindObject(BSTSmartPointer<Object>& a_objPtr, VMHandle a_handle, bool a_conditional) = 0;                                            // 03
			virtual void                   HandleLoadedBinding(BSTSmartPointer<Object>& a_objPtr, VMHandle a_handle, bool a_conditional) = 0;                                   // 04
			virtual void                   RemoveAllBoundObjects(VMHandle a_handle) = 0;                                                                                        // 05
			virtual void                   RemoveAllDiskLoadedBoundObjects(VMHandle a_handle) = 0;                                                                              // 06
			virtual void                   HandleCObjectDeletion(VMHandle a_handle) = 0;                                                                                        // 07
			virtual void                   UnbindObject(const BSTSmartPointer<Object>& a_objPtr) = 0;                                                                           // 08
			virtual bool                   CreateObjectWithProperties(const BSFixedString& a_className, std::uint32_t a_numProperties, BSTSmartPointer<Object>& a_objPtr) = 0;  // 09
			virtual bool                   InitObjectProperties(BSTSmartPointer<Object>& a_objPtr, void* a_property, bool a_arg3) = 0;                                          // 0A
		};
		static_assert(sizeof(IVMObjectBindInterface) == 0x8);
	}
}


===============================================
File: include/RE/I/IVMSaveLoadInterface.h
===============================================
#pragma once
#include "RE/B/BSStorage.h"
#include "RE/C/CodeTasklet.h"
#include "RE/L/LoadStorageWrapper.h"
#include "RE/O/Object.h"
#include "RE/S/SaveFileHandleReaderWriter.h"
namespace RE
{
	namespace BSScript
	{
		enum class StringIndexSize
		{
			kSmall,
			kLarge
		};

		class ReadableStringTable
		{
		public:
			class StringEntry
			{
			public:
				// members
				const char*   originalData;     // 00
				BSFixedString convertedString;  // 08
			};
			static_assert(sizeof(StringEntry) == 0x10);

			// members
			void*                                           unk00;      // 00
			BSScrapArray<StringEntry>*                      entries;    // 08
			stl::enumeration<StringIndexSize, std::int32_t> indexSize;  // 10
		};
		static_assert(sizeof(ReadableStringTable) == 0x18);

		class WritableStringTable
		{
		public:
			// members
			void*                                           unk00;         // 00
			BSTScrapHashMap<BSFixedString, std::uint32_t>*  referenceMap;  // 08
			stl::enumeration<StringIndexSize, std::int32_t> indexSize;     // 10
		};
		static_assert(sizeof(WritableStringTable) == 0x18);

		class IVMSaveLoadInterface
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IVMSaveLoadInterface;

			virtual ~IVMSaveLoadInterface();  // 00

			// add
			virtual void                                                              SaveGame(SaveStorageWrapper* a_wrapper, SkyrimScript::SaveFileHandleReaderWriter* a_handle, bool unk) = 0;  // 01
			virtual void                                                              LoadGame(LoadStorageWrapper* a_wrapper, SkyrimScript::SaveFileHandleReaderWriter* a_handle) = 0;            // 02
			virtual void                                                              MarkSaveInvalid(BSStorage* a_storage) = 0;                                                                  // 03
			virtual std::byte                                                         GetSaveGameVersion() = 0;                                                                                   // 04
			virtual void                                                              CleanupSave() = 0;                                                                                          // 05
			virtual void                                                              Unk_06(void) = 0;                                                                                           // 06
			virtual void                                                              DropAllRunningData() = 0;                                                                                   // 07
			virtual void                                                              Unk_08(void* unk) = 0;                                                                                      // 08
			virtual void                                                              Unk_09(void) = 0;                                                                                           // 09
			virtual void                                                              Unk_0A(VMHandle a_handle, Object** a_out) = 0;                                                              // 0A
			virtual void                                                              Unk_0B(void* unk) = 0;                                                                                      // 0B
			virtual void                                                              Unk_0C(void) = 0;                                                                                           // 0C
			virtual void                                                              Unk_0D(VMHandle a_handle, Array** a_out) = 0;                                                               // 0D
			virtual void                                                              Unk_0E(LoadStorageWrapper* a_storage, void* unk) = 0;                                                       // 0E
			virtual bool                                                              GetStackByID(VMStackID a_stackID, Stack** a_out) = 0;                                                       // 0F
			virtual WritableStringTable                                               GetWritableStringTable() = 0;                                                                               // 10
			virtual const WritableStringTable                                         GetWritableStringTable2() = 0;                                                                              // 11
			virtual ReadableStringTable                                               GetReadableStringTable() = 0;                                                                               // 12
			virtual BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>*       GetWritableTypeTable() = 0;                                                                                 // 13
			virtual const BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>* GetWritableTypeTable2() = 0;                                                                                // 14
			virtual BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>*       GetReadableTypeTable() = 0;                                                                                 // 15
			virtual bool                                                              CreateEmptyTasklet(Stack* a_stack, Internal::CodeTasklet** a_out) = 0;                                      // 16
		};
		static_assert(sizeof(IVMSaveLoadInterface) == 0x8);
	}
}


===============================================
File: include/RE/I/IVirtualMachine.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/E/ErrorLogger.h"
#include "RE/T/TypeInfo.h"
#include "RE/T/TypeTraits.h"

namespace RE
{
	namespace BSJobs
	{
		class JobList;
	}

	class TESForm;

	namespace BSScript
	{
		class Array;
		class ErrorLogger;
		class IForEachScriptObjectFunctor;
		class IFunction;
		class IFunctionArguments;
		class ISavePatcherInterface;
		class IStackCallbackFunctor;
		class ITypeLinkedCallback;
		class Object;
		class ObjectBindPolicy;
		class ObjectTypeInfo;
		class Variable;
		struct IObjectHandlePolicy;
		struct LogEvent;
		struct StatsEvent;

		class IVirtualMachine : public BSIntrusiveRefCounted
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__IVirtualMachine;

			using Severity = BSScript::ErrorLogger::Severity;

			virtual ~IVirtualMachine();  // 00

			// add
			virtual void SetLinkedCallback(ITypeLinkedCallback* a_callback) = 0;                                                                                    // 01
			virtual void TraceStack(const char* a_str, VMStackID a_stackID, Severity a_severity = Severity::kError) = 0;                                            // 02
			virtual void FormatAndPostMessage(const char* a_message, Severity a_severity) = 0;                                                                                                                       // 03
			virtual void Update(float a_budget) = 0;                                                                                                                // 04
			virtual void UpdateTasklets(float a_budget) = 0;                                                                                                        // 05
			virtual void SetOverstressed(bool a_set) = 0;                                                                                                           // 06
			virtual bool IsCompletelyFrozen() const = 0;                                                                                                            // 07
			virtual bool RegisterObjectType(VMTypeID a_typeID, const char* a_className) = 0;                                                                        // 08
			virtual bool GetScriptObjectType1(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr) = 0;                             // 09
			virtual bool GetScriptObjectType2(VMTypeID a_typeID, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr) = 0;                                            // 0A
			virtual bool GetScriptObjectTypeNoLoad1(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_typeInfoPtr) const = 0;                    // 0B
			virtual bool GetScriptObjectTypeNoLoad2(VMTypeID a_typeID, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr) const = 0;                                // 0C
			virtual bool GetTypeIDForScriptObject(const BSFixedString& a_className, VMTypeID& a_typeID) const = 0;                                                  // 0D
			virtual void GetScriptObjectsWithATypeID(BSScrapArray<BSFixedString>& a_classes) const = 0;                                                             // 0E
			virtual bool GetParentNativeType(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_typeInfoPtr) = 0;                                 // 0F
			virtual bool TypeIsValid(const BSFixedString& a_className) = 0;                                                                                         // 10
			virtual bool ReloadType(const char* a_className) = 0;                                                                                                   // 11
			virtual void TasksToJobs(BSJobs::JobList& a_jobList) = 0;                                                                                               // 12
			virtual void CalculateFullReloadList(void) const = 0;                                                                                                   // 13
			virtual bool CreateObject1(const BSFixedString& a_className, void* a_property, BSTSmartPointer<Object>& a_objPtr) = 0;                                  // 14
			virtual bool CreateObject2(const BSFixedString& a_className, BSTSmartPointer<Object>& a_result) = 0;                                                    // 15
			virtual bool CreateArray1(const TypeInfo& a_typeInfo, std::uint32_t a_size, BSTSmartPointer<Array>& a_arrayPtr) = 0;                                    // 16
			virtual bool CreateArray2(TypeInfo::RawType a_typeID, const BSFixedString& a_className, std::uint32_t a_size, BSTSmartPointer<Array>& a_arrayPtr) = 0;  // 17
			virtual bool BindNativeMethod(IFunction* a_fn) = 0;                                                                                                     // 18
			virtual void SetCallableFromTasklets1(const char* a_className, const char* a_stateName, const char* a_fnName, bool a_callable) = 0;                     // 19
			virtual void SetCallableFromTasklets2(const char* a_className, const char* a_fnName, bool a_callable) = 0;                                              // 1A
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
			virtual void New_1B(void) = 0;
#endif
			SKYRIM_REL_VR_VIRTUAL void ForEachBoundObject(VMHandle a_handle, IForEachScriptObjectFunctor* a_functor);  // 1B, 1C
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
			virtual void New_1D(void) = 0;
#endif
			SKYRIM_REL_VR_VIRTUAL bool                       FindBoundObject(VMHandle a_handle, const char* a_className, BSTSmartPointer<Object>& a_result) const;                                                                                   // 1C
			SKYRIM_REL_VR_VIRTUAL void                       MoveBoundObjects(VMHandle a_from, VMHandle a_to);                                                                                                                                       // 1D
			SKYRIM_REL_VR_VIRTUAL void                       ResetAllBoundObjects(VMHandle a_handle);                                                                                                                                                // 1E
			SKYRIM_REL_VR_VIRTUAL bool                       CastObject(const BSTSmartPointer<Object>& a_fromObjPtr, const BSTSmartPointer<ObjectTypeInfo>& a_toTypeInfoPtr, BSTSmartPointer<Object>& a_toObjPtr);                                   // 1F
			SKYRIM_REL_VR_VIRTUAL bool                       SetPropertyValue(BSTSmartPointer<Object>& a_obj, const char* a_propertyName, Variable& a_setVal);                                                                                       // 20
			SKYRIM_REL_VR_VIRTUAL bool                       GetPropertyValue(BSTSmartPointer<Object>& a_obj, const char* a_propertyName, Variable& a_getVal);                                                                                       // 21
			SKYRIM_REL_VR_VIRTUAL bool                       GetVariableValue1(const BSTSmartPointer<Object>& a_objPtr, std::uint32_t a_index, Variable& a_out) const;                                                                               // 22
			SKYRIM_REL_VR_VIRTUAL bool                       GetVariableValue2(VMHandle a_handle, const BSFixedString& a_className, std::int32_t a_variableIndex, Variable& a_out) const;                                                            // 23
			SKYRIM_REL_VR_VIRTUAL void                       SendEvent(VMHandle a_handle, const BSFixedString& a_eventName, IFunctionArguments* a_args);                                                                                             // 24
			SKYRIM_REL_VR_VIRTUAL void                       SendEventAll(const BSFixedString& a_eventName, IFunctionArguments* a_args);                                                                                                             // 25
			SKYRIM_REL_VR_VIRTUAL bool                       DispatchStaticCall(const BSFixedString& a_className, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result);                      // 26
			SKYRIM_REL_VR_VIRTUAL bool                       DispatchMethodCall1(BSTSmartPointer<Object>& a_obj, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result);                       // 27
			SKYRIM_REL_VR_VIRTUAL bool                       DispatchMethodCall2(VMHandle a_handle, const BSFixedString& a_className, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result);  // 28
			SKYRIM_REL_VR_VIRTUAL bool                       DispatchUnboundMethodCall(void);                                                                                                                                                        // 29
			SKYRIM_REL_VR_VIRTUAL bool                       IsWaitingOnLatent(VMStackID a_stackID) const;                                                                                                                                           // 2A
			SKYRIM_REL_VR_VIRTUAL void                       ReturnFromLatent(VMStackID a_stackID, const Variable& a_val);                                                                                                                           // 2B
			SKYRIM_REL_VR_VIRTUAL ErrorLogger*               GetErrorLogger();                                                                                                                                                                       // 2C
			SKYRIM_REL_VR_VIRTUAL IObjectHandlePolicy*       GetObjectHandlePolicy1();                                                                                                                                                               // 2D
			SKYRIM_REL_VR_VIRTUAL const IObjectHandlePolicy* GetObjectHandlePolicy2() const;                                                                                                                                                         // 2E
			SKYRIM_REL_VR_VIRTUAL ObjectBindPolicy*          GetObjectBindPolicy1();                                                                                                                                                                 // 2F
			SKYRIM_REL_VR_VIRTUAL const ObjectBindPolicy*    GetObjectBindPolicy2() const;                                                                                                                                                           // 30
			SKYRIM_REL_VR_VIRTUAL ISavePatcherInterface*     GetSavePatcherInterface();                                                                                                                                                              // 31
			SKYRIM_REL_VR_VIRTUAL void                       RegisterForLogEvent(BSTEventSink<LogEvent>* a_sink);                                                                                                                                    // 32
			SKYRIM_REL_VR_VIRTUAL void                       UnregisterForLogEvent(BSTEventSink<LogEvent>* a_sink);                                                                                                                                  // 33
			SKYRIM_REL_VR_VIRTUAL void                       RegisterForStatsEvent(BSTEventSink<StatsEvent>* a_sink);                                                                                                                                // 34
			SKYRIM_REL_VR_VIRTUAL void                       UnregisterForStatsEvent(BSTEventSink<StatsEvent>* a_sink);                                                                                                                              // 35

			bool                       CreateArray(const TypeInfo& a_typeInfo, std::uint32_t a_size, BSTSmartPointer<Array>& a_arrayPtr);
			bool                       CreateArray(TypeInfo::RawType a_typeID, const BSFixedString& a_className, std::uint32_t a_size, BSTSmartPointer<Array>& a_arrayPtr);
			bool                       CreateObject(const BSFixedString& a_className, void* a_property, BSTSmartPointer<Object>& a_objPtr);
			bool                       CreateObject(const BSFixedString& a_className, BSTSmartPointer<Object>& a_result);
			bool                       DispatchMethodCall(BSTSmartPointer<Object>& a_obj, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result);
			bool                       DispatchMethodCall(VMHandle a_handle, const BSFixedString& a_className, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result);
			ObjectBindPolicy*          GetObjectBindPolicy();
			const ObjectBindPolicy*    GetObjectBindPolicy() const;
			IObjectHandlePolicy*       GetObjectHandlePolicy();
			const IObjectHandlePolicy* GetObjectHandlePolicy() const;
			bool                       GetScriptObjectType(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr);
			bool                       GetScriptObjectType(VMTypeID a_typeID, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr);
			bool                       GetScriptObjectTypeNoLoad(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_typeInfoPtr) const;
			bool                       GetScriptObjectTypeNoLoad(VMTypeID a_typeID, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr) const;
			bool                       GetVariableValue(const BSTSmartPointer<Object>& a_objPtr, std::uint32_t a_index, Variable& a_out) const;
			bool                       GetVariableValue(VMHandle a_handle, const BSFixedString& a_className, std::int32_t a_variableIndex, Variable& a_out) const;

			template <class F>
			void RegisterFunction(std::string_view a_fnName, std::string_view a_className, F a_callback, bool a_callableFromTasklets = false);

			template <class R, class F>
			void RegisterLatentFunction(std::string_view a_fnName, std::string_view a_className, F a_callback, bool a_callableFromTasklets = false);

			template <class V>
			requires is_return_convertible_v<V>
			void ReturnLatentResult(VMStackID a_stackID, V result);

			void SetCallableFromTasklets(const char* a_className, const char* a_stateName, const char* a_fnName, bool a_callable);
			void SetCallableFromTasklets(const char* a_className, const char* a_fnName, bool a_callable);
			void TraceForm(TESForm* a_form, const char* a_str, VMStackID a_stackID, Severity a_severity = Severity::kError);
			void VTraceStack(VMStackID a_stackID, Severity a_severity, const char* a_fmt, ...);

			// members
			std::uint32_t pad0C;  // 0C
		};
		static_assert(sizeof(IVirtualMachine) == 0x10);
	}
}


===============================================
File: include/RE/I/IXAudio2VoiceCallback.h
===============================================
#pragma once

namespace RE
{
	struct IXAudio2VoiceCallback
	{
	public:
		inline static constexpr auto RTTI = RTTI_IXAudio2VoiceCallback;
	};
}


===============================================
File: include/RE/I/ImageData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	struct ImageData
	{
		void*         unk00;     // 00 - smart ptr
		std::uint64_t unk08;     // 08
		BSFixedString filePath;  // 10
	};
	static_assert(sizeof(ImageData) == 0x18);
}


===============================================
File: include/RE/I/ImageSpaceData.h
===============================================
#pragma once

namespace RE
{
	struct ImageSpaceBaseData
	{
		struct HDR  // HNAM
		{
		public:
			// members
			float eyeAdaptSpeed;          // 00
			float bloomBlurRadius;        // 04
			float bloomThreshold;         // 08
			float bloomScale;             // 0C
			float receiveBloomThreshold;  // 10
			float white;                  // 14
			float sunlightScale;          // 18
			float skyScale;               // 1C
			float eyeAdaptStrength;       // 20
		};
		static_assert(sizeof(HDR) == 0x24);

		struct Cinematic  // CNAM
		{
		public:
			// members
			float saturation;  // 0
			float brightness;  // 4
			float contrast;    // 8
		};
		static_assert(sizeof(Cinematic) == 0xC);

		struct Tint  // TNAM
		{
		public:
			struct ColorF
			{
			public:
				// members
				float red;    // 0
				float green;  // 4
				float blue;   // 8
			};
			static_assert(sizeof(ColorF) == 0xC);

			// members
			float  amount;  // 00
			ColorF color;   // 04
		};
		static_assert(sizeof(Tint) == 0x10);

		struct DepthOfField  // DNAM
		{
		public:
			enum class SkyBlurRadius
			{
				kRadius0 = 16384,        // 0x4000
				kRadius1 = 16672,        // 0x4120
				kRadius2 = 16784,        // 0x4190
				kRadius3 = 16848,        // 0x41D0
				kRadius4 = 16904,        // 0x4208
				kRadius5 = 16936,        // 0x4228
				kRadius6 = 16968,        // 0x4248
				kRadius7 = 17000,        // 0x4268
				kNoSky_Radius0 = 16576,  // 0x40C0
				kNoSky_Radius1 = 16736,  // 0x4160
				kNoSky_Radius2 = 16816,  // 0x41B0
				kNoSky_Radius3 = 16880,  // 0x41F0
				kNoSky_Radius4 = 16920,  // 0x4218
				kNoSky_Radius5 = 16952,  // 0x4238
				kNoSky_Radius6 = 16984,  // 0x4258
				kNoSky_Radius7 = 17016   // 0x4278
			};

			// members
			float                                          strength;       // 00
			float                                          distance;       // 04
			float                                          range;          // 08
			std::uint16_t                                  flags;          // 0C
			stl::enumeration<SkyBlurRadius, std::uint16_t> skyBlurRadius;  // 0E
		};
		static_assert(sizeof(DepthOfField) == 0x10);

		// members
		HDR          hdr;           // 00 - HNAM
		Cinematic    cinematic;     // 24 - CNAM
		Tint         tint;          // 30 - TNAM
		DepthOfField depthOfField;  // 40 - DNAM
	};
	static_assert(sizeof(ImageSpaceBaseData) == 0x50);

	struct ImageSpaceModData
	{
	public:
		enum
		{
			kFadeAmount = 0,
			kFadeR = 1,
			kFadeG = 2,
			kFadeB = 3,
			kBlurRadius = 4,
			kDoubleVisionStrength = 5,
			kRadialBlurStrength = 6,
			kRadialBlurRampup = 7,
			kRadialBlurStart = 8,
			kRadialBlurRampdown = 9,
			kRadialBlurDownStart = 10,
			kRadialBlurCenterX = 11,
			kRadialBlurCenterY = 12,
			kDOFStrength = 13,
			kDOFDistance = 14,
			kDOFRange = 15,
			kDOFMode = 16,
			kMotionBlurStrength = 17,

			kTotal = 18
		};

		// members
		float data[kTotal];  // 00
	};
	static_assert(sizeof(ImageSpaceModData) == 0x48);

	class ImageSpaceData
	{
	public:
		// members
		ImageSpaceBaseData baseData;    // 00
		ImageSpaceModData  modData;     // 50
		float              baseAmount;  // 98
		float              modAmount;   // 9C
	};
	static_assert(sizeof(ImageSpaceData) == 0xA0);
}


===============================================
File: include/RE/I/ImageSpaceEffect.h
===============================================
#pragma once

#include "RE/N/NiTArray.h"

namespace RE
{
	class ImageSpaceManager;
	class ImageSpaceEffectParam;
	class ImageSpaceTexture;

	class ImageSpaceEffect
	{
	public:
		class EffectInput;

		inline static constexpr auto RTTI = RTTI_ImageSpaceEffect;

		virtual ~ImageSpaceEffect();  // 00

		// add
		virtual void Render(BSTriShape* a_shape, ImageSpaceEffectParam* a_param);          // 01
		virtual void Setup(ImageSpaceManager* a_manager, ImageSpaceEffectParam* a_param);  // 02 - { return; }
		virtual void ShutDown();                                                           // 03 - { return; }
		virtual void BorrowTextures(ImageSpaceEffectParam* a_param);                       // 04 - { return; }
		virtual void ReturnTextures();                                                     // 05 - { return; }
		virtual bool IsActive();                                                           // 06
		virtual bool UpdateParams(ImageSpaceEffectParam* a_param);                         // 07 - { return 0; }
		virtual bool SetRenderStates(ImageSpaceEffectParam* a_param);                      // 08 - { return 0; }
		virtual bool RestoreRenderStates(ImageSpaceEffectParam* a_param);                  // 09 - { return 0; }

		// members
		bool                                              active;          // 08
		bool                                              unk09;           // 09
		std::uint16_t                                     pad0A;           // 0A
		std::uint32_t                                     pad0C;           // 0C
		NiTPrimitiveArray<ImageSpaceEffect*>              effects;         // 10
		NiTPrimitiveArray<ImageSpaceEffectParam*>         effectParams;    // 28
		NiTPrimitiveArray<ImageSpaceTexture*>             effectTextures;  // 40
		NiTPrimitiveArray<ImageSpaceEffect::EffectInput*> effectInputs;    // 58
		NiTPrimitiveArray<std::int32_t>                   unk70;           // 70
		bool                                              unk88;           // 88
		std::uint8_t                                      pad89;           // 89
		std::uint16_t                                     pad8A;           // 8A
		std::uint32_t                                     pad8C;           // 8C
	};
	static_assert(sizeof(ImageSpaceEffect) == 0x90);
}


===============================================
File: include/RE/I/ImageSpaceEffectDepthOfField.h
===============================================
#pragma once

#include "RE/I/ImageSpaceEffectOption.h"
#include "RE/I/ImageSpaceTexture.h"

namespace RE
{
	class ImageSpaceEffectDepthOfField : public ImageSpaceEffectOption
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceEffectDepthOfField;

		~ImageSpaceEffectDepthOfField() override;  // 00

		// override (ImageSpaceEffectOption)
		void Render(BSTriShape* a_shape, ImageSpaceEffectParam* a_param) override;          // 01
		void Setup(ImageSpaceManager* a_manager, ImageSpaceEffectParam* a_param) override;  // 02
		void BorrowTextures(ImageSpaceEffectParam* a_param) override;                       // 04
		void ReturnTextures() override;                                                     // 05
		bool IsActive() override;                                                           // 06
		bool UpdateParams(ImageSpaceEffectParam* a_param) override;                         // 07

		// members
		std::uint64_t     unk0A8;     // 0A8
		std::uint32_t     unk0B0;     // 0B0
		std::uint32_t     unk0B4;     // 0B4
		std::uint32_t     unk0B8;     // 0B8
		std::uint32_t     unk0BC;     // 0BC
		std::uint8_t      unk0C0;     // 0C0
		std::uint8_t      unk0C1;     // 0C1
		std::uint16_t     unk0C2;     // 0C2
		std::uint32_t     unk0C4;     // 0C4
		ImageSpaceTexture unk0C8[4];  // 0C8
		bool              enabled;    // 148
		float             unk14C;     // 14C
		float             unk150;     // 150
		std::uint32_t     pad154;     // 154
	};
	static_assert(sizeof(ImageSpaceEffectDepthOfField) == 0x158);
}


===============================================
File: include/RE/I/ImageSpaceEffectOption.h
===============================================
#pragma once

#include "RE/I/ImageSpaceEffect.h"

namespace RE
{
	class ImageSpaceEffectOption : public ImageSpaceEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceEffectOption;

		~ImageSpaceEffectOption() override;  // 00

		// override (ImageSpaceEffect)
		void Render(BSTriShape* a_shape, ImageSpaceEffectParam* a_param) override;  // 01

		// members
		NiTPrimitiveArray<bool> options;  // 90
	};
	static_assert(sizeof(ImageSpaceEffectOption) == 0xA8);
}


===============================================
File: include/RE/I/ImageSpaceEffectParam.h
===============================================
#pragma once

namespace RE
{
	class ImageSpaceEffectParam
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceEffectParam;

		virtual ~ImageSpaceEffectParam();  // 00
	};
	static_assert(sizeof(ImageSpaceEffectParam) == 0x8);
}


===============================================
File: include/RE/I/ImageSpaceManager.h
===============================================
#pragma once

#include "RE/I/ImageSpaceData.h"
#include "RE/I/ImageSpaceTexture.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTArray.h"

namespace RE
{
	class BSShader;
	class BSTriShape;
	class ImageSpaceEffect;

	class ImageSpaceManager
	{
	public:
		enum ImageSpaceEffectEnum
		{
			WorldMap = 0,                                  // ImageSpaceEffectWorldMap
			Refraction = 1,                                // ImageSpaceEffectRefraction
			ISFXAA = 2,                                    // BSImagespaceShaderFXAA
			DepthOfField = 3,                              // ImageSpaceEffectDepthOfField
			RadialBlur = 5,                                // ImageSpaceEffectRadialBlur
			FullScreenBlur = 6,                            // ImageSpaceEffectFullScreenBlur
			GetHit = 7,                                    // ImageSpaceEffectGetHit
			Map = 8,                                       // ImageSpaceEffectMap
			Blur3 = 9,                                     // ImageSpaceEffectBlur
			Blur5 = 10,                                    // ImageSpaceEffectBlur
			Blur7 = 11,                                    // ImageSpaceEffectBlur
			Blur9 = 12,                                    // ImageSpaceEffectBlur
			Blur11 = 13,                                   // ImageSpaceEffectBlur
			Blur13 = 14,                                   // ImageSpaceEffectBlur
			Blur15 = 15,                                   // ImageSpaceEffectBlur
			BlurNonHDR3 = 16,                              // ImageSpaceEffectBlur
			BlurNonHDR5 = 17,                              // ImageSpaceEffectBlur
			BlurNonHDR7 = 18,                              // ImageSpaceEffectBlur
			BlurNonHDR9 = 19,                              // ImageSpaceEffectBlur
			BlurNonHDR11 = 20,                             // ImageSpaceEffectBlur
			BlurNonHDR13 = 21,                             // ImageSpaceEffectBlur
			BlurNonHDR15 = 22,                             // ImageSpaceEffectBlur
			BlurBrightPass3 = 23,                          // ImageSpaceEffectBlur
			BlurBrightPass5 = 24,                          // ImageSpaceEffectBlur
			BlurBrightPass7 = 25,                          // ImageSpaceEffectBlur
			BlurBrightPass9 = 26,                          // ImageSpaceEffectBlur
			BlurBrightPass11 = 27,                         // ImageSpaceEffectBlur
			BlurBrightPass13 = 28,                         // ImageSpaceEffectBlur
			BlurBrightPass15 = 29,                         // ImageSpaceEffectBlur
			HDR = 30,                                      // ImageSpaceEffectHDR
			WaterDisplacement = 31,                        // ImageSpaceEffectWaterDisplacement
			VolumetricLighting = 32,                       // ImageSpaceEffectVolumetricLighting
			Noise = 33,                                    // ImageSpaceEffectNoise
			ISCopy = 34,                                   // BSImagespaceShaderCopy
			ISCopyDynamicFetchDisabled = 35,               // BSImagespaceShaderCopyDynamicFetchDisabled
			ISCopyScaleBias = 36,                          // BSImagespaceShaderCopyScaleBias
			ISCopyCustomViewport = 37,                     // BSImagespaceShaderCopyCustomViewport
			ISCopyGrayScale = 38,                          // BSImagespaceShaderGreyScale
			ISRefraction = 39,                             // BSImagespaceShaderRefraction
			ISDoubleVision = 40,                           // BSImagespaceShaderDoubleVision
			ISCopyTextureMask = 41,                        // BSImagespaceShaderTextureMask
			ISMap = 42,                                    // BSImagespaceShaderMap
			ISWorldMap = 43,                               // BSImagespaceShaderWorldMap
			ISWorldMapNoSkyBlur = 44,                      // BSImagespaceShaderWorldMapNoSkyBlur
			ISDepthOfField = 45,                           // BSImagespaceShaderDepthOfField
			ISDepthOfFieldFogged = 46,                     // BSImagespaceShaderDepthOfFieldFogged
			ISDepthOfFieldMaskedFogged = 47,               // BSImagespaceShaderDepthOfFieldMaskedFogged
			ISDistantBlur = 49,                            // BSImagespaceShaderDistantBlur
			ISDistantBlurFogged = 50,                      // BSImagespaceShaderDistantBlurFogged
			ISDistantBlurMaskedFogged = 51,                // BSImagespaceShaderDistantBlurMaskedFogged
			ISRadialBlur = 52,                             // BSImagespaceShaderRadialBlur
			ISRadialBlurMedium = 53,                       // BSImagespaceShaderRadialBlurMedium
			ISRadialBlurHigh = 54,                         // BSImagespaceShaderRadialBlurHigh
			ISHDRTonemapBlendCinematic = 55,               // BSImagespaceShaderHDRTonemapBlendCinematic
			ISHDRTonemapBlendCinematicFade = 56,           // BSImagespaceShaderHDRTonemapBlendCinematicFade
			ISHDRDownSample16 = 57,                        // BSImagespaceShaderHDRDownSample16
			ISHDRDownSample4 = 58,                         // BSImagespaceShaderHDRDownSample4
			ISHDRDownSample16Lum = 59,                     // BSImagespaceShaderHDRDownSample16Lum
			ISHDRDownSample4RGB2Lum = 60,                  // BSImagespaceShaderHDRDownSample4RGB2Lum
			ISHDRDownSample4LumClamp = 61,                 // BSImagespaceShaderHDRDownSample4LumClamp
			ISHDRDownSample4LightAdapt = 62,               // BSImagespaceShaderHDRDownSample4LightAdapt
			ISHDRDownSample16LumClamp = 63,                // BSImagespaceShaderHDRDownSample16LumClamp
			ISHDRDownSample16LightAdapt = 64,              // BSImagespaceShaderHDRDownSample16LightAdapt
			ISBlur3 = 65,                                  // BSImagespaceShaderBlur3
			ISBlur5 = 66,                                  // BSImagespaceShaderBlur5
			ISBlur7 = 67,                                  // BSImagespaceShaderBlur7
			ISBlur9 = 68,                                  // BSImagespaceShaderBlur9
			ISBlur11 = 69,                                 // BSImagespaceShaderBlur11
			ISBlur13 = 70,                                 // BSImagespaceShaderBlur13
			ISBlur15 = 71,                                 // BSImagespaceShaderBlur15
			ISNonHDRBlur3 = 72,                            // BSImagespaceShaderNonHDRBlur3
			ISNonHDRBlur5 = 73,                            // BSImagespaceShaderNonHDRBlur5
			ISNonHDRBlur7 = 74,                            // BSImagespaceShaderNonHDRBlur7
			ISNonHDRBlur9 = 75,                            // BSImagespaceShaderNonHDRBlur9
			ISNonHDRBlur11 = 76,                           // BSImagespaceShaderNonHDRBlur11
			ISNonHDRBlur13 = 77,                           // BSImagespaceShaderNonHDRBlur13
			ISNonHDRBlur15 = 78,                           // BSImagespaceShaderNonHDRBlur15
			ISBrightPassBlur3 = 79,                        // BSImagespaceShaderBrightPassBlur3
			ISBrightPassBlur5 = 80,                        // BSImagespaceShaderBrightPassBlur5
			ISBrightPassBlur7 = 81,                        // BSImagespaceShaderBrightPassBlur7
			ISBrightPassBlur9 = 82,                        // BSImagespaceShaderBrightPassBlur9
			ISBrightPassBlur11 = 83,                       // BSImagespaceShaderBrightPassBlur11
			ISBrightPassBlur13 = 84,                       // BSImagespaceShaderBrightPassBlur13
			ISBrightPassBlur15 = 85,                       // BSImagespaceShaderBrightPassBlur15
			ISWaterDisplacementClearSimulation = 86,       // BSImagespaceShaderWaterDisplacementClearSimulation
			ISWaterDisplacementTexOffset = 87,             // BSImagespaceShaderWaterDisplacementTexOffset
			ISWaterDisplacementWadingRipple = 88,          // BSImagespaceShaderWaterDisplacementWadingRipple
			ISWaterDisplacementRainRipple = 89,            // BSImagespaceShaderWaterDisplacementRainRipple
			ISWaterWadingHeightmap = 90,                   // BSImagespaceShaderWaterWadingHeightmap
			ISWaterRainHeightmap = 91,                     // BSImagespaceShaderWaterRainHeightmap
			ISWaterBlendHeightmaps = 92,                   // BSImagespaceShaderWaterBlendHeightmaps
			ISWaterSmoothHeightmap = 93,                   // BSImagespaceShaderWaterSmoothHeightmap
			ISWaterDisplacementNormals = 94,               // BSImagespaceShaderWaterDisplacementNormals
			ISNoiseScrollAndBlend = 95,                    // BSImagespaceShaderNoiseScrollAndBlend
			ISNoiseNormalmap = 96,                         // BSImagespaceShaderNoiseNormalmap
			ISVolumetricLighting = 97,                     // BSImagespaceShaderVolumetricLighting
			ISLocalMap = 98,                               // BSImagespaceShaderLocalMap
			ISAlphaBlend = 99,                             // BSImagespaceShaderAlphaBlend
			ISLensFlare = 100,                             // BSImagespaceShaderLensFlare
			ISLensFlareVisibility = 101,                   // BSImagespaceShaderLensFlareVisibility
			ISApplyReflections = 102,                      // BSImagespaceShaderApplyReflections
			ISApplyVolumetricLighting = 103,               // BSImagespaceShaderISApplyVolumetricLighting
			ISBasicCopy = 104,                             // BSImagespaceShaderISBasicCopy
			ISBlur = 105,                                  // BSImagespaceShaderISBlur
			ISVolumetricLightingBlurHCS = 106,             // BSImagespaceShaderISVolumetricLightingBlurHCS
			ISVolumetricLightingBlurVCS = 107,             // BSImagespaceShaderISVolumetricLightingBlurVCS
			ISReflectionBlurHCS = 108,                     // BSImagespaceShaderReflectionBlurHCS
			ISReflectionBlurVCS = 109,                     // BSImagespaceShaderReflectionBlurVCS
			ISParallaxMaskBlurHCS = 110,                   // BSImagespaceShaderISParallaxMaskBlurHCS
			ISParallaxMaskBlurVCS = 111,                   // BSImagespaceShaderISParallaxMaskBlurVCS
			ISDepthOfFieldBlurHCS = 112,                   // BSImagespaceShaderISDepthOfFieldBlurHCS
			ISDepthOfFieldBlurVCS = 113,                   // BSImagespaceShaderISDepthOfFieldBlurVCS
			ISCompositeVolumetricLighting = 114,           // BSImagespaceShaderISCompositeVolumetricLighting
			ISCompositeLensFlare = 115,                    // BSImagespaceShaderISCompositeLensFlare
			ISCompositeLensFlareVolumetricLighting = 116,  // BSImagespaceShaderISCompositeLensFlareVolumetricLighting
			ISCopySubRegionCS = 117,                       // BSImagespaceShaderISCopySubRegionCS
			ISDebugSnow = 118,                             // BSImagespaceShaderISDebugSnow
			ISDownsample = 119,                            // BSImagespaceShaderISDownsample
			ISDownsampleIgnoreBrightest = 120,             // BSImagespaceShaderISDownsampleIgnoreBrightest
			ISDownsampleCS = 121,                          // BSImagespaceShaderISDownsampleCS
			ISDownsampleIgnoreBrightestCS = 122,           // BSImagespaceShaderISDownsampleIgnoreBrightestCS
			ISExp = 123,                                   // BSImagespaceShaderISExp
			ISIBLensFlares = 124,                          // BSImagespaceShaderISIBLensFlares
			ISLightingComposite = 125,                     // BSImagespaceShaderISLightingComposite
			ISLightingCompositeNoDirectionalLight = 126,   // BSImagespaceShaderISLightingCompositeNoDirectionalLight
			ISLightingCompositeMenu = 127,                 // BSImagespaceShaderISLightingCompositeMenu
			ISPerlinNoiseCS = 128,                         // BSImagespaceShaderISPerlinNoiseCS
			ISPerlinNoise2DCS = 129,                       // BSImagespaceShaderISPerlinNoise2DCS
			ISReflectionsRayTracing = 130,                 // BSImagespaceShaderReflectionsRayTracing
			ISReflectionsDebugSpecMask = 131,              // BSImagespaceShaderReflectionsDebugSpecMask
			ISSAOBlurH = 132,                              // BSImagespaceShaderISSAOBlurH
			ISSAOBlurV = 133,                              // BSImagespaceShaderISSAOBlurV
			ISSAOBlurHCS = 134,                            // BSImagespaceShaderISSAOBlurHCS
			ISSAOBlurVCS = 135,                            // BSImagespaceShaderISSAOBlurVCS
			ISSAOCameraZ = 136,                            // BSImagespaceShaderISSAOCameraZ
			ISSAOCameraZAndMipsCS = 137,                   // BSImagespaceShaderISSAOCameraZAndMipsCS
			ISSAOCompositeSAO = 138,                       // BSImagespaceShaderISSAOCompositeSAO
			ISSAOCompositeFog = 139,                       // BSImagespaceShaderISSAOCompositeFog
			ISSAOCompositeSAOFog = 140,                    // BSImagespaceShaderISSAOCompositeSAOFog
			ISMinify = 141,                                // BSImagespaceShaderISMinify
			ISMinifyContrast = 142,                        // BSImagespaceShaderISMinifyContrast
			ISSAORawAO = 143,                              // BSImagespaceShaderISSAORawAO
			ISSAORawAONoTemporal = 144,                    // BSImagespaceShaderISSAORawAONoTemporal
			ISSAORawAOCS = 145,                            // BSImagespaceShaderISSAORawAOCS
			ISSILComposite = 146,                          // BSImagespaceShaderISSILComposite
			ISSILRawInd = 147,                             // BSImagespaceShaderISSILRawInd
			ISSimpleColor = 148,                           // BSImagespaceShaderISSimpleColor
			ISDisplayDepth = 149,                          // BSImagespaceShaderISDisplayDepth
			ISSnowSSS = 150,                               // BSImagespaceShaderISSnowSSS
			ISTemporalAA = 151,                            // BSImagespaceShaderISTemporalAA
			ISTemporalAA_UI = 152,                         // BSImagespaceShaderISTemporalAA_UI
			ISTemporalAA_Water = 153,                      // BSImagespaceShaderISTemporalAA_Water
			ISUpsampleDynamicResolution = 154,             // BSImagespaceShaderISUpsampleDynamicResolution
			ISWaterBlend = 155,                            // BSImagespaceShaderISWaterBlend
			ISUnderwaterMask = 156,                        // BSImagespaceShaderISUnderwaterMask
			ISWaterFlow = 157,                             // BSImagespaceShaderWaterFlow

			Total = 159
		};

		static ImageSpaceManager* GetSingleton()
		{
			REL::Relocation<ImageSpaceManager**> singleton{ RELOCATION_ID(527731, 414660) };
			return *singleton;
		}

		// members
		std::uint64_t                        unk00;               // 000
		std::uint64_t                        unk08;               // 008
		std::int32_t                         unk10;               // 010
		std::int32_t                         unk14;               // 014
		std::uint64_t                        unk18;               // 018
		NiTPrimitiveArray<ImageSpaceEffect*> effects;             // 020
		bool                                 initEffects;         // 038
		std::uint32_t                        unk3C;               // 03C
		std::int32_t                         unk40;               // 040
		NiPointer<BSTriShape>                unk48;               // 048
		NiPointer<BSTriShape>                unk50;               // 050
		std::uint8_t                         unk58;               // 058
		std::uint32_t                        unk5C;               // 05C
		std::uint32_t                        unk60;               // 060
		RENDER_TARGET                        unk64;               // 064
		std::uint32_t                        unk68;               // 068
		std::uint32_t                        unk6C;               // 06C
		std::uint32_t                        unk70;               // 070
		float                                unk74;               // 074
		ImageSpaceTexture                    unk78;               // 078
		NiColorA                             refractionTint;      // 098
		ImageSpaceBaseData*                  currentBaseData;     // 0A8
		ImageSpaceBaseData*                  overrideBaseData;    // 0B0
		ImageSpaceBaseData*                  underwaterBaseData;  // 0B8
		ImageSpaceBaseData*                  consoleBaseData;     // 0C0
		ImageSpaceData                       data;                // 0C8
		std::uint64_t                        unk168;              // 168
		std::uint64_t                        unk170;              // 170
		std::uint64_t                        unk178;              // 178
		std::uint64_t                        unk180;              // 180
		std::uint64_t                        unk188;              // 188
		std::uint64_t                        unk190;              // 190
		std::uint64_t                        unk198;              // 198
		std::uint64_t                        unk1A0;              // 1A0
		std::uint64_t                        unk1A8;              // 1A8
		std::uint64_t                        unk1B0;              // 1B0
		std::uint64_t                        unk1B8;              // 1B8
		std::uint64_t                        unk1C0;              // 1C0
		std::uint64_t                        unk1C8;              // 1C8
		std::uint64_t                        unk1D0;              // 1D0
		std::uint64_t                        unk1D8;              // 1D8
		std::uint64_t                        unk1E0;              // 1E0
		std::uint64_t                        unk1E8;              // 1E8
		std::uint64_t                        unk1F0;              // 1F0
		std::uint64_t                        unk1F8;              // 1F8
		std::uint64_t                        unk200;              // 200
		std::uint64_t                        unk208;              // 208
		bool                                 usesLDR;             // 210
		bool                                 unk211;              // 211
		std::uint64_t                        unk218;              // 218
	};
	static_assert(sizeof(ImageSpaceManager) == 0x220);
}


===============================================
File: include/RE/I/ImageSpaceModifierInstance.h
===============================================
#pragma once

#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiAVObject;
	class ImageSpaceModifierInstanceForm;

	class ImageSpaceModifierInstance : NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceModifierInstance;

		~ImageSpaceModifierInstance() override;  // 00

		// add
		virtual bool                            Unk_25(void);                   // 25 - { return 0; }
		virtual void                            Apply() = 0;                    // 26
		virtual ImageSpaceModifierInstanceForm* IsForm();                       // 27 - { return 0; }
		virtual void                            PrintInfo(char* a_dstBuf) = 0;  // 28

		// members
		std::uint32_t         unk10;     // 10
		float                 strength;  // 14
		NiPointer<NiAVObject> target;    // 18
		float                 age;       // 20
		std::uint32_t         flags;     // 24
	};
	static_assert(sizeof(ImageSpaceModifierInstance) == 0x28);
}


===============================================
File: include/RE/I/ImageSpaceModifierInstanceDOF.h
===============================================
#pragma once

#include "RE/I/ImageSpaceData.h"
#include "RE/I/ImageSpaceModifierInstanceTemp.h"

namespace RE
{
	class ImageSpaceModifierInstanceDOF : public ImageSpaceModifierInstanceTemp
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceModifierInstanceDOF;

		enum class DepthOfFieldMode
		{
			kFrontBack = 0,
			kFront = 1,
			kBack = 2,
			kNone = 3
		};

		~ImageSpaceModifierInstanceDOF() override;  // 00

		// override (ImageSpaceModifierInstanceTemp)
		void Apply() override;                    // 26
		void PrintInfo(char* a_dstBuf) override;  // 28

		// members
		ImageSpaceModData data;  // 30
	};
	static_assert(sizeof(ImageSpaceModifierInstanceDOF) == 0x78);
}


===============================================
File: include/RE/I/ImageSpaceModifierInstanceForm.h
===============================================
#pragma once

#include "RE/I/ImageSpaceModifierInstance.h"

namespace RE
{
	class TESImageSpaceModifier;

	class ImageSpaceModifierInstanceForm : public ImageSpaceModifierInstance
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceModifierInstanceForm;

		~ImageSpaceModifierInstanceForm() override;  // 00

		// override (ImageSpaceModifierInstance)
		bool                            Unk_25(void) override;               // 25
		void                            Apply() override;                    // 26
		ImageSpaceModifierInstanceForm* IsForm() override;                   // 27
		void                            PrintInfo(char* a_dstBuf) override;  // 28

		static ImageSpaceModifierInstanceForm* Trigger(TESImageSpaceModifier* a_imod, float a_strength, NiAVObject* a_target)
		{
			using func_t = decltype(&ImageSpaceModifierInstanceForm::Trigger);
			REL::Relocation<func_t> func{ RELOCATION_ID(18185, 18570) };
			return func(a_imod, a_strength, a_target);
		}

		static void Stop(TESImageSpaceModifier* a_imod)
		{
			using func_t = decltype(&ImageSpaceModifierInstanceForm::Stop);
			REL::Relocation<func_t> func{ RELOCATION_ID(18188, 18573) };
			return func(a_imod);
		}

		static void StopCrossFade(float a_seconds)
		{
			using func_t = decltype(&ImageSpaceModifierInstanceForm::StopCrossFade);
			REL::Relocation<func_t> func{ RELOCATION_ID(18192, 18577) };
			return func(a_seconds);
		}

		// members
		TESImageSpaceModifier* imod;   // 28
		std::uint64_t          unk30;  // 30
		float                  unk38;  // 38
		std::uint32_t          unk3C;  // 3C
		std::uint64_t          unk40;  // 40
		std::uint32_t          unk48;  // 48
	};
	static_assert(sizeof(ImageSpaceModifierInstanceForm) == 0x50);
}


===============================================
File: include/RE/I/ImageSpaceModifierInstanceTemp.h
===============================================
#pragma once

#include "RE/I/ImageSpaceModifierInstance.h"

namespace RE
{
	class ImageSpaceModifierInstanceTemp : public ImageSpaceModifierInstance
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceModifierInstanceTemp;

		~ImageSpaceModifierInstanceTemp() override;  // 00

		// override (ImageSpaceModifierInstance)
		bool Unk_25(void) override;               // 25
		void PrintInfo(char* a_dstBuf) override;  // 28

		// members
		float         duration;  // 28
		std::uint32_t pad3C;     // 2C
	};
	static_assert(sizeof(ImageSpaceModifierInstanceTemp) == 0x30);
}


===============================================
File: include/RE/I/ImageSpaceShaderParam.h
===============================================
#pragma once

#include "RE/I/ImageSpaceEffectParam.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTArray.h"
#include "RE/N/NiTexture.h"
#include "RE/T/TextureFilterModes.h"

namespace RE
{
	class ImageSpaceShaderParam : public ImageSpaceEffectParam
	{
	public:
		inline static constexpr auto RTTI = RTTI_ImageSpaceShaderParam;

		~ImageSpaceShaderParam() override;  // 00

		// members
		std::uint32_t                                    unk08;                    // 08
		bool                                             SLIMode;                  // 0C
		std::uint8_t                                     pad0D;                    // 0D
		std::uint16_t                                    pad0E;                    // 0E
		std::uint64_t                                    unk10;                    // 10
		std::uint64_t                                    unk18;                    // 18
		std::uint8_t                                     unk20;                    // 20
		std::uint8_t                                     pad21;                    // 21
		std::uint16_t                                    pad22;                    // 22
		std::uint32_t                                    unk24;                    // 24
		float                                            unk28;                    // 28
		std::uint32_t                                    unk2C;                    // 2C
		float*                                           vertexConstantGroup;      // 30
		std::uint32_t                                    vertexConstantGroupSize;  // 38
		std::uint32_t                                    unk3C;                    // 3C
		float*                                           pixelConstantGroup;       // 40
		std::uint32_t                                    pixelConstantGroupSize;   // 48
		std::uint32_t                                    unk4C;                    // 4C
		NiTObjectArray<NiPointer<NiTexture>>             textures;                 // 50
		NiTPrimitiveArray<BSGraphics::TextureFilterMode> textureFilterModes;       // 68 - NiTPrimitiveArray<enum BSGraphics::TextureFilterMode>
	};
	static_assert(sizeof(ImageSpaceShaderParam) == 0x80);
}


===============================================
File: include/RE/I/ImageSpaceTexture.h
===============================================
#pragma once

#include "RE/B/BSShaderRenderTargets.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TextureAddressModes.h"
#include "RE/T/TextureFilterModes.h"

namespace RE
{
	class NiSourceTexture;

	class ImageSpaceTexture
	{
	public:
		// members
		NiPointer<NiSourceTexture>     texture;       // 00
		RENDER_TARGET                  renderTarget;  // 08
		std::uint32_t                  unk0C;         // 0C
		BSGraphics::TextureFilterMode  filterMode;    // 10
		BSGraphics::TextureAddressMode clampMode;     // 14
		bool                           isAcquired;    // 18
		std::uint8_t                   pad19;         // 19
		std::uint16_t                  pad1A;         // 1A
		std::uint16_t                  pad1C;         // 1C
	};
	static_assert(sizeof(ImageSpaceTexture) == 0x20);
}


===============================================
File: include/RE/I/ImpactResults.h
===============================================
#pragma once

namespace RE
{
	enum class ImpactResult
	{
		kNone = 0,
		kDestroy = 1,
		kBounce = 2,
		kImpale = 3,
		kStick = 4
	};
}


===============================================
File: include/RE/I/Info.h
===============================================
#pragma once

namespace RE
{
	namespace BSResource
	{
		struct Info
		{
		public:
			// members
			WinAPI::FILETIME modifyTime;  // 00
			WinAPI::FILETIME createTime;  // 08
			std::uint64_t    fileSize;    // 10
		};
		static_assert(sizeof(Info) == 0x18);
	}
}


===============================================
File: include/RE/I/IngredientItem.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MagicItem.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	class IngredientItem :
		public MagicItem,                  // 000
		public TESModelTextureSwap,        // 090
		public TESIcon,                    // 0C8
		public TESWeightForm,              // 0D8
		public BGSEquipType,               // 0E8
		public BGSDestructibleObjectForm,  // 0F8
		public BGSPickupPutdownSounds,     // 108
		public TESValueForm                // 120
	{
	public:
		inline static constexpr auto RTTI = RTTI_IngredientItem;
		inline static constexpr auto VTABLE = VTABLE_IngredientItem;
		inline static constexpr auto FORMTYPE = FormType::Ingredient;

		enum class IngredientFlag
		{
			kNone = 0,
			kCostOverride = 1 << 0,
			kFoodItem = 1 << 1,
			kExtendDuration = 1 << 3,
			kReferencesPersist = 1 << 8
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kIngredientUse = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		class Data  // ENIT
		{
		public:
			// members
			std::int32_t                                    costOverride;  // 00
			stl::enumeration<IngredientFlag, std::uint32_t> flags;         // 04
		};
		static_assert(sizeof(Data) == 0x8);

		struct GameData
		{
		public:
			// members
			std::uint16_t knownEffectFlags;
			std::uint16_t playerUses;
		};
		static_assert(sizeof(GameData) == 0x4);

		~IngredientItem() override;  // 00

		// override (MagicItem)
		void                     InitializeData() override;                                             // 04
		void                     ClearData() override;                                                  // 05
		void                     SaveGame(BGSSaveFormBuffer* a_buf) override;                           // 0E
		void                     LoadGame(BGSLoadFormBuffer* a_buf) override;                           // 0F
		void                     Revert(BGSLoadFormBuffer* a_buf) override;                             // 12
		void                     InitItemImpl() override;                                               // 13
		MagicSystem::SpellType   GetSpellType() const override;                                         // 53 - { return MagicSystem::SpellType::kIngredient; }
		MagicSystem::CastingType GetCastingType() const override;                                       // 55 - { return  MagicSystem::CastingType::kFireAndForget; }
		MagicSystem::Delivery    GetDelivery() const override;                                          // 57 - { return MagicSystem::Delivery::kSelf; }
		bool                     IsFood() const override;                                               // 5D - { return (GetData()->flags >> 1) & 1; }
		bool                     GetSkillUsageData(SkillUsageData& a_data) const override;              // 60
		std::uint32_t            GetMaxEffectCount() const override;                                    // 65 - { return 4; }
		ActorValue               GetAssociatedSkill() const override;                                   // 66 - { return ActorValue::kConfidence; }
		std::uint32_t            GetChunkID() override;                                                 // 68 - { return 'ENIT'; }
		void                     CopyMagicItemData(MagicItem* a_src) override;                          // 69
		void                     LoadMagicItemChunk(TESFile* a_mod, std::uint32_t a_chunkID) override;  // 6A
		const MagicItem::Data*   GetData1() const override;                                             // 6C - { return &effectData; }
		MagicItem::Data*         GetData2() override;                                                   // 6D - { return &effectData; }
		std::uint32_t            GetDataSize() const override;                                          // 6E - { return 0x8; }
		void                     InitFromChunk(TESFile* a_mod) override;                                // 6F
		void                     InitChunk() override;                                                  // 70

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05

		[[nodiscard]] bool           IsHostile() const;
		bool                         LearnEffect(std::uint32_t a_index);
		bool                         LearnEffect(EffectSetting* a_effect);
		std::optional<std::uint32_t> LearnNextEffect();
		void                         LearnAllEffects();
		// members
		Data          data;      // 130 - ENIT
		GameData      gamedata;  // 138
		std::uint32_t pad13C;    // 13C
	};
	static_assert(sizeof(IngredientItem) == 0x140);
}


===============================================
File: include/RE/I/InputDevices.h
===============================================
#pragma once

namespace RE
{
	struct INPUT_DEVICES
	{
		enum INPUT_DEVICE
		{
			kNone = static_cast<std::underlying_type_t<INPUT_DEVICE>>(-1),
			kKeyboard = 0,
			kMouse,
			kGamepad,
			kVirtualKeyboard,
#ifdef ENABLE_SKYRIM_VR
			kVRRight = 5,
			kVRLeft = 6,
#endif

			kTotal
		};
		static_assert(sizeof(INPUT_DEVICE) == 0x4);
	};
	using INPUT_DEVICE = INPUT_DEVICES::INPUT_DEVICE;
}


===============================================
File: include/RE/I/InputEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/I/InputDevices.h"

namespace RE
{
	enum class INPUT_EVENT_TYPE
	{
		kButton = 0,
		kMouseMove,
		kChar,
		kThumbstick,
		kDeviceConnect,
		kKinect
	};

	class ButtonEvent;
	class IDEvent;

	class InputEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_InputEvent;

		virtual ~InputEvent();  // 00

		[[nodiscard]] virtual bool                 HasIDCode() const;   // 01 - { return false; }
		[[nodiscard]] virtual const BSFixedString& QUserEvent() const;  // 02 - { return ""; }

		[[nodiscard]] constexpr INPUT_EVENT_TYPE GetEventType() const noexcept { return *eventType; }
		[[nodiscard]] constexpr INPUT_DEVICE     GetDevice() const noexcept { return *device; }

		[[nodiscard]] ButtonEvent*       AsButtonEvent();
		[[nodiscard]] const ButtonEvent* AsButtonEvent() const;

		[[nodiscard]] IDEvent*       AsIDEvent();
		[[nodiscard]] const IDEvent* AsIDEvent() const;

		// members
		stl::enumeration<INPUT_DEVICE, std::uint32_t>     device;     // 08
		stl::enumeration<INPUT_EVENT_TYPE, std::uint32_t> eventType;  // 0C
		InputEvent*                                       next;       // 10
	};
	static_assert(sizeof(InputEvent) == 0x18);
}


===============================================
File: include/RE/I/InterfaceStrings.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	class InterfaceStrings : public BSTSingletonSDM<InterfaceStrings>
	{
	public:
		static InterfaceStrings* GetSingleton();

		// members
		std::uint8_t  pad001;                   // 001
		std::uint16_t pad002;                   // 002
		std::uint32_t pad004;                   // 004
		BSFixedString faderData;                // 008 - "FaderData"
		BSFixedString hudData;                  // 010 - "HUDData"
		BSFixedString hudCamData;               // 018 - "HUDCamData"
		BSFixedString floatingQuestMarkers;     // 020 - "FloatingQuestMarkers"
		BSFixedString consoleData;              // 028 - "ConsoleData"
		BSFixedString quantityData;             // 030 - "QuantityData"
		BSFixedString messageBoxData;           // 038 - "MessageBoxData"
		BSFixedString bsUIScaleformData;        // 040 - "BSUIScaleformData"
		BSFixedString bsUIMessageData;          // 048 - "BSUIMessageData"
		BSFixedString bsUIAnalogData;           // 050 - "BSUIAnalogData"
		BSFixedString inventoryUpdateData;      // 058 - "InventoryUpdateData"
		BSFixedString refHandleUIData;          // 060 - "RefHandleUIData"
		BSFixedString tesFormUIData;            // 068 - "TESFormUIData"
		BSFixedString loadingMenuData;          // 070 - "LoadingMenuData"
		BSFixedString kinectStateData;          // 078 - "KinectStateChangeData"
		BSFixedString kinectUserEventData;      // 080 - "KinectUserEventData"
		BSFixedString inventoryMenu;            // 088 - "InventoryMenu"
		BSFixedString console;                  // 090 - "Console"
		BSFixedString dialogueMenu;             // 098 - "Dialogue Menu"
		BSFixedString hudMenu;                  // 0A0 - "HUD Menu"
		BSFixedString mainMenu;                 // 0A8 - "Main Menu"
		BSFixedString messageBoxMenu;           // 0B0 - "MessageBoxMenu"
		BSFixedString cursorMenu;               // 0B8 - "Cursor Menu"
		BSFixedString faderMenu;                // 0C0 - "Fader Menu"
		BSFixedString magicMenu;                // 0C8 - "MagicMenu"
		BSFixedString topMenu;                  // 0D0 - "Top Menu"
		BSFixedString overlayMenu;              // 0D8 - "Overlay Menu"
		BSFixedString overlayInteractionMenu;   // 0E0 - "Overlay Interaction Menu"
		BSFixedString loadingMenu;              // 0E8 - "Loading Menu"
		BSFixedString tweenMenu;                // 0F0 - "TweenMenu"
		BSFixedString barterMenu;               // 0F8 - "BarterMenu"
		BSFixedString giftMenu;                 // 100 - "GiftMenu"
		BSFixedString debugTextMenu;            // 108 - "Debug Text Menu"
		BSFixedString mapMenu;                  // 110 - "MapMenu"
		BSFixedString lockpickingMenu;          // 118 - "Lockpicking Menu"
		BSFixedString quantityMenu;             // 120 - "Quantity Menu"
		BSFixedString statsMenu;                // 128 - "StatsMenu"
		BSFixedString containerMenu;            // 130 - "ContainerMenu"
		BSFixedString sleepWaitMenu;            // 138 - "Sleep/Wait Menu"
		BSFixedString levelUpMenu;              // 140 - "LevelUp Menu"
		BSFixedString journalMenu;              // 148 - "Journal Menu"
		BSFixedString bookMenu;                 // 150 - "Book Menu"
		BSFixedString favoritesMenu;            // 158 - "FavoritesMenu"
		BSFixedString raceSexMenu;              // 160 - "RaceSex Menu"
		BSFixedString craftingMenu;             // 168 - "Crafting Menu"
		BSFixedString trainingMenu;             // 170 - "Training Menu"
		BSFixedString mistMenu;                 // 178 - "Mist Menu"
		BSFixedString tutorialMenu;             // 180 - "Tutorial Menu"
		BSFixedString creditsMenu;              // 188 - "Credits Menu"
		BSFixedString modManagerMenu;           // 190 - "Mod Manager Menu"
		BSFixedString creationClubMenu;         // 198 - "Creation Club Menu"
		BSFixedString titleSequenceMenu;        // 1A0 - "TitleSequence Menu"
		BSFixedString consoleNativeUIMenu;      // 1A8 - "Console Native UI Menu"
		BSFixedString kinectMenu;               // 1B0 - "Kinect Menu"
		BSFixedString loadWaitSpinner;          // 1B8 - "LoadWaitSpinner"
		BSFixedString streamingInstallMenu;     // 1C0 - "StreamingInstallMenu"
		BSFixedString textWidget;               // 1C8 - "TextWidget"
		BSFixedString buttonBarWidget;          // 1D0 - "ButtonBarWidget"
		BSFixedString graphWidget;              // 1D8 - "GraphWidget"
		BSFixedString textureWidget;            // 1E0 - "TextureWidget"
		BSFixedString uiMenuOK;                 // 1E8 - "UIMenuOK"
		BSFixedString uiMenuCancel;             // 1F0 - "UIMenuCancel"
		BSFixedString showText;                 // 1F8 - "Show Text"
		BSFixedString hideText;                 // 200 - "Hide Text"
		BSFixedString showList;                 // 208 - "Show List"
		BSFixedString voiceReady;               // 210 - "Voice Ready"
		BSFixedString dmfoStr;                  // 218 - "DMFOStr"
		BSFixedString showJournal;              // 220 - "Show Journal"
		BSFixedString journalSettingsSaved;     // 228 - "Journal Settings Saved"
		BSFixedString closeMenu;                // 230 - "CloseMenu"
		BSFixedString closingAllMenus;          // 238 - "Closing All Menus"
		BSFixedString refreshMenu;              // 240 - "RefreshMenu"
		BSFixedString cancelLoading;            // 248 - "CancelLoading"
		BSFixedString menuTextureDegradeEvent;  // 250 - "Menu Texture Degrade Event"
		BSFixedString diamondMarker;            // 258 - "<img src='DiamondMarker' width='10' height='15' align='baseline' vspace='5'>"
	};
	static_assert(sizeof(InterfaceStrings) == 0x260);
}


===============================================
File: include/RE/I/InteriorData.h
===============================================
#pragma once

#include "RE/B/BGSDirectionalAmbientLightingColors.h"
#include "RE/C/Color.h"

namespace RE
{
	struct INTERIOR_DATA
	{
	public:
		enum class Inherit
		{
			kAmbientColor = 1 << 0,
			kDirectionalColor = 1 << 1,
			kFogColor = 1 << 2,
			kFogNear = 1 << 3,
			kFogFar = 1 << 4,
			kDirectionalRotation = 1 << 5,
			kDirectionalFade = 1 << 6,
			kClipDistance = 1 << 7,
			kFogPower = 1 << 8,
			kFogMax = 1 << 9,
			kLightFadeDistances = 1 << 10
		};

		// members
		Color                                    ambient;                           // 00
		Color                                    directional;                       // 04
		Color                                    fogColorNear;                      // 08
		float                                    fogNear;                           // 0C
		float                                    fogFar;                            // 10
		std::uint32_t                            directionalXY;                     // 14
		std::uint32_t                            directionalZ;                      // 18
		float                                    directionalFade;                   // 1C
		float                                    clipDist;                          // 20
		float                                    fogPower;                          // 24
		BGSDirectionalAmbientLightingColors      directionalAmbientLightingColors;  // 28
		Color                                    fogColorFar;                       // 48
		float                                    fogClamp;                          // 4C
		float                                    lightFadeStart;                    // 50
		float                                    lightFadeEnd;                      // 54
		stl::enumeration<Inherit, std::uint32_t> lightingTemplateInheritanceFlags;  // 58
		std::uint32_t                            unk5C;                             // 5C - interiorOffset?
	};
	static_assert(sizeof(INTERIOR_DATA) == 0x60);
}


===============================================
File: include/RE/I/Inventory.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class TESObjectREFR;
	class InventoryEntryData;

	struct Inventory
	{
	public:
		struct Event
		{
		public:
			// members
			TESObjectREFR*      objRefr;    // 00
			InventoryEntryData* entryData;  // 08
			std::int32_t        newCount;   // 10
			std::int32_t        prevCount;  // 14
		};
		static_assert(sizeof(Event) == 0x18);

		static BSTEventSource<Inventory::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/I/Inventory3DManager.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/E/ExtraDataList.h"
#include "RE/M/MenuEventHandler.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "SKSE/Version.h"

namespace RE
{
	class InventoryEntryData;
	class NewInventoryMenuItemLoadTask;
	class NiAVObject;
	class TESBoundObject;
	class TESObjectREFR;

	struct LoadedInventoryModel
	{
	public:
		// members
		TESForm*              itemBase;  // 00 - smart ptr
		TESBoundObject*       modelObj;  // 08
		NiPointer<NiAVObject> spModel;   // 10
		std::uint64_t         unk18;     // 18
	};
	static_assert(sizeof(LoadedInventoryModel) == 0x20);

	class Inventory3DManager :
		public BSTSingletonSDM<Inventory3DManager>,  // 10
		public MenuEventHandler                      // 00
	{
	public:
		~Inventory3DManager() override;  // 00

		static Inventory3DManager* GetSingleton();

		void          UpdateItem3D(InventoryEntryData* a_objDesc);
		void          UpdateMagic3D(TESForm* a_form, std::uint32_t a_arg2);
		void          Clear3D();
		std::uint32_t Render();

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                                                                            \
	BSTSmallArray<LoadedInventoryModel, 7>        loadedModels; /* 058, 060 */                                                          \
	std::uint32_t                                 unk148;       /* 148, 150 */                                                          \
	float                                         zoomProgress; /* 14C, 154 - 1 if zoomed in, 0 if not, in-between during transition */ \
	BSTSmartPointer<NewInventoryMenuItemLoadTask> loadTask;     /* 150, 158 */                                                          \
	std::uint8_t                                  unk158;       /* 158, 160 */                                                          \
	std::uint8_t                                  unk159;       /* 159, 161 */                                                          \
	std::uint8_t                                  unk15A;       /* 15A, 162 */                                                          \
	std::uint8_t                                  pad15B;       /* 15B, 163 */                                                          \
	std::uint32_t                                 pad15C;       /* 15C, 164 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x108);

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x58, 0x60);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x58, 0x60);
		}

		// members
		std::uint8_t                                  unk011;         // 011
		std::uint16_t                                 unk012;         // 012
		NiPoint3                                      itemPosCopy;    // 014
		NiPoint3                                      itemPos;        // 020
		float                                         itemScaleCopy;  // 02C
		float                                         itemScale;      // 030
		std::uint32_t                                 unk034;         // 034
		TESObjectREFR*                                tempRef;        // 038
		ExtraDataList                                 originalExtra;  // 040

#ifndef ENABLE_SKYRIM_AE
		RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(Inventory3DManager) == 0x160);
#endif
}
#undef RUNTIME_DATA


===============================================
File: include/RE/I/InventoryChanges.h
===============================================
#pragma once

#include "RE/B/BSContainer.h"
#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MemoryManager.h"
#include "RE/T/TESBoundObject.h"

namespace RE
{
	class ExtraDataList;
	class InventoryEntryData;
	class TESBoundObject;

	class InventoryChanges
	{
	public:
		class IItemChangeVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_InventoryChanges__IItemChangeVisitor;
			inline static constexpr auto VTABLE = VTABLE_InventoryChanges__IItemChangeVisitor;

			virtual ~IItemChangeVisitor();  // 00

			// add
			virtual BSContainer::ForEachResult Visit(InventoryEntryData* a_entryData) = 0;                                                                                // 01
			virtual bool                       ShouldVisit([[maybe_unused]] InventoryEntryData* a_entryData, [[maybe_unused]] TESBoundObject* a_object) { return true; }  // 02
			virtual BSContainer::ForEachResult Unk_03(InventoryEntryData* a_entryData, [[maybe_unused]] void* a_arg2, bool* a_arg3)                                       // 03
			{
				*a_arg3 = true;
				return Visit(a_entryData);
			}
		};
		static_assert(sizeof(IItemChangeVisitor) == 0x8);

		InventoryChanges();
		explicit InventoryChanges(TESObjectREFR* a_ref);
		~InventoryChanges();

		void           AddEntryData(InventoryEntryData* a_entry);
		TESObjectARMO* GetArmorInSlot(std::int32_t a_slot);
		std::uint16_t  GetNextUniqueID();
		std::uint32_t  GetWornMask();
		void           InitFromContainerExtra();
		void           InitLeveledItems();
		void           InitOutfitItems(BGSOutfit* a_outfit, std::uint16_t a_npcLevel);
		void           InitScripts();
		void           RemoveFavorite(InventoryEntryData* a_entry, ExtraDataList* a_itemList);
		void           SendContainerChangedEvent(ExtraDataList* a_itemExtraList, TESObjectREFR* a_fromRefr, TESForm* a_item, std::int32_t a_count);
		void           SetFavorite(InventoryEntryData* a_entry, ExtraDataList* a_itemList);
		void           SetUniqueID(ExtraDataList* a_itemList, TESForm* a_oldForm, TESForm* a_newForm);
		void           GenerateLeveledListChanges();
		std::int16_t   GetItemCount(RE::TESBoundObject* a_obj);
		void           VisitInventory(IItemChangeVisitor& visitor);
		void           VisitWornItems(IItemChangeVisitor& visitor);

		TES_HEAP_REDEFINE_NEW();

		// members
		BSSimpleList<InventoryEntryData*>* entryList{ nullptr };  // 00
		TESObjectREFR*                     owner{ nullptr };      // 08
		float                              totalWeight{ 0.0F };   // 10
		float                              armorWeight{ 0.0F };   // 14
		bool                               changed{ false };      // 18
		std::uint8_t                       unk19{ 0 };            // 19
		std::uint8_t                       unk1A{ 0 };            // 1A
		std::uint8_t                       unk1B{ 0 };            // 1B
		std::uint32_t                      unk1C{ 0 };            // 1C

	private:
		InventoryChanges* Ctor(TESObjectREFR* a_ref);
		void              Dtor();
	};
	static_assert(sizeof(InventoryChanges) == 0x20);
}


===============================================
File: include/RE/I/InventoryEntryData.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataList.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MemoryManager.h"
#include "RE/S/SoulLevels.h"

namespace RE
{
	class ExtraDataList;
	class TESBoundObject;

	class InventoryEntryData
	{
	public:
		InventoryEntryData() noexcept = default;
		InventoryEntryData(const InventoryEntryData& a_rhs);

		InventoryEntryData(InventoryEntryData&& a_rhs) noexcept :
			object(std::exchange(a_rhs.object, nullptr)),
			extraLists(std::exchange(a_rhs.extraLists, nullptr)),
			countDelta(std::exchange(a_rhs.countDelta, 0))
		{}

		InventoryEntryData(TESBoundObject* a_object, std::int32_t a_countDelta) :
			object(a_object),
			countDelta(a_countDelta)
		{}

		~InventoryEntryData();

		InventoryEntryData& operator=(const InventoryEntryData& a_rhs);
		InventoryEntryData& operator=(InventoryEntryData&& a_rhs);

		void                                          AddExtraList(ExtraDataList* a_extra);
		[[nodiscard]] const char*                     GetDisplayName();
		[[nodiscard]] EnchantmentItem*                GetEnchantment() const;
		[[nodiscard]] std::optional<double>           GetEnchantmentCharge() const;
		[[nodiscard]] constexpr TESBoundObject*       GetObject() noexcept { return object; }
		[[nodiscard]] constexpr const TESBoundObject* GetObject() const noexcept { return object; }
		[[nodiscard]] TESForm*                        GetOwner();
		[[nodiscard]] SOUL_LEVEL                      GetSoulLevel() const;
		[[nodiscard]] std::int32_t                    GetValue() const;
		[[nodiscard]] float                           GetWeight() const;
		[[nodiscard]] bool                            IsEnchanted() const;
		[[nodiscard]] bool                            IsFavorited() const;
		[[nodiscard]] bool                            IsLeveled() const;
		[[nodiscard]] bool                            IsPoisoned() const;
		[[nodiscard]] bool                            IsWorn() const;
		[[nodiscard]] bool                            IsOwnedBy(Actor* a_testOwner, bool a_defaultTo = true);
		[[nodiscard]] bool                            IsOwnedBy(Actor* a_testOwner, TESForm* a_itemOwner, bool a_defaultTo = true);
		[[nodiscard]] bool                            IsQuestObject() const;
		void                                          PoisonObject(AlchemyItem* a_alchItem, std::uint32_t a_count);

		TES_HEAP_REDEFINE_NEW();

		// members
		TESBoundObject*               object{ nullptr };      // 00
		BSSimpleList<ExtraDataList*>* extraLists{ nullptr };  // 08
		std::int32_t                  countDelta{ 0 };        // 10
		std::uint32_t                 pad14{ 0 };             // 14

	private:
		[[nodiscard]] bool IsOwnedBy_Impl(Actor* a_testOwner, TESForm* a_itemOwner, bool a_defaultTo);

		template <class T>
		[[nodiscard]] bool HasExtraDataType() const
		{
			if (extraLists) {
				for (const auto& xList : *extraLists) {
					if (xList && xList->HasType<T>()) {
						return true;
					}
				}
			}

			return false;
		}
	};
	static_assert(sizeof(InventoryEntryData) == 0x18);
}


===============================================
File: include/RE/I/InventoryEvent.h
===============================================
#pragma once

namespace RE
{
	enum class INVENTORY_EVENT
	{
		kWeaponChanged = 0,
		kDraw,
		kSheath,
	};
}


