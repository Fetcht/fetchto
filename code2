===============================================
File: include/RE/B/BSTCaseInsensitiveStringMap.h
===============================================
#pragma once

#include "RE/N/NiTStringMap.h"

namespace RE
{
	// 28
	template <class T>
	class BSTCaseInsensitiveStringMap : public NiTStringMap<T>
	{
	private:
		using base = NiTStringMap<T>;

	public:
		using key_type = typename base::key_type;

		virtual ~BSTCaseInsensitiveStringMap();  // 00

		// override (NiTStringMap<T>)
		std::uint32_t hash_function(key_type a_key) const override;           // 01
		bool          key_eq(key_type a_lhs, key_type a_rhs) const override;  // 02
	};
}


===============================================
File: include/RE/B/BSTCreateFactoryManager.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	template <class>
	struct IBSTCreator;

	template <class Key, class T, std::uint32_t SIZE, template <class> class Singleton>
	class BSTFactoryManager : public Singleton<BSTFactoryManager<Key, T, SIZE, Singleton>>
	{
	public:
		// members
		BSTStaticHashMap<Key, const T*, SIZE> factories;  // 00
	};

	template <class Key, class T, std::uint32_t SIZE>
	class BSTCreateFactoryManager : public BSTFactoryManager<Key, IBSTCreator<T>, SIZE, BSTSingletonImplicit>
	{
	public:
	};

	class IUIMessageData;
	template <class, class>
	struct BSTDerivedCreator;

	class MessageDataFactoryManager : public BSTCreateFactoryManager<BSFixedString, IUIMessageData, 16>
	{
	public:
		static MessageDataFactoryManager* GetSingleton();

		template <class T = IUIMessageData>
		inline const BSTDerivedCreator<T, IUIMessageData>* GetCreator(const BSFixedString& a_type) const
		{
			auto it = factories.find(a_type);
			return it != factories.end() ? static_cast<const BSTDerivedCreator<T, IUIMessageData>*>(it->second) : 0;
		}
	};
	static_assert(sizeof(MessageDataFactoryManager) == 0x1A8);
}


===============================================
File: include/RE/B/BSTDerivedCreator.h
===============================================
#pragma once

#include "RE/I/IBSTCreator.h"

namespace RE
{
	// 08
	template <class Derived, class Parent>
	struct BSTDerivedCreator : public IBSTCreator<Parent>
	{
	public:
		virtual ~BSTDerivedCreator();  // 00

	protected:
		// override (IBSTCreator<Parent>)
		Parent* CreateImpl() const override;  // 01

	public:
		void Destroy(const Parent* a_val) const override;  // 02

		Derived* Create() const
		{
			return static_cast<Derived*>(CreateImpl());
		}
	};
}


===============================================
File: include/RE/B/BSTEvent.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"

namespace RE
{
	template <class T>
	class BSTEventSink;

	enum class BSEventNotifyControl
	{
		kContinue = 0,
		kStop = 1
	};

	template <class Event>
	class BSTEventSource
	{
	public:
		using Sink = BSTEventSink<Event>;

		BSTEventSource() :
			sinks(),
			pendingRegisters(),
			pendingUnregisters(),
			lock(),
			notifying(false),
			pad51(0),
			pad52(0),
			pad54(0)
		{}

		void AddEventSink(Sink* a_eventSink)
		{
			if (!a_eventSink) {
				return;
			}

			BSSpinLockGuard locker(lock);

			if (notifying) {
				if (std::find(pendingRegisters.begin(), pendingRegisters.end(), a_eventSink) == pendingRegisters.end()) {
					pendingRegisters.push_back(a_eventSink);
				}
			} else {
				if (std::find(sinks.begin(), sinks.end(), a_eventSink) == sinks.end()) {
					sinks.push_back(a_eventSink);
				}
			}

			auto it = std::find(pendingUnregisters.begin(), pendingUnregisters.end(), a_eventSink);
			if (it != pendingUnregisters.end()) {
				pendingUnregisters.erase(it);
			}
		}

		template <class SinkEvent>
		inline void AddEventSink(BSTEventSink<SinkEvent>* a_sink)
		{
			AddEventSink(a_sink);
		}

		void RemoveEventSink(Sink* a_eventSink)
		{
			if (!a_eventSink) {
				return;
			}

			BSSpinLockGuard locker(lock);

			if (notifying) {
				if (std::find(pendingUnregisters.begin(), pendingUnregisters.end(), a_eventSink) == pendingUnregisters.end()) {
					pendingUnregisters.push_back(a_eventSink);
				}
			} else {
				auto it = std::find(sinks.begin(), sinks.end(), a_eventSink);
				if (it != sinks.end()) {
					sinks.erase(it);
				}
			}

			auto it = std::find(pendingRegisters.begin(), pendingRegisters.end(), a_eventSink);
			if (it != pendingRegisters.end()) {
				pendingRegisters.erase(it);
			}
		}

		void SendEvent(const Event* a_event)
		{
			BSSpinLockGuard locker(lock);

			const auto wasNotifying = notifying;
			notifying = true;
			if (!wasNotifying && !pendingRegisters.empty()) {
				for (auto& toAdd : pendingRegisters) {
					if (std::find(sinks.begin(), sinks.end(), toAdd) == sinks.end()) {
						sinks.push_back(toAdd);
					}
				}
				pendingRegisters.clear();
			}

			for (auto& sink : sinks) {
				if (std::find(pendingUnregisters.begin(), pendingUnregisters.end(), sink) == pendingUnregisters.end()) {
					if (sink->ProcessEvent(a_event, this) == BSEventNotifyControl::kStop) {
						break;
					}
				}
			}

			notifying = wasNotifying;
			if (!wasNotifying && !pendingUnregisters.empty()) {
				for (auto& toRemove : pendingUnregisters) {
					auto it = std::find(sinks.begin(), sinks.end(), toRemove);
					if (it != sinks.end()) {
						sinks.erase(it);
					}
				}
				pendingUnregisters.clear();
			}
		}

		void operator()(const Event* a_event)
		{
			return SendEvent(a_event);
		}

		// members
		BSTArray<Sink*>    sinks;               // 00
		BSTArray<Sink*>    pendingRegisters;    // 18
		BSTArray<Sink*>    pendingUnregisters;  // 30
		mutable BSSpinLock lock;                // 48
		bool               notifying;           // 50
		std::uint8_t       pad51;               // 51
		std::uint16_t      pad52;               // 52
		std::uint32_t      pad54;               // 54
	};
	static_assert(sizeof(BSTEventSource<void*>) == 0x58);

	template <class Event>
	class BSTEventSink
	{
	public:
		virtual ~BSTEventSink() = default;                                                                          // 00
		virtual BSEventNotifyControl ProcessEvent(const Event* a_event, BSTEventSource<Event>* a_eventSource) = 0;  // 01
	};
	static_assert(sizeof(BSTEventSink<void>) == 0x8);
}


===============================================
File: include/RE/B/BSTFreeList.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	struct BSTFreeListElem
	{
		char                elem[sizeof(T)];  // 00
		BSTFreeListElem<T>* next;             // ??
	};
	// size == sizeof(T) + 0x8

	template <class T>
	class BSTFreeList
	{
	public:
		virtual ~BSTFreeList();  // 00

		// members
		std::uint32_t       lock;   // 08
		std::uint32_t       pad0C;  // 0C
		BSTFreeListElem<T>* free;   // 10
	};
	static_assert(sizeof(BSTFreeList<void*>) == 0x18);

	template <class T, std::size_t SIZE>
	class BSTStaticFreeList : public BSTFreeList<T>
	{
		virtual ~BSTStaticFreeList();  // 00

		// members
		BSTFreeListElem<T> elems[SIZE];  // 18
	};
	// size == 0x18 + sizeof(BSTFreeListElem<T>) * SIZE
}


===============================================
File: include/RE/B/BSTHashMap.h
===============================================
#pragma once

#include "RE/B/BSTTuple.h"
#include "RE/C/CRC.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	namespace detail
	{
		static constexpr std::uint8_t BSTScatterTableSentinel[] = { 0xDEu, 0xADu, 0xBEu, 0xEFu };
	}

	// scatter table with chaining
	template <
		class Hash,
		class KeyEqual,
		class Traits,
		template <std::size_t, std::size_t> class Allocator>
	class BSTScatterTable
	{
	public:
		using traits_type = Traits;
		using key_type = typename Traits::key_type;
		using mapped_type = typename Traits::mapped_type;
		using value_type = typename Traits::value_type;
		using size_type = std::uint32_t;
		using difference_type = std::int32_t;
		using hasher = Hash;
		using key_equal = KeyEqual;
		using reference = value_type&;
		using const_reference = const value_type&;
		using pointer = value_type*;
		using const_pointer = const value_type*;

		static_assert(std::is_invocable_r_v<size_type, const hasher&, const key_type&>);
		static_assert(std::is_invocable_r_v<bool, const key_equal&, const key_type&, const key_type&>);

	private:
		struct entry_type
		{
			entry_type() = default;
			entry_type(const entry_type&) = delete;

			entry_type(entry_type&& a_rhs)  //
				noexcept(std::is_nothrow_move_constructible_v<value_type>&&
						std::is_nothrow_destructible_v<value_type>)
			{
				if (a_rhs.has_value()) {
					const auto rnext = a_rhs.next;
					emplace(std::move(a_rhs).steal(), rnext);
				}
			}

			~entry_type() noexcept { destroy(); };

			entry_type& operator=(const entry_type&) = delete;

			entry_type& operator=(entry_type&& a_rhs)  //
				noexcept(std::is_nothrow_move_constructible_v<value_type>&&
						std::is_nothrow_destructible_v<value_type>)
			{
				if (this != std::addressof(a_rhs)) {
					destroy();
					if (a_rhs.has_value()) {
						const auto rnext = a_rhs.next;
						emplace(std::move(a_rhs).steal(), rnext);
					}
				}
				return *this;
			}

			[[nodiscard]] bool has_value() const noexcept { return next != nullptr; }

			void destroy()  //
				noexcept(std::is_nothrow_destructible_v<value_type>)
			{
				if (has_value()) {
					std::destroy_at(std::addressof(value_data.value));
					next = nullptr;
				}
				assert(!has_value());
			}

			template <class Arg>
			void emplace(Arg&& a_value, const entry_type* a_next)  //
				noexcept(std::is_nothrow_constructible_v<value_type, Arg>)
			{
				static_assert(std::same_as<std::decay_t<Arg>, value_type>);
				destroy();
				std::construct_at(std::addressof(value_data.value), std::forward<Arg>(a_value));
				next = const_cast<entry_type*>(a_next);
				assert(has_value());
			}

			[[nodiscard]] value_type steal() &&  //
				noexcept(std::is_nothrow_move_constructible_v<value_type>&&
						std::is_nothrow_destructible_v<value_type>)
			{
				assert(has_value());
				value_type val = std::move(value_data.value);
				destroy();
				assert(!has_value());
				return val;
			}

			union value_union
			{
				value_union() :
					value() {}

				~value_union() { value.~value_type(); }

				value_type value;
				std::byte  buffer[sizeof(value_type)]{ static_cast<std::byte>(0) };
			};
			value_union value_data;
			entry_type* next{ nullptr };
		};

		template <class U>
		class iterator_base
		{
		public:
			using difference_type = std::ptrdiff_t;
			using value_type = std::remove_const_t<U>;
			using pointer = value_type*;
			using reference = value_type&;
			using iterator_category = std::forward_iterator_tag;

			iterator_base() = default;
			~iterator_base() = default;

			iterator_base(const volatile iterator_base&) = delete;
			iterator_base& operator=(const volatile iterator_base&) = delete;

			template <class V>
			iterator_base(const iterator_base<V>& a_rhs) noexcept  //
				requires(std::convertible_to<typename iterator_base<V>::reference, reference>) :
				_first(a_rhs._first),
				_last(a_rhs._last)
			{}

			template <class V>
			iterator_base& operator=(const iterator_base<V>& a_rhs) noexcept  //
				requires(std::convertible_to<typename iterator_base<V>::reference, reference>)
			{
				assert(_last == a_rhs._last);
				_first = a_rhs._first;
				_last = a_rhs._last;
				return *this;
			}

			[[nodiscard]] reference operator*() const noexcept
			{
				assert(iterable());
				assert(_first->has_value());
				return _first->value_data.value;
			}

			template <class V>
			[[nodiscard]] bool operator==(const iterator_base<V>& a_rhs) const noexcept
			{
				assert(_last == a_rhs._last);
				return _first == a_rhs._first;
			}

			iterator_base& operator++() noexcept
			{
				seek();
				return *this;
			}

			iterator_base operator++(int) noexcept
			{
				iterator_base result = *this;
				++result;
				return result;
			}

			[[nodiscard]] pointer operator->() const noexcept
			{
				return &**this;
			}

		protected:
			friend class BSTScatterTable;

			iterator_base(entry_type* a_first, entry_type* a_last) noexcept :
				_first(a_first),
				_last(a_last)
			{
				assert(!!_first == !!_last);  // both or neither have values
				assert(_first <= _last);
				if (iterable() && !_first->has_value()) {
					seek();
				}
			}

			[[nodiscard]] entry_type* get_entry() const noexcept { return _first; }

		private:
			template <class>
			friend class iterator_base;

			[[nodiscard]] bool iterable() const noexcept { return _first && _last && _first != _last; }

			void seek() noexcept
			{
				assert(iterable());
				do {
					++_first;
				} while (_first != _last && !_first->has_value());
			}

			entry_type* _first{ nullptr };
			entry_type* _last{ nullptr };
		};

	public:
		using allocator_type = Allocator<sizeof(entry_type), alignof(entry_type)>;
		using iterator = iterator_base<value_type>;
		using const_iterator = iterator_base<const value_type>;

		BSTScatterTable() = default;

		BSTScatterTable(const BSTScatterTable& a_rhs) { insert(a_rhs.begin(), a_rhs.end()); }

		BSTScatterTable(BSTScatterTable&& a_rhs) noexcept  //
			requires(std::same_as<typename allocator_type::propagate_on_container_move_assignment, std::true_type>) :
			_capacity(std::exchange(a_rhs._capacity, 0)),
			_free(std::exchange(a_rhs._free, 0)),
			_good(std::exchange(a_rhs._good, 0)),
			_sentinel(a_rhs._sentinel),
			_allocator(std::move(a_rhs._allocator))
		{
			assert(a_rhs.empty());
		}

		~BSTScatterTable() { free_resources(); }

		BSTScatterTable& operator=(const BSTScatterTable& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				clear();
				insert(a_rhs.begin(), a_rhs.end());
			}
			return *this;
		}

		BSTScatterTable& operator=(BSTScatterTable&& a_rhs)  //
			requires(std::same_as<typename allocator_type::propagate_on_container_move_assignment, std::true_type>)
		{
			if (this != std::addressof(a_rhs)) {
				free_resources();

				_capacity = std::exchange(a_rhs._capacity, 0);
				_free = std::exchange(a_rhs._free, 0);
				_good = std::exchange(a_rhs._good, 0);
				_sentinel = a_rhs._sentinel;
				_allocator = std::move(a_rhs._allocator);

				assert(a_rhs.empty());
			}
			return *this;
		}

		[[nodiscard]] iterator       begin() noexcept { return make_iterator<iterator>(get_entries()); }
		[[nodiscard]] const_iterator begin() const noexcept { return make_iterator<const_iterator>(get_entries()); }
		[[nodiscard]] const_iterator cbegin() const noexcept { return make_iterator<const_iterator>(get_entries()); }

		[[nodiscard]] iterator       end() noexcept { return make_iterator<iterator>(); }
		[[nodiscard]] const_iterator end() const noexcept { return make_iterator<const_iterator>(); }
		[[nodiscard]] const_iterator cend() const noexcept { return make_iterator<const_iterator>(); }

		[[nodiscard]] bool      empty() const noexcept { return size() == 0; }
		[[nodiscard]] size_type size() const noexcept { return _capacity - _free; }

		void clear()
		{
			if (size() > 0) {
				const auto entries = get_entries();
				assert(entries != nullptr);
				for (size_type i = 0; i < _capacity; ++i) {
					entries[i].destroy();
				}
				_free = _capacity;
				_good = 0;
			}

			assert(empty());
		}

		std::pair<iterator, bool> insert(const value_type& a_value) { return do_insert(a_value); }
		std::pair<iterator, bool> insert(value_type&& a_value) { return do_insert(std::move(a_value)); }

		template <std::input_iterator InputIt>
		void insert(InputIt a_first, InputIt a_last)  //
			requires(std::convertible_to<std::iter_reference_t<InputIt>, const_reference>)
		{
			reserve(size() + static_cast<size_type>(std::distance(a_first, a_last)));
			for (; a_first != a_last; ++a_first) {
				insert(*std::move(a_first));
			}
		}

		template <class... Args>
		std::pair<iterator, bool> emplace(Args&&... a_args)  //
			requires(std::constructible_from<value_type, Args...>)
		{
			return insert(value_type(std::forward<Args>(a_args)...));
		}

		iterator erase(const_iterator a_pos) { return do_erase(a_pos); }
		iterator erase(iterator a_pos) { return do_erase(a_pos); }

		size_type erase(const key_type& a_key)
		{
			const auto pos = find(a_key);
			const auto result = pos != end() ? erase(pos) : pos;
			return result != end() ? 1 : 0;
		}

		[[nodiscard]] iterator       find(const key_type& a_key) { return do_find<iterator>(a_key); }
		[[nodiscard]] const_iterator find(const key_type& a_key) const { return do_find<const_iterator>(a_key); }

		[[nodiscard]] bool contains(const key_type& a_key) const { return find(a_key) != end(); }

		void reserve(size_type a_count)
		{
			if (a_count <= _capacity) {
				return;
			}

			const auto oldCap = _capacity;
			const auto oldEntries = get_entries();

			const auto [newCap, newEntries] = [&]() {
				constexpr std::uint64_t min = allocator_type::min_size();
				static_assert(min > 0 && std::has_single_bit(min));
				const auto cap = (std::max)(std::bit_ceil<std::uint64_t>(a_count), min);
				assert(cap >= min);
				if (cap > 1u << 31) {
					stl::report_and_fail("a buffer grew too large"sv);
				}

				const auto entries = allocate(static_cast<size_type>(cap));
				if (!entries) {
					stl::report_and_fail("failed to handle an allocation"sv);
				}

				return std::make_pair(static_cast<size_type>(cap), entries);
			}();

			const auto setCap = [&](size_type a_newCap) {
				_capacity = a_newCap;
				_free = _capacity;
				_good = 0;
			};

			if (newEntries == oldEntries) {
				std::uninitialized_default_construct_n(oldEntries + oldCap, newCap - oldCap);
				std::vector<value_type> todo;
				todo.reserve(size());
				for (size_type i = 0; i < oldCap; ++i) {
					auto& entry = oldEntries[i];
					if (entry.has_value()) {
						todo.emplace_back(std::move(entry).steal());
					}
				}
				setCap(newCap);
				insert(
					std::make_move_iterator(todo.begin()),
					std::make_move_iterator(todo.end()));
			} else {
				// in with the new
				std::uninitialized_default_construct_n(newEntries, newCap);
				setCap(newCap);
				set_entries(newEntries);

				if (oldEntries) {  // out with the old
					for (size_type i = 0; i < oldCap; ++i) {
						auto& entry = oldEntries[i];
						if (entry.has_value()) {
							insert(std::move(entry).steal());
						}
					}
					std::destroy_n(oldEntries, oldCap);
					deallocate(oldEntries);
				}
			}
		}

	private:
		[[nodiscard]] static const key_type& unwrap_key(const value_type& a_value) noexcept
		{
			return traits_type::unwrap_key(a_value);
		}

		[[nodiscard]] entry_type* allocate(size_type a_count)
		{
			return static_cast<entry_type*>(_allocator.allocate_bytes(sizeof(entry_type) * a_count));
		}

		void deallocate(entry_type* a_entry) { _allocator.deallocate_bytes(a_entry); }

		[[nodiscard]] iterator do_erase(const_iterator a_pos)
		{
			assert(a_pos != end());
			const auto entry = a_pos.get_entry();
			assert(entry != nullptr);
			assert(entry->has_value());

			if (entry->next == _sentinel) {  // end of chain
				if (auto prev = &get_entry_for(unwrap_key(entry->value_data.value)); prev != entry) {
					while (prev->next != entry) {
						prev = prev->next;
					}
					prev->next = const_cast<entry_type*>(_sentinel);  // detach from chain
				}

				entry->destroy();
			} else {  // move next into current
				*entry = std::move(*entry->next);
			}

			++_free;
			return make_iterator<iterator>(entry + 1);
		}

		template <class Iter>
		[[nodiscard]] Iter do_find(const key_type& a_key) const  //
			noexcept(noexcept(hash_function(a_key)) && noexcept(key_eq(a_key, a_key)))
		{
			if (empty()) {
				return make_iterator<Iter>();
			}

			auto entry = &get_entry_for(a_key);
			if (entry->has_value()) {
				do {  // follow chain
					if (key_eq(unwrap_key(entry->value_data.value), a_key)) {
						return make_iterator<Iter>(entry);
					} else {
						entry = entry->next;
					}
				} while (entry != _sentinel);
			}

			return make_iterator<Iter>();
		}

		template <class P>
		[[nodiscard]] std::pair<iterator, bool> do_insert(P&& a_value)  //
			requires(std::same_as<std::decay_t<P>, value_type>)
		{
			if (const auto it = find(unwrap_key(a_value)); it != end()) {  // already exists
				return std::make_pair(it, false);
			}

			if (_free == 0) {  // no free entries
				reserve(_capacity + 1);
				assert(_free > 0);
			}

			const stl::scope_exit decrement{ [&]() noexcept { --_free; } };
			const auto            entry = &get_entry_for(unwrap_key(a_value));
			if (entry->has_value()) {  // slot is taken, resolve conflict
				const auto free = &get_free_entry();
				const auto wouldve = &get_entry_for(unwrap_key(entry->value_data.value));
				if (wouldve == entry) {  // hash collision
					free->emplace(std::forward<P>(a_value), std::exchange(entry->next, free));
					return std::make_pair(make_iterator<iterator>(free), true);
				} else {  // how did we get here?
					auto prev = wouldve;
					while (prev->next != entry) {
						prev = prev->next;
					}

					// evict current value and detach from chain
					*free = std::move(*entry);
					prev->next = free;
					entry->emplace(std::forward<P>(a_value), _sentinel);

					return std::make_pair(make_iterator<iterator>(entry), true);
				}
			} else {  // its free realestate
				entry->emplace(std::forward<P>(a_value), _sentinel);
				return std::make_pair(make_iterator<iterator>(entry), true);
			}
		}

		void free_resources()
		{
			if (_capacity > 0) {
				assert(get_entries() != nullptr);
				std::destroy_n(get_entries(), _capacity);
				deallocate(get_entries());
				set_entries(nullptr);
				_capacity = 0;
				_free = 0;
				_good = 0;
			}

			assert(get_entries() == nullptr);
			assert(_capacity == 0);
			assert(_free == 0);
		}

		[[nodiscard]] entry_type& get_entry_for(const key_type& a_key) const  //
			noexcept(noexcept(hash_function(a_key)))
		{
			assert(get_entries() != nullptr);
			assert(std::has_single_bit(_capacity));

			const auto hash = hash_function(a_key);
			const auto idx = hash & (_capacity - 1);  // quick modulo
			return get_entries()[idx];
		}

		[[nodiscard]] entry_type* get_entries() const noexcept { return static_cast<entry_type*>(_allocator.get_entries()); }

		[[nodiscard]] entry_type& get_free_entry() noexcept
		{
			assert(_free > 0);
			assert(get_entries() != nullptr);
			assert(std::has_single_bit(_capacity));
			assert([&]() noexcept {
				const auto begin = get_entries();
				const auto end = get_entries() + _capacity;
				return std::find_if(
						   begin,
						   end,
						   [](const auto& a_entry) noexcept {
							   return !a_entry.has_value();
						   }) != end;
			}());

			const auto entries = get_entries();
			while (entries[_good].has_value()) {
				_good = (_good + 1) & (_capacity - 1);  // wrap around w/ quick modulo
			}
			return entries[_good];
		}

		[[nodiscard]] size_type hash_function(const key_type& a_key) const  //
			noexcept(std::is_nothrow_constructible_v<hasher>&&
					std::is_nothrow_invocable_v<const hasher&, const key_type&>)
		{
			return static_cast<size_type>(hasher()(a_key));
		}

		[[nodiscard]] bool key_eq(const key_type& a_lhs, const key_type& a_rhs) const  //
			noexcept(std::is_nothrow_constructible_v<key_equal>&&
					std::is_nothrow_invocable_v<const key_equal&, const key_type&, const key_type&>)
		{
			return static_cast<bool>(key_equal()(a_lhs, a_rhs));
		}

		template <class Iter>
		[[nodiscard]] Iter make_iterator() const noexcept
		{
			return Iter(get_entries() + _capacity, get_entries() + _capacity);
		}

		template <class Iter>
		[[nodiscard]] Iter make_iterator(entry_type* a_first) const noexcept
		{
			return Iter(a_first, get_entries() + _capacity);
		}

		void set_entries(entry_type* a_entries) noexcept { _allocator.set_entries(a_entries); }

		// members
		std::uint64_t     _pad00{ 0 };                                                                        // 00
		std::uint32_t     _pad08{ 0 };                                                                        // 08
		size_type         _capacity{ 0 };                                                                     // 0C - total # of slots, always a power of 2
		size_type         _free{ 0 };                                                                         // 10 - # of free slots
		size_type         _good{ 0 };                                                                         // 14 - last free index
		const entry_type* _sentinel{ reinterpret_cast<const entry_type*>(detail::BSTScatterTableSentinel) };  // 18 - signals end of chain
		allocator_type    _allocator;                                                                         // 20
	};

	template <class Key, class T>
	class BSTScatterTableTraits
	{
	public:
		using key_type = Key;
		using mapped_type = T;
		using value_type = RE::BSTTuple<const key_type, mapped_type>;

		[[nodiscard]] static const key_type& unwrap_key(const value_type& a_value) noexcept { return a_value.first; }
	};

	template <class Key>
	class BSTSetTraits
	{
	public:
		using key_type = Key;
		using mapped_type = void;
		using value_type = key_type;

		[[nodiscard]] static const key_type& unwrap_key(const value_type& a_value) noexcept { return a_value; }
	};

	template <std::size_t S, std::size_t A>
	struct BSTScatterTableHeapAllocator
	{
	public:
		using size_type = std::uint32_t;
		using propagate_on_container_move_assignment = std::true_type;

		BSTScatterTableHeapAllocator() = default;
		BSTScatterTableHeapAllocator(const BSTScatterTableHeapAllocator&) = delete;

		BSTScatterTableHeapAllocator(BSTScatterTableHeapAllocator&& a_rhs) noexcept :
			_entries(std::exchange(a_rhs._entries, nullptr))
		{}

		~BSTScatterTableHeapAllocator() = default;
		BSTScatterTableHeapAllocator& operator=(const BSTScatterTableHeapAllocator&) = delete;

		BSTScatterTableHeapAllocator& operator=(BSTScatterTableHeapAllocator&& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				assert(_entries == nullptr);
				_entries = std::exchange(a_rhs._entries, nullptr);
			}
			return *this;
		}

		[[nodiscard]] static constexpr size_type min_size() noexcept { return 1u << 3; }

		[[nodiscard]] void* allocate_bytes(std::size_t a_bytes)
		{
			assert(a_bytes % S == 0);
			return malloc(a_bytes);
		}

		void deallocate_bytes(void* a_ptr) { free(a_ptr); }

		[[nodiscard]] void* get_entries() const noexcept { return _entries; }
		void                set_entries(void* a_entries) noexcept { _entries = static_cast<std::byte*>(a_entries); }

	private:
		// members
		std::uint64_t _pad00{ 0 };          // 00 (20)
		std::byte*    _entries{ nullptr };  // 08 (28)
	};

	template <std::uint32_t N>
	struct BSTStaticHashMapBase
	{
	public:
		static_assert(N > 0 && std::has_single_bit(N));

		template <std::size_t S, std::size_t A>
		struct Allocator
		{
		public:
			using size_type = std::uint32_t;
			using propagate_on_container_move_assignment = std::false_type;

			Allocator() = default;
			Allocator(const Allocator&) = delete;
			Allocator(Allocator&&) = delete;
			~Allocator() = default;
			Allocator& operator=(const Allocator&) = delete;
			Allocator& operator=(Allocator&&) = delete;

			[[nodiscard]] static constexpr size_type min_size() noexcept { return N; }

			[[nodiscard]] void* allocate_bytes(std::size_t a_bytes)
			{
				assert(a_bytes % S == 0);
				return a_bytes <= N * S ? _buffer : nullptr;
			}

			void deallocate_bytes([[maybe_unused]] void* a_ptr) { assert(a_ptr == _buffer); }

			[[nodiscard]] void* get_entries() const noexcept { return _entries; }

			void set_entries(void* a_entries) noexcept
			{
				assert(a_entries == _buffer || a_entries == nullptr);
				_entries = static_cast<std::byte*>(a_entries);
			}

		private:
			alignas(A) std::byte _buffer[N * S]{ static_cast<std::byte>(0) };  // 00 (20)
			std::byte* _entries{ nullptr };                                    // ??
		};
	};

	template <std::size_t S, std::size_t A>
	class BSTScatterTableScrapAllocator
	{
	public:
		using size_type = std::uint32_t;
		using propagate_on_container_move_assignment = std::false_type;

		BSTScatterTableScrapAllocator() = default;
		BSTScatterTableScrapAllocator(const BSTScatterTableScrapAllocator&) = delete;
		BSTScatterTableScrapAllocator(BSTScatterTableScrapAllocator&&) = delete;
		~BSTScatterTableScrapAllocator() = default;
		BSTScatterTableScrapAllocator& operator=(const BSTScatterTableScrapAllocator&) = delete;
		BSTScatterTableScrapAllocator& operator=(BSTScatterTableScrapAllocator&&) = delete;

		[[nodiscard]] static constexpr size_type min_size() noexcept { return 1u << 3; }

		[[nodiscard]] void* allocate_bytes(std::size_t a_bytes)
		{
			assert(_allocator != nullptr);
			assert(a_bytes % S == 0);
			return _allocator->Allocate(a_bytes, 0x10);
		}

		void deallocate_bytes(void* a_ptr)
		{
			assert(_allocator != nullptr);
			_allocator->Deallocate(a_ptr);
		}

		[[nodiscard]] void* get_entries() const noexcept { return _entries; }
		void                set_entries(void* a_entries) noexcept { _entries = static_cast<std::byte*>(a_entries); }

	private:
		// members
		ScrapHeap* _allocator{ MemoryManager::GetSingleton()->GetThreadScrapHeap() };  // 00 (20)
		std::byte* _entries{ nullptr };                                                // 08 (28)
	};

	template <
		class Key,
		class T,
		class Hash = BSCRC32<Key>,
		class KeyEq = std::equal_to<Key>>
	using BSTHashMap =
		BSTScatterTable<
			Hash,
			KeyEq,
			BSTScatterTableTraits<Key, T>,
			BSTScatterTableHeapAllocator>;

	namespace detail
	{
		using _dummy_bsthashmap = BSTHashMap<int, int>;
		static_assert(std::forward_iterator<_dummy_bsthashmap::iterator>);
	}

	template <
		class Key,
		class Hash = BSCRC32<Key>,
		class KeyEq = std::equal_to<Key>>
	using BSTSet =
		BSTScatterTable<
			Hash,
			KeyEq,
			BSTSetTraits<Key>,
			BSTScatterTableHeapAllocator>;

	template <
		class Key,
		class T,
		std::uint32_t N,
		class Hash = BSCRC32<Key>,
		class KeyEq = std::equal_to<Key>>
	using BSTStaticHashMap =
		BSTScatterTable<
			Hash,
			KeyEq,
			BSTScatterTableTraits<Key, T>,
			BSTStaticHashMapBase<N>::template Allocator>;

	template <
		class Key,
		class T,
		class Hash = BSCRC32<Key>,
		class KeyEq = std::equal_to<Key>>
	using BSTScrapHashMap =
		BSTScatterTable<
			Hash,
			KeyEq,
			BSTScatterTableTraits<Key, T>,
			BSTScatterTableScrapAllocator>;

	using UnkKey = std::uintptr_t;
	using UnkValue = std::uintptr_t;
}


===============================================
File: include/RE/B/BSTList.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	// forward list
	template <class T>
	class BSSimpleList
	{
	public:
		using value_type = T;
		using size_type = std::uint32_t;
		using reference = value_type&;
		using const_reference = const value_type&;

		struct Node
		{
		public:
			inline Node() :
				item{},
				next(nullptr)
			{}

			inline Node(value_type a_value, Node* a_next) :
				item(a_value),
				next(a_next)
			{}

			inline Node(const Node& a_rhs) :
				item(a_rhs.item),
				next(a_rhs.next)
			{}

			inline Node(Node&& a_rhs) :
				item(std::move(a_rhs.item)),
				next(std::move(a_rhs.next))
			{
				a_rhs.next = nullptr;
			}

			inline Node(const value_type& a_value) :
				item(a_value),
				next(nullptr)
			{}

			inline Node(value_type&& a_value) :
				item(std::move(a_value)),
				next(nullptr)
			{}

			~Node() = default;

			inline Node& operator=(const Node& a_rhs)
			{
				if (this != std::addressof(a_rhs)) {
					item = a_rhs.item;
					next = a_rhs.next;
				}
				return *this;
			}

			inline Node& operator=(Node&& a_rhs)
			{
				if (this != std::addressof(a_rhs)) {
					item = std::move(a_rhs.item);

					next = std::move(a_rhs.next);
					a_rhs.next = nullptr;
				}
				return *this;
			}

			TES_HEAP_REDEFINE_NEW();

			// members
			value_type           item;  // 00
			stl::observer<Node*> next;  // ??
		};

		template <class U>
		class iterator_base
		{
		public:
			using difference_type = std::ptrdiff_t;
			using value_type = U;
			using pointer = U*;
			using reference = U&;
			using iterator_category = std::forward_iterator_tag;

			constexpr iterator_base() noexcept :
				_cur(nullptr)
			{}

			constexpr iterator_base(const iterator_base& a_rhs) noexcept :
				_cur(a_rhs._cur)
			{}

			constexpr iterator_base(iterator_base&& a_rhs) noexcept :
				_cur(std::move(a_rhs._cur))
			{
				a_rhs._cur = nullptr;
			}

			constexpr iterator_base(Node* a_node) noexcept :
				_cur(a_node)
			{}

			inline ~iterator_base() noexcept { _cur = nullptr; }

			constexpr iterator_base& operator=(const iterator_base& a_rhs) noexcept
			{
				if (this != std::addressof(a_rhs)) {
					_cur = a_rhs._cur;
				}
				return *this;
			}

			constexpr iterator_base& operator=(iterator_base&& a_rhs) noexcept
			{
				if (this != std::addressof(a_rhs)) {
					_cur = std::move(a_rhs._cur);
					a_rhs._cur = nullptr;
				}
				return *this;
			}

			[[nodiscard]] constexpr reference operator*() const noexcept { return _cur->item; }
			[[nodiscard]] constexpr pointer   operator->() const noexcept { return std::addressof(_cur->item); }

			[[nodiscard]] constexpr bool operator==(const iterator_base& a_rhs) const noexcept { return _cur == a_rhs._cur; }
			[[nodiscard]] constexpr bool operator!=(const iterator_base& a_rhs) const noexcept { return !(*this == a_rhs); }

			// prefix
			constexpr iterator_base& operator++() noexcept
			{
				assert(_cur);
				_cur = _cur->next;
				return *this;
			}

			// postfix
			[[nodiscard]] constexpr iterator_base operator++(int) noexcept
			{
				iterator_base tmp(*this);
				++(*this);
				return tmp;
			}

		protected:
			friend class BSSimpleList<T>;

			[[nodiscard]] constexpr Node*       get_current() noexcept { return _cur; }
			[[nodiscard]] constexpr const Node* get_current() const noexcept { return _cur; }

			[[nodiscard]] constexpr bool comes_before(const iterator_base& a_rhs) const noexcept
			{
				for (auto iter = _cur; iter; iter = iter->next) {
					if (iter == a_rhs._cur) {
						return true;
					}
				}
				return false;
			}

		private:
			stl::observer<Node*> _cur;
		};

		using iterator = iterator_base<value_type>;
		using const_iterator = iterator_base<const value_type>;

		inline BSSimpleList() :
			_listHead()
		{}

		inline BSSimpleList(const BSSimpleList& a_rhs) :
			_listHead()
		{
			copy_from(a_rhs);
		}

		inline BSSimpleList(BSSimpleList&& a_rhs) :
			_listHead(std::move(a_rhs._listHead))
		{}

		inline ~BSSimpleList()
		{
			clear();
		}

		inline BSSimpleList& operator=(const BSSimpleList& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				clear();
				copy_from(a_rhs);
			}
			return *this;
		}

		inline BSSimpleList& operator=(BSSimpleList&& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				clear();
				_listHead = std::move(a_rhs._listHead);
			}
			return *this;
		}

		TES_HEAP_REDEFINE_NEW();

		[[nodiscard]] inline reference front()
		{
			assert(!empty());
			return *begin();
		}

		[[nodiscard]] inline const_reference front() const
		{
			assert(!empty());
			return *begin();
		}

		[[nodiscard]] inline iterator       begin() { return empty() ? end() : iterator(get_head()); }
		[[nodiscard]] inline const_iterator begin() const { return empty() ? end() : const_iterator(get_head()); }
		[[nodiscard]] inline const_iterator cbegin() const { return begin(); }

		[[nodiscard]] constexpr iterator       end() noexcept { return iterator(nullptr); }
		[[nodiscard]] constexpr const_iterator end() const noexcept { return const_iterator(nullptr); }
		[[nodiscard]] constexpr const_iterator cend() const noexcept { return end(); }

		[[nodiscard]] inline bool empty() const { return !_listHead.next && !_listHead.item; }

		inline void clear()
		{
			erase_after_impl(get_head(), nullptr);
			if (static_cast<bool>(_listHead.item)) {
				std::destroy_at(std::addressof(_listHead.item));
			}
		}

		inline iterator insert_after(iterator a_pos, const_reference a_value)
		{
			auto node = new Node(a_value);
			return insert_after_impl(
				a_pos.get_current(),
				std::make_pair(node, node));
		}

		inline iterator insert_after(iterator a_pos, value_type&& a_value)
		{
			auto node = new Node(std::move(a_value));
			return insert_after_impl(
				a_pos.get_current(),
				std::make_pair(node, node));
		}

		inline iterator insert_after(const_iterator a_pos, const_reference a_value)
		{
			auto node = new Node(a_value);
			return insert_after_impl(
				a_pos.get_current(),
				std::make_pair(node, node));
		}

		inline iterator insert_after(const_iterator a_pos, value_type&& a_value)
		{
			auto node = new Node(std::move(a_value));
			return insert_after_impl(
				a_pos.get_current(),
				std::make_pair(node, node));
		}

		inline iterator insert_after(const_iterator a_pos, size_type a_count, const_reference a_value)
		{
			if (a_count <= 0) {
				return a_pos;
			}

			return insert_after_impl(
				a_pos.get_current(),
				alloc_copies(a_count, a_value));
		}

		inline iterator erase_after(const_iterator a_pos)
		{
			if (a_pos == cend()) {
				return end();
			}

			auto node = a_pos.get_current();
			erase_after_impl(node, node->next);
			return node->next;
		}

		inline iterator erase_after(const_iterator a_first, const_iterator a_last)
		{
			assert(a_first.comes_before(a_last));

			auto head = a_first.get_current();
			auto tail = a_last.get_current();

			erase_after_impl(head, tail);
			return tail;
		}

		inline void push_front(const_reference a_value) { emplace_front_impl(a_value); }
		inline void push_front(value_type&& a_value) { emplace_front_impl(std::move(a_value)); }

		template <class... Args>
		inline reference emplace_front(Args&&... a_args)
		{
			emplace_front_impl(std::forward<Args>(a_args)...);
			return front();
		}

		inline void pop_front()
		{
			assert(!empty());

			std::destroy_at(std::addressof(_listHead.item));
			auto node = _listHead.next;
			if (node) {
				_listHead.next = node->next;
				std::construct_at(std::addressof(_listHead.item), std::move(node->item));
				delete node;
			}
		}

		inline void resize(size_type a_count) { resize(a_count, value_type{}); }
		inline void resize(size_type a_count, const value_type& a_value) { resize_impl(a_count, a_value); }

	protected:
		[[nodiscard]] constexpr Node*       get_head() noexcept { return std::addressof(_listHead); }
		[[nodiscard]] constexpr const Node* get_head() const noexcept { return std::addressof(_listHead); }

		[[nodiscard]] inline std::pair<Node*, Node*> alloc_copies(size_type a_count, const_reference a_value)
		{
			assert(a_count > 0);

			auto head = new Node(a_value);
			auto tail = head;
			for (size_type i = 1; i < a_count; ++i) {
				tail->next = new Node(a_value);
				tail = tail->next;
			}

			return std::make_pair(head, tail);
		}

		inline void copy_from(const BSSimpleList& a_rhs)
		{
			auto lhs = get_head();
			auto rhs = a_rhs.get_head();

			lhs->item = rhs->item;
			while (rhs->next) {
				rhs = rhs->next;
				lhs->next = new Node(rhs->item);
				lhs = lhs->next;
			}
		}

		[[nodiscard]] inline Node* insert_after_impl(Node* a_pos, std::pair<Node*, Node*> a_values)
		{
			auto [head, tail] = a_values;

			assert(a_pos);
			assert(head && tail);

			tail->next = a_pos->next;
			a_pos->next = head;
			return tail;
		}

		inline void erase_after_impl(Node* a_head, Node* a_tail)
		{
			if (a_head && a_head != a_tail) {
				auto iter = a_head->next;
				auto tmp = iter;
				while (iter != a_tail) {
					tmp = iter;
					iter = iter->next;
					delete tmp;
				}
				a_head->next = a_tail;
			}
		}

		template <class... Args>
		inline void emplace_front_impl(Args&&... a_args)
		{
			if (static_cast<bool>(_listHead.item)) {
				auto node = new Node(std::move(_listHead));
				_listHead.next = node;
			}

			std::destroy_at(std::addressof(_listHead.item));
			std::construct_at(std::addressof(_listHead.item), std::forward<Args>(a_args)...);
		}

		inline void resize_impl(size_type a_count, const_reference a_value)
		{
			if (a_count <= 0) {
				clear();
			}

			auto      iter = begin();
			auto      last = end();
			size_type elems = 1;
			while (iter != last && elems != a_count) {
				++iter;
				++elems;
			}

			if (elems < a_count) {
				// need to grow
				insert_after(iter, a_count - elems, a_value);
			} else if (iter != last) {
				// need to shrink
				erase_after(iter, last);
			} else {
				// already required size
			}
		}

		// members
		Node _listHead;  // 00

		// T				_item;	// 00
		// BSSimpleList<T>* _next;	// ??
	};
}


===============================================
File: include/RE/B/BSTLocklessQueue.h
===============================================
#pragma once

namespace RE
{
	struct BSTLocklessQueue
	{
		template <class T, std::uint32_t SIZE, std::uint32_t UNKNOWN>
		class PtrMultiProdCons
		{
			T*                     data[SIZE];  // 00
			volatile std::uint32_t start;       // 08
			volatile std::uint32_t fetched;     // 0C
			volatile std::uint32_t end;         // 10
			volatile std::uint32_t allocated;   // 14
		};
		static_assert(sizeof(PtrMultiProdCons<void*, 1, 1>) == 0x18);

		template <class QueueContainer, class T, std::uint32_t SIZE, std::uint32_t UNKNOWN>
		struct ObjQueueBase
		{
			T              data[SIZE];  // 00
			QueueContainer queued;      // ??
			QueueContainer free;        // ??
		};

		template <class T, std::uint32_t SIZE, std::uint32_t UNKNOWN>
		class ObjMultiProdCons : public ObjQueueBase<PtrMultiProdCons<T, SIZE * 2, UNKNOWN>, T, SIZE, UNKNOWN>
		{};
	};
}


===============================================
File: include/RE/B/BSTMessageQueue.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class BSTFreeList;

	template <class T>
	struct BSTFreeListElem;

	class ScrapHeap;

	template <class T>
	class BSTMessageQueue
	{
	public:
		virtual ~BSTMessageQueue();  // 00

		// add
		virtual bool Push(T* a_obj) = 0;     // 01 - Wait for lock, then push
		virtual bool TryPush(T* a_obj) = 0;  // 02 - Try for lock, return false if taken, else push
		virtual bool Pop(T* a_obj) = 0;      // 03 - Wait for lock, then remove
		virtual bool TryPop(T* a_obj) = 0;   // 04 - Try for lock, return false if taken, else remove
	};
	static_assert(sizeof(BSTMessageQueue<void*>) == 0x8);

	template <class T>
	class BSTCommonMessageQueue : public BSTMessageQueue<T>
	{
	public:
		~BSTCommonMessageQueue() override;  // 00

		// override (BSTMessageQueue<T>)
		bool Push(T* a_obj) override;     // 01
		bool TryPush(T* a_obj) override;  // 02
		bool Pop(T* a_obj) override;      // 03
		bool TryPop(T* a_obj) override;   // 04

	protected:
		// add
		virtual bool PushInternal(T* a_obj);  // 05 - { return false; }
		virtual bool PopInternal(T* a_obj);   // 06 - { return false; }

	public:
		volatile mutable std::uint32_t lock;   // 08
		volatile std::uint32_t         pad0C;  // 0C
	};
	static_assert(sizeof(BSTCommonMessageQueue<void*>) == 0x10);

	template <class T>
	class BSTCommonScrapHeapMessageQueue : public BSTCommonMessageQueue<T>
	{
	public:
		// members
		ScrapHeap*    unk10;  // 10
		std::uint64_t unk18;  // 18
		std::uint64_t unk20;  // 20
	};
	static_assert(sizeof(BSTCommonScrapHeapMessageQueue<void*>) == 0x28);

	template <class T>
	class BSTCommonLLMessageQueue : public BSTCommonMessageQueue<T>
	{
	public:
		~BSTCommonLLMessageQueue() override;  // 00

	protected:
		// override (BSTCommonMessageQueue<T>)
		bool PushInternal(T* a_obj) override;  // 05
		bool PopInternal(T* a_obj) override;   // 06

	public:
		BSTFreeList<T>*      freeList;  // 10
		BSTFreeListElem<T>*  head;      // 18
		BSTFreeListElem<T>** tail;      // 20
	};
	static_assert(sizeof(BSTCommonLLMessageQueue<void*>) == 0x28);

	template <class T, std::size_t SIZE>
	class BSTCommonStaticMessageQueue : public BSTCommonMessageQueue<T>
	{
	public:
		virtual ~BSTCommonStaticMessageQueue();  // 00

	protected:
		// override (BSTCommonMessageQueue<T>)
		bool PushInternal(T* a_obj) override;  // 05
		bool PopInternal(T* a_obj) override;   // 06

	public:
		char          queueBuffer[sizeof(T) * SIZE];  // 10
		std::uint32_t numEntries;                     // ??
		std::uint32_t pushIdx;                        // ??
		std::uint32_t popIdx;                         // ??
	};
}


===============================================
File: include/RE/B/BSTObjectDictionary.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	template <
		class T,
		class Key,
		template <class, class> class MissPolicy,
		template <class, class> class InitializationPolicy>
	class BSTObjectDictionary :
		public MissPolicy<T, Key>,                                                             // 00
		public InitializationPolicy<T, Key>,                                                   // 08
		public BSTSingletonSDM<BSTObjectDictionary<T, Key, MissPolicy, InitializationPolicy>>  // 10
	{
	public:
		std::uint8_t       pad11;              // 11
		std::uint16_t      pad12;              // 12
		std::uint32_t      pad14;              // 14
		BSTHashMap<Key, T> objectDefinitions;  // 18
		mutable BSSpinLock definitionLock;     // 48
	};
	//static_assert(sizeof(BSTObjectDictionary) == 0x50);
}


===============================================
File: include/RE/B/BSTPoint.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class BSTPointDefaultOps
	{
	public:
	};
	static_assert(sizeof(BSTPointDefaultOps<float>) == 0x1);

	template <class T>
	class BSTPoint2Base
	{
	public:
		// members
		T x;  // 00
		T y;  // ??
	};
	static_assert(sizeof(BSTPoint2Base<float>) == 0x8);

	template <class T, class Ops = BSTPointDefaultOps<T>>
	class BSTPoint2 :
		public BSTPoint2Base<T>,  // 00
		public Ops                // ??
	{
	public:
	};
	static_assert(sizeof(BSTPoint2<float>) == 0x8);

	template <class T>
	class BSTPoint3Base
	{
	public:
		// members
		T x;  // 00
		T y;  // ??
		T z;  // ??
	};
	static_assert(sizeof(BSTPoint3Base<float>) == 0xC);

	template <class T, class Ops = BSTPointDefaultOps<T>>
	class BSTPoint3 :
		public BSTPoint3Base<T>,  // 00
		public Ops                // ??
	{
	public:
	};
	static_assert(sizeof(BSTPoint3<float>) == 0xC);
}


===============================================
File: include/RE/B/BSTPointerAndFlags.h
===============================================
#pragma once

namespace RE
{
	// 0x8
	template <class T, std::uintptr_t MASK = 1>
	class BSTPointerAndFlags
	{
	public:
		using value_type = T;
		using element_type = typename T::element_type;

		constexpr BSTPointerAndFlags() noexcept = default;

		BSTPointerAndFlags(const BSTPointerAndFlags& a_rhs) { _storage.ptr = a_rhs.get(); }

		constexpr BSTPointerAndFlags(BSTPointerAndFlags&& a_rhs) noexcept
		{
			_storage.address = a_rhs._storage.address;
			a_rhs._storage.address = 0;
		}

		constexpr BSTPointerAndFlags(std::nullptr_t) noexcept {}

		~BSTPointerAndFlags()
		{
			clear_flags();
			_storage.ptr.~value_type();
			_storage.address = 0;
		}

		BSTPointerAndFlags& operator=(const BSTPointerAndFlags& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				clear_flags();
				_storage.ptr = a_rhs.get();
			}
			return *this;
		}

		BSTPointerAndFlags& operator=(BSTPointerAndFlags&& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				clear_flags();
				a_rhs.clear_flags();
				_storage.address = a_rhs._storage.address;
				a_rhs.storage.address = 0;
			}
			return *this;
		}

		void reset() noexcept
		{
			clear_flags();
			_storage.ptr.reset();
		}

		[[nodiscard]] element_type* get() const noexcept
		{
			auto ptr = _storage.address;
			return reinterpret_cast<element_type*>(ptr & ~FLAG_MASK);
		}

		[[nodiscard]] element_type& operator*() const noexcept
		{
			assert(get() != nullptr);
			return *get();
		}

		[[nodiscard]] element_type* operator->() const noexcept { return get(); }

		[[nodiscard]] explicit operator bool() const noexcept { return get() != nullptr; }

	protected:
		union Storage
		{
			~Storage() noexcept {}

			value_type     ptr;
			std::uintptr_t address{ 0 };
		};

		constexpr void clear_flags() noexcept { _storage.address &= ~FLAG_MASK; }

		static constexpr std::uintptr_t FLAG_MASK = MASK;

		// members
		Storage _storage;  // 0
	};
}


===============================================
File: include/RE/B/BSTSingleton.h
===============================================
#pragma once

namespace RE
{
	//=====================================================
	// BSTSingletonExplicit
	//=====================================================

	template <class T>
	struct BSTSingletonExplicit
	{};

	//=====================================================
	// BSTSingletonImplicit
	//=====================================================

	template <class T>
	struct BSTSingletonImplicit
	{};

	//=====================================================
	// BSTSingletonSDM
	//=====================================================

	template <class>
	struct BSTSingletonSDMBase;

	template <class T>
	struct BSTSingletonSDMOpStaticBuffer
	{};

	template <class T, class Alloc = BSTSingletonSDMOpStaticBuffer<T>>
	struct BSTSDMTraits
	{
		using Type = T;
		using Allocator = Alloc;
	};

	template <class Traits>
	struct BSTSingletonSDMBase :
		public Traits,
		public Traits::Allocator
	{
		using Type = typename Traits::Type;
		using Allocator = typename Traits::Allocator;
	};

	template <class T, template <class> class Singleton = BSTSingletonSDMOpStaticBuffer>
	struct BSTSingletonSDM : public BSTSingletonSDMBase<BSTSDMTraits<T, Singleton<T>>>
	{};
}


===============================================
File: include/RE/B/BSTSmartPointer.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	struct BSTSmartPointerIntrusiveRefCount
	{
		static void Acquire(T* a_ptr)
		{
			a_ptr->IncRef();
		}

		static void Release(T* a_ptr)
		{
			if (a_ptr->DecRef() == 0) {
				delete a_ptr;
			}
		}
	};

	template <class T>
	struct BSTSmartPointerAutoPtr
	{
		constexpr static void Acquire([[maybe_unused]] T* a_ptr)
		{
		}

		static void Release(T* a_ptr)
		{
			delete a_ptr;
		}
	};

	template <class T, template <class> class RefManager = BSTSmartPointerIntrusiveRefCount>
	class BSTSmartPointer
	{
	public:
		using element_type = T;
		using reference_manager = RefManager<T>;

		// 1
		inline constexpr BSTSmartPointer() noexcept :
			_ptr(nullptr)
		{}

		// 2
		inline constexpr BSTSmartPointer(std::nullptr_t) noexcept :
			_ptr(nullptr)
		{}

		// 3
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline explicit BSTSmartPointer(Y* a_rhs) :
			_ptr(a_rhs)
		{
			TryAttach();
		}

		// 9a
		inline BSTSmartPointer(const BSTSmartPointer& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 9b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline BSTSmartPointer(const BSTSmartPointer<Y>& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 10a
		inline BSTSmartPointer(BSTSmartPointer&& a_rhs) noexcept :
			_ptr(std::move(a_rhs._ptr))
		{
			a_rhs._ptr = nullptr;
		}

		// 10b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline BSTSmartPointer(BSTSmartPointer<Y>&& a_rhs) noexcept :
			_ptr(std::move(a_rhs._ptr))
		{
			a_rhs._ptr = nullptr;
		}

		inline ~BSTSmartPointer()
		{
			TryDetach();
		}

		// 1a
		inline BSTSmartPointer& operator=(const BSTSmartPointer& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = a_rhs._ptr;
				TryAttach();
			}
			return *this;
		}

		// 1b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline BSTSmartPointer& operator=(const BSTSmartPointer<Y>& a_rhs)
		{
			TryDetach();
			_ptr = a_rhs._ptr;
			TryAttach();
			return *this;
		}

		// 2a
		inline BSTSmartPointer& operator=(BSTSmartPointer&& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = std::move(a_rhs._ptr);
				a_rhs._ptr = nullptr;
			}
			return *this;
		}

		// 2b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline BSTSmartPointer& operator=(BSTSmartPointer<Y>&& a_rhs)
		{
			TryDetach();
			_ptr = std::move(a_rhs._ptr);
			a_rhs._ptr = nullptr;
			return *this;
		}

		inline void reset()
		{
			TryDetach();
		}

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		inline void reset(Y* a_ptr)
		{
			if (_ptr != a_ptr) {
				TryDetach();
				_ptr = a_ptr;
				TryAttach();
			}
		}

		[[nodiscard]] constexpr element_type* get() const noexcept
		{
			return _ptr;
		}

		[[nodiscard]] explicit constexpr operator bool() const noexcept
		{
			return static_cast<bool>(_ptr);
		}

		[[nodiscard]] constexpr element_type& operator*() const noexcept
		{
			assert(static_cast<bool>(*this));
			return *_ptr;
		}

		[[nodiscard]] constexpr element_type* operator->() const noexcept
		{
			assert(static_cast<bool>(*this));
			return _ptr;
		}

	protected:
		template <class, template <class> class>
		friend class BSTSmartPointer;

		inline void TryAttach()
		{
			if (_ptr) {
				reference_manager::Acquire(_ptr);
			}
		}

		inline void TryDetach()
		{
			if (_ptr) {
				reference_manager::Release(_ptr);
				_ptr = nullptr;
			}
		}

		// members
		element_type* _ptr;  // 0
	};
	static_assert(sizeof(BSTSmartPointer<void*>) == 0x8);

	template <class T, class... Args>
	[[nodiscard]] inline BSTSmartPointer<T> make_smart(Args&&... a_args)
	{
		return BSTSmartPointer<T>{ new T(std::forward<Args>(a_args)...) };
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator==(const BSTSmartPointer<T1>& a_lhs, const BSTSmartPointer<T2>& a_rhs)
	{
		return a_lhs.get() == a_rhs.get();
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator!=(const BSTSmartPointer<T1>& a_lhs, const BSTSmartPointer<T2>& a_rhs)
	{
		return !(a_lhs == a_rhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(const BSTSmartPointer<T>& a_lhs, std::nullptr_t) noexcept
	{
		return !a_lhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(std::nullptr_t, const BSTSmartPointer<T>& a_rhs) noexcept
	{
		return !a_rhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(const BSTSmartPointer<T>& a_lhs, std::nullptr_t) noexcept
	{
		return static_cast<bool>(a_lhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(std::nullptr_t, const BSTSmartPointer<T>& a_rhs) noexcept
	{
		return static_cast<bool>(a_rhs);
	}

	template <class T>
	BSTSmartPointer(T*) -> BSTSmartPointer<T, BSTSmartPointerIntrusiveRefCount>;

	template <class T>
	using BSTAutoPointer = BSTSmartPointer<T, BSTSmartPointerAutoPtr>;
	static_assert(sizeof(BSTAutoPointer<void*>) == 0x8);
}

#define BSSmartPointer(className) \
	class className;              \
	using className##Ptr = RE::BSTSmartPointer<className>;


===============================================
File: include/RE/B/BSTTuple.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	template <class T1, class T2>
	struct BSTTuple
	{
	public:
		using first_type = T1;
		using second_type = T2;

		// 1)
		BSTTuple()  //
			noexcept(std::is_nothrow_default_constructible_v<first_type>&&
					std::is_nothrow_default_constructible_v<second_type>)  //
			requires(std::is_default_constructible_v<first_type>&&
					std::is_default_constructible_v<second_type>) :
			first(),
			second()
		{}

		// 2)
		explicit(!std::is_convertible_v<const first_type&, first_type> ||
				 !std::is_convertible_v<const second_type&, second_type>)     //
			BSTTuple(const first_type& a_first, const second_type& a_second)  //
			noexcept(std::is_nothrow_copy_constructible_v<first_type>&&
					std::is_nothrow_copy_constructible_v<second_type>)  //
			requires(std::is_copy_constructible_v<first_type>&&
					std::is_copy_constructible_v<second_type>) :
			first(a_first),
			second(a_second)
		{}

		// 3)
		template <class U1, class U2>
		explicit(!std::is_convertible_v<U1&&, first_type> ||
				 !std::is_convertible_v<U2&&, second_type>)  //
			BSTTuple(U1&& a_first, U2&& a_second)            //
			noexcept(std::is_nothrow_constructible_v<first_type, U1&&>&&
					std::is_nothrow_constructible_v<second_type, U2&&>)  //
			requires(std::is_constructible_v<first_type, U1&&>&&
					std::is_constructible_v<second_type, U2&&>) :
			first(std::forward<U1>(a_first)),
			second(std::forward<U2>(a_second))
		{}

		// 4)
		template <class U1, class U2>
		explicit(!std::is_convertible_v<const U1&, first_type> ||
				 !std::is_convertible_v<const U2&, second_type>)  //
			BSTTuple(const BSTTuple<U1, U2>& a_rhs)               //
			noexcept(std::is_nothrow_constructible_v<first_type, const U1&>&&
					std::is_nothrow_constructible_v<second_type, const U2&>)  //
			requires(std::is_constructible_v<first_type, const U1&>&&
					std::is_constructible_v<second_type, const U2&>) :
			first(a_rhs.first),
			second(a_rhs.second)
		{}

		// 5)
		template <class U1, class U2>
		explicit(!std::is_convertible_v<U1&&, first_type> ||
				 !std::is_convertible_v<U2&&, second_type>)  //
			BSTTuple(BSTTuple<U1, U2>&& a_rhs)               //
			noexcept(std::is_nothrow_constructible_v<first_type, U1&&>&&
					std::is_nothrow_constructible_v<second_type, U2&&>)  //
			requires(std::is_constructible_v<first_type, U1&&>&&
					std::is_constructible_v<second_type, U2&&>) :
			first(std::forward<U1>(a_rhs.first)),
			second(std::forward<U2>(a_rhs.second))
		{}

		// 6)
		template <
			class... Args1,
			class... Args2>
		BSTTuple(std::piecewise_construct_t, std::tuple<Args1...> a_firstArgs, std::tuple<Args2...> a_secondArgs) :
			BSTTuple(a_firstArgs, a_secondArgs, std::index_sequence_for<Args1...>(), std::index_sequence_for<Args2...>())
		{}

	private:
		// 6) impl
		template <
			class Tuple1,
			class Tuple2,
			std::size_t... I1,
			std::size_t... I2>
		BSTTuple(Tuple1& a_firstArgs, Tuple2& a_secondArgs, std::index_sequence<I1...>, std::index_sequence<I2...>) :
			first(std::get<I1>(std::move(a_firstArgs))...),
			second(std::get<I2>(std::move(a_secondArgs))...)
		{}

	public:
		// 7)
		BSTTuple(const BSTTuple&) = default;

		// 8)
		BSTTuple(BSTTuple&&) = default;

		~BSTTuple() = default;

		// 1)
		BSTTuple& operator=(const BSTTuple& a_rhs)  //
			noexcept(std::is_nothrow_copy_assignable_v<first_type>&&
					std::is_nothrow_copy_assignable_v<second_type>)  //
			requires(std::is_copy_assignable_v<first_type>&&
					std::is_copy_assignable_v<second_type>)
		{
			if (this != std::addressof(a_rhs)) {
				first = a_rhs.first;
				second = a_rhs.second;
			}
			return *this;
		}

		// 2)
		template <class U1, class U2>
		BSTTuple& operator=(const BSTTuple<U1, U2>& a_rhs)  //
			noexcept(std::is_nothrow_assignable_v<first_type&, const U1&>&&
					std::is_nothrow_assignable_v<second_type&, const U2&>)  //
			requires(std::is_assignable_v<first_type&, const U1&>&&
					std::is_assignable_v<second_type&, const U2&>)
		{
			first = a_rhs.first;
			second = a_rhs.second;
			return *this;
		}

		// 3)
		BSTTuple& operator=(BSTTuple&& a_rhs)  //
			noexcept(std::is_nothrow_move_assignable_v<first_type>&&
					std::is_nothrow_move_assignable_v<second_type>)  //
			requires(std::is_move_assignable_v<first_type>&&
					std::is_move_assignable_v<second_type>)
		{
			if (this != std::addressof(a_rhs)) {
				first = std::move(a_rhs.first);
				second = std::move(a_rhs.second);
			}
			return *this;
		}

		// 4)
		template <class U1, class U2>
		BSTTuple& operator=(BSTTuple<U1, U2>&& a_rhs)  //
			noexcept(std::is_nothrow_assignable_v<first_type&, U1>&&
					std::is_nothrow_assignable_v<second_type&, U2>)  //
			requires(std::is_assignable_v<first_type&, U1>&&
					std::is_assignable_v<second_type&, U2>)
		{
			first = std::move(a_rhs.first);
			second = std::move(a_rhs.second);
			return *this;
		}

		TES_HEAP_REDEFINE_NEW();

		void swap(BSTTuple& a_rhs)  //
			noexcept(std::is_nothrow_swappable_v<first_type>&&
					std::is_nothrow_swappable_v<second_type>)
		{
			using std::swap;
			if (this != std::addressof(a_rhs)) {
				swap(first, a_rhs.first);
				swap(second, a_rhs.second);
			}
		}

		// members
		first_type  first;   // 00
		second_type second;  // ??
	};

	template <class T1, class T2>
	[[nodiscard]] auto make_pair(T1&& a_first, T2&& a_second)
	{
		using result_t =
			BSTTuple<
				std::decay_t<T1>,
				std::decay_t<T2>>;
		return result_t(std::forward<T1>(a_first), std::forward<T2>(a_second));
	}

	template <class T1, class T2>
	[[nodiscard]] auto make_tuple(T1&& a_first, T2&& a_second)
	{
		using result_t =
			BSTTuple<
				std::decay_t<T1>,
				std::decay_t<T2>>;
		return result_t(std::forward<T1>(a_first), std::forward<T2>(a_second));
	}

	template <class T1, class T2>
	[[nodiscard]] bool operator==(const BSTTuple<T1, T2>& a_lhs, const BSTTuple<T1, T2>& a_rhs)
	{
		return a_lhs.first == a_rhs.first && a_lhs.second == a_rhs.second;
	}

	template <class T1, class T2>
	[[nodiscard]] bool operator<(const BSTTuple<T1, T2>& a_lhs, const BSTTuple<T1, T2>& a_rhs)
	{
		return a_lhs.first < a_rhs.first   ? true :
		       a_rhs.first < a_lhs.first   ? false :
		       a_lhs.second < a_rhs.second ? true :
                                             false;
	}

	template <class T1, class T2>
	void swap(BSTTuple<T1, T2>& a_lhs, BSTTuple<T1, T2>& a_rhs)  //
		noexcept(noexcept(a_lhs.swap(a_rhs)))                    //
		requires(std::is_swappable_v<T1>&&
				std::is_swappable_v<T2>)
	{
		a_lhs.swap(a_rhs);
	}

	template <class T1, class T2>
	BSTTuple(T1, T2) -> BSTTuple<T1, T2>;
}


===============================================
File: include/RE/B/BSTempEffect.h
===============================================
#pragma once

#include "RE/N/NiObject.h"

namespace RE
{
	class BGSLoadGameBuffer;
	class BGSSaveGameBuffer;
	class NiAVObject;
	class TESObjectCELL;

	enum class TEMP_EFFECT_TYPE
	{
		kTerrain = 0,
		kWeaponBlood = 1,
		kDecal = 2,
		kGeometryDecal = 3,
		kParticle = 4,
		kDebris = 5,
		kSPG = 6,
		kDefault = 7,
		kRefDefault = 8,
		kRefModel = 9,
		kRefShader = 10,
		kMagicSummon = 11
	};

	class BSTempEffect : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTempEffect;
		inline static auto           Ni_RTTI = NiRTTI_BSTempEffect;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kDefault;

		~BSTempEffect() override;  // 00

		// override (NiObject)
		const NiRTTI*                 GetRTTI() const override;                   // 02
		NiNode*                       AsNode() override;                          // 03 - { return 0; }
		NiSwitchNode*                 AsSwitchNode() override;                    // 04 - { return 0; }
		BSFadeNode*                   AsFadeNode() override;                      // 05 - { return 0; }
		BSMultiBoundNode*             AsMultiBoundNode() override;                // 06 - { return 0; }
		BSGeometry*                   AsGeometry() override;                      // 07 - { return 0; }
		NiTriStrips*                  AsTriStrips() override;                     // 08 - { return 0; }
		BSTriShape*                   AsTriShape() override;                      // 09 - { return 0; }
		BSSegmentedTriShape*          AsSegmentedTriShape() override;             // 0A - { return 0; }
		BSSubIndexTriShape*           AsSubIndexTriShape() override;              // 0B - { return 0; }
		BSDynamicTriShape*            AsDynamicTriShape() override;               // 0C - { return 0; }
		NiGeometry*                   AsNiGeometry() override;                    // 0D - { return 0; }
		NiTriBasedGeom*               AsNiTriBasedGeom() override;                // 0E - { return 0; }
		NiTriShape*                   AsNiTriShape() override;                    // 0F - { return 0; }
		NiParticles*                  AsParticlesGeom() override;                 // 10 - { return 0; }
		BSLines*                      AsLinesGeom() override;                     // 11 - { return 0; }
		bhkNiCollisionObject*         AsBhkNiCollisionObject() override;          // 12 - { return 0; }
		bhkBlendCollisionObject*      AsBhkBlendCollisionObject() override;       // 13 - { return 0; }
		bhkAttachmentCollisionObject* AsBhkAttachmentCollisionObject() override;  // 14 - { return 0; }
		bhkRigidBody*                 AsBhkRigidBody() override;                  // 15 - { return 0; }
		bhkLimitedHingeConstraint*    AsBhkLimitedHingeConstraint() override;     // 16 - { return 0; }

		// add
		virtual void                           Initialize();                                     // 25 - { initialized = true; }
		virtual void                           Attach();                                         // 26 - { return; }
		virtual void                           Detach();                                         // 27 - { return; }
		virtual bool                           Update(float a_arg1);                             // 28
		[[nodiscard]] virtual NiAVObject*      Get3D() const;                                    // 29 - { return 0; }
		[[nodiscard]] virtual bool             GetManagerHandlesSaveLoad() const;                // 2A - { return true; }
		[[nodiscard]] virtual bool             GetClearWhenCellIsUnloaded() const;               // 2B - { return true; }
		[[nodiscard]] virtual TEMP_EFFECT_TYPE GetType() const;                                  // 2C - { return 7; }
		virtual void                           SaveGame(BGSSaveGameBuffer* a_buf);               // 2D
		virtual void                           LoadGame(BGSLoadGameBuffer* a_buf);               // 2E
		virtual void                           FinishLoadGame(BGSLoadGameBuffer* a_buf);         // 2F - { return; }
		[[nodiscard]] virtual bool             IsInterfaceEffect() const;                        // 30 - { return false; }
		virtual void                           SetInterfaceEffect(bool a_set);                   // 31 - { return; }
		[[nodiscard]] virtual bool             GetStackable() const;                             // 32 - { return false; }
		virtual bool                           GetStackableMatch(BSTempEffect* a_effect) const;  // 33 - { return false; }
		virtual void                           Push();                                           // 34 - { return; }
		virtual void                           Pop();                                            // 35 - { return; }

		template <
			class T,
			class = std::enable_if_t<
				std::negation_v<
					std::disjunction<
						std::is_pointer<T>,
						std::is_reference<T>,
						std::is_const<T>,
						std::is_volatile<T>>>>>
		[[nodiscard]] T* As() noexcept;

		template <
			class T,
			class = std::enable_if_t<
				std::negation_v<
					std::disjunction<
						std::is_pointer<T>,
						std::is_reference<T>,
						std::is_const<T>,
						std::is_volatile<T>>>>>
		[[nodiscard]] const T* As() const noexcept;

		// members
		float          lifetime;     // 10
		std::uint32_t  pad14;        // 14
		TESObjectCELL* cell;         // 18
		float          age;          // 20
		bool           initialized;  // 24
		std::uint8_t   pad25;        // 25
		std::uint16_t  pad26;        // 26
		std::uint32_t  effectID;     // 28
		std::uint32_t  pad2C;        // 2C
	};
	static_assert(sizeof(BSTempEffect) == 0x30);
}


===============================================
File: include/RE/B/BSTempEffectDebris.h
===============================================
#pragma once

#include "RE/B/BSTempEffect.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiAVObject;

	class BSTempEffectDebris : public BSTempEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTempEffectDebris;
		inline static auto           Ni_RTTI = NiRTTI_BSTempEffectDebris;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kDebris;

		~BSTempEffectDebris() override;  // 00

		// override (BSTempEffect)
		const NiRTTI*    GetRTTI() const override;       // 02
		bool             Update(float a_arg1) override;  // 28
		NiAVObject*      Get3D() const override;         // 29
		TEMP_EFFECT_TYPE GetType() const override;       // 2C - { return kDebris; }

		// members;
		NiPointer<NiAVObject> debris3D;        // 030
		const char*           debrisFileName;  // 038
		bool                  unk40;           // 040
		std::uint8_t          unk41;           // 041
		std::uint8_t          pad42;           // 042
		std::uint8_t          pad43;           // 043
		std::uint32_t         pad44;           // 044
	};
	static_assert(sizeof(BSTempEffectDebris) == 0x48);
}


===============================================
File: include/RE/B/BSTempEffectGeometryDecal.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BSTempEffect.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSGeometry;
	class NiAVObject;
	class BGSTextureSet;
	class QueuedTempEffect;

	class BSTempEffectGeometryDecal : public BSTempEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTempEffectGeometryDecal;
		inline static auto           Ni_RTTI = NiRTTI_BSTempEffectGeometryDecal;
		inline static constexpr auto VTABLE = VTABLE_BSTempEffectGeometryDecal;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kGeometryDecal;

		~BSTempEffectGeometryDecal() override;  // 00

		// override (BSTempEffect)
		const NiRTTI*                  GetRTTI() const override;       // 02
		void                           Initialize() override;          // 25
		void                           Attach() override;              // 26
		bool                           Update(float a_arg1) override;  // 28
		NiAVObject*                    Get3D() const override;         // 29
		[[nodiscard]] TEMP_EFFECT_TYPE GetType() const override;       // 2C - { return kGeometryDecal; }

		// members
		NiPointer<BSGeometry>             decal;                   // 30
		NiPointer<BSGeometry>             attachedGeometry;        // 38
		NiPointer<NiNode>                 attachedGeometryParent;  // 40
		NiPointer<NiNode>                 decalNode;               // 48
		BSTSmartPointer<QueuedTempEffect> queuedDecal;             // 50
		BGSTextureSet*                    texSet;                  // 58
		BGSTextureSet*                    texSet2;                 // 60
		NiMatrix3                         rotation;                // 68
		NiPoint3                          origin;                  // 8C
		NiPoint3                          direction;               // 98
		float                             width;                   // A4
		std::uint32_t                     unkA8;                   // A8
		std::uint32_t                     flags;                   // AC
		bool                              unkB0;                   // B0
	};
	static_assert(sizeof(BSTempEffectGeometryDecal) == 0xB8);
}


===============================================
File: include/RE/B/BSTempEffectParticle.h
===============================================
#pragma once

#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BSTempEffect.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTransform.h"

namespace RE
{
	class BGSImpactData;
	class BGSParticleObjectCloneTask;
	class NiAVObject;
	class NiNode;

	class BSTempEffectParticle : public BSTempEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTempEffectParticle;
		inline static auto           Ni_RTTI = NiRTTI_BSTempEffectParticle;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kParticle;

		~BSTempEffectParticle() override;  // 00

		// override (BSTempEffect)
		const NiRTTI*                  GetRTTI() const override;       // 02
		void                           Detach() override;              // 27
		bool                           Update(float a_arg1) override;  // 28
		[[nodiscard]] TEMP_EFFECT_TYPE GetType() const override;       // 2C - { return kParticle; }

		static BSTempEffectParticle* Spawn(TESObjectCELL* a_cell, float a_lifetime, const char* a_modelName, const NiPoint3& a_rotation, const NiPoint3& a_position, float a_scale, std::uint32_t a_flags, NiAVObject* a_target)
		{
			using func_t = BSTempEffectParticle* (*)(TESObjectCELL*, float, const char*, const NiPoint3&, const NiPoint3&, float, std::uint32_t, NiAVObject*);
			REL::Relocation<func_t> func{ RELOCATION_ID(29218, 30071) };
			return func(a_cell, a_lifetime, a_modelName, a_rotation, a_position, a_scale, a_flags, a_target);
		}
		static BSTempEffectParticle* Spawn(TESObjectCELL* a_cell, float a_lifetime, const char* a_modelName, const NiMatrix3& a_normal, const NiPoint3& a_position, float a_scale, std::uint32_t a_flags, NiAVObject* a_target)
		{
			using func_t = BSTempEffectParticle* (*)(TESObjectCELL*, float, const char*, const NiMatrix3&, const NiPoint3&, float, std::uint32_t, NiAVObject*);
			REL::Relocation<func_t> func{ RELOCATION_ID(29219, 30072) };
			return func(a_cell, a_lifetime, a_modelName, a_normal, a_position, a_scale, a_flags, a_target);
		}

		// members
		NiPointer<NiAVObject>                       particleObject;           // 30
		BSTSmartPointer<BGSParticleObjectCloneTask> cloneTask;                // 38
		const char*                                 modelName;                // 40
		NiPointer<NiNode>                           dynamicCellNode;          // 48
		NiTransform                                 particleEffectTransform;  // 50
		std::uint32_t                               flags;                    // 84
		NiPointer<NiAVObject>                       spawnNode;                // 88
		NiTransform                                 spawnNodeTransform;       // 90
		std::uint32_t                               padC4;                    // C4
		BGSImpactData*                              impactData;               // C8
		BSSoundHandle                               sound1;                   // D0
		BSSoundHandle                               sound2;                   // DC
		std::uint8_t                                unkE8;                    // E8
		std::uint8_t                                padE9;                    // E9
		std::uint16_t                               unkEA;                    // EA
		std::uint32_t                               unkEC;                    // EC
	};
	static_assert(sizeof(BSTempEffectParticle) == 0xF0);
};


===============================================
File: include/RE/B/BSTempEffectSPG.h
===============================================
#pragma once

#include "RE/B/BSTempEffect.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSShaderParticleGeometryData;
	class NiAVObject;

	class BSTempEffectSPG : public BSTempEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTempEffectSPG;
		inline static auto           Ni_RTTI = NiRTTI_BSTempEffectSPG;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kSPG;

		~BSTempEffectSPG() override;  // 00

		// override (BSTempEffect)
		const NiRTTI*    GetRTTI() const override;                           // 02
		void             Detach() override;                                  // 27
		bool             Update(float a_arg1) override;                      // 28
		TEMP_EFFECT_TYPE GetType() const override;                           // 2C - { return kSPG; }
		void             SaveGame(BGSSaveGameBuffer* a_buf) override;        // 2D
		void             LoadGame(BGSLoadGameBuffer* a_buf) override;        // 2E
		void             FinishLoadGame(BGSLoadGameBuffer* a_buf) override;  // 2F

		// members;
		BGSShaderParticleGeometryData* data;   // 30
		NiPointer<NiAVObject>          spg3D;  // 38
		float                          unk40;  // 40
		float                          unk44;  // 40
		bool                           unk48;  // 45
		std::uint8_t                   pad49;  // 49
		std::uint16_t                  pad4A;  // 4A
		std::uint32_t                  pad4C;  // 4C
	};
	static_assert(sizeof(BSTempEffectSPG) == 0x50);
}


===============================================
File: include/RE/B/BSTempEffectSimpleDecal.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTempEffect.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiFrustumPlanes.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSDecalNode;
	class BGSTextureSet;
	class BSTriShape;
	class NiAVObject;

	class BSTempEffectSimpleDecal : public BSTempEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTempEffectSimpleDecal;
		inline static auto           Ni_RTTI = NiRTTI_BSTempEffectSimpleDecal;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kDecal;

		~BSTempEffectSimpleDecal() override;  // 00

		// override (BSTempEffect)
		const NiRTTI*             GetRTTI() const override;       // 02
		void                      Initialize() override;          // 25
		void                      Attach() override;              // 26
		bool                      Update(float a_arg1) override;  // 28
		[[nodiscard]] NiAVObject* Get3D() const override;         // 29

		// members
		std::uint8_t            unk30;            // 030
		std::uint8_t            unk31;            // 031
		bool                    unk32;            // 032
		std::uint16_t           unk36;            // 036
		std::uint64_t           unk38;            // 038
		std::uint32_t           unk40;            // 040
		std::uint32_t           unk44;            // 044
		NiPointer<BSGeometry>   effect3D;         // 048
		std::uint32_t           unk50;            // 050
		bool                    permanent;        // 054
		std::uint8_t            unk55;            // 055
		bool                    unk56;            // 056
		std::uint8_t            unk57;            // 057
		BGSTextureSet*          textureSet;       // 058
		BGSTextureSet*          textureSet2;      // 060
		NiPoint3                origin1;          // 068
		NiPoint3                direction1;       // 074
		NiPoint3                origin2;          // 080 - copy?
		NiPoint3                direction2;       // 08C - copy?
		NiFrustumPlanes         planes;           // 098
		std::uint64_t           unk108;           // 108
		std::uint64_t           unk110;           // 110
		std::uint64_t           unk118;           // 118
		std::uint64_t           unk120;           // 120
		std::uint64_t           unk128;           // 128
		std::uint64_t           unk130;           // 130
		std::uint64_t           unk138;           // 138
		std::uint64_t           unk140;           // 140
		std::uint64_t           unk148;           // 148
		std::uint64_t           unk150;           // 150
		BSTArray<void*>         unk158;           // 158 - triangle data?
		NiPointer<BGSDecalNode> decalNode;        // 170
		NiPointer<BSTriShape>   avShape;          // 178
		float                   unk180;           // 180
		NiMatrix3               emitterRotation;  // 184
		std::uint32_t           unk1A8;           // 1A8
		float                   width;            // 1AC
		float                   height;           // 1B0
		float                   depth;            // 1B4;
		std::uint8_t            subTextureIndex;  // 1B8
		bool                    parallaxOcc;      // 1B9
		std::uint8_t            unk1BA;           // 1BA
		std::uint8_t            unk1BB;           // 1BB
		float                   parallaxScale;    // 1BC
		std::uint8_t            parallaxPasses;   // 1C0
		bool                    alphaBlending;    // 1C1
		bool                    enableBlending;   // 1C2
		std::uint8_t            unk1C3;           // 1C3
		float                   shininess;        // 1C4
		NiColor                 color;            // 1C8
		bool                    unk1D4;           // 1D4
		bool                    twoSided;         // 1D5
		bool                    unk1D6;           // 1D6
		std::uint8_t            unk1D7;           // 1D7
		std::uint32_t           unk1D8;           // 1D8
		std::uint32_t           unk1DC;           // 1DC
	};
	static_assert(sizeof(BSTempEffectSimpleDecal) == 0x1E0);
};


===============================================
File: include/RE/B/BSTempEffectWeaponBlood.h
===============================================
#pragma once

#include "RE/B/BSTempEffect.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiAVObject;

	class BSTempEffectWeaponBlood : public BSTempEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTempEffectWeaponBlood;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kWeaponBlood;

		~BSTempEffectWeaponBlood() override;  // 00

		bool                           Update(float a_arg1) override;  // 28
		[[nodiscard]] TEMP_EFFECT_TYPE GetType() const override;       // 2C - { return 1; }

		static void ClearEffectForWeapon(NiAVObject* a_weapon3D)
		{
			using func_t = decltype(&ClearEffectForWeapon);
			REL::Relocation<func_t> func{ RELOCATION_ID(29303, 30154) };
			return func(a_weapon3D);
		}

		// members;
		NiPointer<NiAVObject> weapon3D;        // 030
		float                 alphaThreshold;  // 038
	};
	static_assert(sizeof(BSTempEffectWeaponBlood) == 0x40);
}


===============================================
File: include/RE/B/BSTerrainEffect.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTempEffect.h"
#include "RE/N/NiQuaternion.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class bhkWorld;
	class NiAVObject;
	struct PositionPlayerEvent;

	class BSTerrainEffect :
		public BSTempEffect,                      // 00
		public BSTEventSink<PositionPlayerEvent>  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTerrainEffect;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kTerrain;

		~BSTerrainEffect() override;  // 00

		// override (BSTempEffect)
		bool                           Update(float a_arg1) override;                // 28
		[[nodiscard]] bool             GetManagerHandlesSaveLoad() const override;   // 2A
		[[nodiscard]] TEMP_EFFECT_TYPE GetType() const override;                     // 2C - { return 0; }
		void                           SaveGame(BGSSaveGameBuffer* a_buf) override;  // 2D
		void                           LoadGame(BGSLoadGameBuffer* a_buf) override;  // 2E

		// add
		virtual bool SetupTerrainEffect(const char* a_modelName, ObjectRefHandle& a_handle, std::uint32_t a_collisionFilter);

		// override (BSTEventSink<PositionPlayerEvent>)
		BSEventNotifyControl ProcessEvent(const PositionPlayerEvent* a_event, BSTEventSource<PositionPlayerEvent>* a_eventSource) override;  // 01 - { return BSEventNotifyControl::kContinue; }

		// members;
		NiQuaternion          orientation;      // 38
		NiPoint3              location;         // 48
		std::uint32_t         unk54;            // 54
		BSTArray<void*>       unk58;            // 58
		BSTArray<void*>       unk70;            // 70
		NiPointer<NiAVObject> effectModel;      // 88
		NiPoint3              unk90;            // 90
		ObjectRefHandle       unk9C;            // 9C
		NiPointer<bhkWorld>   physicsWorld;     // A0
		std::uint32_t         collisionFilter;  // A8
		std::uint32_t         unkAC;            // AC
		NiPointer<NiAVObject> followNode;       // B0
	};
	static_assert(sizeof(BSTerrainEffect) == 0xB8);
}


===============================================
File: include/RE/B/BSTextureSet.h
===============================================
#pragma once

#include "RE/N/NiObject.h"
#include "RE/N/NiSourceTexture.h"

namespace RE
{
	class BSTextureSet : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTextureSet;
		inline static auto           Ni_RTTI = NiRTTI_BSTextureSet;

		struct Textures
		{
			enum Texture : std::uint32_t
			{
				kDiffuse = 0,
				kNormal,
				kGloss = kNormal,
				kEnvironmentMask,
				kSubsurfaceTint = kEnvironmentMask,
				kGlowMap,
				kDetailMap = kGlowMap,
				kHeight,
				kEnvironment,
				kMultilayer,
				kBacklightMask,
				kSpecular = kBacklightMask,
				kUnused08,
				kUsedTotal = kUnused08,

				kTotal
			};
		};
		using Texture = Textures::Texture;

		~BSTextureSet() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C

		// add
		virtual const char* GetTexturePath(Texture a_texture) = 0;                             // 25
		virtual void        SetTexture(Texture a_texture, NiSourceTexture* a_srcTexture) = 0;  // 26
		virtual void        SetTexturePath(Texture a_texture, const char* a_path) = 0;         // 27
	};
	static_assert(sizeof(BSTextureSet) == 0x10);
}


===============================================
File: include/RE/B/BSThread.h
===============================================
#pragma once

namespace RE
{
	class BSThread
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSThread;

		virtual ~BSThread();  // 00

		// add
		virtual void Unk_01(void);  // 01 - { return 0; }
		virtual void Unk_02(void);  // 02 - { return; }

		// members
		WinAPI::CRITICAL_SECTION lock;           // 08
		void*                    thread;         // 30
		void*                    ownerThread;    // 38
		std::uint32_t            threadID;       // 40
		std::uint32_t            ownerThreadID;  // 44
		bool                     initialized;    // 48
		std::uint8_t             pad49;          // 49
		std::uint16_t            pad4A;          // 4A
		std::uint32_t            pad4C;          // 4C
	};
	static_assert(sizeof(BSThread) == 0x50);
}


===============================================
File: include/RE/B/BSThreadEvent.h
===============================================
#pragma once

namespace RE
{
	struct BSThreadEvent
	{
		static void InitSDM()
		{
			using func_t = decltype(&BSThreadEvent::InitSDM);
			REL::Relocation<func_t> func{ RELOCATION_ID(67151, 68449) };
			return func();
		}
	};
}


===============================================
File: include/RE/B/BSTimer.h
===============================================
#pragma once

namespace RE
{
	class BSTimer
	{
	public:
		static float& GetCurrentGlobalTimeMult()
		{
			REL::Relocation<float*> value{ RELOCATION_ID(511883, 388443) };
			return *value;
		}

		// members
		std::uint64_t unk00;                          // 00
		std::uint32_t lastPerformanceCount;           // 08
		float         clamp;                          // 10
		float         clampRemainder;                 // 14
		float         delta;                          // 18
		float         realTimeDelta;                  // 1C
		std::uint32_t unk20;                          // 20
		std::uint32_t unk24;                          // 24
		float         unk28;                          // 28
		std::uint32_t unk2C;                          // 2C
		std::uint32_t unk30;                          // 30
		std::uint32_t unk34;                          // 34
		std::uint8_t  unk38;                          // 38
		std::uint8_t  unk39;                          // 39
		bool          useGlobalTimeMultiplierTarget;  // 3A
		std::uint8_t  pad3B;                          // 3B
		std::uint32_t pad3C;                          // 3C
	};
	static_assert(sizeof(BSTimer) == 0x40);
}


===============================================
File: include/RE/B/BSTrackedControllerDevice.h
===============================================
#pragma once

#include "RE/B/BSIInputDevice.h"
#include "RE/B/BSInputDevice.h"

namespace RE
{
	class BSTrackedControllerDevice : public BSInputDevice
	{
	public:
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		inline static constexpr auto RTTI = RTTI_BSTrackedControllerDevice;
#endif

		~BSTrackedControllerDevice() override;

		// override BSIInputDevice
		bool               GetKeyMapping(std::uint32_t a_key, BSFixedString& a_mapping) override;  // 04
		std::uint32_t      GetMappingKey(BSFixedString a_mapping) override;                        // 05
		bool               GetMappedKeycode(std::uint32_t a_key, std::uint32_t& outKeyCode) override;  // 06
		[[nodiscard]] bool IsEnabled() const override;                                             // 07
	};
	static_assert(sizeof(BSTrackedControllerDevice) == 0x70);
}


===============================================
File: include/RE/B/BSTreeManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiPoint2.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSLeafAnimNode;
	class BSTreeNode;
	class NiCamera;

	class BSTreeManager : public BSTSingletonSDM<BSTreeManager>
	{
	public:
		class IQueryCullingCamera
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSTreeManager__IQueryCullingCamera;

			virtual ~IQueryCullingCamera();  // 00

			// add
			virtual NiCamera* GetCamera() = 0;  // 01
		};
		static_assert(sizeof(IQueryCullingCamera) == 0x8);

		static BSTreeManager* GetSingleton()
		{
			REL::Relocation<BSTreeManager**> singleton{ RELOCATION_ID(514181, 400330) };
			return *singleton;
		}

		// members
		bool                                enableTrees;       // 01
		bool                                enableTreeAnims;   // 02
		bool                                forceFullDetail;   // 03
		std::uint32_t                       pad04;             // 04
		IQueryCullingCamera*                cullingCamera;     // 08
		mutable BSSpinLock                  treeLock;          // 10
		mutable BSSpinLock                  branchLock;        // 18
		BSTArray<NiPointer<BSTreeNode>>     loadedTrees;       // 20
		BSTArray<BSTreeNode*>               skinnedTrees;      // 38
		BSTArray<NiPointer<BSLeafAnimNode>> branches;          // 50
		std::uint32_t                       unk68;             // 68
		std::uint32_t                       unk6C;             // 6C
		NiPoint2                            windDirection;     // 70
		float                               windMagnitude;     // 78
		float                               treeUpdateTimer;   // 7C
		float                               midLODSwitchDist;  // 80
		std::uint32_t                       pad84;             // 84
	};
	static_assert(sizeof(BSTreeManager) == 0x88);
}


===============================================
File: include/RE/B/BSTriShape.h
===============================================
#pragma once

#include "RE/B/BSGeometry.h"

namespace RE
{
	class BSTriShape : public BSGeometry
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSTriShape;
		inline static auto           Ni_RTTI = NiRTTI_BSTriShape;

		struct TRISHAPE_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT             \
	std::uint16_t triangleCount; /* 0 */ \
	std::uint16_t vertexCount;   /* 2 */ \
	std::uint32_t pad15C;        /* 3 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(TRISHAPE_RUNTIME_DATA) == 0x8);

		~BSTriShape() override;  // 00

		// override (BSGeometry)
		const NiRTTI* GetRTTI() const override;                           // 02
		BSTriShape*   AsTriShape() override;                              // 09
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { BSGeometry::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return BSGeometry::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C - { return false; }

		[[nodiscard]] inline TRISHAPE_RUNTIME_DATA& GetTrishapeRuntimeData() noexcept
		{
			return REL::RelocateMember<TRISHAPE_RUNTIME_DATA>(this, 0x158, 0x1A0);
		}

		[[nodiscard]] inline const TRISHAPE_RUNTIME_DATA& GetTrishapeRuntimeData() const noexcept
		{
			return REL::RelocateMember<TRISHAPE_RUNTIME_DATA>(this, 0x158, 0x1A0);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 158, 1A0
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSTriShape) == 0x160);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSTriShape) == 0x1A8);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSUIMessageData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSString.h"
#include "RE/I/IUIMessageData.h"

namespace RE
{
	class BSUIMessageData : public IUIMessageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSUIMessageData;

		union Data
		{
			bool          b;
			std::uint32_t u;
			float         f;
			void*         p;
		};
		static_assert(sizeof(Data) == 0x8);

		~BSUIMessageData() override;  // 00

		// members
		BSString*     str;       // 10
		BSFixedString fixedStr;  // 18
		Data          data;      // 20
	};
	static_assert(sizeof(BSUIMessageData) == 0x28);
}


===============================================
File: include/RE/B/BSUIScaleformData.h
===============================================
#pragma once

#include "RE/I/IUIMessageData.h"

namespace RE
{
	class GFxEvent;

	class BSUIScaleformData : public IUIMessageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSUIScaleformData;

		~BSUIScaleformData() override;  // 00

		// members
		GFxEvent* scaleformEvent;  // 10
	};
	static_assert(sizeof(BSUIScaleformData) == 0x18);
}


===============================================
File: include/RE/B/BSVRInterface.h
===============================================
#pragma once

namespace RE
{
	class VRDeviceConnectionChange;
	class VROverlayChange;
	class VRResetHMDHeight;

	class BSVRInterface :
		public BSTEventSource<VROverlayChange>,
		public BSTEventSource<VRDeviceConnectionChange>,
		public BSTEventSource<VRResetHMDHeight>
	{
	public:
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		constexpr static auto RTTI = RTTI_BSVRInterface;
#endif

		virtual ~BSVRInterface();  // 0

		// add
		virtual void* Shutdown(void) = 0;  // 01
		virtual void  Unk_02(void) = 0;    // 02
		virtual void  Unk_03(void) = 0;    // 03
		virtual void  Unk_04(void) = 0;    // 04
		virtual void  Unk_05(void) = 0;    // 05
		virtual void  Unk_06(void) = 0;    // 06
		virtual void  Unk_07(void) = 0;    // 07
		virtual void  Unk_08(void) = 0;    // 08
		virtual void  Unk_09(void) = 0;    // 09
		virtual void  Unk_0A(void) = 0;    // 0A
		virtual void  Unk_0B(void) = 0;    // 0B
		virtual void  Unk_0C(void) = 0;    // 0C -- { return 0; }
		virtual void  Unk_0D(void) = 0;    // 0D
		virtual void  Unk_0E(void) = 0;    // 0E
		virtual void  Unk_0F(void) = 0;    // 0F
		virtual void  Unk_10(void) = 0;    // 10
		virtual void  Unk_11(void);        // 11 -- { return; }
		virtual void  Unk_12(void) = 0;    // 12
		virtual void  Unk_13(void) = 0;    // 13
		virtual void  Unk_14(void) = 0;    // 14
		virtual void  Unk_15(void);        // 15 -- { return; }
		virtual void  Unk_16(void) = 0;    // 16
		virtual void  Unk_17(void) = 0;    // 17
	};
	static_assert(sizeof(BSVRInterface) == 0x110);
}


===============================================
File: include/RE/B/BSValueNode.h
===============================================
#pragma once

#include "RE/B/BSNiNode.h"

namespace RE
{
	class BSMasterParticleSystem;

	class BSValueNode : public BSNiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSValueNode;
		inline static constexpr auto Ni_RTTI = NiRTTI_BSValueNode;

		~BSValueNode() override;  // 00

		// override (BSNiNode)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
#ifndef SKYRIM_CROSS_VR
		void UpdateWorldData(NiUpdateData* a_data) override;              // 30
#endif

		// add
		virtual bool ParseNameForValue();  // 35

		struct VALUE_NODE_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                      \
	std::uint8_t                      flags;            /* 128 */ \
	std::uint32_t                     value;            /* 12C */ \
	NiPointer<BSMasterParticleSystem> associatedObject; /* 130 */
		};

		[[nodiscard]] inline VALUE_NODE_RUNTIME_DATA& GetValueNodeRuntimeData() noexcept
		{
			return REL::RelocateMember<VALUE_NODE_RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const VALUE_NODE_RUNTIME_DATA& GetValueNodeRuntimeData() const noexcept
		{
			return REL::RelocateMember<VALUE_NODE_RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSVirtualKeyboardDevice.h
===============================================
#pragma once

#include "RE/B/BSKeyboardDevice.h"

namespace RE
{
	class BSVirtualKeyboardDevice : public BSKeyboardDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSVirtualKeyboardDevice;
		inline static constexpr auto VTABLE = VTABLE_BSVirtualKeyboardDevice;

		~BSVirtualKeyboardDevice() override;  // 00

		// override (BSKeyboardDevice)
		void Unk_09(void) override;  // 09 - { return; }
		void Unk_0A(void) override;  // 0A - { return; }

		// add
		virtual void Unk_0B(void) = 0;  // 0B
		virtual void Unk_0C(void) = 0;  // 0C
		virtual void Unk_0D(void) = 0;  // 0D

	protected:
		BSVirtualKeyboardDevice();  // The virtual keyboard device constructor does not set the device type to virtualKeyboard, it remains 'kKeyboard'
	};
	static_assert(sizeof(BSVirtualKeyboardDevice) == 0x70);
}


===============================================
File: include/RE/B/BSVisit.h
===============================================
#pragma once

namespace RE
{
	class bhkNiCollisionObject;
	class BSGeometry;
	class NiAVObject;

	namespace BSVisit
	{
		enum class BSVisitControl
		{
			kContinue = 0,
			kStop = 1
		};

		BSVisitControl TraverseScenegraphCollision(NiAVObject* a_object, std::function<BSVisitControl(bhkNiCollisionObject*)> a_func);
		BSVisitControl TraverseScenegraphGeometries(NiAVObject* a_object, std::function<BSVisitControl(BSGeometry*)> a_func);
		BSVisitControl TraverseScenegraphObjects(NiAVObject* a_object, std::function<BSVisitControl(NiAVObject*)> a_func);
	}
}


===============================================
File: include/RE/B/BSVolumetricLightingRenderData.h
===============================================
#pragma once

namespace RE
{
	class BSVolumetricLightingRenderData
	{
	public:
		struct CustomColor
		{
		public:
			// members
			float contribution;  // DNAM
		};
		static_assert(sizeof(CustomColor) == 0x4);

		struct Density
		{
		public:
			// members
			float contribution;  // HNAM
			float size;          // INAM
			float windSpeed;     // JNAM
			float fallingSpeed;  // KNAM
		};
		static_assert(sizeof(Density) == 0x10);

		struct PhaseFunction
		{
		public:
			// members
			float contribution;  // LNAM
			float scattering;    // MNAM
		};
		static_assert(sizeof(PhaseFunction) == 0x8);

		struct SamplingRepartition
		{
		public:
			// members
			float rangeFactor;  // NNAM
		};
		static_assert(sizeof(SamplingRepartition) == 0x4);

		// members
		float               intensity;            // 00 - CNAM
		CustomColor         customColor;          // 04
		float               red;                  // 08 - ENAM
		float               green;                // 0C - FNAM
		float               blue;                 // 10 - GNAM
		Density             density;              // 14
		PhaseFunction       phaseFunction;        // 24
		SamplingRepartition samplingRepartition;  // 2C
	};
	static_assert(sizeof(BSVolumetricLightingRenderData) == 0x30);
}


===============================================
File: include/RE/B/BSWaterShaderMaterial.h
===============================================
#pragma once

#include "RE/B/BSShaderMaterial.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESWaterForm.h"

namespace RE
{
	class NiSourceTexture;

	class BSWaterShaderMaterial : public BSShaderMaterial
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWaterShaderMaterial;

		~BSWaterShaderMaterial() override;  // 00::

		// override (BSShaderMaterial)
		BSShaderMaterial* Create() override;                                // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;  // 02
		bool              DoIsCopy(BSShaderMaterial* a_other) override;     // 03
		std::uint32_t     ComputeCRC32(void) override;                      // 04
		BSShaderMaterial* GetDefault() override;                            // 05
		Type              GetType() const override;                         // 07 - { return Type::kWater; }

		// members
		NiPointer<NiSourceTexture>       staticReflectionTexture;  // 038
		NiPointer<NiSourceTexture>       normalTexture1;           // 040
		NiPointer<NiSourceTexture>       normalTexture2;           // 048
		NiPointer<NiSourceTexture>       normalTexture3;           // 050
		NiPointer<NiSourceTexture>       normalTexture4;           // 058
		NiColor                          shallowWaterColor;        // 060
		float                            sunSparklePower;          // 06C
		NiColorA                         deepWaterColor;           // 070
		NiColorA                         reflectionColor;          // 080
		float                            sunSpecularPower;         // 090
		float                            reflectionAmount;         // 094
		float                            alpha;                    // 098
		float                            refractionMagnitude;      // 09C
		std::uint64_t                    unk0A0;                   // 0A0
		float                            unk0A8;                   // 0A8
		std::uint64_t                    unk0B0;                   // 0B0
		std::uint64_t                    unk0B8;                   // 0B8
		std::uint64_t                    unk0C0;                   // 0C0
		float                            specularPower;            // 0C8
		std::uint64_t                    unk0D0;                   // 0D0
		std::uint64_t                    unk0D8;                   // 0D8
		float                            noiseFalloff;             // 0E0
		float                            reflectionMagnitude;      // 0E4
		float                            sunSparkleMagnitude;      // 0E8
		float                            unk0EC;                   // 0EC
		WaterShaderData::DepthProperties depthProperties;          // 0F0
		std::uint64_t                    unk100;                   // 100
		std::uint64_t                    unk108;                   // 108
		std::uint64_t                    unk110;                   // 100
		std::uint64_t                    unk118;                   // 118
		float                            uvScaleA[3];              // 120
		std::uint32_t                    unk12C;                   // 12C
		float                            amplitudeA[3];            // 130
		float                            displacementDampener;     // 13C
		NiPlane                          plane;                    // 140
		std::uint32_t                    unk150;                   // 150
		float                            flowmapScale;             // 154
		float                            aboveWaterFogDistFar;     // 158
		float                            unk15C;                   // 15C
		float                            unk160;                   // 160
		float                            underwaterFogDistFar;     // 164
		float                            unk168;                   // 168
		float                            underwaterFogAmount;      // 16C
		float                            fresnelAmount;            // 170
		std::uint32_t                    unk174;                   // 174
		std::uint32_t                    unk178;                   // 178
		std::uint8_t                     unk17C;                   // 17C
		std::uint8_t                     unk17D;                   // 17D
		std::uint8_t                     unk17E;                   // 17E
		std::uint8_t                     unk17F;                   // 17F
	};
	static_assert(sizeof(BSWaterShaderMaterial) == 0x180);
}


===============================================
File: include/RE/B/BSWaterShaderProperty.h
===============================================
#pragma once

#include "RE/B/BSShaderProperty.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiPlane.h"

namespace RE
{
	class BSWaterShaderProperty : public BSShaderProperty
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWaterShaderProperty;
		inline static constexpr auto Ni_RTTI = NiRTTI_BSWaterShaderProperty;

		enum class WaterFlag
		{
			kNone = 0,
			kUnderwater = 1 << 5,
			kUseReflections = 1 << 6,
			kUseCubemapReflections = 1 << 14,
			kEnableFlowmap = 1 << 15,
			kBlendNormals = 1 << 16
		};

		~BSWaterShaderProperty() override;  // 00

		// override (BSShaderProperty)
		const NiRTTI*          GetRTTI() const override;                                                                                    // 02
		NiObject*              CreateClone(NiCloningProcess& a_cloning) override;                                                           // 17
		void                   LoadBinary(NiStream& a_stream) override;                                                                     // 18
		void                   LinkObject(NiStream& a_stream) override;                                                                     // 19
		bool                   RegisterStreamables(NiStream& a_stream) override;                                                            // 1A
		void                   SaveBinary(NiStream& a_stream) override;                                                                     // 1B
		bool                   IsEqual(NiObject* a_object) override;                                                                        // 1C - { return false; }
		void                   PostLinkObject(NiStream& a_stream) override;                                                                 // 1E
		RenderPassArray*       GetRenderPasses(BSGeometry* a_geometry, std::uint32_t a_arg2, BSShaderAccumulator* a_accumulator) override;  // 2A
		void                   Unk_2C(void) override;                                                                                       // 2C                                                                                        // 2C
		void                   Unk_2D(void) override;                                                                                       // 2D
		void                   Unk_2F(void) override;                                                                                       // 2F
		std::int32_t           ForEachTexture(ForEachVisitor& a_visitor) override;                                                          // 33
		void                   DoClearRenderPasses() override;                                                                              // 34
		std::int32_t           QShader() override;                                                                                          // 35 - { return 17; }
		BSShaderMaterial::Type GetMaterialType() override;                                                                                  // 3E - { return 3; }

		// members
		stl::enumeration<WaterFlag, std::uint32_t> waterFlags;            // 88
		std::uint32_t                              unk8C;                 // 8C
		std::uint64_t                              unk90;                 // 90
		std::uint64_t                              unk98;                 // 98
		NiPlane                                    plane;                 // A0
		std::uint64_t                              unkB0;                 // B0
		std::uint8_t                               unkB8;                 // B8
		std::uint8_t                               padB9;                 // B9
		std::uint16_t                              padBA;                 // BA
		std::uint16_t                              padBC;                 // BC
		BSRenderPass*                              unkC0;                 // C0
		RenderPassArray                            simpleRenderPassList;  // C8
		std::uint64_t                              unkD0;                 // D0
		BSTArray<void*>                            unkD8;                 // D8
		std::int32_t                               unkF0;                 // F0
		std::uint32_t                              unkF4;                 // F4
		std::uint8_t                               unkF8;                 // F8
		std::uint8_t                               padF9;                 // F9
		std::uint16_t                              padFA;                 // FA
		std::uint16_t                              padFC;                 // FC
	};
	static_assert(sizeof(BSWaterShaderProperty) == 0x100);
}


===============================================
File: include/RE/B/BSWin32GamepadDevice.h
===============================================
#pragma once

#include "RE/B/BSPCGamepadDeviceDelegate.h"

namespace RE
{
	class BSWin32GamepadDevice : public BSPCGamepadDeviceDelegate
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWin32GamepadDevice;
		inline static constexpr auto VTABLE = VTABLE_BSWin32GamepadDevice;

		struct Keys
		{
			enum Key : std::uint32_t
			{
				// button masks for wButtons
				kUp = XInput::XInputButton::XINPUT_GAMEPAD_DPAD_UP,                    // 0x0001
				kDown = XInput::XInputButton::XINPUT_GAMEPAD_DPAD_DOWN,                // 0x0002
				kLeft = XInput::XInputButton::XINPUT_GAMEPAD_DPAD_LEFT,                // 0x0004
				kRight = XInput::XInputButton::XINPUT_GAMEPAD_DPAD_RIGHT,              // 0x0008
				kStart = XInput::XInputButton::XINPUT_GAMEPAD_START,                   // 0x0010
				kBack = XInput::XInputButton::XINPUT_GAMEPAD_BACK,                     // 0x0020
				kLeftThumb = XInput::XInputButton::XINPUT_GAMEPAD_LEFT_THUMB,          // 0x0040
				kRightThumb = XInput::XInputButton::XINPUT_GAMEPAD_RIGHT_THUMB,        // 0x0080
				kLeftShoulder = XInput::XInputButton::XINPUT_GAMEPAD_LEFT_SHOULDER,    // 0x0100
				kRightShoulder = XInput::XInputButton::XINPUT_GAMEPAD_RIGHT_SHOULDER,  // 0x0200
				kA = XInput::XInputButton::XINPUT_GAMEPAD_A,                           // 0x1000
				kB = XInput::XInputButton::XINPUT_GAMEPAD_B,                           // 0x2000
				kX = XInput::XInputButton::XINPUT_GAMEPAD_X,                           // 0x4000
				kY = XInput::XInputButton::XINPUT_GAMEPAD_Y,                           // 0x8000

				// arbitrary values
				// IDs meant to be used with ButtonEvent
				kLeftTrigger = 0x0009,
				kRightTrigger = 0x000A,
				// IDs meant to be used with ThumbstickEvent
				kLeftStick = 0x000B,
				kRightStick = 0x000C
			};
		};
		using Key = Keys::Key;

		struct ButtonState
		{
			bool up: 1;             // 0x0001
			bool down: 1;           // 0x0002
			bool left: 1;           // 0x0004
			bool right: 1;          // 0x0008
			bool start: 1;          // 0x0010
			bool back: 1;           // 0x0020
			bool leftThumb: 1;      // 0x0040
			bool rightThumb: 1;     // 0x0080
			bool leftShoulder: 1;   // 0x0100
			bool rightShoulder: 3;  // 0x0200, skip over 2 bits (XInput documentation says the state of these two bits are undefined)
			bool a: 1;              // 0x1000
			bool b: 1;              // 0x2000
			bool x: 1;              // 0x4000
			bool y: 1;              // 0x8000
		};

		~BSWin32GamepadDevice() override;  // 00

		// override (BSPCGamepadDeviceDelegate)
		void Initialize() override;                           // 01
		void Process(float a_arg1) override;                  // 02
		void Release() override;                              // 03 - { return; }
		void Reset() override;                                // 08 - { std::memset(&unk0D8, 0, 0x50); }
		void SetRumble(float lValue, float rValue) override;  // 09 - { return; }

		// Returns the previous ButtonState of the gamepad
		ButtonState GetPreviousButtonState() const
		{
			return stl::unrestricted_cast<ButtonState>(previousState.Gamepad.wButtons & XInput::XINPUT_BUTTON_MASK);
		}

		// Returns the current ButtonState of the gamepad
		ButtonState GetCurrentButtonState() const
		{
			return stl::unrestricted_cast<ButtonState>(currentState.Gamepad.wButtons & XInput::XINPUT_BUTTON_MASK);
		}

		// members
		XInput::XINPUT_STATE previousState;  // 0D8
		float                previousLT;     // 0E8
		float                previousRT;     // 0EC
		float                previousLX;     // 0F0
		float                previousLY;     // 0F4
		float                previousRX;     // 0F8
		float                previousRY;     // 0FC
		XInput::XINPUT_STATE currentState;   // 100
		float                currentLT;      // 110
		float                currentRT;      // 114
		float                currentLX;      // 118
		float                currentLY;      // 11C
		float                currentRX;      // 120
		float                currentRY;      // 124

	protected:
		friend class BSGamepadDeviceHandler;
		BSWin32GamepadDevice();
	};
	static_assert(sizeof(BSWin32GamepadDevice) == 0x128);
}


===============================================
File: include/RE/B/BSWin32KeyboardDevice.h
===============================================
#pragma once

#include "RE/B/BSKeyboardDevice.h"

namespace RE
{
	class BSWin32KeyboardDevice : public BSKeyboardDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWin32KeyboardDevice;
		inline static constexpr auto VTABLE = VTABLE_BSWin32KeyboardDevice;

		~BSWin32KeyboardDevice() override;  // 00

		// override (BSKeyboardDevice)
		void Initialize() override;           // 01
		void Process(float a_unk1) override;  // 02
		void Release() override;              // 03
		void Reset() override;                // 08 - { std::memset(&curState, 0, 0x200); }
		void Unk_09(void) override;           // 09 - { return; }
		void Unk_0A(void) override;           // 0A - { return; }

		[[nodiscard]] bool IsPressed(std::uint32_t a_keyCode) const;
		[[nodiscard]] Key  RemapNumpadKey(DirectInput8::DIKey a_key);

		// members
		DirectInput8::IDirectInput8A*    dInputDevice;      // 070
		DirectInput8::DIDEVICEOBJECTDATA diObjData[10];     // 078
		std::uint8_t                     prevState[0x100];  // 168
		std::uint8_t                     curState[0x100];   // 268
		bool                             capsLockOn;        // 368

	protected:
		BSWin32KeyboardDevice();
	};
	static_assert(offsetof(BSWin32KeyboardDevice, prevState) == 0x168);
	static_assert(offsetof(BSWin32KeyboardDevice, curState) == 0x268);
	static_assert(sizeof(BSWin32KeyboardDevice) == 0x370);
}


===============================================
File: include/RE/B/BSWin32MouseDevice.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSMouseDevice.h"

namespace RE
{
	class BSWin32MouseDevice : public BSMouseDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWin32MouseDevice;
		inline static constexpr auto VTABLE = VTABLE_BSWin32MouseDevice;

		struct Keys
		{
			enum Key : std::uint32_t
			{
				kLeftButton,
				kRightButton,
				kMiddleButton,
				kButton3,
				kButton4,
				kButton5,
				kButton6,
				kButton7,
				kWheelUp,
				kWheelDown
			};
		};
		using Key = Keys::Key;

		~BSWin32MouseDevice() override;  // 00

		// override (BSMouseDevice)
		void Initialize() override;           // 01
		void Process(float a_arg1) override;  // 02
		void Release() override;              // 03
		void Reset() override;                // 08
		void Reinitialize(void) override;     // 09

		// members
		DirectInput8::IDirectInputDevice8A* dInputDevice;       // 78
		DirectInput8::DIMOUSESTATE2         dInputPrevState{};  // 80
		DirectInput8::DIMOUSESTATE2         dInputNextState{};  // 94
		bool                                notInitialized;     // A8
		mutable BSSpinLock                  reinitializeLock;   // AC

	protected:
		BSWin32MouseDevice();
	};
	static_assert(sizeof(BSWin32MouseDevice) == 0xB8);
}


===============================================
File: include/RE/B/BSWin32SaveDataSystemUtility.h
===============================================
#pragma once

#include "RE/B/BSSaveDataSystemUtility.h"

namespace RE
{
	class BSWin32SaveDataSystemUtility : public BSSaveDataSystemUtility
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWin32SaveDataSystemUtility;

		~BSWin32SaveDataSystemUtility() override;

		// override (BSSaveDataSystemUtility)
		bool    CreateSaveDirectory(const char* a_pathName, bool a_ignoreINI) override;                               // 01
		errno_t PrepareFileSavePath(const char* a_fileName, char* a_dst, bool a_tmpSave, bool a_ignoreINI) override;  // 02
		void    Unk_05(void) override;                                                                                // 05
		void    Unk_06(void) override;                                                                                // 06
		void    Unk_07(void) override;                                                                                // 07
		void    Unk_08(void) override;                                                                                // 08 - { return; }
		void    Unk_09(void) override;                                                                                // 09 - { return; }
		void    Unk_0C(void) override;                                                                                // 0C
		void    Unk_11(void) override;                                                                                // 11 - { return; }

		static BSWin32SaveDataSystemUtility* GetSingleton();
	};
	static_assert(sizeof(BSWin32SaveDataSystemUtility) == 0x228);
}


===============================================
File: include/RE/B/BSWin32VirtualKeyboardDevice.h
===============================================
#pragma once

#include "RE/B/BSVirtualKeyboardDevice.h"

namespace RE
{
	class BSWin32VirtualKeyboardDevice : public BSVirtualKeyboardDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWin32VirtualKeyboardDevice;
		inline static constexpr auto VTABLE = VTABLE_BSWin32VirtualKeyboardDevice;

		~BSWin32VirtualKeyboardDevice() override;  // 00

		// override (BSVirtualKeyboardDevice)
		void Initialize() override;           // 01 - { return; }
		void Process(float a_arg1) override;  // 02 - { return; }
		void Release() override;              // 03 - { return; }
		void Reset() override;                // 08 - { return; }
		void Unk_0B(void) override;           // 0B - { return; }
		void Unk_0C(void) override;           // 0C - { return; }
		void Unk_0D(void) override;           // 0D - { return; }

	protected:
		BSWin32VirtualKeyboardDevice();
	};
	static_assert(sizeof(BSWin32VirtualKeyboardDevice) == 0x70);
}


===============================================
File: include/RE/B/BSWindModifier.h
===============================================
#pragma once

#include "RE/N/NiPSysModifier.h"

namespace RE
{
	class BSWindModifier : public NiPSysModifier
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSWindModifier;
		inline static constexpr auto Ni_RTTI = NiRTTI_BSWindModifier;
		inline static constexpr auto VTABLE = VTABLE_BSWindModifier;

		~BSWindModifier() override;  // 00

		// override (NiPSysModifier)
		const NiRTTI* GetRTTI() const override;                                                                                                  // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;                                                                         // 17
		void          LoadBinary(NiStream& a_stream) override;                                                                                   // 18
		void          LinkObject(NiStream& a_stream) override;                                                                                   // 19
		bool          RegisterStreamables(NiStream& a_stream) override;                                                                          // 1A
		void          SaveBinary(NiStream& a_stream) override;                                                                                   // 1B
		bool          IsEqual(NiObject* a_object) override;                                                                                      // 1C - { return false; }
		void          ProcessClone(NiCloningProcess& a_cloning) override;                                                                        // 1D
		bool          Update(float a_time, NiPSysData* a_particleData, NiPoint3* a_position, NiPoint3* a_radii, NiColorA* a_rotation) override;  // 25

		static BSWindModifier* Create(const BSFixedString& a_name, float a_strength);

		// members
		float         strength;  // 30
		std::uint32_t pad34;     // 34

	private:
		BSWindModifier* Ctor();
	};
	static_assert(sizeof(BSWindModifier) == 0x38);
}


===============================================
File: include/RE/B/BSXAudio2GameSound.h
===============================================
#pragma once

#include "RE/B/BSGameSound.h"
#include "RE/I/IXAudio2VoiceCallback.h"

namespace RE
{
	class BSXAudio2GameSound :
		public BSGameSound,           // 000
		public IXAudio2VoiceCallback  // 0C8
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSXAudio2GameSound;

		// override (BSGameSound)
		void Unk_00(void) override;  // 00

		~BSXAudio2GameSound() override;  // 01

		void Unk_04(void) override;  // 04
		void Unk_06(void) override;  // 06
		void Unk_07(void) override;  // 07
		void Unk_08(void) override;  // 08
		void Unk_09(void) override;  // 09
		void Unk_0A(void) override;  // 0A
		void Unk_0B(void) override;  // 0B
		void Unk_0C(void) override;  // 0C
		void Unk_0D(void) override;  // 0D
		void Unk_0E(void) override;  // 0E
		void Unk_0F(void) override;  // 0F
		void Unk_10(void) override;  // 10
		void Unk_11(void) override;  // 11
		void Unk_12(void) override;  // 12
		void Unk_13(void) override;  // 13
		void Unk_14(void) override;  // 14
		void Unk_15(void) override;  // 15
		void Unk_16(void) override;  // 16
		void Unk_17(void) override;  // 17
		void Unk_18(void) override;  // 18

		// members
		std::uint64_t unk0C8;  // 0C8
		std::uint64_t unk0D0;  // 0D0
		std::uint64_t unk0D8;  // 0D8
		std::uint64_t unk0E0;  // 0E0
		std::uint64_t unk0E8;  // 0E8
		std::uint64_t unk0F0;  // 0F0
		std::uint64_t unk0F8;  // 0F8
		std::uint64_t unk100;  // 100
		std::uint64_t unk108;  // 108
		std::uint64_t unk110;  // 110
		std::uint64_t unk118;  // 118
		std::uint64_t unk120;  // 120
		std::uint64_t unk128;  // 128
		std::uint64_t unk130;  // 130
		std::uint64_t unk138;  // 138
		std::uint64_t unk140;  // 140
		std::uint64_t unk148;  // 148
		std::uint64_t unk150;  // 150
		std::uint64_t unk158;  // 158
		std::uint64_t unk160;  // 160
		std::uint64_t unk168;  // 168
		std::uint64_t unk170;  // 170
		std::uint64_t unk178;  // 178
		std::uint64_t unk180;  // 180
		std::uint64_t unk188;  // 188
		std::uint64_t unk190;  // 190
		std::uint64_t unk198;  // 198
		std::uint64_t unk1A0;  // 1A0
		std::uint64_t unk1A8;  // 1A8
		std::uint64_t unk1B0;  // 1B0
		std::uint64_t unk1B8;  // 1B8
		std::uint64_t unk1C0;  // 1C0
		std::uint64_t unk1C8;  // 1C8
		std::uint64_t unk1D0;  // 1D0
		std::uint64_t unk1D8;  // 1D8
		std::uint64_t unk1E0;  // 1E0
		std::uint64_t unk1E8;  // 1E8
		std::uint64_t unk1F0;  // 1F0
		std::uint64_t unk1F8;  // 1F8
		std::uint64_t unk200;  // 200
		std::uint64_t unk208;  // 208
		std::uint64_t unk210;  // 210
		std::uint64_t unk218;  // 218
	};
	static_assert(sizeof(BSXAudio2GameSound) == 0x220);
}


===============================================
File: include/RE/B/BSXFlags.h
===============================================
#pragma once

#include "RE/N/NiIntegerExtraData.h"

namespace RE
{
	class BSXFlags : public NiIntegerExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSXFlags;
		inline static auto           Ni_RTTI = NiRTTI_BSXFlags;

		enum class Flag
		{
			kNone = 0,
			kAnimated = 1 << 0,
			kHavok = 1 << 1,
			kRagdoll = 1 << 2,
			kComplex = 1 << 3,
			kAddon = 1 << 4,
			kEditorMarker = 1 << 5,
			kDynamic = 1 << 6,
			kArticulated = 1 << 7,
			kNeedsTransformUpdate = 1 << 8,
			kExternalEmit = 1 << 9,
			kMagicShaderParticles = 1 << 10,
			kLights = 1 << 11,
			kBreakable = 1 << 12,
			kSearchedBreakable = 1 << 13
		};

		~BSXFlags() override;  // 00

		// override (NiIntegerExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17 - { return this; }
		void          LoadBinary(NiStream& a_stream) override;            // 18 - { NiIntegerExtraData::LoadBinary(a_stream); }
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiIntegerExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiIntegerExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B - { NiIntegerExtraData::SaveBinary(a_stream); }
		bool          IsEqual(NiObject* a_object) override;               // 1C - { return NiIntegerExtraData::IsEqual(a_object); }

		[[nodiscard]] Flag GetFlags() const;
		void               SetFlags(Flag a_flags);
	};
	static_assert(sizeof(BSXFlags) == 0x20);
}


===============================================
File: include/RE/B/BShkbAnimationGraph.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIRagdollDriver.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/H/hkbCharacter.h"

namespace RE
{
	class bhkWorld;
	class BSFadeNode;
	class BShkFloatController;
	class BSTransformDeltaEvent;
	class hkbBehaviorGraph;
	struct BSAnimationGraphEvent;
	struct hkbGeneratorOutput;

	namespace BSResource
	{
		struct ID;
	}

	BSSmartPointer(BShkbAnimationGraph);

	class BShkbAnimationGraph :
		public BSIRagdollDriver,                       // 000
		public BSIntrusiveRefCounted,                  // 008
		public BSTEventSource<BSTransformDeltaEvent>,  // 010
		public BSTEventSource<BSAnimationGraphEvent>   // 068
	{
	public:
		inline static constexpr auto RTTI = RTTI_BShkbAnimationGraph;

		struct BoneNodeEntry
		{
			NiNode*  node;  // 00
			uint32_t unk08;
			uint32_t unk0C;
		};

		~BShkbAnimationGraph() override;  // 00

		// override (BSIRagdollDriver)
		bool HasRagdoll() override;                                       // 01
		bool AddRagdollToWorld() override;                                // 02
		bool RemoveRagdollFromWorld() override;                           // 03
		void SetWorld(bhkWorld* a_world) override;                        // 04 - { world = a_world; }
		void ResetRagdoll(void) override;                                 // 05
		void Unk_06(void) override;                                       // 06
		void SetRagdollConstraintsFromBhkConstraints() override;          // 07
		void SetMotionType(hkpMotion::MotionType a_motionType) override;  // 08
		void Unk_09(void) override;                                       // 09
		void ToggleSyncOnUpdate(bool a_disable) override;                 // 0A
		void Unk_0B(void) override;                                       // 0B
		void ToggleConstraints(bool a_disable) override;                  // 0C
		void Unk_0D(void) override;                                       // 0D

		template <class T>
		[[nodiscard]] inline BSTEventSource<T>* GetEventSource()
		{
			return static_cast<BSTEventSource<T>*>(this);
		}

		template <class T>
		inline void AddEventSink(BSTEventSink<T>* a_eventSink)
		{
			GetEventSource<T>()->AddEventSink(a_eventSink);
		}

		template <class T>
		inline void RemoveEventSink(BSTEventSink<T>* a_eventSink)
		{
			GetEventSource<T>()->RemoveEventSink(a_eventSink);
		}

		bool GetGraphVariableBool(const BSFixedString& a_variableName, bool& a_out) const
		{
			using func_t = decltype(&BShkbAnimationGraph::GetGraphVariableBool);
			REL::Relocation<func_t> func{ RELOCATION_ID(62696, 63613) };
			return func(this, a_variableName, a_out);
		}

		bool GetGraphVariableFloat(const BSFixedString& a_variableName, float& a_out) const
		{
			using func_t = decltype(&BShkbAnimationGraph::GetGraphVariableFloat);
			REL::Relocation<func_t> func{ RELOCATION_ID(62695, 63614) };
			return func(this, a_variableName, a_out);
		}

		bool GetGraphVariableInt(const BSFixedString& a_variableName, int& a_out) const
		{
			using func_t = decltype(&BShkbAnimationGraph::GetGraphVariableInt);
			REL::Relocation<func_t> func{ RELOCATION_ID(62694, 63615) };
			return func(this, a_variableName, a_out);
		}

		bool SetGraphVariableBool(const BSFixedString& a_variableName, const bool a_in)
		{
			using func_t = decltype(&BShkbAnimationGraph::SetGraphVariableBool);
			REL::Relocation<func_t> func{ RELOCATION_ID(63609, 62708) };
			return func(this, a_variableName, a_in);
		}

		bool SetGraphVariableFloat(const BSFixedString& a_variableName, const float a_in)
		{
			using func_t = decltype(&BShkbAnimationGraph::SetGraphVariableFloat);
			REL::Relocation<func_t> func{ RELOCATION_ID(63608, 62709) };
			return func(this, a_variableName, a_in);
		}

		bool SetGraphVariableInt(const BSFixedString& a_variableName, const int a_in)
		{
			using func_t = decltype(&BShkbAnimationGraph::SetGraphVariableInt);
			REL::Relocation<func_t> func{ RELOCATION_ID(63607, 62710) };
			return func(this, a_variableName, a_in);
		}

		// members
		hkbCharacter                   characterInstance;            // 0C0
		BSTArray<BoneNodeEntry>        boneNodes;                    // 160
		BSTArray<BShkFloatController*> fadeControllers;              // 178
		BSTArray<void*>                unk190;                       // 190
		BSTSmallArray<void*>           unk1A8;                       // 1A8
		BSTSmallArray<std::uint8_t>    unk1C0;                       // 1C0
		std::uint64_t                  unk1D8;                       // 1D8
		std::uint64_t                  unk1E0;                       // 1E0
		float                          interpolationTimeOffsets[2];  // 1E8
		BSFixedString                  projectName;                  // 1F0
		BSResource::ID*                unk1F8;                       // 1F8
		void*                          projectDBData;                // 200 - BShkbHkxDB::ProjectDBData*
		hkbBehaviorGraph*              behaviorGraph;                // 208
		Actor*                         holder;                       // 210
		BSFadeNode*                    rootNode;                     // 218
		hkbGeneratorOutput*            generatorOutputs[2];          // 220
		float                          interpolationAmounts[2];      // 230
		bhkWorld*                      physicsWorld;                 // 238
		std::uint16_t                  numAnimBones;                 // 240
		std::uint8_t                   unk242;                       // 242
		std::uint8_t                   unk243;                       // 243
		std::uint16_t                  unk244;                       // 244
		std::uint8_t                   unk246;                       // 246
		std::uint8_t                   unk247;                       // 247
		std::uint8_t                   unk248;                       // 248
		std::uint8_t                   doFootIK;                     // 249
		std::uint16_t                  unk24A;                       // 24A
		std::uint32_t                  unk24C;                       // 24C
	};
	static_assert(sizeof(BShkbAnimationGraph) == 0x250);
}


===============================================
File: include/RE/B/BanishEffect.h
===============================================
#pragma once

#include "RE/D/DemoralizeEffect.h"

namespace RE
{
	class BanishEffect :
		public DemoralizeEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_BanishEffect;
		inline static constexpr auto VTABLE = VTABLE_BanishEffect;

		// override (ActiveEffect)
		virtual ~BanishEffect();        // 13
		virtual void Start() override;  // 14
	};
	static_assert(sizeof(BanishEffect) == 0x98);
}


===============================================
File: include/RE/B/BarrierProjectile.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/F/FormTypes.h"
#include "RE/P/Projectile.h"

namespace RE
{
	class BarrierProjectile : public Projectile
	{
	public:
		inline static constexpr auto RTTI = RTTI_BarrierProjectile;
		inline static constexpr auto VTABLE = VTABLE_BarrierProjectile;
		inline static constexpr auto FORMTYPE = FormType::ProjectileBarrier;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		struct CollisionData
		{
			ObjectRefHandle ref;    // 0
			std::uint32_t   count;  // 4
		};
		static_assert(sizeof(CollisionData) == 0x8);

		~BarrierProjectile() override;  // 00

		// override (Projectile)
		void        SaveGame(BGSSaveFormBuffer* a_buf) override;        // 0E
		void        LoadGame(BGSLoadFormBuffer* a_buf) override;        // 0F
		void        InitLoadGame(BGSLoadFormBuffer* a_buf) override;    // 10
		void        FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 11
		void        Revert(BGSLoadFormBuffer* a_buf) override;          // 12
		void        InitHavok() override;                               // 66
		NiAVObject* Load3D(bool a_backgroundLoading) override;          // 6A
#ifndef SKYRIM_CROSS_VR
		bool        IsBarrierProjectile() override;                              // A7 - { return 1; }
		void        UpdateImpl(float a_delta) override;                 // AB
		bool        ProcessImpacts() override;                              // AC
		bool        GetKillOnCollision() override;                              // B8 - { return 0; }
#endif

		struct BARRIER_RUNTIME_DATA
		{
#define BARRIER_RUNTIME_DATA_CONTENT                      \
	float                   width;         /* 1D8, 1E0 */ \
	std::uint32_t           pad1DC;        /* 1DC */      \
	BSTArray<CollisionData> collisionData; /* 1E0 */

			BARRIER_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline BARRIER_RUNTIME_DATA& GetBarrierRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<BARRIER_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		[[nodiscard]] inline const BARRIER_RUNTIME_DATA& GetBarrierRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<BARRIER_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		BARRIER_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(BarrierProjectile) == 0x1F8);
#endif
}
#undef BARRIER_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BarterMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	struct BottomBar;
	struct ItemCard;
	struct ItemList;

	// menuDepth = 0
	// flags = kPausesGame | kUsesMenuContext | kDisablePauseMenu | kUpdateUsesCursor | kInventoryItemMenu | kCustomRendering
	// context = kItemMenu
	class BarterMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_BarterMenu;
		constexpr static std::string_view MENU_NAME = "BarterMenu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                              \
	ItemList*       itemList;        /* 00 */             \
	ItemCard*       itemCard;        /* 08 */             \
	BottomBar*      bottomBar;       /* 10 */             \
	GFxValue        root;            /* 18 - "Menu_mc" */ \
	std::uint64_t   unk60;           /* 30 */             \
	std::uint64_t   unk68;           /* 38 */             \
	std::uint64_t   unk70;           /* 40 */             \
	std::uint8_t    unk78;           /* 48 */             \
	std::uint8_t    pad79;           /* 49 */             \
	std::uint16_t   pad7A;           /* 4A */             \
	std::uint32_t   pad7C;           /* 4C */             \
	BSTArray<void*> unk80;           /* 50 */             \
	std::uint64_t   unk98;           /* 68 */             \
	std::uint32_t   unkA0;           /* 70 */             \
	bool            pcControlsReady; /* 74 */             \
	std::uint8_t    padA5;           /* 75 */             \
	std::uint16_t   padA6;           /* 76 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x78);

		~BarterMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04
		void               PostDisplay() override;                           // 06

		[[nodiscard]] static RefHandle GetTargetRefHandle();

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BarterMenu) == 0xA8);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BarterMenu) == 0xB8);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BaseFormComponent.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	class BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BaseFormComponent;

		virtual ~BaseFormComponent();  // 00

		// add
		virtual void InitializeDataComponent() = 0;            // 01
		virtual void ClearDataComponent() = 0;                 // 02
		virtual void CopyComponent(BaseFormComponent* a_rhs);  // 03 - { return; }

		TES_HEAP_REDEFINE_NEW();
	};
	static_assert(sizeof(BaseFormComponent) == 0x8);
}


===============================================
File: include/RE/B/BaseHandleReaderWriter.h
===============================================
#pragma once

#include "RE/I/IHandleReaderWriter.h"

namespace RE::SkyrimScript
{
	class BaseHandleReaderWriter : public RE::BSScript::IHandleReaderWriter
	{
	public:
		inline static constexpr auto RTTI = RTTI_SkyrimScript__BaseHandleReaderWriter;
		inline static constexpr auto VTABLE = VTABLE_BSScript__IHandleReaderWriter;

		~BaseHandleReaderWriter() override;  // 0
	};
	static_assert(sizeof(BaseHandleReaderWriter) == 0x8);
}


===============================================
File: include/RE/B/BeamProjectile.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/F/FormTypes.h"
#include "RE/P/Projectile.h"

namespace RE
{
	class BSProceduralGeomEvent;
	struct BeamProjectileImpactEvent;

	class BeamProjectile :
		public Projectile,                                 // 000
		public BSTEventSource<BeamProjectileImpactEvent>,  // 1E0
		public BSTEventSink<BSProceduralGeomEvent>         // 1D8
	{
	public:
		inline static constexpr auto RTTI = RTTI_BeamProjectile;
		inline static constexpr auto VTABLE = VTABLE_BeamProjectile;
		inline static constexpr auto FORMTYPE = FormType::ProjectileBeam;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~BeamProjectile() override;  // 00

		// override (Projectile)
		void SaveGame(BGSSaveFormBuffer* a_buf) override;        // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;        // 0F
		void InitLoadGame(BGSLoadFormBuffer* a_buf) override;    // 10
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 11
		void Revert(BGSLoadFormBuffer* a_buf) override;          // 12
#ifndef SKYRIM_CROSS_VR
		bool IsBeamProjectile() override;               // A5
		void Process3D() override;               // A9
		void UpdateImpl(float a_delta) override;  // AB
		bool GetKillOnCollision() override;               // B8
		void AddImpact(TESObjectREFR* a_ref, const NiPoint3& a_targetLoc, const NiPoint3& a_velocity, hkpCollidable* a_collidable, std::int32_t a_arg6, std::uint32_t a_arg7) override;               // BD
		void Handle3DLoaded() override;           // C0
		bool ShouldUseDesiredTarget() override;               // C1
#endif

		// override (BSTEventSink<BSProceduralGeomEvent>)
		BSEventNotifyControl ProcessEvent(const BSProceduralGeomEvent* a_event, BSTEventSource<BSProceduralGeomEvent>* a_eventSource) override;  // 01

		struct BEAM_RUNTIME_DATA
		{
#define BEAM_RUNTIME_DATA_CONTENT \
			std::uint64_t unk238;  // 238, 240
		};

		[[nodiscard]] inline BEAM_RUNTIME_DATA& GetBeamRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<BEAM_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		[[nodiscard]] inline const BEAM_RUNTIME_DATA& GetBeamRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<BEAM_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		BEAM_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(BeamProjectile) == 0x240);
#endif
}
#undef BEAM_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BipedAnim.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BipedObjects.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/W/WeaponAnimationGraphManagerHolder.h"

namespace RE
{
	class BGSTextureSet;
	class NiAVObject;
	class NiNode;
	class TESForm;
	class TESModel;
	class TESObjectARMA;

	struct BIPOBJECT
	{
	public:
		// members
		TESForm*                                           item;           // 00
		TESObjectARMA*                                     addon;          // 08
		TESModel*                                          part;           // 10
		BGSTextureSet*                                     skinTexture;    // 18
		NiPointer<NiAVObject>                              partClone;      // 20
		std::uint64_t                                      unk28;          // 28 - same as AIProcess::Data0B8
		std::uint64_t                                      unk30;          // 30
		std::uint64_t                                      unk38;          // 38
		std::uint64_t                                      unk40;          // 40
		std::uint64_t                                      unk48;          // 48
		std::uint64_t                                      unk50;          // 50
		std::uint64_t                                      unk58;          // 58
		BSTSmartPointer<WeaponAnimationGraphManagerHolder> weaponManager;  // 60 - smart ptr
		std::uint64_t                                      unk68;          // 68
		void*                                              unk70;          // 70
	};
	static_assert(sizeof(BIPOBJECT) == 0x78);

	class BipedAnim : public BSIntrusiveRefCounted
	{
	public:
		~BipedAnim();

		void RemoveAllParts();

		std::uint32_t   pad0004;                                 // 0004
		NiNode*         root;                                    // 0008
		BIPOBJECT       objects[BIPED_OBJECTS::kTotal];          // 0010
		BIPOBJECT       bufferedObjects[BIPED_OBJECTS::kTotal];  // 13C0
		ObjectRefHandle actorRef;                                // 2770
		std::uint32_t   pad2774;                                 // 2774

	private:
		void Dtor();
	};
	static_assert(sizeof(BipedAnim) == 0x2778);
}


===============================================
File: include/RE/B/BipedObjects.h
===============================================
#pragma once

namespace RE
{
	struct BIPED_OBJECTS
	{
		enum BIPED_OBJECT : std::uint32_t
		{
			kNone = static_cast<std::underlying_type_t<BIPED_OBJECT>>(-1),
			kHead = 0,
			kHair = 1,
			kBody = 2,
			kHands = 3,
			kForearms = 4,
			kAmulet = 5,
			kRing = 6,
			kFeet = 7,
			kCalves = 8,
			kShield = 9,
			kTail = 10,
			kLongHair = 11,
			kCirclet = 12,
			kEars = 13,
			kModMouth = 14,
			kModNeck = 15,
			kModChestPrimary = 16,
			kModBack = 17,
			kModMisc1 = 18,
			kModPelvisPrimary = 19,
			kDecapitateHead = 20,
			kDecapitate = 21,
			kModPelvisSecondary = 22,
			kModLegRight = 23,
			kModLegLeft = 24,
			kModFaceJewelry = 25,
			kModChestSecondary = 26,
			kModShoulder = 27,
			kModArmLeft = 28,
			kModArmRight = 29,
			kModMisc2 = 30,
			kFX01 = 31,

			kEditorTotal = 32,

			kHandToHandMelee = kEditorTotal,
			kOneHandSword = 33,
			kOneHandDagger = 34,
			kOneHandAxe = 35,
			kOneHandMace = 36,
			kTwoHandMelee = 37,
			kBow = 38,
			kStaff = 39,
			kCrossbow = 40,
			kQuiver = 41,

			kTotal = 42
		};
	};
	using BIPED_OBJECT = BIPED_OBJECTS::BIPED_OBJECT;
}


===============================================
File: include/RE/B/BleedoutCameraState.h
===============================================
#pragma once

#include "RE/B/BSSoundHandle.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/ThirdPersonState.h"

namespace RE
{
	class NiAVObject;

	class BleedoutCameraState : public ThirdPersonState
	{
	public:
		inline static constexpr auto RTTI = RTTI_BleedoutCameraState;
		inline static constexpr auto VTABLE = VTABLE_BleedoutCameraState;

		~BleedoutCameraState() override;  // 00

		// override (ThirdPersonState)
		void Begin() override;                                               // 01
		void End() override;                                                 // 02
		void Update(BSTSmartPointer<TESCameraState>& a_nextState) override;  // 03

		// members
		NiMatrix3             rotationMtx;        // 0E8
		float                 zoom;               // 10C
		float                 pitch;              // 110
		float                 yaw;                // 114
		float                 randHeading;        // 118
		std::uint32_t         pad11C;             // 11C
		NiPointer<NiAVObject> animatedBone;       // 120
		BSSoundHandle         activeSound;        // 128
		bool                  useCurrentHeading;  // 134
		std::uint8_t          pad135;             // 135
		std::uint16_t         pad136;             // 136
	};
	static_assert(sizeof(BleedoutCameraState) == 0x138);
}


===============================================
File: include/RE/B/BookMenu.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTEvent.h"
#include "RE/G/GPtr.h"
#include "RE/I/IMenu.h"
#include "RE/I/ImageData.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/S/SimpleAnimationGraphManagerHolder.h"

namespace RE
{
	struct BSAnimationGraphEvent;

	class ExtraDataList;
	class NiAVObject;
	class TESObjectBOOK;
	class TESObjectREFR;

	// menuDepth = 1
	// flags = kPausesGame | kUsesMenuContext | kDisablePauseMenu | kRequiresUpdate | kTopmostRenderedMenu | kRendersOffscreenTargets
	// context = kBook
	class BookMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                               // 00
		public SimpleAnimationGraphManagerHolder,   // 30
		public BSTEventSink<BSAnimationGraphEvent>  // 48
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_BookMenu;
		inline static constexpr auto      VTABLE = VTABLE_BookMenu;
		constexpr static std::string_view MENU_NAME = "Book Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                              \
	BSTArray<ImageData>   unk50;     /* 00 */             \
	GPtr<GFxMovieView>    book;      /* 18 */             \
	NiPointer<NiAVObject> book3D;    /* 20 */             \
	std::uint32_t         unk78;     /* 28 */             \
	std::uint32_t         pad7C;     /* 2C */             \
	std::uint64_t         unk80;     /* 30 */             \
	void*                 unk88;     /* 38 - smart ptr */ \
	std::uint16_t         unk90;     /* 40 */             \
	std::uint16_t         unk92;     /* 42 */             \
	bool                  closeMenu; /* 44 */             \
	bool                  isNote;    /* 45 */             \
	std::uint8_t          unk96;     /* 46 */             \
	std::uint8_t          pad97;     /* 47 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x48);

		~BookMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05
		void               PostDisplay() override;                                                // 06
		void               PreDisplay() override;                                                 // 07

#ifndef SKYRIM_CROSS_VR
		// override (BSTEventSink<BSAnimationGraphEvent>)
		BSEventNotifyControl ProcessEvent(const BSAnimationGraphEvent* a_event, BSTEventSource<BSAnimationGraphEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] static TESObjectBOOK* GetTargetForm();
		[[nodiscard]] static TESObjectREFR* GetTargetReference();  // returns null if opened from inventory

		[[nodiscard]] SimpleAnimationGraphManagerHolder* AsSimpleAnimationGraphManagerHolder() noexcept
		{
			return &REL::RelocateMember<SimpleAnimationGraphManagerHolder>(this, 0x30, 0x40);
		}

		[[nodiscard]] const SimpleAnimationGraphManagerHolder* AsSimpleAnimationGraphManagerHolder() const noexcept
		{
			return const_cast<BookMenu*>(this)->AsSimpleAnimationGraphManagerHolder();
		}

		[[nodiscard]] BSTEventSink<BSAnimationGraphEvent>* AsBSAnimationGraphEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BSAnimationGraphEvent>>(this, 0x48, 0x58);
		}

		[[nodiscard]] const BSTEventSink<BSAnimationGraphEvent>* AsBSAnimationGraphEventSink() const noexcept
		{
			return const_cast<BookMenu*>(this)->AsBSAnimationGraphEventSink();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x50, 0x60);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x50, 0x60);
		}

		static void OpenBookMenu(const BSString& a_description, const ExtraDataList* a_extraList, TESObjectREFR* a_ref, TESObjectBOOK* a_book, const NiPoint3& a_pos, const NiMatrix3& a_rot, float a_scale, bool a_useDefaultPos);

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 50, 60
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BookMenu) == 0x98);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BookMenu) == 0xA8);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BooksRead.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class TESObjectBOOK;

	struct BooksRead
	{
	public:
		struct Event
		{
		public:
			// members
			TESObjectBOOK* book;        // 00
			bool           skillBook;   // 08
			std::uint8_t   pad11{ 0 };  // 09
			std::uint16_t  pad12{ 0 };  // 10
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<BooksRead::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/B/BottomBar.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"

namespace RE
{
	struct BottomBar
	{
	public:
		// members
		GFxValue obj;  // 00 - kObject
	};
	static_assert(sizeof(BottomBar) == 0x18);
}


===============================================
File: include/RE/B/BoundItemEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/A/ActorInventoryEvent.h"
#include "RE/B/BSTEvent.h"

namespace RE
{
	class TESForm;

	class BoundItemEffect :
		public ActiveEffect,                      // 00
		public BSTEventSink<ActorInventoryEvent>  // 90
	{
	public:
		inline static constexpr auto RTTI = RTTI_BoundItemEffect;
		inline static constexpr auto VTABLE = VTABLE_BoundItemEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;                     // 04
		virtual void SaveGame(BGSSaveFormBuffer* a_buf) override;        // 08
		virtual void LoadGame(BGSLoadFormBuffer* a_buf) override;        // 09
		virtual void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 0A
		virtual void Revert(BGSLoadFormBuffer* a_buf) override;          // 0B
		virtual void ClearTargetImpl() override;                         // 12
		virtual ~BoundItemEffect();                                      // 13
		virtual void Start() override;                                   // 14
		virtual void Finish() override;                                  // 15
		virtual bool CanFinish() override;                               // 16

		// override (BSTEventSink)
		virtual BSEventNotifyControl ProcessEvent(const ActorInventoryEvent* a_event, BSTEventSource<ActorInventoryEvent>* a_eventSource) override;  // 01

		// members
		BSTArray<SpellItem*> spells;  // 98
		bool                 unkB0;   // B0
		bool                 unkB1;   // B1
		bool                 unkB2;   // B2
	};
	static_assert(sizeof(BoundItemEffect) == 0xB8);
}


===============================================
File: include/RE/B/ButtonEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/I/IDEvent.h"
#include "RE/I/InputEvent.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class ButtonEvent : public IDEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_ButtonEvent;
		inline static constexpr auto VTABLE = VTABLE_ButtonEvent;

		~ButtonEvent() override;  // 00

		[[nodiscard]] constexpr float Value() const noexcept { return value; }
		[[nodiscard]] constexpr float HeldDuration() const noexcept { return heldDownSecs; }
		[[nodiscard]] constexpr bool  IsPressed() const noexcept { return Value() > 0.0F; }
		[[nodiscard]] constexpr bool  IsRepeating() const noexcept { return HeldDuration() > 0.0F; }
		[[nodiscard]] constexpr bool  IsDown() const noexcept { return IsPressed() && (HeldDuration() == 0.0F); }
		[[nodiscard]] constexpr bool  IsHeld() const noexcept { return IsPressed() && IsRepeating(); }
		[[nodiscard]] constexpr bool  IsUp() const noexcept { return (Value() == 0.0F) && IsRepeating(); }

		// members
		float value;         // 28
		float heldDownSecs;  // 2C

		static ButtonEvent* Create(INPUT_DEVICE a_inputDevice, const BSFixedString& a_userEvent, uint32_t a_idCode, float a_value, float a_heldDownSecs)
		{
			auto buttonEvent = malloc<ButtonEvent>(sizeof(ButtonEvent));
			std::memset(reinterpret_cast<void*>(buttonEvent), 0, sizeof(ButtonEvent));
			if (buttonEvent) {
				stl::emplace_vtable<ButtonEvent>(buttonEvent);
				buttonEvent->device = a_inputDevice;
				buttonEvent->eventType = INPUT_EVENT_TYPE::kButton;
				buttonEvent->next = nullptr;
				buttonEvent->userEvent = a_userEvent;
				buttonEvent->idCode = a_idCode;
				buttonEvent->value = a_value;
				buttonEvent->heldDownSecs = a_heldDownSecs;
			}
			return buttonEvent;
		}
	};
	static_assert(sizeof(ButtonEvent) == 0x30);
}


===============================================
File: include/RE/B/bhkBackfaceContactListener.h
===============================================
#pragma once

#include "RE/B/bhkContactListener.h"

namespace RE
{
	class bhkBackfaceContactListener : public bhkContactListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkBackfaceContactListener;

		~bhkBackfaceContactListener() override;  // 04
	};
	static_assert(sizeof(bhkBackfaceContactListener) == 0x8);
}


===============================================
File: include/RE/B/bhkCachingShapePhantom.h
===============================================
#pragma once

#include "RE/B/bhkShapePhantom.h"

namespace RE
{
	class bhkCachingShapePhantom : public bhkShapePhantom
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCachingShapePhantom;
		inline static auto           Ni_RTTI = NiRTTI_bhkCachingShapePhantom;

		~bhkCachingShapePhantom() override;  // 00

		// override (bhkShapePhantom)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          Unk_2B(void) override;                              // 2B
		void          Unk_2C(void) override;                              // 2C - { return 112; }
		void          Unk_2E(void) override;                              // 2E
		void          Unk_2F(void) override;                              // 2F
	};
	static_assert(sizeof(bhkCachingShapePhantom) == 0x30);
}


===============================================
File: include/RE/B/bhkCharProxyController.h
===============================================
#pragma once

#include "RE/B/bhkCharacterController.h"
#include "RE/B/bhkCharacterProxy.h"
#include "RE/H/hkpCharacterProxyListener.h"

namespace RE
{
	class hkpCharacterProxy;

	class bhkCharProxyController :
		public hkpCharacterProxyListener,  // 000
		public bhkCharacterController      // 010
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharProxyController;

		~bhkCharProxyController() override;  // 00

		// override (hkpCharacterProxyListener)
		void ProcessConstraintsCallback(const hkpCharacterProxy* a_proxy, const hkArray<hkpRootCdPoint>& a_manifold, hkpSimplexSolverInput& a_input) override;                  // 01
		void ContactPointAddedCallback(const hkpCharacterProxy* a_proxy, const hkpRootCdPoint& a_point) override;                                                               // 02
		void ContactPointRemovedCallback(const hkpCharacterProxy* a_proxy, const hkpRootCdPoint& a_point) override;                                                             // 03
		void CharacterInteractionCallback(hkpCharacterProxy* a_proxy, hkpCharacterProxy* a_otherProxy, const hkContactPoint& a_contact) override;                               // 04
		void ObjectInteractionCallback(hkpCharacterProxy* a_proxy, const hkpCharacterObjectInteractionEvent& a_input, hkpCharacterObjectInteractionResult& a_output) override;  // 05

		// override (bhkCharacterController)
		void GetLinearVelocityImpl(hkVector4& a_velocity) const override;  // 06
		void SetLinearVelocityImpl(const hkVector4& a_velocity) override;  // 07

		hkpCharacterProxy* GetCharacterProxy() const;

		// members
		bhkCharacterProxy proxy;   // 340
		void*             unk5A0;  // 5A0 - smart ptr
		std::uint64_t     unk5A8;  // 5A8
	};
	static_assert(sizeof(bhkCharProxyController) == 0x5B0);
}


===============================================
File: include/RE/B/bhkCharacterController.h
===============================================
#pragma once

#include "RE/B/BSBound.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTHashMap.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkStepInfo.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkpCharacterContext.h"
#include "RE/H/hkpCharacterControl.h"
#include "RE/H/hkpCharacterState.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class bhkCharacterMoveFinishEvent;
	class bhkICharOrientationController;
	class bhkShape;
	class hkpRigidBody;
	class hkTransform;
	class hkVector4;

	enum class CHARACTER_FLAGS
	{
		kNone = 0,
		kQuadruped = 1 << 0,
		kNoGravityOnGround = 1 << 1,
		kTryStep = 1 << 2,
		kNoFriction = 1 << 3,
		kAllowJumpNoContact = 1 << 4,
		kStuckQuad = 1 << 5,
		kAnimAngleMod = 1 << 6,
		kHitDamage = 1 << 7,
		kHitFlags = 1 << 7,
		kSupport = 1 << 8,
		kHasPotentialSupportManifold = 1 << 9,
		kCanJump = 1 << 10,
		kChaseBip = 1 << 11,
		kFollowRagdoll = 1 << 12,
		kJumping = 1 << 13,
		kNotPushable = 1 << 14,
		kFloatLand = 1 << 15,
		kCheckSupport = 1 << 16,
		kNoSim = 1 << 17,
		kFarAway = 1 << 18,
		kOnStilts = 1 << 19,
		kQuickSimulate = 1 << 20,
		kRecordHits = 1 << 21,
		kComputeTiltPreIntegrate = 1 << 22,
		kShouldersUnderWater = 1 << 23,
		kOnStairs = 1 << 24,
		kCanPitch = 1 << 25,
		kCanRoll = 1 << 26,
		kNoCharacterCollisions = 1 << 27,
		kNotPushablePermanent = 1 << 28,
		kPossiblePathObstacle = 1 << 29,
		kShapeRequiresZRot = 1 << 30,
		kSwimAtWaterSurface = 1 << 31,
	};

	class bhkCharacterController :
		public NiRefObject,                                 // 000
		public BSTEventSource<bhkCharacterMoveFinishEvent>  // 010
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterController;

		~bhkCharacterController() override;  // 00

		// add
		virtual void  GetPositionImpl(hkVector4& a_pos, bool a_applyCenterOffset) const = 0;                    // 02
		virtual void  SetPositionImpl(const hkVector4& a_pos, bool a_applyCenterOffset, bool a_forceWarp) = 0;  // 03
		virtual void  GetTransformImpl(hkTransform& a_tranform) const = 0;                                      // 04
		virtual void  SetTransformImpl(const hkTransform& a_tranform) = 0;                                      // 05
		virtual void  GetLinearVelocityImpl(hkVector4& a_velocity) const = 0;                                   // 06
		virtual void  SetLinearVelocityImpl(const hkVector4& a_velocity) = 0;                                   // 07
		virtual void  GetCollisionFilterInfo(std::uint32_t& a_collisionFilterInfo) const = 0;                   // 08
		virtual void  Unk_09(void) = 0;                                                                         // 09
		virtual void  Unk_0A(void) = 0;                                                                         // 0A
		virtual void  Unk_0B(void) = 0;                                                                         // 0B
		virtual void  Unk_0C(void) = 0;                                                                         // 0C
		virtual void  CheckSupportImpl() = 0;                                                                   // 0D
		virtual void  Unk_0E(void) = 0;                                                                         // 0E
		virtual void  Unk_0F(void) = 0;                                                                         // 0F
		virtual void  Unk_10(void) = 0;                                                                         // 10
		virtual float GetVDBAlpha() const = 0;                                                                  // 11
		virtual void  Unk_12(void) = 0;                                                                         // 12
		virtual void  Unk_13(void) = 0;                                                                         // 13

		inline void GetPosition(hkVector4& a_pos, bool a_applyCenterOffset) const { return GetPositionImpl(a_pos, a_applyCenterOffset); }

		// members
		//std::uint64_t						pad068;						// 068
		hkVector4                                        forwardVec;                 // 070
		hkStepInfo                                       stepInfo;                   // 080
		hkVector4                                        outVelocity;                // 090
		hkVector4                                        initialVelocity;            // 0A0
		hkVector4                                        velocityMod;                // 0B0
		hkVector4                                        direction;                  // 0C0
		hkVector4                                        rotCenter;                  // 0D0
		hkVector4                                        pushDelta;                  // 0E0
		hkVector4                                        fakeSupportStart;           // 0F0
		hkVector4                                        up;                         // 100
		hkVector4                                        supportNorm;                // 110
		BSBound                                          collisionBound;             // 120
		BSBound                                          bumperCollisionBound;       // 150
		std::uint64_t                                    unk180;                     // 180
		std::uint64_t                                    unk188;                     // 188
		bhkICharOrientationController*                   orientationCtrl;            // 190
		std::uint64_t                                    pad198;                     // 198
		hkpSurfaceInfo                                   surfaceInfo;                // 1A0
		hkpCharacterContext                              context;                    // 1E0
		stl::enumeration<CHARACTER_FLAGS, std::uint32_t> flags;                      // 218
		hkpCharacterStateType                            wantState;                  // 218
		float                                            velocityTime;               // 220
		float                                            rotMod;                     // 224
		float                                            rotModTime;                 // 228
		float                                            calculatePitchTimer;        // 22C
		float                                            acrobatics;                 // 230
		float                                            center;                     // 234
		float                                            waterHeight;                // 238
		float                                            jumpHeight;                 // 23C
		float                                            fallStartHeight;            // 240
		float                                            fallTime;                   // 244
		float                                            gravity;                    // 248
		float                                            pitchAngle;                 // 24C
		float                                            rollAngle;                  // 250
		float                                            pitchMult;                  // 254
		float                                            scale;                      // 258
		float                                            swimFloatHeight;            // 25C
		float                                            actorHeight;                // 260
		float                                            speedPct;                   // 264
		std::uint32_t                                    pushCount;                  // 268
		std::uint32_t                                    unk26C;                     // 26C
		std::uint64_t                                    unk270;                     // 270
		std::uint64_t                                    unk278;                     // 278
		NiPointer<bhkShape>                              shapes[2];                  // 280
		std::uint64_t                                    unk290;                     // 290
		std::uint32_t                                    unk298;                     // 298
		float                                            lodDistance;                // 29C
		std::uint64_t                                    unk2A0;                     // 2A0
		std::uint64_t                                    unk2A8;                     // 2A8
		hkRefPtr<hkpRigidBody>                           supportBody;                // 2B0
		float                                            bumpedForce;                // 2B8
		std::uint32_t                                    pad2BC;                     // 2BC
		hkRefPtr<hkpRigidBody>                           bumpedBody;                 // 2C0
		hkRefPtr<hkpRigidBody>                           bumpedCharCollisionObject;  // 2C8
		BSTHashMap<UnkKey, UnkValue>                     unk2D0;                     // 2D0
		std::uint64_t                                    unk300;                     // 300
		std::uint64_t                                    unk308;                     // 308
		std::uint64_t                                    unk310;                     // 310
		std::uint64_t                                    unk318;                     // 318
		std::uint64_t                                    unk320;                     // 320
		std::uint64_t                                    unk328;                     // 328
	};
	static_assert(sizeof(bhkCharacterController) == 0x330);
}


===============================================
File: include/RE/B/bhkCharacterPointCollector.h
===============================================
#pragma once

#include "RE/H/hkpAllCdPointCollector.h"

namespace RE
{
	class bhkCharacterPointCollector : public hkpAllCdPointCollector
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterPointCollector;

		~bhkCharacterPointCollector() override;  // 00

		// override (hkpAllCdPointCollector)
		void AddCdPoint(const hkpCdPoint& a_point) override;  // 01
		void Reset() override;                                // 02

		// members
		std::uint64_t unk220;  // 220
		std::uint64_t unk228;  // 228
		std::uint64_t unk230;  // 230
		std::uint64_t unk238;  // 238
	};
	static_assert(sizeof(bhkCharacterPointCollector) == 0x240);
}


===============================================
File: include/RE/B/bhkCharacterProxy.h
===============================================
#pragma once

#include "RE/B/bhkCharacterPointCollector.h"
#include "RE/B/bhkSerializable.h"

namespace RE
{
	class bhkCharacterProxy : public bhkSerializable
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterProxy;
		inline static auto           Ni_RTTI = NiRTTI_bhkCharacterProxy;

		~bhkCharacterProxy() override;  // 00

		// override (bhkSerializable)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		void          AdjustRefCount(bool a_increment) override;          // 26 - "void AdjustRefCount(bool a_increment)"?
		hkpWorld*     GetWorld1() override;                               // 27 - { auto proxy = (hkpCharacterProxy*)referencedObject.get(); if (proxy && proxy->shapePhantom) return proxy->world; else return 0; }
		ahkpWorld*    GetWorld2() override;                               // 28 - { return GetWorld(); }
		void          Unk_2B(void) override;                              // 2B
		void          Unk_2C(void) override;                              // 2C - { return 0x90; }
		void          Unk_2E(void) override;                              // 2E
		void          Unk_2F(void) override;                              // 2F

		// members
		bhkCharacterPointCollector ignoredCollisionStartCollector;  // 020
	};
	static_assert(sizeof(bhkCharacterProxy) == 0x260);
}


===============================================
File: include/RE/B/bhkCharacterState.h
===============================================
#pragma once

#include "RE/H/hkpCharacterState.h"

namespace RE
{
	class bhkCharacterState : public hkpCharacterState
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterState;

		~bhkCharacterState() override;  // 00

		// override (hkpCharacterState)
		void Update(hkpCharacterContext& a_context, const hkpCharacterInput& a_input, hkpCharacterOutput& a_output) override;  // 06
		void Change(hkpCharacterContext& a_context, const hkpCharacterInput& a_input, hkpCharacterOutput& a_output) override;  // 07

		// add
		virtual void Unk_08(void) = 0;  // 08
	};
	static_assert(sizeof(bhkCharacterState) == 0x10);
}


===============================================
File: include/RE/B/bhkCharacterStateClimbing.h
===============================================
#pragma once

#include "RE/B/bhkCharacterState.h"

namespace RE
{
	class bhkCharacterStateClimbing : public bhkCharacterState
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterStateClimbing;

		~bhkCharacterStateClimbing() override;  // 00

		// override (bhkCharacterState)
		hkpCharacterStateType GetType() const override;  // 03 - { return kClimbing; }
		void                  Unk_08(void) override;     // 08
	};
	static_assert(sizeof(bhkCharacterStateClimbing) == 0x10);
}


===============================================
File: include/RE/B/bhkCharacterStateFlying.h
===============================================
#pragma once

#include "RE/B/bhkCharacterState.h"

namespace RE
{
	class bhkCharacterStateFlying : public bhkCharacterState
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterStateFlying;

		~bhkCharacterStateFlying() override;  // 00

		// override (bhkCharacterState)
		hkpCharacterStateType GetType() const override;  // 03 - { return kFlying; }
		void                  Unk_08(void) override;     // 08
	};
	static_assert(sizeof(bhkCharacterStateFlying) == 0x10);
}


===============================================
File: include/RE/B/bhkCharacterStateInAir.h
===============================================
#pragma once

#include "RE/B/bhkCharacterState.h"

namespace RE
{
	class bhkCharacterStateInAir : public bhkCharacterState
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterStateInAir;

		~bhkCharacterStateInAir() override;  // 00

		// override (bhkCharacterState)
		hkpCharacterStateType GetType() const override;  // 03 - { return kInAir; }
		void                  Unk_08(void) override;     // 08

		// members
		std::uint64_t unk10;  // 10
	};
	static_assert(sizeof(bhkCharacterStateInAir) == 0x18);
}


===============================================
File: include/RE/B/bhkCharacterStateJumping.h
===============================================
#pragma once

#include "RE/B/bhkCharacterState.h"

namespace RE
{
	class bhkCharacterStateJumping : public bhkCharacterState
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterStateJumping;

		~bhkCharacterStateJumping() override;  // 00

		// override (bhkCharacterState)
		hkpCharacterStateType GetType() const override;  // 03 - { return kJumping; }
		void                  Unk_08(void) override;     // 08
	};
	static_assert(sizeof(bhkCharacterStateJumping) == 0x10);
}


===============================================
File: include/RE/B/bhkCharacterStateOnGround.h
===============================================
#pragma once

#include "RE/B/bhkCharacterState.h"

namespace RE
{
	class bhkCharacterStateOnGround : public bhkCharacterState
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterStateOnGround;

		~bhkCharacterStateOnGround() override;  // 00

		// override (bhkCharacterState)
		hkpCharacterStateType GetType() const override;  // 03 - { return kOnGround; }
		void                  Unk_08(void) override;     // 08

		// members
		std::uint64_t unk10;  // 10
	};
	static_assert(sizeof(bhkCharacterStateOnGround) == 0x18);
}


===============================================
File: include/RE/B/bhkCharacterStateSwimming.h
===============================================
#pragma once

#include "RE/B/bhkCharacterState.h"

namespace RE
{
	class bhkCharacterStateSwimming : public bhkCharacterState
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCharacterStateSwimming;

		~bhkCharacterStateSwimming() override;  // 00

		// override (bhkCharacterState)
		hkpCharacterStateType GetType() const override;  // 03 - { return kSwimming; }
		void                  Unk_08(void) override;     // 08
	};
	static_assert(sizeof(bhkCharacterStateSwimming) == 0x10);
}


===============================================
File: include/RE/B/bhkCollisionFilter.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSingleton.h"
#include "RE/H/hkpCollisionFilter.h"

namespace RE
{
	class bhkCollisionFilter : public hkpCollisionFilter
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCollisionFilter;

		[[nodiscard]] static bhkCollisionFilter* GetSingleton()
		{
			REL::Relocation<bhkCollisionFilter**> singleton{ RELOCATION_ID(514415, 400562) };
			return *singleton;
		}

		~bhkCollisionFilter() override;  // 00

		std::uint32_t GetNewSystemGroup()
		{
			nextSystemGroup = nextSystemGroup + 1;
			if (nextSystemGroup == 65535) {
				nextSystemGroup = 10;
			}
			return nextSystemGroup;
		}

		// members
		std::uint32_t unk48;                     // 048
		std::uint32_t nextSystemGroup;           // 04C
		std::uint32_t bipedBitfields[32];        // 050
		std::uint32_t layerCollisionGroups[64];  // 0D0
		std::uint64_t layerBitfields[64];        // 1D0
		std::uint64_t triggerField;              // 3D0
		std::uint64_t sensorField;               // 3D8
		BSFixedString collisionLayerNames[64];   // 3E0
		std::uint8_t  unk5E0[256];               // 5E0
		BSFixedString collisionBoneNames[32];    // 6E0
	};
	static_assert(sizeof(bhkCollisionFilter) == 0x7E0);
}


===============================================
File: include/RE/B/bhkCollisionObject.h
===============================================
#pragma once

#include "RE/B/bhkNiCollisionObject.h"

namespace RE
{
	class bhkCollisionObject : public bhkNiCollisionObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCollisionObject;
		inline static auto           Ni_RTTI = NiRTTI_bhkCollisionObject;

		~bhkCollisionObject() override;  // 00

		// override (bhkNiCollisionObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18 - { bhkNiCollisionObject::LoadBinary(a_stream); }
		void          LinkObject(NiStream& a_stream) override;            // 19 - { bhkNiCollisionObject::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return bhkNiCollisionObject::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B - { bhkNiCollisionObject::SaveBinary(a_stream); }
		void          Unk_26(void) override;                              // 26
		void          Unk_2A(void) override;                              // 2A
		void          Unk_2B(void) override;                              // 2B
		void          Unk_2C(void) override;                              // 2C
		void          Unk_2D(void) override;                              // 2D
		void          Unk_2E(void) override;                              // 2E
		void          Unk_2F(void) override;                              // 2F

		[[nodiscard]] bhkRigidBody* GetRigidBody() const
		{
			using func_t = decltype(&bhkCollisionObject::GetRigidBody);
			REL::Relocation<func_t> func{ RELOCATION_ID(12784, 20014) };
			return func(this);
		}
	};
	static_assert(sizeof(bhkCollisionObject) == 0x28);
}


===============================================
File: include/RE/B/bhkCompressedMeshShape.h
===============================================
#pragma once

#include "RE/B/bhkShapeCollection.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class bhkCompressedMeshShapeData;

	class bhkCompressedMeshShape : public bhkShapeCollection
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCompressedMeshShape;
		inline static auto           Ni_RTTI = NiRTTI_bhkCompressedMeshShape;

		~bhkCompressedMeshShape() override;  // 00

		// override (bhkShapeCollection)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
		void          Unk_2B(void) override;                              // 2B
		void          Unk_2C(void) override;                              // 2C - { return 48; }
		void          Unk_2D(void) override;                              // 2D
		void          Unk_2E(void) override;                              // 2E
		void          Unk_2F(void) override;                              // 2F
		void          Unk_32(void) override;                              // 32
		void          Unk_35(void) override;                              // 35
		void          Unk_36(void) override;                              // 36

		// members
		NiPointer<bhkCompressedMeshShapeData> data;  // 28
	};
	static_assert(sizeof(bhkCompressedMeshShape) == 0x30);
}


===============================================
File: include/RE/B/bhkCompressedMeshShapeData.h
===============================================
#pragma once

#include "RE/B/bhkMeshMaterial.h"
#include "RE/H/hkpCompressedMeshShape.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class bhkCompressedMeshShapeData : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkCompressedMeshShapeData;
		inline static auto           Ni_RTTI = NiRTTI_bhkCompressedMeshShapeData;

		~bhkCompressedMeshShapeData() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19 - { NiObject::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A - { return NiObject::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C

		//members
		std::int32_t                                                         bitsPerIndex;    // 10
		std::int32_t                                                         bitsPerWIndex;   // 14
		std::int32_t                                                         wIndexMask;      // 18
		std::int32_t                                                         indexMask;       // 1C
		float                                                                error;           // 20
		std::uint32_t                                                        pad24;           // 24
		std::uint32_t                                                        pad28;           // 28
		std::uint32_t                                                        pad2C;           // 2C
		hkAabb                                                               bounds;          // 30
		hkArray<std::uint32_t>                                               materials;       // 50
		hkArray<std::uint16_t>                                               materials16;     // 60
		hkArray<std::uint8_t>                                                materials8;      // 70
		hkArray<hkpNamedMeshMaterial>                                        namedMaterials;  // 80
		hkArray<bhkMeshMaterial>                                             meshMaterials;   // 90
		hkArray<hkQsTransform>                                               transforms;      // A0
		hkArray<hkpCompressedMeshShape::BigTriangle>                         bigTriangles;    // B0
		hkArray<hkVector4>                                                   bigVertices;     // C0
		hkArray<hkpCompressedMeshShape::Chunk>                               chunks;          // D0
		hkArray<hkpCompressedMeshShape::ConvexPiece>                         convexPieces;    // E0
		stl::enumeration<hkpWeldingUtility::WeldingType, std::uint8_t>       weldingType;     // F0
		stl::enumeration<hkpCompressedMeshShape::MaterialType, std::uint8_t> materialType;    // F1
		std::uint16_t                                                        padF2;           // F2
		std::uint32_t                                                        padF4;           // F4
		std::uint64_t                                                        padF8;           // F8
	};
	static_assert(sizeof(bhkCompressedMeshShapeData) == 0x100);
}


===============================================
File: include/RE/B/bhkContactListener.h
===============================================
#pragma once

#include "RE/H/hkpContactListener.h"

namespace RE
{
	class bhkContactListener : public hkpContactListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkContactListener;

		~bhkContactListener() override;  // 04
	};
	static_assert(sizeof(bhkContactListener) == 0x8);
}


===============================================
File: include/RE/B/bhkEntity.h
===============================================
#pragma once

#include "RE/B/bhkWorldObject.h"

namespace RE
{
	class bhkEntity : public bhkWorldObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkEntity;
		inline static auto           Ni_RTTI = NiRTTI_bhkEntity;

		~bhkEntity() override;  // 00

		// override (bhkEntity)
		const NiRTTI* GetRTTI() const override;                 // 02
		void          LoadBinary(NiStream& a_stream) override;  // 18
		void          SaveBinary(NiStream& a_stream) override;  // 1B
		void          RemoveFromCurrentWorld() override;        // 2A
		void          Unk_30(void) override;                    // 30
	};
	static_assert(sizeof(bhkEntity) == 0x28);
}


===============================================
File: include/RE/B/bhkListShape.h
===============================================
#pragma once

#include "RE/B/bhkShapeCollection.h"

namespace RE
{
	class bhkListShape : public bhkShapeCollection
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkListShape;
		inline static auto           Ni_RTTI = NiRTTI_bhkListShape;

		~bhkListShape() override;  // 00

		// override (bhkShapeCollection)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		void          AdjustRefCount(bool a_increment) override;          // 26
		void          Unk_2B(void) override;                              // 2B
		void          Unk_2C(void) override;                              // 2C - { return 40; }
		void          Unk_2D(void) override;                              // 2D
		void          Unk_2E(void) override;                              // 2E
		void          Unk_2F(void) override;                              // 2F
		void          Unk_32(void) override;                              // 32
		void          Unk_35(void) override;                              // 35
		void          Unk_36(void) override;                              // 36

		// members
		std::uint64_t unk28;  // 28
	};
	static_assert(sizeof(bhkListShape) == 0x30);
}


===============================================
File: include/RE/B/bhkMeshMaterial.h
===============================================
#pragma once

#include "RE/H/hkpMeshMaterial.h"
#include "RE/M/MaterialIDs.h"

namespace RE
{
	class bhkMeshMaterial : public hkpMeshMaterial
	{
	public:
		//members
		MATERIAL_ID materialID;  // 04
	};
	static_assert(sizeof(bhkMeshMaterial) == 0x8);
}


===============================================
File: include/RE/B/bhkNiCollisionObject.h
===============================================
#pragma once

#include "RE/N/NiCollisionObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class bhkWorldObject;

	class bhkNiCollisionObject : public NiCollisionObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkNiCollisionObject;
		inline static auto           Ni_RTTI = NiRTTI_bhkNiCollisionObject;

		enum class Flag
		{
			kNone = 0,
			kActive = 1 << 0,
			kNotify = 1 << 2,
			kSetLocal = 1 << 3,
			kDebugDisplay = 1 << 4,
			kUseVelocity = 1 << 5,
			kReset = 1 << 6,
			kSyncOnUpdate = 1 << 7,
			kAnimTargeted = 1 << 10,
			kDismemberLimb = 1 << 11
		};

		~bhkNiCollisionObject() override;  // 00

		// override (NiCollisionObject)
		const NiRTTI*         GetRTTI() const override;                          // 02
		bhkNiCollisionObject* AsBhkNiCollisionObject() override;                 // 12 - { return this; }
		void                  LoadBinary(NiStream& a_stream) override;           // 18
		void                  LinkObject(NiStream& a_stream) override;           // 19
		bool                  RegisterStreamables(NiStream& a_stream) override;  // 1A
		void                  SaveBinary(NiStream& a_stream) override;           // 1B
		bool                  IsEqual(NiObject* a_object) override;              // 1C
		void                  Unk_25(void) override;                             // 25
		void                  Unk_26(void) override;                             // 26
		void                  Unk_27(void) override;                             // 27 - { return; }

		// add
		virtual void Unk_2A(void);      // 2A
		virtual void Unk_2B(void) = 0;  // 2B
		virtual void Unk_2C(void) = 0;  // 2C
		virtual void Unk_2D(void) = 0;  // 2D
		virtual void Unk_2E(void) = 0;  // 2E
		virtual void Unk_2F(void);      // 2F
		virtual void Unk_30(void);      // 30 - { return 1; }

		// members
		stl::enumeration<Flag, std::uint32_t> flags;  // 18
		std::uint32_t                         pad1C;  // 1C
		NiPointer<bhkWorldObject>             body;   // 20
	};
	static_assert(sizeof(bhkNiCollisionObject) == 0x28);
}


===============================================
File: include/RE/B/bhkPCollisionObject.h
===============================================
#pragma once

#include "RE/B/bhkNiCollisionObject.h"

namespace RE
{
	class bhkPCollisionObject : public bhkNiCollisionObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkPCollisionObject;
		inline static constexpr auto Ni_RTTI = NiRTTI_bhkPCollisionObject;

		~bhkPCollisionObject() override;  // 00

		// override (bhkNiCollisionObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		void          Unk_2B() override;                                  // 2B
		void          Unk_2C() override;                                  // 2C
		void          Unk_2F() override;                                  // 2F
	};
	static_assert(sizeof(bhkPCollisionObject) == 0x28);
}


===============================================
File: include/RE/B/bhkPhantom.h
===============================================
#pragma once

#include "RE/B/bhkWorldObject.h"

namespace RE
{
	class bhkPhantom : public bhkWorldObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkPhantom;
		inline static auto           Ni_RTTI = NiRTTI_bhkPhantom;

		~bhkPhantom() override;  // 00

		// override (bhkWorldObject)
		const NiRTTI* GetRTTI() const override;           // 02
		void          RemoveFromCurrentWorld() override;  // 2A

		// members
		std::uint64_t unk28;  // 28
	};
	static_assert(sizeof(bhkPhantom) == 0x30);
}


===============================================
File: include/RE/B/bhkPickData.h
===============================================
#pragma once

#include "RE/H/hkpWorldRayCastInput.h"
#include "RE/H/hkpWorldRayCastOutput.h"

namespace RE
{
	class hkpClosestRayHitCollector;

	struct bhkPickData
	{
	public:
		// members
		hkpWorldRayCastInput       rayInput;                      // 00
		hkpWorldRayCastOutput      rayOutput;                     // 30
		hkVector4                  ray;                           // 90
		hkpClosestRayHitCollector* rayHitCollectorA0{ nullptr };  // A0
		hkpClosestRayHitCollector* rayHitCollectorA8{ nullptr };  // A8
		hkpClosestRayHitCollector* rayHitCollectorB0{ nullptr };  // B0
		hkpClosestRayHitCollector* rayHitCollectorB8{ nullptr };  // B8
		bool                       unkC0{ false };                // C0
		std::uint8_t               padC1;                         // C1
		std::uint16_t              padC2;                         // C2
		std::uint32_t              padC4;                         // C4
		std::uint32_t              padC8;                         // C8
	};
	static_assert(sizeof(bhkPickData) == 0xD0);
}


===============================================
File: include/RE/B/bhkRefObject.h
===============================================
#pragma once

#include "RE/H/hkRefPtr.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class hkReferencedObject;

	class bhkRefObject : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkRefObject;
		inline static auto           Ni_RTTI = NiRTTI_bhkRefObject;

		~bhkRefObject() override;  // 00

		// override(NiObject)
		[[nodiscard]] const NiRTTI* GetRTTI() const override;  // 02

		// add
		virtual void SetReferencedObject(hkReferencedObject* a_object);  // 25
		virtual void AdjustRefCount(bool a_increment);                   // 26

		// members
		hkRefPtr<hkReferencedObject> referencedObject;  // 10
	};
	static_assert(sizeof(bhkRefObject) == 0x18);
}


===============================================
File: include/RE/B/bhkRigidBody.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/bhkEntity.h"

namespace RE
{
	class hkAabb;
	class hkTransform;
	class hkQuaternion;
	class hkVector4;

	class bhkRigidBody : public bhkEntity
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkRigidBody;
		inline static auto           Ni_RTTI = NiRTTI_bhkRigidBody;

		~bhkRigidBody() override;  // 00

		// override (bhkEntity)
		const NiRTTI* GetRTTI() const override;                           // 02
		bhkRigidBody* AsBhkRigidBody() override;                          // 15 - { return this; }
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
		void          MoveToWorld(bhkWorld* a_world) override;            // 29
		void          RemoveFromCurrentWorld() override;                  // 2A
		void          Unk_2B(void) override;                              // 2B
		void          Unk_2C(void) override;                              // 2C - { return 0x110; }
		void          Unk_2D(void) override;                              // 2D
		void          Unk_2E(void) override;                              // 2E
		void          Unk_2F(void) override;                              // 2F
		void          Unk_30(void) override;                              // 30
		void          Unk_32(void) override;                              // 32

		// add
		virtual void GetPosition(hkVector4& a_outPosition);                                    // 33
		virtual void GetRotation(hkQuaternion& a_outRotation);                                 // 34
		virtual void SetPosition(hkVector4& a_position);                                       // 35
		virtual void SetRotation(hkQuaternion& a_rotation);                                    // 36
		virtual void SetPositionAndRotation(hkVector4& a_position, hkQuaternion& a_rotation);  // 37
		virtual void GetCenterOfMassLocal(hkVector4& a_outCenterOfMassLocal);                  // 38
		virtual void GetCenterOfMassWorld(hkVector4& a_outCenterOfMassWorld);                  // 39
		virtual void GetTransform(hkTransform& a_outTransform);                                // 3A
		virtual void GetAabbWorldspace(hkAabb& a_outAabb);                                     // 3B
		virtual void Unk_3C(void);                                                             // 3C

		void SetAngularImpulse(const hkVector4& a_impulse);
		void SetAngularVelocity(const hkVector4& a_newVel);
		void SetLinearImpulse(const hkVector4& a_impulse);
		void SetLinearVelocity(const hkVector4& a_newVel);

		// members
		BSTArray<void*> unk28;  // 28 - array of smart ptrs to bhkConstraints
	};
	static_assert(sizeof(bhkRigidBody) == 0x40);
}


===============================================
File: include/RE/B/bhkSPCollisionObject.h
===============================================
#pragma once

#include "RE/B/bhkPCollisionObject.h"

namespace RE
{
	class bhkSPCollisionObject : public bhkPCollisionObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkSPCollisionObject;
		inline static constexpr auto Ni_RTTI = NiRTTI_bhkSPCollisionObject;

		~bhkSPCollisionObject() override;  // 00

		// override (bhkSPCollisionObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		void          Unk_2B() override;                                  // 2B
		void          Unk_2C() override;                                  // 2C
	};
	static_assert(sizeof(bhkSPCollisionObject) == 0x28);
}


===============================================
File: include/RE/B/bhkSerializable.h
===============================================
#pragma once

#include "RE/B/bhkRefObject.h"

namespace RE
{
	class ahkpWorld;
	class hkpWorld;
	class bhkWorld;

	class bhkSerializable : public bhkRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkSerializable;
		inline static auto           Ni_RTTI = NiRTTI_bhkSerializable;

		~bhkSerializable() override;  // 00

		// override (bhkRefObject)
		const NiRTTI* GetRTTI() const override;                                    // 02
		void          LoadBinary(NiStream& a_stream) override;                     // 18
		void          LinkObject(NiStream& a_stream) override;                     // 19
		bool          RegisterStreamables(NiStream& a_stream) override;            // 1A - { return NiObject::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;                     // 1B
		void          SetReferencedObject(hkReferencedObject* a_object) override;  // 25

		// add
		virtual hkpWorld*  GetWorld1();                     // 27 - { return 0; }
		virtual ahkpWorld* GetWorld2();                     // 28 - { return 0; }
		virtual void       MoveToWorld(bhkWorld* a_world);  // 29
		virtual void       RemoveFromCurrentWorld();        // 2A
		virtual void       Unk_2B(void);                    // 2B
		virtual void       Unk_2C(void);                    // 2C - { return 1; }
		virtual void       Unk_2D(void);                    // 2D
		virtual void       Unk_2E(void) = 0;                // 2E
		virtual void       Unk_2F(void) = 0;                // 2F
		virtual void       Unk_30(void);                    // 30
		virtual void       Unk_31(void);                    // 31

		// members
		bhkSerializable* serializable;  // 18
	};
	static_assert(sizeof(bhkSerializable) == 0x20);
}


===============================================
File: include/RE/B/bhkShape.h
===============================================
#pragma once

#include "RE/B/bhkMeshMaterial.h"
#include "RE/B/bhkSerializable.h"
#include "RE/H/hkpShape.h"

namespace RE
{
	class bhkShape : public bhkSerializable
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkShape;
		inline static auto           Ni_RTTI = NiRTTI_bhkShape;
		inline static constexpr auto VTABLE = VTABLE_bhkShape;

		~bhkShape() override;  // 00

		// override (bhkSerializable)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19 - { bhkSerializable::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A - { return bhkSerializable::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C
		void          AdjustRefCount(bool a_increment) override;         // 26

		// add
		virtual void Unk_32(void);  // 32
		virtual void Unk_33(void);  // 33
		virtual void Unk_34(void);  // 34 - { return 0; }
		virtual void Unk_35(void);  // 35

		[[nodiscard]] MATERIAL_ID GetMaterialID(hkpShapeKey a_key) const
		{
			using func_t = decltype(&bhkShape::GetMaterialID);
			REL::Relocation<func_t> func{ RELOCATION_ID(76799, 78676) };
			return func(this, a_key);
		}

		// members
		MATERIAL_ID   materialID;  // 20
		std::uint32_t filterInfo;  // 24
	};
	static_assert(sizeof(bhkShape) == 0x28);
}


===============================================
File: include/RE/B/bhkShapeCollection.h
===============================================
#pragma once

#include "RE/B/bhkShape.h"

namespace RE
{
	class bhkShapeCollection : public bhkShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkShapeCollection;
		inline static auto           Ni_RTTI = NiRTTI_bhkShapeCollection;

		~bhkShapeCollection() override;  // 00

		// override (bhkShape)
		const NiRTTI* GetRTTI() const override;  // 02
		void          Unk_34(void) override;     // 34 - { return this; }
		void          Unk_35(void) override;     // 35

		// add
		virtual void Unk_36(void) = 0;  // 36
	};
	static_assert(sizeof(bhkShapeCollection) == 0x28);
}


===============================================
File: include/RE/B/bhkShapePhantom.h
===============================================
#pragma once

#include "RE/B/bhkPhantom.h"

namespace RE
{
	class bhkShapePhantom : public bhkPhantom
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkShapePhantom;
		inline static auto           Ni_RTTI = NiRTTI_bhkShapePhantom;

		~bhkShapePhantom() override;  // 00

		// override (bhkPhantom)
		const NiRTTI* GetRTTI() const override;                 // 02
		void          LinkObject(NiStream& a_stream) override;  // 19 - { bhkWorldObject::LinkObject(a_stream); }
	};
	static_assert(sizeof(bhkShapePhantom) == 0x30);
}


===============================================
File: include/RE/B/bhkThreadMemorySource.h
===============================================
#pragma once

#include "RE/H/hkMemoryAllocator.h"
#include "RE/I/IMemoryHeap.h"

namespace RE
{
	class HeapBlock;
	class HeapBlockFreeHead;

	class bhkThreadMemorySource :
		public hkMemoryAllocator,  // 00
		public IMemoryHeap         // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkThreadMemorySource;

		struct FreeBlock
		{
		public:
			// members
			FreeBlock* next;  // 0
		};
		static_assert(sizeof(FreeBlock) == 0x8);

		struct BlockPage
		{
		public:
			// members
			BlockPage*    left;       // 00
			BlockPage*    right;      // 08
			FreeBlock*    blocks;     // 10
			std::uint16_t totalElem;  // 18
			std::uint16_t freeElem;   // 1A
			std::uint32_t pad1C;      // 1C
		};
		static_assert(sizeof(BlockPage) == 0x20);

		struct Row
		{
		public:
			// members
			BlockPage*   pageList;              // 00
			BlockPage*   currAlloc;             // 08
			std::int32_t totalFreeBlocks;       // 10
			std::int32_t totalAllocatedBlocks;  // 14
			std::int32_t totalBytes;            // 18
			std::int32_t elemSize;              // 1C
		};
		static_assert(sizeof(Row) == 0x20);

		struct MegaBlockPage
		{
		public:
			// members
			char           mem[sizeof(BlockPage[255]) * 256];  // 000000
			BlockPage      blockPages[255];                    // 1FE000
			MegaBlockPage* left;                               // 1FFFE0
			MegaBlockPage* right;                              // 1FFFE8
			BlockPage*     freeBlockPages;                     // 1FFFF0
			std::uint16_t  numFreeBlockPages;                  // 1FFFF8
			std::uint16_t  nextBlockPageAlloc;                 // 1FFFFA
			bool           decommitted;                        // 1FFFFC
			std::uint8_t   pad1FFFFD;                          // 1FFFFD
			std::uint16_t  pad1FFFFE;                          // 1FFFFE
		};
		static_assert(sizeof(MegaBlockPage) == 0x200000);

		~bhkThreadMemorySource() override;  // 00

		// override (hkMemoryAllocator)
		void*        BlockAlloc(std::int32_t a_numBytes) override;                                                       // 01
		void         BlockFree(void* a_ptr, std::int32_t a_numBytes) override;                                           // 02
		void*        BufAlloc(std::int32_t& a_reqNumBytesInOut) override;                                                // 03
		void         BufFree(void* a_ptr, std::int32_t a_numBytes) override;                                             // 04
		void*        BufRealloc(void* a_ptrOld, std::int32_t a_oldNumBytes, std::int32_t& a_reqNumBytesInOut) override;  // 05
		void         BlockAllocBatch(void** a_ptrsOut, std::int32_t a_numPtrs, std::int32_t a_blockSize) override;       // 06
		void         BlockFreeBatch(void** a_ptrsIn, std::int32_t a_numPtrs, std::int32_t a_blockSize) override;         // 07
		void         GetMemoryStatistics(MemoryStatistics& a_usage) override;                                            // 08
		std::int32_t GetAllocatedSize(const void* a_obj, std::int32_t a_numBytes) override;                              // 09

		// override (IMemoryHeap)
		std::size_t                 Size(const void* a_block) const override;                                      // 01
		void                        GetMemoryStats(MemoryStats* a_stats) override;                                 // 02
		const char*                 GetName() const override;                                                      // 07 - { return "bhkThreadMemorySource"; }
		void*                       Allocate(std::size_t a_size, std::uint32_t a_alignment) override;              // 08
		void                        Deallocate(void* a_pointer, std::uint32_t) override;                           // 09
		bool                        PointerInHeap(const void* a_pointer) const override;                           // 0A
		std::size_t                 TotalSize(const void* a_pointer) const override;                               // 0B
		void                        GetHeapStats(HeapStats* a_stats, bool a_fullBlockInfo) override;               // 0C
		bool                        ShouldTrySmallBlockPools(std::size_t a_size, MEM_CONTEXT a_context) override;  // 0D
		[[nodiscard]] std::uint32_t GetPageSize() const override;                                                  // 0E

		// members
		BSCriticalSection  lock;                    // 10
		Row*               rows;                    // 38
		std::uint16_t*     smallRowIndexes;         // 40
		std::uint16_t*     largeRowIndexes;         // 48
		HeapBlock**        lists;                   // 50
		HeapBlockFreeHead* largeFreeTrees;          // 58
		HeapBlock*         firstBlock;              // 60
		HeapBlock*         lastBlock;               // 68
		void*              memoryRoot;              // 70
		char*              allocBase;               // 78
		char*              blockStart;              // 80
		char*              allocEnd;                // 88
		char*              commitEnd;               // 90
		char*              blockPageCommit;         // 98
		char*              addressSpaceEnd;         // A0
		MegaBlockPage*     megaBlockPageList;       // A8
		MegaBlockPage*     currMegaBlockPageAlloc;  // B0
		std::int32_t       addressSpaceSize;        // B8
		std::int32_t       totalFreeBlockPages;     // BC
		std::uint32_t      usedRows;                // C0
		std::int32_t       totalAllocated;          // C4
		std::int32_t       totalFreeBlocks;         // C8
		std::int32_t       totalBlocks;             // CC
		bool               allowDecommits;          // D0
		std::uint8_t       padD1;                   // D1
		std::uint16_t      padD2;                   // D2
		std::uint32_t      padD4;                   // D4
	};
	static_assert(sizeof(bhkThreadMemorySource) == 0xD8);
}


===============================================
File: include/RE/B/bhkWorld.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/bhkSerializable.h"

namespace RE
{
	struct bhkPickData;
	class BGSAcousticSpaceListener;
	class hkpSuspendInactiveAgentsUtil;
	class NiAVObject;

	class bhkWorld : public bhkSerializable
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkWorld;
		inline static auto           Ni_RTTI = NiRTTI_bhkWorld;
		inline static constexpr auto VTABLE = VTABLE_bhkWorld;

		class bhkConstraintProjector;

		~bhkWorld() override;  // 00

		// override (bhkSerializable)
		const NiRTTI* GetRTTI() const override;                                    // 02
		void          SetReferencedObject(hkReferencedObject* a_object) override;  // 25
		void          AdjustRefCount(bool a_increment) override;                   // 26
		hkpWorld*     GetWorld1() override;                                        // 27 - { return referencedObject.ptr; }
		ahkpWorld*    GetWorld2() override;                                        // 28 - { return referencedObject.ptr; }
		void          Unk_2B(void) override;                                       // 2B
		void          Unk_2C(void) override;                                       // 2C - { return 1; }
		void          Unk_2E(void) override;                                       // 2E
		void          Unk_2F(void) override;                                       // 2F

		// add
		virtual void Unk_32(void);                                              // 32
		virtual bool PickObject(bhkPickData& a_pickData);                       // 33
		virtual void Unk_34(void);                                              // 34
		virtual void Unk_35(void);                                              // 35
		virtual void InitHavok(NiAVObject* a_sceneObject, NiAVObject* a_root);  // 36

		static float GetWorldScale()
		{
			REL::Relocation<float*> worldScale{ RELOCATION_ID(231896, 188105) };
			return *worldScale;
		}

		static float GetWorldScaleInverse()
		{
			REL::Relocation<float*> worldScaleInverse{ RELOCATION_ID(230692, 187407) };
			return *worldScaleInverse;
		}

		// members
		std::uint8_t                  unk0020[0x320];             // 0020
		std::uint8_t                  unk0340[0x6400];            // 0340
		std::uint8_t                  unk6740[0x5DC0];            // 6740
		BSTArray<void*>               unkC500;                    // C500
		BSTArray<void*>               unkC518;                    // C518
		BSTArray<void*>               unkC530;                    // C530
		BSTArray<void*>               unkC548;                    // C548
		std::uint64_t                 unkC560;                    // C560
		std::uint32_t                 unkC568;                    // C568
		float                         unkC56C;                    // C56C
		bhkConstraintProjector*       constraintProjector;        // C570
		std::uint64_t                 unkC578;                    // C578
		std::uint32_t                 unkC580;                    // C580
		float                         unkC584;                    // C584
		std::uint64_t                 unkC588;                    // C588
		std::uint64_t                 unkC590;                    // C590
		mutable BSReadWriteLock       worldLock;                  // C598
		mutable BSReadWriteLock       unkC5A0;                    // C5A0
		std::uint64_t                 unkC5A8;                    // C5A8
		hkVector4                     unkC5B0;                    // C5B0
		std::uint64_t                 unkC5C0;                    // C5C0
		BGSAcousticSpaceListener*     acousticSpaceListener;      // C5C8
		hkpSuspendInactiveAgentsUtil* suspendInactiveAgentsUtil;  // C5D0
		std::uint32_t                 unkC5D8;                    // C5D8 - incremented per frame
		std::uint32_t                 unkC5DC;                    // C5DC
		std::uint32_t                 unkC5E0;                    // C5E0
		std::uint32_t                 unkC5E4;                    // C5E4
		std::uint32_t                 unkC5E8;                    // C5E8
		std::uint32_t                 unkC5EC;                    // C5EC
		float                         tau;                        // C5F0
		float                         damping;                    // C5F4
		std::uint8_t                  unkC5F8;                    // C5F8
		bool                          toggleCollision;            // C5F9
		std::uint16_t                 unkC5FA;                    // C5FA
		std::uint16_t                 unkC5FC;                    // C5FC
		std::uint16_t                 unkC5FE;                    // C5FE
	};
	static_assert(sizeof(bhkWorld) == 0xC600);
}


===============================================
File: include/RE/B/bhkWorldObject.h
===============================================
#pragma once

#include "RE/B/bhkSerializable.h"

namespace RE
{
	class bhkWorldObject : public bhkSerializable
	{
	public:
		inline static constexpr auto RTTI = RTTI_bhkWorldObject;
		inline static auto           Ni_RTTI = NiRTTI_bhkWorldObject;

		~bhkWorldObject() override;  // 00

		// override (bhkSerializable)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		void          AdjustRefCount(bool a_increment) override;         // 26
		hkpWorld*     GetWorld1() override;                              // 27 - { return world; }
		ahkpWorld*    GetWorld2() override;                              // 28 - { return world; }
		void          MoveToWorld(bhkWorld* a_world) override;           // 29

		// add
		virtual void Unk_32(void);  // 32 - { return Unk_29(); }

		// members
		hkpWorld* world;  // 20
	};
	static_assert(sizeof(bhkWorldObject) == 0x28);
}


===============================================
File: include/RE/C/CFilter.h
===============================================
#pragma once

#include "RE/C/CollisionLayers.h"

namespace RE
{
	enum class BIPED_PART
	{
		kOther = 0,
		kHead = 1,
		kBody = 2,
		kSpine1 = 3,
		kSpine2 = 4,
		kLUpperArm = 5,
		kLForearm = 6,
		kLHand = 7,
		kLThigh = 8,
		kLCalf = 9,
		kLFoot = 10,
		kRUpperArm = 11,
		kRForearm = 12,
		kRHand = 13,
		kRThigh = 14,
		kRCalf = 15,
		kRFoot = 16,
		kTail = 17,
		kShield = 18,
		kQuiver = 19,
		kWeapon = 20,
		kPonyTail = 21,
		kWing = 22,
		kPack = 23,
		kChain = 24,
		kAddonHead = 25,
		kAddonChest = 26,
		kAddonLeg = 27,
		kAddonArm = 28
	};

	class CFilter
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kNoCollision = 1 << 14,

			kLayerMask = 0x7F  // COL_LAYER
		};

		// members
		stl::enumeration<Flag, std::uint32_t> flags;  // 0
	};
	static_assert(sizeof(CFilter) == 0x4);
}


===============================================
File: include/RE/C/CRC.h
===============================================
#pragma once

namespace RE
{
	namespace detail
	{
		[[nodiscard]] constexpr std::uint32_t GenerateCRC32(std::span<const std::uint8_t> a_data) noexcept
		{
			constexpr std::array<std::uint32_t, 256> table{
				0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
				0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
				0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
				0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
				0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
				0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
				0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
				0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
				0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
				0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
				0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
				0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
				0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
				0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
				0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
				0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
				0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
				0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
				0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
				0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
				0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
				0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
				0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
				0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
				0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
				0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
				0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
				0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
				0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
				0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
				0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
				0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
			};

			std::uint32_t hash = 0;
			for (const auto byte : a_data) {
				hash = (hash >> 8) ^ table[(hash ^ byte) & 0xFF];
			}
			return hash;
		}

		template <class, bool>
		struct BSCRC32;

		template <class Key>
		struct BSCRC32<Key, true>
		{
		public:
		};
	}

	template <class Key>
	struct BSCRC32_;

	template <class Key>
	struct BSCRC32_ :
		public detail::BSCRC32<
			Key,
			std::disjunction_v<
				std::is_arithmetic<Key>,
				std::is_enum<Key>,
				std::is_pointer<Key>>>
	{
	public:
		[[nodiscard]] inline std::uint32_t operator()(Key a_data) const noexcept
		{
			return detail::GenerateCRC32({ reinterpret_cast<const std::uint8_t*>(std::addressof(a_data)), sizeof(Key) });
		}
	};

	template <class CharT>
	struct BSCRC32_<std::basic_string_view<CharT>>
	{
	public:
		[[nodiscard]] inline std::uint32_t operator()(std::basic_string_view<CharT> a_data) const noexcept
		{
			return detail::GenerateCRC32({ reinterpret_cast<const std::uint8_t*>(a_data.data()), a_data.size() });
		}
	};

	template <>
	struct BSCRC32_<std::nullptr_t>
	{
	public:
		[[nodiscard]] inline std::uint32_t operator()(std::nullptr_t) const noexcept
		{
			return BSCRC32_<std::uintptr_t>()(0);
		}
	};

	template <class T>
	struct BSCRC32 :
		public BSCRC32_<
			std::remove_cv_t<T>>
	{};
}


===============================================
File: include/RE/C/Calendar.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"

namespace RE
{
	class TESGlobal;

	class Calendar : public BSTSingletonSDM<Calendar>
	{
	public:
		static constexpr std::uint8_t DAYS_IN_MONTH[] = {
			31,  // Morning Star
			28,  // Sun's Dawn
			31,  // First Seed
			30,  // Rain's Hand
			31,  // Second Seed
			30,  // Midyear
			31,  // Sun's Height
			31,  // Last Seed
			30,  // Hearthfire
			31,  // Frostfall
			30,  // Sun's Dusk
			31   // Evening Star
		};

		struct Days
		{
			enum Day
			{
				kSundas,
				kMorndas,
				kTirdas,
				kMiddas,
				kTurdas,
				kFredas,
				kLoredas,
				kTotal
			};
		};
		using Day = Days::Day;

		struct Months
		{
			enum Month
			{
				kMorningStar,
				kSunsDawn,
				kFirstSeed,
				kRainsHand,
				kSecondSeed,
				kMidyear,
				kSunsHeight,
				kLastSeed,
				kHearthfire,
				kFrostfall,
				kSunsDusk,
				kEveningStar,
				kTotal
			};
		};
		using Month = Months::Month;

		static Calendar* GetSingleton();

		[[nodiscard]] float         GetCurrentGameTime() const;
		[[nodiscard]] float         GetDay() const;
		[[nodiscard]] std::string   GetDayName() const;
		[[nodiscard]] std::uint32_t GetDayOfWeek() const;
		[[nodiscard]] float         GetDaysPassed() const;
		void                        GetTimeDateString(char* a_dest, std::uint32_t a_max, bool a_showYear) const;
		[[nodiscard]] float         GetHour() const;
		[[nodiscard]] float         GetHoursPassed() const;
		[[nodiscard]] float         GetHoursPerDay() const;
		[[nodiscard]] std::uint32_t GetMonth() const;
		[[nodiscard]] std::string   GetMonthName() const;
		[[nodiscard]] std::tm       GetTime() const;
		[[nodiscard]] float         GetTimescale() const;
		[[nodiscard]] std::uint32_t GetYear() const;

		// members
		std::uint8_t  pad01;            // 01
		std::uint16_t pad02;            // 02
		std::uint32_t pad04;            // 04
		TESGlobal*    gameYear;         // 08
		TESGlobal*    gameMonth;        // 10
		TESGlobal*    gameDay;          // 18
		TESGlobal*    gameHour;         // 20
		TESGlobal*    gameDaysPassed;   // 28
		TESGlobal*    timeScale;        // 30
		std::uint32_t midnightsPassed;  // 38
		float         rawDaysPassed;    // 3C
	};
	static_assert(sizeof(Calendar) == 0x40);
}


===============================================
File: include/RE/C/CalmEffect.h
===============================================
#pragma once

#include "RE/T/TargetValueModifierEffect.h"

namespace RE
{
	class CalmEffect : public TargetValueModifierEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_CalmEffect;
		inline static constexpr auto VTABLE = VTABLE_CalmEffect;

		// override (TargetValueModifierEffect)
		~CalmEffect() override;  // 13

		void  Start() override;                 // 14
		float GetTargetValue() const override;  // 21 - { return -1.0f; }
	};
	static_assert(sizeof(CalmEffect) == 0x98);
}


===============================================
File: include/RE/C/CharEvent.h
===============================================
#pragma once

#include "RE/I/InputEvent.h"

namespace RE
{
	class CharEvent : public InputEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_CharEvent;

		~CharEvent() override;  // 00

		// members
		std::uint32_t keycode;  // 18
		std::uint32_t pad1C;    // 1C
	};
	static_assert(sizeof(CharEvent) == 0x20);
}


===============================================
File: include/RE/C/Character.h
===============================================
#pragma once

#include "RE/A/Actor.h"

namespace RE
{
	class Character : public Actor
	{
	public:
		inline static constexpr auto RTTI = RTTI_Character;
		inline static constexpr auto VTABLE = VTABLE_Character;
		inline static constexpr auto FORMTYPE = FormType::ActorCharacter;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kStartsDead = 1 << 9,
				kPersistent = 1 << 10,
				kInitiallyDisabled = 1 << 11,
				kIgnored = 1 << 12,
				kNoAIAcquire = 1 << 25,
				kDontHavokSettle = 1 << 29
			};
		};

		~Character() override;  // 000

		// override (Actor)
		void                                  SaveGame(BGSSaveFormBuffer* a_buf) override;                   // 00E - { Actor::SaveBuffer(a_buf); }
		void                                  LoadGame(BGSLoadFormBuffer* a_buf) override;                   // 00F - { Actor::LoadBuffer(a_buf); }
		void                                  InitLoadGame(BGSLoadFormBuffer* a_buf) override;               // 010 - { Actor::InitLoadGame(a_arg1); }
		void                                  FinishLoadGame(BGSLoadFormBuffer* a_buf) override;             // 011 - { Actor::FinishLoadGame(a_arg1); }
		void                                  Revert(BGSLoadFormBuffer* a_buf) override;                     // 012 - { return; }
		void                                  Predestroy(void) override;                                     // 03B
		[[nodiscard]] bool                    IsChild() const override;                                      // 05E - { return race ? (race->data.flags & Flag::kChild) != Flag::kNone : false; }
		[[nodiscard]] BSFaceGenNiNode*        GetFaceNodeSkinned() override;                                 // 061
		[[nodiscard]] BSFaceGenAnimationData* GetFaceGenAnimationData() override;                            // 063
		void                                  SetBiped(const BSTSmartPointer<BipedAnim>& a_biped) override;  // 081
#ifndef SKYRIM_CROSS_VR
		void  InitiateVampireFeedPackage(Actor* a_arg1, TESObjectREFR* a_arg2) override;  // 0C0
		void  Unk_C4(void) override;                                                      // 0C4 - { unk272 = a_arg1; }
		void  Unk_C5(void) override;                                                      // 0C5 - { return unk272; }
		void  Unk_C6(void) override;                                                      // 0C6 - { return 1; }
		void  OnArmorActorValueChanged() override;                                        // 0CA
		bool  InitiateTresPassPackage(TrespassPackage* a_trespassPackage) override;       // 0D7
		void  SetSize(float a_size) override;                                             // 0D9
		float CalcArmorRating() override;                                                 // 0E6
		float GetArmorBaseFactorSum() override;                                           // 0E7
		float CalcUnarmedDamage() override;                                               // 0E8
		void  PrecacheData(void) override;                                                // 120
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void Unk_128(void);  // 128
		SKYRIM_REL_VR_VIRTUAL void Unk_129(void);  // 129 - { return 1; }
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(Character) == 0x2B0);
#endif
}


===============================================
File: include/RE/C/ChestsLooted.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	struct ChestsLooted
	{
	public:
		struct Event
		{
		public:
		};
		static_assert(std::is_empty_v<Event>);

		static BSTEventSource<Event>* GetEventSource();
		static void                   SendEvent();
	};
	static_assert(std::is_empty_v<ChestsLooted>);
}


===============================================
File: include/RE/C/CloakEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class CloakEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_CloakEffect;
		inline static constexpr auto VTABLE = VTABLE_CloakEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;  // 04
		virtual ~CloakEffect();                       // 13

		// members
		std::uint64_t nextTargetCheck;  // 90
	};
	static_assert(sizeof(CloakEffect) == 0x98);
}


===============================================
File: include/RE/C/Clouds.h
===============================================
#pragma once

#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/S/SkyObject.h"

namespace RE
{
	class BSGeometry;
	class NiTexture;

	class Clouds : public SkyObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_Clouds;
		inline static constexpr auto VTABLE = VTABLE_Clouds;

		enum
		{
			kTotalLayers = 32
		};

		~Clouds() override;  // 00

		// override (SkyObject)
		void Init(NiNode* a_root) override;              // 02
		void Update(Sky* a_sky, float a_arg2) override;  // 03

		// members
		NiPointer<BSGeometry> clouds[kTotalLayers];        // 010
		std::uint64_t         unk110[kTotalLayers];        // 110
		NiPointer<NiTexture>  transTexture[kTotalLayers];  // 210
		NiColor               colors[kTotalLayers];        // 310
		float                 alphas[kTotalLayers];        // 490
		std::uint16_t         numLayers;                   // 510
		bool                  forceUpdate;                 // 512
		std::uint8_t          pad513;                      // 513
		std::uint32_t         pad514;                      // 514
		std::uint64_t         pad520;                      // 520
	};
	static_assert(sizeof(Clouds) == 0x520);
}


===============================================
File: include/RE/C/CodeTasklet.h
===============================================
#pragma once

#include "RE/I/IFuncCallQuery.h"

namespace RE
{
	namespace BSScript
	{
		class ErrorLogger;
		class Stack;
		class StackFrame;

		namespace Internal
		{
			class VirtualMachine;

			class CodeTasklet : public IFuncCallQuery
			{
			public:
				inline static constexpr auto RTTI = RTTI_BSScript__Internal__CodeTasklet;

				enum class ResumeReason
				{
					kNotResuming = 0,
					kNotResumingNoIncrement = 1,
					kInitialStart = 2,
					kFunctionReturn = 3,
					kRetryInstruction = 4,
					kFunctionCall = 5
				};

				enum class OpCode
				{
					kNOP,
					kIADD,
					kFADD,
					kISUB,
					kFSUB,
					kIMUL,
					kFMUL,
					kIDIV,
					kFDIV,
					kIMOD,
					kNOT,
					kINEG,
					kFNEG,
					kASSIGN,
					kCAST,
					kCMP_EQ,
					kCMP_LT,
					kCMP_LTE,
					kCMP_GT,
					kCMP_GTE,
					kJMP,
					kJMPT,
					kJMPF,
					kCALLMETHOD,
					kCALLPARENT,
					kCALLSTATIC,
					kRETURN,
					kSTRCAT,
					kPROPGET,
					kPROPSET,
					kARRAY_CREATE,
					kARRAY_LENGTH,
					kARRAY_GETELEMENT,
					kARRAY_SETELEMENT,
					kARRAY_FINDELEMENT,
					kARRAY_RFINDELEMENT
				};

				~CodeTasklet() override;  // 00

				// override (IFuncCallQuery)
				bool GetFunctionCallInfo(CallType& a_callType, BSTSmartPointer<ObjectTypeInfo>& a_arg2, BSFixedString& a_arg3, Variable& a_arg4, BSScrapArray<Variable>& a_arg5) override;  // 01

				// members
				Stack*                                        stack;                    // 10
				VirtualMachine*                               vm;                       // 18
				ErrorLogger*                                  errorLogger;              // 20
				stl::enumeration<ResumeReason, std::uint32_t> resumeReason;             // 28
				std::uint32_t                                 pad2C;                    // 2C
				StackFrame*                                   topFrame;                 // 30
				std::uint32_t                                 frameMemoryPage;          // 38
				std::int8_t                                   jumpBitCount;             // 3C
				std::int8_t                                   localVarBitCount;         // 3D
				std::int8_t                                   memberVarBitCount;        // 3E
				std::uint8_t                                  pad3F;                    // 3F
				std::uint32_t                                 instructionDataBitCount;  // 40
				std::uint32_t                                 pad44;                    // 44
				const void*                                   instructionDataStart;     // 48
			};
			static_assert(sizeof(CodeTasklet) == 0x50);
		}
	}
}


===============================================
File: include/RE/C/CollisionLayers.h
===============================================
#pragma once

namespace RE
{
	enum class COL_LAYER
	{
		kUnidentified = 0,
		kStatic = 1,
		kAnimStatic = 2,
		kTransparent = 3,
		kClutter = 4,
		kWeapon = 5,
		kProjectile = 6,
		kSpell = 7,
		kBiped = 8,
		kTrees = 9,
		kProps = 10,
		kWater = 11,
		kTrigger = 12,
		kTerrain = 13,
		kTrap = 14,
		kNonCollidable = 15,
		kCloudTrap = 16,
		kGround = 17,
		kPortal = 18,
		kDebrisSmall = 19,
		kDebrisLarge = 20,
		kAcousticSpace = 21,
		kActorZone = 22,
		kProjectileZone = 23,
		kGasTrap = 24,
		kShellCasting = 25,
		kTransparentWall = 26,
		kInvisibleWall = 27,
		kTransparentSmallAnim = 28,
		kClutterLarge = 29,
		kCharController = 30,
		kStairHelper = 31,
		kDeadBip = 32,
		kBipedNoCC = 33,
		kAvoidBox = 34,
		kCollisionBox = 35,
		kCameraSphere = 36,
		kDoorDetection = 37,
		kConeProjectile = 38,
		kCamera = 39,
		kItemPicker = 40,
		kLOS = 41,
		kPathingPick = 42,
		kUnused0 = 43,
		kUnused1 = 44,
		kSpellExplosion = 45,
		kDroppingPick = 46
	};
}


===============================================
File: include/RE/C/Color.h
===============================================
#pragma once

namespace RE
{
	class NiColor;

	struct Color
	{
	public:
		enum : std::size_t
		{
			kRed,
			kGreen,
			kBlue,
			kAlpha,

			kTotal
		};

		constexpr Color() noexcept :
			red(0),
			green(0),
			blue(0),
			alpha(0)
		{}

		constexpr Color(const Color& a_rhs) noexcept :
			red(a_rhs.red),
			green(a_rhs.green),
			blue(a_rhs.blue),
			alpha(a_rhs.alpha)
		{}

		constexpr Color(Color&& a_rhs) noexcept :
			red(std::move(a_rhs.red)),
			green(std::move(a_rhs.green)),
			blue(std::move(a_rhs.blue)),
			alpha(std::move(a_rhs.alpha))
		{}

		constexpr Color(std::uint8_t a_red, std::uint8_t a_green, std::uint8_t a_blue, std::uint8_t a_alpha) noexcept :
			red(a_red),
			green(a_green),
			blue(a_blue),
			alpha(a_alpha)
		{}

		constexpr Color(std::uint32_t a_hexValue) noexcept :
			red((a_hexValue >> 16) & 0xFF),
			green((a_hexValue >> 8) & 0xFF),
			blue((a_hexValue)&0xFF),
			alpha(0)
		{}

		Color(const NiColor& a_rhs);
		~Color() noexcept = default;

		constexpr Color& operator=(const Color& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				red = a_rhs.red;
				green = a_rhs.green;
				blue = a_rhs.blue;
				alpha = a_rhs.alpha;
			}
			return *this;
		}

		constexpr Color& operator=(Color&& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				red = std::move(a_rhs.red);
				green = std::move(a_rhs.green);
				blue = std::move(a_rhs.blue);
				alpha = std::move(a_rhs.alpha);
			}
			return *this;
		}

		[[nodiscard]] friend constexpr bool operator==(const Color& a_lhs, const Color& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				if (a_lhs[i] != a_rhs[i]) {
					return false;
				}
			}
			return true;
		}

		[[nodiscard]] friend constexpr bool operator!=(const Color& a_lhs, const Color& a_rhs) noexcept
		{
			return !(a_lhs == a_rhs);
		}

		[[nodiscard]] constexpr std::uint8_t& operator[](std::size_t a_idx) noexcept
		{
			assert(a_idx < kTotal);
			return std::addressof(red)[a_idx];
		}

		[[nodiscard]] constexpr const std::uint8_t& operator[](std::size_t a_idx) const noexcept
		{
			assert(a_idx < kTotal);
			return std::addressof(red)[a_idx];
		}

		[[nodiscard]] Color operator+(const Color& a_rhs) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] += a_rhs[i];
			}
			return tmp;
		}

		Color& operator+=(const Color& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) += a_rhs[i];
			}
			return *this;
		}

		[[nodiscard]] Color operator-(const Color& a_rhs) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] -= a_rhs[i];
			}
			return tmp;
		}

		Color& operator-=(const Color& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) -= a_rhs[i];
			}
			return *this;
		}

		friend Color operator-(std::uint8_t a_lhs, const Color& a_rhs)
		{
			return Color(
				a_lhs - a_rhs.red,
				a_lhs - a_rhs.green,
				a_lhs - a_rhs.blue,
				a_lhs - a_rhs.alpha);
		}

		[[nodiscard]] Color operator*(const Color& a_rhs) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] *= a_rhs[i];
			}
			return tmp;
		}

		Color& operator*=(const Color& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) *= a_rhs[i];
			}
			return *this;
		}

		friend Color operator*(std::uint8_t a_lhs, const Color& a_rhs)
		{
			return Color(
				a_lhs * a_rhs.red,
				a_lhs * a_rhs.green,
				a_lhs * a_rhs.blue,
				a_lhs * a_rhs.alpha);
		}

		[[nodiscard]] Color operator/(const Color& a_rhs) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] /= a_rhs[i];
			}
			return tmp;
		}

		Color& operator/=(const Color& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) /= a_rhs[i];
			}
			return *this;
		}

		friend Color operator/(std::uint8_t a_lhs, const Color& a_rhs)
		{
			return Color(
				a_lhs / a_rhs.red,
				a_lhs / a_rhs.green,
				a_lhs / a_rhs.blue,
				a_lhs / a_rhs.alpha);
		}

		[[nodiscard]] Color operator+(std::uint8_t a_value) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] += a_value;
			}
			return tmp;
		}

		Color& operator+=(std::uint8_t a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) += a_value;
			}
			return *this;
		}

		[[nodiscard]] Color operator-(std::uint8_t a_value) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] -= a_value;
			}
			return tmp;
		}

		Color& operator-=(std::uint8_t a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) -= a_value;
			}
			return *this;
		}

		[[nodiscard]] Color operator*(std::uint8_t a_value) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] *= a_value;
			}
			return tmp;
		}

		Color& operator*=(std::uint8_t a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) *= a_value;
			}
			return *this;
		}

		[[nodiscard]] Color operator/(std::uint8_t a_value) const noexcept
		{
			Color tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] /= a_value;
			}
			return tmp;
		}

		Color& operator/=(std::uint8_t a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) /= a_value;
			}
			return *this;
		}

		std::uint32_t ToInt() const;
		std::string   ToHex() const;

		// members
		std::uint8_t red;    // 0
		std::uint8_t green;  // 1
		std::uint8_t blue;   // 2
		std::uint8_t alpha;  // 3
	};
	static_assert(sizeof(Color) == 0x4);
}


===============================================
File: include/RE/C/ColorUtil.h
===============================================
#pragma once

#include "RE/N/NiColor.h"

namespace RE
{
	namespace ColorUtil
	{
		enum class BLEND_MODE
		{
			kDarken = 0,
			kMultiply,
			kColorBurn,
			kLinearBurn,
			kDarkerColor,

			kLighten,
			kScreen,
			kColorDodge,
			kLinearDodge,
			kLighterColor,

			kOverlay,
			kSoftLight,
			kHardLight,
			kVividLight,
			kLinearLight,
			kPinLight,
			kHardMix,

			kDifference,
			kExclusion,
			kSubtract,
			kDivide
		};

		namespace detail
		{
			//https://www.shadertoy.com/view/XdS3RW
			//ben, 2013

			inline NiColor abs(const NiColor& a_rhs)
			{
				return NiColor(std::abs(a_rhs.red),
					std::abs(a_rhs.green),
					std::abs(a_rhs.blue));
			}

			inline NiColor clamp(const NiColor& a_rhs, float a_min, float a_max)
			{
				return NiColor(std::clamp(a_rhs.red, a_min, a_max),
					std::clamp(a_rhs.green, a_min, a_max),
					std::clamp(a_rhs.blue, a_min, a_max));
			}

			inline NiColor floor(const NiColor& a_rhs)
			{
				return NiColor(std::floor(a_rhs.red),
					std::floor(a_rhs.green),
					std::floor(a_rhs.blue));
			}

			inline NiColor (min)(const NiColor& a_lhs, const NiColor& a_rhs)
			{
				return NiColor(
					(std::min)(a_lhs.red, a_rhs.red),
					(std::min)(a_lhs.green, a_rhs.green),
					(std::min)(a_lhs.blue, a_rhs.blue));
			}

			inline NiColor (max)(const NiColor& a_lhs, const NiColor& a_rhs)
			{
				return NiColor(
					(std::max)(a_lhs.red, a_rhs.red),
					(std::max)(a_lhs.green, a_rhs.green),
					(std::max)(a_lhs.blue, a_rhs.blue));
			}

			// BLEND MODES

			inline NiColor darken(const NiColor& a_src, const NiColor& a_dest)
			{
				return (min)(a_src, a_dest);
			}

			inline NiColor multiply(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_src * a_dest;
			}

			inline NiColor colorBurn(const NiColor& a_src, const NiColor& a_dest)
			{
				return 1.0 - (1.0 - a_dest) / a_src;
			}

			inline NiColor linearBurn(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_src + a_dest - 1.0;
			}

			inline NiColor darkerColor(const NiColor& a_src, const NiColor& a_dest)
			{
				return (a_src.red + a_src.green + a_src.blue < a_dest.red + a_dest.green + a_dest.blue) ? a_src : a_dest;
			}

			inline NiColor lighten(const NiColor& a_src, const NiColor& a_dest)
			{
				return (max)(a_src, a_dest);
			}

			inline NiColor screen(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_src + a_dest - a_src * a_dest;
			}

			inline NiColor colorDodge(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_dest / (1.0 - a_src);
			}

			inline NiColor linearDodge(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_src + a_dest;
			}

			inline NiColor lighterColor(const NiColor& a_src, const NiColor& a_dest)
			{
				return (a_src.red + a_src.green + a_src.blue > a_dest.red + a_dest.green + a_dest.blue) ? a_src : a_dest;
			}

			inline float overlay(float a_src, float a_dest)
			{
				return (a_dest < 0.5f) ? 2.0f * a_src * a_dest : 1.0f - 2.0f * (1.0f - a_src) * (1.0f - a_dest);
			}

			inline NiColor overlay(const NiColor& a_src, const NiColor& a_dest)
			{
				return NiColor(overlay(a_src.red, a_dest.red), overlay(a_src.green, a_dest.green), overlay(a_src.blue, a_dest.blue));
			}

			inline float softLight(float a_src, float a_dest)
			{
				return (a_src < 0.5f) ? a_dest - (1.0f - 2.0f * a_src) * a_dest * (1.0f - a_dest) : (a_dest < 0.25f) ? a_dest + (2.0f * a_src - 1.0f) * a_dest * ((16.0f * a_dest - 12.0f) * a_dest + 3.0f) :
                                                                                                                       a_dest + (2.0f * a_src - 1.0f) * (sqrt(a_dest) - a_dest);
			}

			inline NiColor softLight(const NiColor& a_src, const NiColor& a_dest)
			{
				return NiColor(softLight(a_src.red, a_dest.red), softLight(a_src.green, a_dest.green), softLight(a_src.blue, a_dest.blue));
			}

			inline float hardLight(float a_src, float a_dest)
			{
				return (a_src < 0.5f) ? 2.0f * a_src * a_dest : 1.0f - 2.0f * (1.0f - a_src) * (1.0f - a_dest);
			}

			inline NiColor hardLight(const NiColor& a_src, const NiColor& a_dest)
			{
				return NiColor(hardLight(a_src.red, a_dest.red), hardLight(a_src.green, a_dest.green), hardLight(a_src.blue, a_dest.blue));
			}

			inline float vividLight(float a_src, float a_dest)
			{
				return (a_src < 0.5f) ? 1.0f - (1.0f - a_dest) / (2.0f * a_src) : a_dest / (2.0f * (1.0f - a_src));
			}

			inline NiColor vividLight(const NiColor& a_src, const NiColor& a_dest)
			{
				return NiColor(vividLight(a_src.red, a_dest.red), vividLight(a_src.green, a_dest.green), vividLight(a_src.blue, a_dest.blue));
			}

			inline NiColor linearLight(const NiColor& a_src, const NiColor& a_dest)
			{
				return 2.0 * a_src + a_dest - 1.0;
			}

			inline float pinLight(float a_src, float a_dest)
			{
				return (2.0f * a_src - 1.0f > a_dest) ? 2.0f * a_src - 1.0f : (a_src < 0.5f * a_dest) ? 2.0f * a_src :
                                                                                                        a_dest;
			}

			inline NiColor pinLight(const NiColor& a_src, const NiColor& a_dest)
			{
				return NiColor(pinLight(a_src.red, a_dest.red), pinLight(a_src.green, a_dest.green), pinLight(a_src.blue, a_dest.blue));
			}

			inline NiColor hardMix(const NiColor& a_src, const NiColor& a_dest)
			{
				return floor(a_src + a_dest);
			}

			inline NiColor difference(const NiColor& a_src, const NiColor& a_dest)
			{
				return abs(a_dest - a_src);
			}

			inline NiColor exclusion(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_src + a_dest - 2.0 * a_src * a_dest;
			}

			inline NiColor subtract(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_src - a_dest;
			}

			inline NiColor divide(const NiColor& a_src, const NiColor& a_dest)
			{
				return a_src / a_dest;
			}

			inline NiColor mix(const NiColor& a_src, const NiColor& a_dest, float a_alpha)
			{
				return a_src * (1 - a_alpha) + a_dest * a_alpha;
			}
		}

		NiColor Blend(const NiColor& a_src, const NiColor& a_dest, BLEND_MODE a_mode, float a_alpha);

		float CalcLuminance(const NiColor& a_src);

		NiColor Mix(const NiColor& a_src, const NiColor& a_dest, float a_percentage);
	}
}


===============================================
File: include/RE/C/CombatController.h
===============================================
#pragma once

#include "RE/A/AITimer.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/C/CombatState.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class CombatAimController;
	class CombatAreaStandard;
	class CombatBehaviorController;
	class CombatBlackboard;
	class CombatGroup;
	class CombatInventory;
	class CombatTargetSelectorStandard;
	class CombatState;
	class TESCombatStyle;

	class CombatController
	{
	public:
		[[nodiscard]] bool IsFleeing() const
		{
			return state->isFleeing;
		}

		// members
		CombatGroup*                   combatGroup;           // 00
		CombatState*                   state;                 // 08
		CombatInventory*               inventory;             // 10
		CombatBlackboard*              blackboard;            // 18
		CombatBehaviorController*      behaviorController;    // 20
		ActorHandle                    attackerHandle;        // 28
		ActorHandle                    targetHandle;          // 2C
		ActorHandle                    previousTargetHandle;  // 30
		std::uint8_t                   unk34;                 // 34
		bool                           startedCombat;         // 35
		std::uint8_t                   unk36;                 // 36
		std::uint8_t                   unk37;                 // 37
		TESCombatStyle*                combatStyle;           // 38
		bool                           stoppedCombat;         // 40
		bool                           unk41;                 // 41 - isbeingMeleeAttacked?
		bool                           ignoringCombat;        // 42
		bool                           inactive;              // 43
		AITimer                        unk44;                 // 44
		float                          unk4C;                 // 4C
		BSTArray<CombatAimController*> aimControllers;        // 50
#ifdef SKYRIM_SUPPORT_AE
		mutable BSSpinLock aimControllerLock;  // 68
#endif
		CombatAimController*                    currentAimController;    // 68
		CombatAimController*                    previousAimController;   // 70
		BSTArray<CombatAreaStandard*>           areas;                   // 78
		CombatAreaStandard*                     currentArea;             // 90
		BSTArray<CombatTargetSelectorStandard*> targetSelectors;         // 98
		CombatTargetSelectorStandard*           currentTargetSelector;   // B0
		CombatTargetSelectorStandard*           previousTargetSelector;  // B8
		std::uint32_t                           handleCount;             // C0
		std::int32_t                            unkC4;                   // C4
		NiPointer<Actor>                        cachedAttacker;          // C8 - attackerHandle
		NiPointer<Actor>                        cachedTarget;            // D0 - targetHandle
	};
#ifndef SKYRIM_SUPPORT_AE
	static_assert(sizeof(CombatController) == 0xD8);
#else
	static_assert(sizeof(CombatController) == 0xE0);
#endif
}


===============================================
File: include/RE/C/CombatGroup.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/A/AITimer.h"
#include "RE/B/BGSWorldLocation.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/C/CombatGroupDetectionListener.h"

namespace RE
{
	class BSPathingLOSGridMap;
	class CombatSearchLocation;

	class CombatTarget
	{
	public:
		enum class Flags
		{
			kNone = 0,
			kTargetKnown = 1 << 0,
			kTargetLost = 1 << 1
		};

		// members
		ActorHandle                            targetHandle;        // 00
		std::int32_t                           detectLevel;         // 04
		float                                  stealthPoints;       // 08
		float                                  unk0C;               // 0C
		BGSWorldLocation                       lastKnownLoc;        // 10
		BGSWorldLocation                       unk28;               // 28
		BGSWorldLocation                       unk40;               // 40
		BGSWorldLocation                       searchLoc;           // 58
		BGSWorldLocation                       unk70;               // 70
		AITimeStamp                            unk88;               // 88 - unk40
		AITimeStamp                            unk8C;               // 8C - unk28
		AITimeStamp                            lastKnownTimeStamp;  // 90 - lastKnownLoc
		AITimeStamp                            unk94;               // 94 - ??
		AITimeStamp                            unk98;               // 98 - unk58
		AITimeStamp                            unk9C;               // 9C - unk70
		ActorHandle                            attackedMember;      // A0
		std::uint16_t                          attackerCount;       // A4
		stl::enumeration<Flags, std::uint16_t> flags;               // A6
	};
	static_assert(sizeof(CombatTarget) == 0xA8);

	class CombatMember
	{
	public:
		// members
		ActorHandle memberHandle;              // 00
		float       groupStrengthUpdateTimer;  // 04
		float       threatValue;               // 08
	};
	static_assert(sizeof(CombatMember) == 0x0C);

	struct CombatSearchDoor
	{
	public:
		// members
		ObjectRefHandle doorHandle;        // 00
		ObjectRefHandle linkedDoorHandle;  // 04
		std::uint8_t    unk08;             // 08
		std::uint8_t    unk09;             // 09
		std::uint8_t    unk0A;             // 0A
	};
	static_assert(sizeof(CombatSearchDoor) == 0xC);

	class CombatGroup
	{
	public:
		// members
		std::uint32_t                  groupID;                      // 000
		std::uint32_t                  groupIndex;                   // 004
		BSTArray<CombatTarget>         targets;                      // 008
		BSTArray<CombatMember>         members;                      // 020
		CombatGroupDetectionListener*  detectionListener;            // 038
		AITimer                        allyKilledTimer;              // 040
		AITimer                        avoidThreathTimer;            // 048
		AITimer                        unk50;                        // 050
		AITimer                        detectionDialogueTimers[11];  // 058
		AITimer                        updateTimer;                  // 0B0
		AITimer                        musicThreatRatioTimer;        // 0B8
		AITimer                        unkC0;                        // 0C0
		float                          unkC8;                        // 0C8
		float                          unkCC;                        // 0CC
		float                          unkD0;                        // 0D0
		float                          unkD4;                        // 0D4
		std::uint32_t                  searchState;                  // 0D8
		std::uint32_t                  padDC;                        // 0DC
		BSPathingLOSGridMap*           gridMap;                      // 0E0
		AITimer                        searchUpdateTimer;            // 0E8
		AITimer                        searchAreaUpdateTimer;        // 0F0
		AITimeStamp                    unkF8;                        // 0F8
		ActorHandle                    targetToSearchFor;            // 0FC
		BGSWorldLocation               searchTargetLoc;              // 100
		float                          searchRadius;                 // 118
		std::uint32_t                  unk11C;                       // 11C
		BSTArray<CombatSearchLocation> searchLocations;              // 120
		BSTArray<CombatSearchDoor>     searchDoors;                  // 138
		std::uint32_t                  unk150;                       // 150 - count
		std::uint32_t                  fleeCount;                    // 154
		std::uint32_t                  fightCount;                   // 158
		std::uint8_t                   musicState;                   // 15C
		std::uint8_t                   unk15D;                       // 15D
		std::uint8_t                   unk15E;                       // 15E
		std::uint8_t                   unk15F;                       // 15F
		mutable BSReadWriteLock        lock;                         // 160
	};
	static_assert(sizeof(CombatGroup) == 0x168);
}


===============================================
File: include/RE/C/CombatGroupDetectionListener.h
===============================================
#pragma once

#include "RE/D/DetectionListener.h"

namespace RE
{
	class CombatGroupDetectionListener : public DetectionListener
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatGroupDetectionListener;

		~CombatGroupDetectionListener() override;  // 00

		// override (DetectionListener)
		void Unk_02(void) override;  // 01

		// add
		virtual void Unk_05(void);  // 01 - { unk10 = 0; }

		// members
		void* unk10;  // 10
	};
	static_assert(sizeof(CombatGroupDetectionListener) == 0x18);
}


===============================================
File: include/RE/C/CombatInventory.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/A/AITimer.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSEquipSlot;
	class CombatController;
	class CombatInventoryItem;
	class CombatObject;
	class TESObjectWEAP;
	class TESForm;

	struct CombatEquipment
	{
	public:
		// members
		BSTArray<NiPointer<CombatInventoryItem>> items;         // 00
		std::uint32_t                            slot;          // 18
		float                                    maxRange;      // 1C
		float                                    optimalRange;  // 20
		float                                    minRange;      // 24
		float                                    score;         // 28
	};
	static_assert(sizeof(CombatEquipment) == 0x30);

	struct CombatEquippedItem
	{
	public:
		// members
		NiPointer<CombatInventoryItem> item;       // 00
		AITimeStamp                    equipTime;  // 08
	};
	static_assert(sizeof(CombatEquippedItem) == 0x10);

	class CombatInventory
	{
	public:
		// members
		CombatController*                        parentController;          // 000
		BSTArray<NiPointer<CombatInventoryItem>> inventoryItems[7];         // 008 - sorted by score?
		BSTArray<TESForm*>                       unk0B0;                    // 0B0
		BSTArray<TESForm*>                       unk0C8;                    // 0C8
		BSTArray<BGSEquipSlot*>*                 raceEquipSlots;            // 0E0
		std::uint64_t                            unk0E8;                    // 0E8 - map?
		std::uint32_t                            unk0F0;                    // 0F0
		std::uint32_t                            unk0F4;                    // 0F4
		std::uint32_t                            unk0F8;                    // 0F8
		std::uint32_t                            unk0FC;                    // 0FC
		std::uint64_t                            unk100;                    // 100
		std::uint64_t                            unk108;                    // 108
		std::uint64_t                            unk110;                    // 110
		CombatEquipment                          unk118;                    // 118
		CombatEquipment                          unk148;                    // 148
		BSTArray<CombatEquippedItem>             equippedItems;             // 178
		std::int32_t                             unk190;                    // 190
		AITimer                                  equippedTimer;             // 194
		std::uint32_t                            unk19C;                    // 19C
		std::uint32_t                            unk1A0;                    // 1A0
		std::uint32_t                            unk1A4;                    // 1A4
		float                                    actorExtents;              // 1A8
		float                                    actorCollisionExtents;     // 1AC
		float                                    minimumEffectiveDistance;  // 1B0
		float                                    maximumEffectiveDistance;  // 1B4
		float                                    maximumRange;              // 1B8
		float                                    optimalRange;              // 1BC
		float                                    minimumRange;              // 1C0
		bool                                     dirty;                     // 1C4
	};
	static_assert(sizeof(CombatInventory) == 0x1C8);
}


===============================================
File: include/RE/C/CombatInventoryItem.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/C/CombatObject.h"

namespace RE
{
	class BGSLoadGameBuffer;
	class BGSSaveGameBuffer;
	class CombatController;
	class TESBoundObject;
	class BGSEquipSlot;

	struct CombatInventoryItemResource
	{
	public:
		// members
		ActorValue actorValue;  // 00
		float      value;       // 04
	};
	static_assert(sizeof(CombatInventoryItemResource) == 0x8);

	class CombatInventoryItemSlot
	{
	public:
		// members
		BGSEquipSlot* equipSlot;  // 08
		std::uint32_t slot;       // 0C
	};
	static_assert(sizeof(CombatInventoryItemSlot) == 0x10);

	class CombatInventoryItem : public CombatObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatInventoryItem;

		enum class TYPE
		{
			kNone = 0,
			kMelee,
			kRanged,
			kShield,
			kOneHandedBlock = kShield,
			kMagic,
			kShout,
			kStaff,
			kPotion,
			kScroll,
			kTorch
		};

		enum class CATEGORY
		{
			kTotal = 7
		};

		~CombatInventoryItem() override;  // 00

		// override (CombatObject)
		void SaveGame(BGSSaveGameBuffer* a_buf) override;  // 03
		void LoadGame(BGSLoadGameBuffer* a_buf) override;  // 04

		// add
		virtual float                GetMinRange();                                             // 05 - { return 0.0; }
		virtual float                GetMaxRange();                                             // 06 - { return 0.0; }
		virtual float                GetOptimalRange();                                         // 07 - { return 0.0; }
		virtual float                GetEquipRange();                                           // 08 - { return FLT_MAX; }
		virtual TYPE                 GetType();                                                 // 09
		virtual TYPE                 GetEquipType(BGSEquipSlot a_slot);                         // 0A - { return GetType(); }
		virtual CATEGORY             GetCategory() = 0;                                         // 0B
		virtual float                CalculateScore(CombatController* a_controller) = 0;        // 0C
		virtual CombatInventoryItem* Clone() = 0;                                               // 0D
		virtual bool                 CheckBusy(CombatController* a_controller);                 // 0E
		virtual bool                 CheckShouldEquip(CombatController* a_controller);          // 0F - { return !a_controller->state->isFleeing; }
		virtual bool                 GetResource(CombatInventoryItemResource& a_resource);      // 10
		virtual void                 Equip(CombatController* a_controller);                     // 11
		virtual void                 Unequip(CombatController* a_controller);                   // 12
		virtual bool                 IsValid();                                                 // 13 - { return item != nullptr; }
		virtual void                 GetDescription(const char* a_dest, std::uint32_t a_size);  // 14

		// members
		TESForm*                item;       // 10
		float                   itemScore;  // 18
		std::uint32_t           unk1C;      // 1C
		CombatInventoryItemSlot itemSlot;   // 20
	};
	static_assert(sizeof(CombatInventoryItem) == 0x30);
}


===============================================
File: include/RE/C/CombatInventoryItemMagic.h
===============================================
#pragma once

#include "RE/C/CombatInventoryItem.h"

namespace RE
{
	class MagicItem;

	struct Effect;

	class CombatInventoryItemMagic : public CombatInventoryItem
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatInventoryItemMagic;
		inline static constexpr auto VTABLE = VTABLE_CombatInventoryItemMagic;

		~CombatInventoryItemMagic() override;  // 00

		// override (CombatInventoryItem)
		void  SaveGame(BGSSaveGameBuffer* a_buf) override;                    // 03
		void  LoadGame(BGSLoadGameBuffer* a_buf) override;                    // 04
		float GetMinRange() override;                                         // 05 - { return minRange; }
		float GetMaxRange() override;                                         // 06 - { return maxRange; }
		float GetOptimalRange() override;                                     // 07 - { return ((maxRange - minRange) * fCombatInventoryOptimalRangePercent) + minRange; }
		float GetEquipRange() override;                                       // 08
		TYPE  GetType() override;                                             // 09 - { return 4; }
		TYPE  GetEquipType(BGSEquipSlot a_slot) override;                     // 0A
		float CalculateScore(CombatController* a_controller) override;        // 0C
		bool  CheckBusy(CombatController* a_controller) override;             // 0E
		bool  CheckShouldEquip(CombatController* a_controller) override;      // 0F - { return true; }
		bool  GetResource(CombatInventoryItemResource& a_resource) override;  // 10
		bool  IsValid() override;                                             // 12 - { return item && effect; }

		//add
		virtual void*      CreateCaster() = 0;  // 15
		virtual MagicItem* GetMagic();          // 16 - { return unk10; };

		// members
		float   minRange;          // 30
		float   maxRange;          // 34
		float   tacticalDuration;  // 38
		float   power;             // 3C
		float   currentAV;         // 40
		Effect* effect;            // 48
	};
	static_assert(sizeof(CombatInventoryItemMagic) == 0x50);
}


===============================================
File: include/RE/C/CombatInventoryItemMagicT.h
===============================================
#pragma once

#include "RE/C/CombatInventoryItemMagic.h"

namespace RE
{
	template <class InventoryItem, class MagicCaster>
	class CombatInventoryItemMagicT : public CombatInventoryItemMagic
	{
	public:
		~CombatInventoryItemMagicT() override;  // 00
	};
	static_assert(sizeof(CombatInventoryItemMagicT<void*, void*>) == 0x50);
}


===============================================
File: include/RE/C/CombatInventoryItemPotion.h
===============================================
#pragma once

#include "RE/C/CombatInventoryItemMagic.h"

namespace RE
{
	class CombatInventoryItemPotion : public CombatInventoryItemMagic
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatInventoryItemPotion;
		inline static constexpr auto VTABLE = VTABLE_CombatInventoryItemPotion;

		~CombatInventoryItemPotion() override;  // 00

		// override (CombatInventoryItemMagic)
		TYPE GetType() override;                                  // 09 - { return 7; }
		bool CheckBusy(CombatController* a_controller) override;  // 0E
	};
	static_assert(sizeof(CombatInventoryItemPotion) == 0x50);
}


===============================================
File: include/RE/C/CombatInventoryItemScroll.h
===============================================
#pragma once

#include "RE/C/CombatInventoryItemMagic.h"

namespace RE
{
	class CombatInventoryItemScroll : public CombatInventoryItemMagic
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatInventoryItemScroll;
		inline static constexpr auto VTABLE = VTABLE_CombatInventoryItemScroll;

		~CombatInventoryItemScroll() override;  // 00

		// override (CombatInventoryItemMagic)
		TYPE GetType() override;                                  // 09 - { return 8; }
		bool CheckBusy(CombatController* a_controller) override;  // 0E
	};
	static_assert(sizeof(CombatInventoryItemScroll) == 0x50);
}


===============================================
File: include/RE/C/CombatInventoryItemShout.h
===============================================
#pragma once

#include "RE/C/CombatInventoryItemMagic.h"

namespace RE
{
	class CombatInventoryItemShout : public CombatInventoryItemMagic
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatInventoryItemShout;
		inline static constexpr auto VTABLE = VTABLE_CombatInventoryItemShout;

		~CombatInventoryItemShout() override;  // 00

		// override (CombatInventoryItemMagic)
		TYPE       GetType() override;                                         // 09 - { return 5; }
		bool       CheckBusy(CombatController* a_controller) override;         // 0E - { return actor->GetVoiceState() != 0; }
		bool       CheckShouldEquip(CombatController* a_controller) override;  // 0F - { return fCombatInventoryShoutMaxRecoveryTime >= actor->GetVoiceRecoveryTime(); }
		MagicItem* GetMagic() override;                                        // 16
	};
	static_assert(sizeof(CombatInventoryItemShout) == 0x50);
}


===============================================
File: include/RE/C/CombatInventoryItemStaff.h
===============================================
#pragma once

#include "RE/C/CombatInventoryItemMagic.h"

namespace RE
{
	class CombatInventoryItemStaff : public CombatInventoryItemMagic
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatInventoryItemStaff;
		inline static constexpr auto VTABLE = VTABLE_CombatInventoryItemStaff;

		~CombatInventoryItemStaff() override;  // 00

		// override (CombatInventoryItemMagic)
		TYPE       GetType() override;   // 09 - { return 6; }
		MagicItem* GetMagic() override;  // 16
	};
	static_assert(sizeof(CombatInventoryItemStaff) == 0x50);
}


===============================================
File: include/RE/C/CombatMagicCaster.h
===============================================
#pragma once

#include "RE/C/CombatInventoryItem.h"
#include "RE/C/CombatObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class CombatController;
	class CombatProjectileAimController;
	class MagicItem;

	class CombatMagicCaster : public CombatObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCaster;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCaster;

		~CombatMagicCaster() override;  // 00

		// override (CombatObject)
		void SaveGame(BGSSaveGameBuffer* a_buf) override;  // 03
		void LoadGame(BGSLoadGameBuffer* a_buf) override;  // 04

		// add
		virtual CombatInventoryItem::CATEGORY GetCategory() = 0;                                                   // 05
		virtual bool                          CheckStartCast(CombatController* a_combatController);                // 06
		virtual bool                          CheckStopCast(CombatController* a_combatController);                 // 07
		virtual float                         CalcCastMagicChance(CombatController* a_combatController) const;     // 08
		virtual float                         CalcMagicHoldTime(CombatController* a_combatController) const;       // 09
		virtual void*                         GetMagicTarget(CombatController* a_combatController) const;          // 0A
		virtual void                          NotifyStartCast(CombatController* a_combatController);               // 0B
		virtual void                          NotifyStopCast(CombatController* a_combatController);                // 0C
		virtual void                          SetupAimController(CombatProjectileAimController* a_aimController);  // 0D

		bool CheckTargetValid(const CombatController* a_combatController)
		{
			using func_t = bool* (*)(CombatMagicCaster*, const CombatController*);
			REL::Relocation<func_t> func{ RELOCATION_ID(43956, 45348) };
			return func(this, a_combatController);
		}

		static bool CheckTargetValid(const CombatController* a_combatController, Actor* a_target, const CombatInventoryItemMagic* a_inventoryItem)
		{
			using func_t = bool* (*)(const CombatController*, Actor*, const CombatInventoryItemMagic*);
			REL::Relocation<func_t> func{ RELOCATION_ID(43952, 45343) };
			return func(a_combatController, a_target, a_inventoryItem);
		}

		// members
		NiPointer<CombatInventoryItemMagic> inventoryItem;  // 10
		MagicItem*                          magicItem;      // 18
	};
	static_assert(sizeof(CombatMagicCaster) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterBoundItem.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterBoundItem : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterBoundItem;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterBoundItem;

		~CombatMagicCasterBoundItem() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
	};
	static_assert(sizeof(CombatMagicCasterBoundItem) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterCloak.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterCloak : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterCloak;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterCloak;

		~CombatMagicCasterCloak() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		bool                          CheckStopCast(CombatController* a_combatController) override;   // 07
	};
	static_assert(sizeof(CombatMagicCasterCloak) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterDisarm.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterDisarm : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterDisarm;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterDisarm;

		~CombatMagicCasterDisarm() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		void                          NotifyStopCast(CombatController* a_combatController) override;  // 0C
	};
	static_assert(sizeof(CombatMagicCasterDisarm) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterInvisibility.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterInvisibility : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterInvisibility;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterInvisibility;

		~CombatMagicCasterInvisibility() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
	};
	static_assert(sizeof(CombatMagicCasterInvisibility) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterLight.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterLight : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterLight;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterLight;

		~CombatMagicCasterLight() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		bool                          CheckStopCast(CombatController* a_combatController) override;   // 07
	};
	static_assert(sizeof(CombatMagicCasterLight) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterOffensive.h
===============================================
#pragma once

#include "RE/A/AITimer.h"
#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterOffensive : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterOffensive;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterOffensive;

		~CombatMagicCasterOffensive() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                                  // 02
		void                          SaveGame(BGSSaveGameBuffer* a_buf) override;                               // 03
		void                          LoadGame(BGSLoadGameBuffer* a_buf) override;                               // 04
		CombatInventoryItem::CATEGORY GetCategory() override;                                                    // 05 - { return 0; }
		bool                          CheckStartCast(CombatController* a_combatController) override;             // 06
		bool                          CheckStopCast(CombatController* a_combatController) override;              // 07
		float                         CalcCastMagicChance(CombatController* a_combatController) const override;  // 08
		float                         CalcMagicHoldTime(CombatController* a_combatController) const override;    // 09
		void                          NotifyStartCast(CombatController* a_combatController) override;            // 0B
		void                          NotifyStopCast(CombatController* a_combatController) override;             // 0C

		// members
		AITimer startCastTimer;  // 20
		AITimer stopCastTimer;   // 28
	};
	static_assert(sizeof(CombatMagicCasterOffensive) == 0x30);
}


===============================================
File: include/RE/C/CombatMagicCasterParalyze.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterParalyze : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterParalyze;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterParalyze;

		~CombatMagicCasterParalyze() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		void                          NotifyStopCast(CombatController* a_combatController) override;  // 0C
	};
	static_assert(sizeof(CombatMagicCasterParalyze) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterReanimate.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterReanimate : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterReanimate;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterReanimate;

		~CombatMagicCasterReanimate() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                                     // 02
		void                          SaveGame(BGSSaveGameBuffer* a_buf) override;                                  // 03
		void                          LoadGame(BGSLoadGameBuffer* a_buf) override;                                  // 04
		CombatInventoryItem::CATEGORY GetCategory() override;                                                       // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;                // 06
		void*                         GetMagicTarget(CombatController* a_combatController) const override;          // 0A
		void                          NotifyStopCast(CombatController* a_combatController) override;                // 0C
		void                          SetupAimController(CombatProjectileAimController* a_aimController) override;  // 0D

		// members
		NiPointer<CombatProjectileAimController> aimController;    // 20
		ActorHandle                              reanimateTarget;  // 28
	};
	static_assert(sizeof(CombatMagicCasterReanimate) == 0x30);
}


===============================================
File: include/RE/C/CombatMagicCasterRestore.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/A/ActorValues.h"
#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterRestore : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterRestore;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterRestore;

		~CombatMagicCasterRestore() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                        // 02
		void                          SaveGame(BGSSaveGameBuffer* a_buf) override;                     // 03
		void                          LoadGame(BGSLoadGameBuffer* a_buf) override;                     // 04
		CombatInventoryItem::CATEGORY GetCategory() override;                                          // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;   // 06
		bool                          CheckStopCast(CombatController* a_combatController) override;    // 07
		void                          NotifyStartCast(CombatController* a_combatController) override;  // 0B
		void                          NotifyStopCast(CombatController* a_combatController) override;   // 0C

		// members
		AITimeStamp   concentrationCastTimeStamp;  // 20
		std::uint32_t unk24;                       // 24
		ActorValue    primaryAV;                   // 28
	};
	static_assert(sizeof(CombatMagicCasterRestore) == 0x30);
}


===============================================
File: include/RE/C/CombatMagicCasterScript.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterScript : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterScript;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterScript;

		~CombatMagicCasterScript() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		void                          NotifyStopCast(CombatController* a_combatController) override;  // 0C
	};
	static_assert(sizeof(CombatMagicCasterScript) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterStagger.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterStagger : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterStagger;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterStagger;

		~CombatMagicCasterStagger() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		bool                          CheckStopCast(CombatController* a_combatController) override;   // 07
	};
	static_assert(sizeof(CombatMagicCasterStagger) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterSummon.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterSummon : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterSummon;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterSummon;

		~CombatMagicCasterSummon() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		void                          NotifyStopCast(CombatController* a_combatController) override;  // 0C
	};
	static_assert(sizeof(CombatMagicCasterSummon) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterTargetEffect.h
===============================================
#pragma once

#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterTargetEffect : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterTargetEffect;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterTargetEffect;

		~CombatMagicCasterTargetEffect() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
	};
	static_assert(sizeof(CombatMagicCasterTargetEffect) == 0x20);
}


===============================================
File: include/RE/C/CombatMagicCasterWard.h
===============================================
#pragma once

#include "RE/A/AITimer.h"
#include "RE/C/CombatMagicCaster.h"

namespace RE
{
	class CombatMagicCasterWard : public CombatMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatMagicCasterWard;
		inline static constexpr auto VTABLE = VTABLE_CombatMagicCasterWard;

		~CombatMagicCasterWard() override;  // 00

		// override (CombatMagicCaster)
		std::uint32_t                 GetObjectType() override;                                       // 02
		void                          SaveGame(BGSSaveGameBuffer* a_buf) override;                    // 03
		void                          LoadGame(BGSLoadGameBuffer* a_buf) override;                    // 04
		CombatInventoryItem::CATEGORY GetCategory() override;                                         // 05
		bool                          CheckStartCast(CombatController* a_combatController) override;  // 06
		bool                          CheckStopCast(CombatController* a_combatController) override;   // 07

		// members
		AITimer cooldownTimer;  // 20
	};
	static_assert(sizeof(CombatMagicCasterWard) == 0x28);
}


===============================================
File: include/RE/C/CombatManager.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/A/AITimer.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSTHashMap.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTArray.h"

namespace RE
{
	class CombatGroup;
	class CombatThreat;

	struct CombatThreatMap
	{
		BSTHashMap<std::uint32_t, NiPointer<CombatThreat>> threats;                   // 00
		mutable BSReadWriteLock                            lock;                      // 30
		AITimeStamp                                        lastThreatAddedTimeStamp;  // 38
	};
	static_assert(sizeof(CombatThreatMap) == 0x40);

	class CombatManager
	{
	public:
		[[nodiscard]] static CombatManager* GetSingleton()
		{
			REL::Relocation<CombatManager**> singleton{ RELOCATION_ID(518706, 405246) };
			return *singleton;
		}

		// members
		NiTPrimitiveArray<CombatGroup*> combatGroups;      // 00
		mutable BSReadWriteLock         lock;              // 18
		std::uint64_t                   unk20;             // 20
		CombatThreatMap*                combatThreatMap;   // 28
		std::uint64_t                   unk30;             // 30
		std::uint64_t                   unk38;             // 38
		std::uint64_t                   unk40;             // 40
		float                           unk48;             // 48
		AITimer                         musicStopTimer;    // 4C
		AITimer                         musicUpdateTimer;  // 54
		std::uint32_t                   combatCount;       // 5C
		std::uint32_t                   groupCount;        // 60
		std::uint32_t                   unk64;             // 64
	};
	static_assert(sizeof(CombatManager) == 0x68);
}


===============================================
File: include/RE/C/CombatObject.h
===============================================
#pragma once

#include "RE/N/NiRefObject.h"

namespace RE
{
	class BGSLoadGameBuffer;
	class BGSSaveGameBuffer;

	class CombatObject : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_CombatObject;

		~CombatObject() override;  // 00

		// add
		virtual std::uint32_t GetObjectType() = 0;                 // 02
		virtual void          SaveGame(BGSSaveGameBuffer* a_buf);  // 03 - { return }
		virtual void          LoadGame(BGSLoadGameBuffer* a_buf);  // 04 - { return }
	};
	static_assert(sizeof(CombatObject) == 0x10);
}


===============================================
File: include/RE/C/CombatSearchLocation.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/B/BGSWorldLocation.h"

namespace RE
{
	class CombatSearchLocation
	{
	public:
		// members
		BGSWorldLocation loc;        // 00
		AITimeStamp      timestamp;  // 18
		float            unk20;      // 20
	};
	static_assert(sizeof(CombatSearchLocation) == 0x20);
}


===============================================
File: include/RE/C/CombatState.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/A/AITimer.h"
#include "RE/B/BGSWorldLocation.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class CombatController;
	class CombatThreat;

	struct UnreachableLocation
	{
	public:
		// members
		BGSWorldLocation loc;        // 00
		AITimeStamp      timestamp;  // 18
		std::uint32_t    pad20;      // 20
	};
	static_assert(sizeof(UnreachableLocation) == 0x20);

	class CombatState
	{
	public:
		// members
		float                             unk00;                        // 00
		bool                              isFleeing;                    // 04
		bool                              isDetected;                   // 05
		std::uint8_t                      unk06;                        // 06
		std::uint8_t                      unk07;                        // 07
		std::uint8_t                      unk08;                        // 08
		std::uint8_t                      unk09;                        // 09
		std::uint8_t                      unk0A;                        // 0A
		std::uint8_t                      unk0B;                        // 0B
		std::uint32_t                     unk0C;                        // 0C
		NiPoint3                          unk10;                        // 10
		AITimeStamp                       activeCombatantLastSeenTime;  // 1C
		AITimeStamp                       unk20;                        // 20
		AITimeStamp                       unk24;                        // 24
		AITimeStamp                       unk28;                        // 28
		AITimer                           attackDialogueTimer;          // 2C
		AITimer                           tauntDialogueTimer;           // 34
		AITimer                           bleedOutDialogueTimer;        // 3C
		AITimer                           fleeDialogueTimer;            // 44
		std::uint32_t                     unk4C;                        // 4C
		BSTArray<NiPointer<CombatThreat>> combatThreats;                // 50
		AITimeStamp                       unk68;                        // 68
		std::uint8_t                      unk6C;                        // 6C
		std::uint8_t                      unk6D;                        // 6D
		float                             confidenceModifier;           // 70
		float                             threatValue;                  // 74
		float                             unk78;                        // 78
		std::uint32_t                     unk7C;                        // 7C
		BSTArray<UnreachableLocation>     unreachableLocations;         // 80
		CombatController*                 unk98;                        // 98
		std::uint8_t                      unkA0;                        // A0
		AITimer                           strengthUpdateTimer;          // A4
		AITimer                           threatRatioUpdateTimer;       // AC
		AITimer                           threatUpdateTimer;            // B4
	};
	static_assert(sizeof(CombatState) == 0xC0);
}


===============================================
File: include/RE/C/CommandEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class CommandEffect : public ActiveEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_CommandEffect;
		inline static constexpr auto VTABLE = VTABLE_CommandEffect;

		// override (ActiveEffect)
		void           OnAdd(MagicTarget* a_target) override;              // 01
		TESObjectREFR* GetVisualsTarget() override;                        // 03
		void           Update(float a_delta) override;                     // 04
		void           SaveGame(BGSSaveFormBuffer* a_buf) override;        // 08
		void           LoadGame(BGSLoadFormBuffer* a_buf) override;        // 09
		void           FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 0A
		void           ClearTargetImpl() override;                         // 12

		~CommandEffect() override;  // 13

		void Start() override;   // 14
		void Finish() override;  // 15

		// members
		ActorHandle   commandedActor;  // 90
		std::uint32_t pad94;           // 94
	};
	static_assert(sizeof(CommandEffect) == 0x98);
}


===============================================
File: include/RE/C/CommandSummonedEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class CommandSummonedEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_CommandSummonedEffect;
		inline static constexpr auto VTABLE = VTABLE_CommandSummonedEffect;

		// override (ActiveEffect)
		virtual ~CommandSummonedEffect();  // 13
		virtual void Start() override;     // 14
	};
	static_assert(sizeof(CommandSummonedEffect) == 0x90);
}


===============================================
File: include/RE/C/CommandTable.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class ScriptLocals;
	struct ACTION_OBJECT;
	struct ConditionCheckParams;
	struct ScriptCompileData;
	struct ScriptLineBuffer;
	struct ScriptVariable;
	struct SCRIPT_EFFECT_DATA;
	struct SCRIPT_HEADER;
	struct SCRIPT_LINE;
	struct SCRIPT_LOCAL;
	struct SCRIPT_PARAMETER;
	struct SCRIPT_REFERENCED_OBJECT;

	enum class SCRIPT_PARAM_TYPE
	{
		kChar = 0x0,
		kInt = 0x1,
		kFloat = 0x2,
		kInventoryObject = 0x3,
		kObjectRef = 0x4,
		kActorValue = 0x5,
		kActor = 0x6,
		kSpellItem = 0x7,
		kAxis = 0x8,
		kCell = 0x9,
		kAnimGroup = 0x0A,
		kMagicItem = 0x0B,
		kSound = 0x0C,
		kTopic = 0x0D,
		kQuest = 0x0E,
		kRace = 0x0F,
		kClass = 0x10,
		kFaction = 0x11,
		kSex = 0x12,
		kGlobal = 0x13,
		kFurnitureOrFormList = 0x14,
		kObject = 0x15,
		kScriptVar = 0x16,
		kStage = 0x17,
		kMapMarker = 0x18,
		kActorBase = 0x19,
		kContainerRef = 0x1A,
		kWorldOrList = 0x1B,
		kCrimeType = 0x1C,
		kPackage = 0x1D,
		kCombatStyle = 0x1E,
		kMagicEffect = 0x1F,
		kFormType = 0x20,
		kWeather = 0x21,
		kNPC = 0x22,
		kOwner = 0x23,
		kShaderEffect = 0x24,
		kFormList = 0x25,
		kMenuIcon = 0x26,
		kPerk = 0x27,
		kNote = 0x28,
		kMiscStat = 0x29,
		kImagespaceMod = 0x2A,
		kImagespace = 0x2B,
		kVATSValue = 0x2C,
		kVATSValueData = 0x2D,
		kEventFunction = 0x2E,
		kEventFunctionMember = 0x2F,
		kEventFunctionData = 0x30,
		kVoiceType = 0x31,
		kEncounterZone = 0x32,
		kIdleForm = 0x33,
		kMessage = 0x34,
		kInvObjectOrFormList = 0x35,
		kAlignment = 0x36,
		kEquipType = 0x37,
		kObjectOrFormList = 0x38,
		kMusic = 0x39,
		kCritStage = 0x3A,
		kKeyword = 0x3B,
		kRefType = 0x3C,
		kLocation = 0x3D,
		kForm = 0x3E,
		kAlias = 0x3F,
		kShout = 0x40,
		kWordOfPower = 0x41,
		kRelationshipRank = 0x42,
		kBGSScene = 0x43,
		kCastingSource = 0x44,
		kAssociationType = 0x45,
		kWardState = 0x46,
		kPackageDataCanBeNull = 0x47,
		kPackageDataNumeric = 0x48,
		kFurnitureAnimType = 0x49,
		kFurnitureEntryType = 0x4A,
		kVMScriptVar = 0x4C,
		kReferenceEffect = 0x4D,
		kPackageData = 0x4E,
		kSkillAction = 0x50,
		kKnowableForm = 0x51,
		kRegion = 0x52
	};

	// basically the unique id for the function, there's ~5000 of these
	enum class SCRIPT_OUTPUT
	{
	};

	enum class SCRIPT_ERROR
	{
	};

	struct SCRIPT_HEADER
	{
	public:
		// members
		std::uint32_t variableCount;        // 00
		std::uint32_t refObjectCount;       // 04
		std::uint32_t dataSize;             // 08
		std::uint32_t lastID;               // 0C
		bool          isQuestScript;        // 10
		bool          isMagicEffectScript;  // 11
		bool          isCompiled;           // 12
		std::uint8_t  pad13;                // 13
	};
	static_assert(sizeof(SCRIPT_HEADER) == 0x14);

	struct SCRIPT_PARAMETER
	{
	public:
		// members
		const char*                                        paramName;   // 00
		stl::enumeration<SCRIPT_PARAM_TYPE, std::uint32_t> paramType;   // 08
		bool                                               optional;    // 0C
		std::uint8_t                                       pad0D{ 0 };  // 0D
		std::uint16_t                                      pad0E{ 0 };  // 0E
	};
	static_assert(sizeof(SCRIPT_PARAMETER) == 0x10);

	struct SCRIPT_REFERENCED_OBJECT
	{
	public:
		// members
		BSString      editorID;    // 00
		TESForm*      form;        // 10
		std::uint32_t variableID;  // 18
		std::uint32_t pad1C;       // 1C
	};
	static_assert(sizeof(SCRIPT_REFERENCED_OBJECT) == 0x20);

	struct ACTION_OBJECT
	{
	public:
		// members
		TESForm*      form;   // 00
		std::uint32_t flags;  // 08
		std::uint32_t pad0C;  // 0C
	};
	static_assert(sizeof(ACTION_OBJECT) == 0x10);

	struct SCRIPT_LOCAL
	{
	public:
		// members
		std::uint32_t id;         // 0
		float         value;      // 4
		bool          isInteger;  // 8
		std::uint8_t  pad9;       // 9
		std::uint16_t padA;       // A
	};
	static_assert(sizeof(SCRIPT_LOCAL) == 0xC);

	struct SCRIPT_EFFECT_DATA
	{
	public:
		// members
		bool          scriptEffectStart;   // 00
		bool          scriptEffectFinish;  // 01
		std::uint16_t pad02;               // 02
		float         secondsElapsed;      // 04
	};
	static_assert(sizeof(SCRIPT_EFFECT_DATA) == 0x8);

	class ScriptLocals
	{
	public:
		// members
		Script*                       masterScript;      // 00
		char                          flags;             // 08
		std::uint8_t                  pad09;             // 09
		std::uint16_t                 pad0A;             // 0A
		std::uint32_t                 pad0C;             // 0C
		BSSimpleList<ACTION_OBJECT*>* actionList;        // 10
		BSSimpleList<SCRIPT_LOCAL*>*  localList;         // 18
		SCRIPT_EFFECT_DATA*           scriptEffectData;  // 20
	};
	static_assert(sizeof(ScriptLocals) == 0x28);

	struct ScriptVariable
	{
	public:
		// members
		SCRIPT_LOCAL  data;   // 00
		std::uint32_t pad0C;  // 0C
		BSString      name;   // 10
	};
	static_assert(sizeof(ScriptVariable) == 0x20);

	struct SCRIPT_LINE
	{
	public:
		// members
		std::uint32_t                                  lineNumber;      // 000
		char                                           line[512];       // 004
		std::uint32_t                                  size;            // 204
		std::uint32_t                                  offset;          // 208
		char                                           output[512];     // 20C
		std::uint32_t                                  outputSize;      // 40C
		stl::enumeration<SCRIPT_OUTPUT, std::uint32_t> expression;      // 410
		std::uint32_t                                  refObjectIndex;  // 414
		stl::enumeration<SCRIPT_ERROR, std::uint32_t>  scriptError;     // 418
	};
	static_assert(sizeof(SCRIPT_LINE) == 0x41C);

	struct SCRIPT_FUNCTION
	{
		struct Commands
		{
			enum : std::uint32_t
			{
				kConsoleCommandsEnd = 0x01B4,
				kConsoleOpBase = 0x0100,

				kScriptCommandsEnd = 0x02E0,
				kScriptOpBase = 0x1000
			};
		};

		struct StringChunk;
		struct IntegerChunk;

		struct Chunk
		{
		public:
			StringChunk*  AsString();
			IntegerChunk* AsInteger();
		};

		struct StringChunk : public Chunk
		{
		public:
			[[nodiscard]] std::string GetString() const;
			Chunk*                    GetNext();

			// members
			std::uint16_t length;  // 00
			char          str[0];  // 02
		};
		static_assert(sizeof(StringChunk) == 0x2);

#pragma pack(push, 1)
		struct IntegerChunk : public Chunk
		{
		public:
			[[nodiscard]] int GetInteger() const;
			Chunk*            GetNext();

			// members
			char         magic;  // 00
			std::int32_t value;  // 01
		};
		static_assert(offsetof(IntegerChunk, value) == 0x1);
		static_assert(sizeof(IntegerChunk) == 0x5);
#pragma pack(pop)

		struct ScriptData
		{
		public:
			Chunk*        GetChunk();
			StringChunk*  GetStringChunk();
			IntegerChunk* GetIntegerChunk();

			// members
			std::uint16_t opcode;     // 00
			std::uint16_t chunkSize;  // 02
			std::uint16_t numParams;  // 04
		};
		static_assert(sizeof(ScriptData) == 0x6);

		using Execute_t = bool(const SCRIPT_PARAMETER* a_paramInfo, ScriptData* a_scriptData, TESObjectREFR* a_thisObj, TESObjectREFR* a_containingObj, Script* a_scriptObj, ScriptLocals* a_locals, double& a_result, std::uint32_t& a_opcodeOffsetPtr);
		using Compile_t = bool(std::uint16_t a_numParams, const SCRIPT_PARAMETER* a_paramInfo, SCRIPT_LINE* a_lineBuf, ScriptCompileData* a_scriptBuf);
		using Condition_t = bool(TESObjectREFR* a_thisObj, void* a_param1, void* a_param2, double& a_result);

		static SCRIPT_FUNCTION* GetFirstScriptCommand();
		static SCRIPT_FUNCTION* LocateScriptCommand(std::string_view a_longName);

		static SCRIPT_FUNCTION* GetFirstConsoleCommand();
		static SCRIPT_FUNCTION* LocateConsoleCommand(std::string_view a_longName);

		template <std::uint16_t SIZE>
		inline void SetParameters(SCRIPT_PARAMETER (&a_params)[SIZE])
		{
			numParams = SIZE;
			params = a_params;
		}

		void SetParameters();

		// members
		const char*       functionName;         // 00
		const char*       shortName;            // 08
		SCRIPT_OUTPUT     output;               // 10
		std::uint32_t     pad14;                // 14
		const char*       helpString;           // 18
		bool              referenceFunction;    // 20
		std::uint8_t      pad21;                // 21
		std::uint16_t     numParams;            // 22
		std::uint32_t     pad24;                // 24
		SCRIPT_PARAMETER* params;               // 28
		Execute_t*        executeFunction;      // 30
		Compile_t*        compileFunction;      // 38
		Condition_t*      conditionFunction;    // 40
		bool              editorFilter;         // 48
		bool              invalidatesCellList;  // 49
		std::uint16_t     pad4A;                // 4A
		std::uint32_t     pad4C;                // 4C
	};
	static_assert(sizeof(SCRIPT_FUNCTION) == 0x50);
}


===============================================
File: include/RE/C/CommonTypeTraits.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/B/BGSBaseAlias.h"
#include "RE/B/BSFixedString.h"
#include "RE/T/TESForm.h"

namespace RE
{
	namespace BSScript
	{
		template <class T>
		struct is_not_const :
			std::negation<
				std::is_const<T>>
		{};

		template <class T>
		inline constexpr bool is_not_const_v = is_not_const<T>::value;

		template <class T>
		struct is_not_volatile :
			std::negation<
				std::is_volatile<T>>
		{};

		template <class T>
		inline constexpr bool is_not_volatile_v = is_not_volatile<T>::value;

		template <class T>
		struct is_not_reference :
			std::negation<
				std::is_reference<T>>
		{};

		template <class T>
		inline constexpr bool is_not_reference_v = is_not_reference<T>::value;

		template <class T>
		struct is_not_pointer :
			std::negation<
				std::is_pointer<T>>
		{};

		template <class T>
		inline constexpr bool is_not_pointer_v = is_not_pointer<T>::value;

		template <class, class = void>
		struct defines_value_type :
			std::false_type
		{};

		template <class T>
		struct defines_value_type<
			T,
			std::void_t<
				typename T::value_type>> :
			std::true_type
		{};

		template <class T>
		inline constexpr bool defines_value_type_v = defines_value_type<T>::value;

		template <class, class = void>
		struct defines_size_type :
			std::false_type
		{};

		template <class T>
		struct defines_size_type<
			T,
			std::void_t<
				typename T::size_type>> :
			std::true_type
		{};

		template <class T>
		inline constexpr bool defines_size_type_v = defines_size_type<T>::value;

		template <class, class = void>
		struct defines_iterator :
			std::false_type
		{};

		template <class T>
		struct defines_iterator<
			T,
			std::void_t<
				typename T::iterator>> :
			std::true_type
		{};

		template <class T>
		inline constexpr bool defines_iterator_v = defines_iterator<T>::value;

		template <class, class = void>
		struct implements_begin :
			std::false_type
		{};

		template <class T>
		struct implements_begin<
			T,
			std::enable_if_t<
				std::is_same_v<
					typename T::iterator,
					decltype(std::declval<T>().begin())>>> :
			std::true_type
		{};

		template <class T>
		inline constexpr bool implements_begin_v = implements_begin<T>::value;

		template <class, class = void>
		struct implements_end :
			std::false_type
		{};

		template <class T>
		struct implements_end<
			T,
			std::enable_if_t<
				std::is_same_v<
					typename T::iterator,
					decltype(std::declval<T>().end())>>> :
			std::true_type
		{};

		template <class T>
		inline constexpr bool implements_end_v = implements_end<T>::value;

		template <class, class = void>
		struct implements_size :
			std::false_type
		{};

		template <class T>
		struct implements_size<
			T,
			std::enable_if_t<
				std::is_invocable_r_v<
					typename T::size_type,
					decltype(&T::size),
					T>>> :
			std::true_type
		{};

		template <class T>
		inline constexpr bool implements_size_v = implements_size<T>::value;

		template <class, class = void>
		struct implements_push_back :
			std::false_type
		{};

		template <class T>
		struct implements_push_back<
			T,
			std::void_t<
				decltype(std::declval<T>().push_back(std::declval<typename T::value_type>()))>> :
			std::true_type
		{};

		template <class T>
		inline constexpr bool implements_push_back_v = implements_push_back<T>::value;

		template <class T>
		struct _is_integer :
			std::is_integral<T>
		{};

		template <>
		struct _is_integer<bool> :
			std::false_type
		{};

		template <class T>
		struct is_integer :
			_is_integer<
				std::remove_cv_t<T>>
		{};

		template <class T>
		inline constexpr bool is_integer_v = is_integer<T>::value;

		template <class T>
		struct index_sequence_for_tuple :
			std::make_index_sequence<
				std::tuple_size_v<
					std::decay_t<T>>>
		{};

		template <class T>
		struct decay_pointer :
			std::decay_t<
				std::remove_pointer<T>>
		{};

		template <class T>
		using decay_pointer_t = typename decay_pointer<T>::type;

		template <class T>
		struct is_string :
			std::is_same<
				std::remove_cv_t<T>,
				BSFixedString>
		{};

		template <class T>
		inline constexpr bool is_string_v = is_string<T>::value;

		template <class T>
		struct is_signed_integral :
			std::conjunction<
				is_integer<T>,
				std::is_signed<T>,
				std::bool_constant<sizeof(T) == 4>>
		{};

		template <class T>
		inline constexpr bool is_signed_integral_v = is_signed_integral<T>::value;

		template <class T>
		struct is_unsigned_integral :
			std::conjunction<
				is_integer<T>,
				std::is_unsigned<T>,
				std::bool_constant<sizeof(T) == 4>>
		{};

		template <class T>
		inline constexpr bool is_unsigned_integral_v = is_unsigned_integral<T>::value;

		template <class T>
		struct is_integral :
			std::disjunction<
				is_signed_integral<T>,
				is_unsigned_integral<T>>
		{};

		template <class T>
		inline constexpr bool is_integral_v = is_integral<T>::value;

		template <class T>
		struct is_floating_point :
			std::is_same<
				std::remove_cv_t<T>,
				float>
		{};

		template <class T>
		inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

		template <class T>
		struct is_boolean :
			std::is_same<
				std::remove_cv_t<T>,
				bool>
		{};

		template <class T>
		inline constexpr bool is_boolean_v = is_boolean<T>::value;

		template <class T>
		struct is_builtin :
			std::disjunction<
				std::is_void<T>,
				is_string<T>,
				is_signed_integral<T>,
				is_unsigned_integral<T>,
				is_floating_point<T>,
				is_boolean<T>>
		{};

		template <class T>
		inline constexpr bool is_builtin_v = is_builtin<T>::value;

		template <class T>
		struct is_string_convertible :
			std::is_convertible<T, std::string_view>
		{};

		template <class T>
		inline constexpr bool is_string_convertible_v = is_string_convertible<T>::value;

		template <class T, class = void>
		struct is_signed_integral_convertible :
			std::conjunction<
				is_integer<T>,
				std::is_signed<T>>
		{};

		template <class T>
		struct is_signed_integral_convertible<
			T,
			std::enable_if_t<
				std::is_enum_v<T>>> :
			std::is_signed<
				std::underlying_type_t<T>>
		{};

		template <class T>
		inline constexpr bool is_signed_integral_convertible_v = is_signed_integral_convertible<T>::value;

		template <class T, class = void>
		struct is_unsigned_integral_convertible :
			std::conjunction<
				is_integer<T>,
				std::is_unsigned<T>>
		{};

		template <class T>
		struct is_unsigned_integral_convertible<
			T,
			std::enable_if_t<
				std::is_enum_v<T>>> :
			std::is_unsigned<
				std::underlying_type_t<T>>
		{};

		template <class T>
		inline constexpr bool is_unsigned_integral_convertible_v = is_unsigned_integral_convertible<T>::value;

		template <class T>
		struct is_integral_convertible :
			std::disjunction<
				is_signed_integral_convertible<T>,
				is_unsigned_integral_convertible<T>>
		{};

		template <class T>
		inline constexpr bool is_integral_convertible_v = is_integral_convertible<T>::value;

		template <class T>
		struct is_floating_point_convertible :
			std::is_floating_point<T>
		{};

		template <class T>
		inline constexpr bool is_floating_point_convertible_v = is_floating_point_convertible<T>::value;

		template <class T>
		struct is_builtin_convertible :
			std::disjunction<
				std::is_void<T>,
				is_string_convertible<T>,
				is_signed_integral_convertible<T>,
				is_unsigned_integral_convertible<T>,
				is_floating_point_convertible<T>,
				is_boolean<T>>
		{};

		template <class T>
		inline constexpr bool is_builtin_convertible_v = is_builtin_convertible<T>::value;

		template <class T>
		struct is_form :
			std::is_base_of<
				RE::TESForm,
				std::remove_cv_t<T>>
		{};

		template <class T>
		inline constexpr bool is_form_v = is_form<T>::value;

		template <class T>
		struct is_form_pointer :
			std::conjunction<
				is_form<
					std::remove_pointer_t<T>>,
				std::is_pointer<T>>
		{};

		template <class T>
		inline constexpr bool is_form_pointer_v = is_form_pointer<T>::value;

		template <class T>
		struct is_alias :
			std::is_base_of<
				RE::BGSBaseAlias,
				std::remove_cv_t<T>>
		{};

		template <class T>
		inline constexpr bool is_alias_v = is_alias<T>::value;

		template <class T>
		struct is_alias_pointer :
			std::conjunction<
				is_alias<
					std::remove_pointer_t<T>>,
				std::is_pointer<T>>
		{};

		template <class T>
		inline constexpr bool is_alias_pointer_v = is_alias_pointer<T>::value;

		template <class T>
		struct is_active_effect :
			std::is_base_of<
				RE::ActiveEffect,
				std::remove_cv_t<T>>
		{};

		template <class T>
		inline constexpr bool is_active_effect_v = is_active_effect<T>::value;

		template <class T>
		struct is_active_effect_pointer :
			std::conjunction<
				is_active_effect<
					std::remove_pointer_t<T>>,
				std::is_pointer<T>>
		{};

		template <class T>
		inline constexpr bool is_active_effect_pointer_v = is_active_effect_pointer<T>::value;

		template <class T>
		struct _is_array :
			std::conjunction<
				std::negation<
					is_string_convertible<T>>,
				std::is_default_constructible<T>,
				std::is_destructible<T>,
				is_not_reference<T>,
				is_not_pointer<T>,
				defines_value_type<T>,
				defines_size_type<T>,
				defines_iterator<T>,
				implements_begin<T>,
				implements_end<T>,
				implements_size<T>,
				implements_push_back<T>>
		{};

		template <>
		struct _is_array<
			std::vector<bool>> :
			std::true_type
		{};

		template <class T>
		struct is_array :
			_is_array<
				std::remove_cv_t<T>>
		{};

		template <class T>
		inline constexpr bool is_array_v = is_array<T>::value;
	}
}


===============================================
File: include/RE/C/CompactingStore.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/I/IMemoryStoreBase.h"

namespace RE
{
	namespace CompactingStore
	{
		class BlockHeader;
		class FreeBlock;
		class StoreBlock;

		class Store : public IMemoryStoreBase
		{
		public:
			inline static constexpr auto RTTI = RTTI_CompactingStore__Store;

			~Store() override;  // 00

			// override (IMemoryStoreBase)
			std::size_t Size(const void* a_block) const override;               // 01
			void        GetMemoryStats(MemoryStats* a_stats) override;          // 02
			bool        ContainsBlockImpl(const void* a_block) const override;  // 03

			// members
			BSNonReentrantSpinLock lock;
			void*                  allocBase;
			void*                  allocEndMin;
			void*                  allocEnd;
			void*                  storeEnd;
			BlockHeader*           lastBlock;
			FreeBlock*             smallFree[66];
			FreeBlock*             currentFree;
			FreeBlock*             nextMerge;
			StoreBlock*            storeBlockMin;
			StoreBlock*            nextStoreBlock;
			StoreBlock*            freeStoreBlockList;
			std::uint32_t          currentThread;
			std::size_t            allocated;
			std::uint32_t          numAllocatedBlocks;
			std::size_t            free;
			std::uint32_t          numFreeBlocks;
			std::uint32_t          compacted;
			std::uint32_t          batchDeallocateTlsSlot;
		};
		static_assert(sizeof(Store) == 0x2A0);
	}
}


===============================================
File: include/RE/C/CompiledScriptLoader.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/I/ILoader.h"
#include "RE/I/IVMSaveLoadInterface.h"

namespace RE
{
	namespace BSScript
	{
		class ErrorLogger;
		class IStore;

		class CompiledScriptLoader : public ILoader
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__CompiledScriptLoader;
			inline static constexpr auto VTABLE = VTABLE_BSScript__CompiledScriptLoader;

			~CompiledScriptLoader() override;  // 00

			// override (ILoader)
			ILoader* Clone() override;                                                                  // 01
			void     SetScriptStore(const BSTSmartPointer<IStore>& a_store) override;                   // 02
			bool     GetClass(const char* a_name, BSScript::UnlinkedTypes::Object& a_object) override;  // 03

			// members
			ErrorLogger*            errorHandler;         // 08
			BSTSmartPointer<IStore> scriptStore;          // 10
			ReadableStringTable     readableStringTable;  // 18 - This gets filled and cleared each time reading from a script
			std::byte               majorVersion;         // 30 - Set each time reading from a script
			std::byte               minorVersion;         // 31 - Set each time reading from a script
			std::byte               loadDebugInfo: 1;     // 32 - Set to INI setting `Papyrus::bLoadDebugInformation` in the constructor
			std::byte               loadDocStrings: 1;    // 32 - Never set true in vanilla, requires loadDebugInfo = 1 to work
		};
		static_assert(sizeof(CompiledScriptLoader) == 0x38);
	}
}


===============================================
File: include/RE/C/ConcreteFormFactory.h
===============================================
#pragma once

#include "RE/I/IFormFactory.h"
#include "RE/T/TESForm.h"

namespace RE
{
	template <class T, FormType FORM_TYPE>
	class ConcreteFormFactory : public IFormFactory
	{
	public:
		~ConcreteFormFactory() override;  // 00

	protected:
		// override (IFormFactory)
		TESForm* CreateImpl() override;  // 01

	public:
		const char*            GetFormName() const override;  // 02 - { return _name; }
		[[nodiscard]] FormType GetFormType() const override;  // 03 - { return FORM_TYPE; }

		inline T* Create()
		{
			return static_cast<T*>(CreateImpl());
		}

	protected:
		// members
		const char* _name;  // 08
	};
	static_assert(sizeof(ConcreteFormFactory<TESForm, FormType::None>) == 0x10);

	template <class T>
	inline ConcreteFormFactory<T, T::FORMTYPE>* IFormFactory::GetConcreteFormFactoryByType()
	{
		return static_cast<ConcreteFormFactory<T, T::FORMTYPE>*>(GetFormFactoryByType(T::FORMTYPE));
	}
}


===============================================
File: include/RE/C/ConcreteObjectFormFactory.h
===============================================
#pragma once

#include "RE/C/ConcreteFormFactory.h"

namespace RE
{
	template <class T, FormType FORM_TYPE, OBJECT_TYPE OBJ_TYPE, OBJECT_CATEGORY_TYPE OBJ_CATEGORY_TYPE>
	class ConcreteObjectFormFactory : public ConcreteFormFactory<T, FORM_TYPE>
	{
	public:
		~ConcreteObjectFormFactory() override;  // 00

		// override (ConcreteFormFactory)
		const char*                        GetObjectName() const override;      // 04 - { return _name; }
		OBJECT_TYPE                        GetObjectType() const override;      // 05 - { return OBJ_TYPE; }
		[[nodiscard]] OBJECT_CATEGORY_TYPE GetObjectCategory() const override;  // 06 - { return OBJ_CATEGORY_TYPE; }
	};
	static_assert(sizeof(ConcreteObjectFormFactory<TESForm, FormType::None, static_cast<OBJECT_TYPE>(0), static_cast<OBJECT_CATEGORY_TYPE>(0)>) == 0x10);
}


===============================================
File: include/RE/C/ConcussionEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class ConcussionEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_ConcussionEffect;
		inline static constexpr auto VTABLE = VTABLE_ConcussionEffect;

		// override (ActiveEffect)
		virtual ~ConcussionEffect();  // 13
	};
	static_assert(sizeof(ConcussionEffect) == 0x90);
}


===============================================
File: include/RE/C/ConeProjectile.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/H/hkRefPtr.h"
#include "RE/I/ImpactResults.h"
#include "RE/N/NiPoint3.h"
#include "RE/P/Projectile.h"

namespace RE
{
	class hkpSphereShape;

	class ConeProjectile : public Projectile
	{
	public:
		inline static constexpr auto RTTI = RTTI_ConeProjectile;
		inline static constexpr auto VTABLE = VTABLE_ConeProjectile;
		inline static constexpr auto FORMTYPE = FormType::ProjectileCone;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~ConeProjectile() override;  // 00

		// override (Projectile)
		void SaveGame(BGSSaveFormBuffer* a_buf) override;        // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;        // 0F
		void InitLoadGame(BGSLoadFormBuffer* a_buf) override;    // 10
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 11
		void Revert(BGSLoadFormBuffer* a_buf) override;          // 12
#ifndef SKYRIM_CROSS_VR
		void      Process3D() override;               // A9
		void UpdateImpl(float a_delta) override;  // AB
		bool      ProcessImpacts() override;               // AC
		bool      GetKillOnCollision() override;               // B8 - { return 0; }
		bhkShape* GetCollisionShape() override;               // BC
		void      AddImpact(TESObjectREFR* a_ref, const NiPoint3& a_targetLoc, const NiPoint3& a_velocity, hkpCollidable* a_collidable, std::int32_t a_arg6, std::uint32_t a_arg7) override;               // BD
		bool      HandleHits(hkpCollidable* a_collidable) override;               // BE
		void Handle3DLoaded() override;           // C0
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void Unk_C2(void);  // C2 - { return 1; }

		inline float GetHeight() const
		{
			return GetConeRuntimeData().initialCollisionSphereRadius * 2;
		}

		struct CONE_RUNTIME_DATA
		{
#define CONE_RUNTIME_DATA_CONTENT \
			ImpactResult             impactResult;                  /* 1D8 */ \
			float                    environmentTimer;              /* 1DC */ \
			float                    coneAngleTangent;              /* 1E0 */ \
			float                    initialCollisionSphereRadius;  /* 1E4 */ \
			NiPoint3                 origin;                        /* 1E8 */ \
			std::uint32_t            pad1F4;                        /* 1F4 */ \
			hkRefPtr<hkpSphereShape> collisionShape;                /* 1F8 */ \
			BSTArray<void*>          collisions;                    /* 200 */
			
			CONE_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline CONE_RUNTIME_DATA& GetConeRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<CONE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		[[nodiscard]] inline const CONE_RUNTIME_DATA& GetConeRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<CONE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		CONE_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(ConeProjectile) == 0x218);
#endif
}
#undef CONE_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/C/Console.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/I/IMenu.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	// menuDepth = 12
	// flags = kPausesGame | kAlwaysOpen | kUsesCursor | kAllowSaving
	// context = kConsole
	class Console : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_Console;
		constexpr static std::string_view MENU_NAME = "Console";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT       \
	void*         opcode; /* 00 */ \
	std::uint64_t unk38;  /* 08 */ \
	std::uint64_t unk40;  /* 10 */ \
	std::uint64_t unk48;  /* 18 */ \
	std::uint64_t unk50;  /* 20 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x28);

		~Console() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

		static NiPointer<TESObjectREFR> GetSelectedRef();
		static ObjectRefHandle          GetSelectedRefHandle();

		void SetSelectedRef(NiPointer<TESObjectREFR> a_refPtr);
		void SetSelectedRef(TESObjectREFR* a_ref);
		void SetSelectedRef(ObjectRefHandle a_handle);

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif

			protected :
			void
			SetSelectedRef_Impl(ObjectRefHandle& a_handle);
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(Console) == 0x58);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(Console) == 0x68);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/C/ConsoleData.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSString.h"
#include "RE/I/IUIMessageData.h"

namespace RE
{
	class NiBinaryStream;

	class ConsoleData : public IUIMessageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ConsoleData;

		enum class DataType
		{
		};

		~ConsoleData() override;  // 00

		// members
		BSString*                                 str;      // 10
		ObjectRefHandle                           pickRef;  // 18
		std::uint32_t                             pad1C;    // 1C
		NiBinaryStream*                           file;     // 20
		stl::enumeration<DataType, std::uint32_t> type;     // 28
		std::uint32_t                             pad2C;    // 2C
	};
	static_assert(sizeof(ConsoleData) == 0x30);
}


===============================================
File: include/RE/C/ConsoleLog.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	class ConsoleLog : public BSTSingletonSDM<ConsoleLog>
	{
	public:
		static ConsoleLog* GetSingleton();
		static bool        IsConsoleMode();

		void Print(const char* a_fmt, ...);
		void VPrint(const char* a_fmt, std::va_list a_args);

		// members
		char          lastMessage[0x400];  // 001
		std::uint8_t  pad401;              // 401
		std::uint16_t pad402;              // 402
		std::uint32_t pad404;              // 404
		BSString      buffer;              // 408
	};
	static_assert(sizeof(ConsoleLog) == 0x418);
}


===============================================
File: include/RE/C/ConsoleNativeUIMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 3
	// flags = kPausesGame
	// context = kNone
	class ConsoleNativeUIMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_ConsoleNativeUIMenu;
		constexpr static std::string_view MENU_NAME = "Console Native UI Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT      \
	std::uint8_t  unk30; /* 00 */ \
	std::uint8_t  pad31; /* 01 */ \
	std::uint16_t pad32; /* 02 */ \
	std::uint32_t pad34; /* 04 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x8);

		~ConsoleNativeUIMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(ConsoleNativeUIMenu) == 0x38);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(ConsoleNativeUIMenu) == 0x48);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/C/ConstructibleObjectMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/C/CraftingSubMenu.h"
#include "RE/I/IMessageBoxCallback.h"

namespace RE
{
	namespace CraftingSubMenus
	{
		class ConstructibleObjectMenu : public CraftingSubMenu
		{
		public:
			inline static constexpr auto RTTI = RTTI_CraftingSubMenus__ConstructibleObjectMenu;

			class CreationConfirmCallback : public IMessageBoxCallback
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__ConstructibleObjectMenu__CreationConfirmCallback;

				~CreationConfirmCallback() override;  // 00

				// override (IMessageBoxCallback)
				void Run(Message a_msg) override;  // 01

				// members
				ConstructibleObjectMenu* menu;  // 10
			};
			static_assert(sizeof(CreationConfirmCallback) == 0x18);

			struct ItemEntry
			{
				BGSConstructibleObject* constructibleObject;  // 00
				std::uint32_t           filterFlag;           // 08
				std::uint32_t           pad0C;                // 0C
			};
			static_assert(sizeof(ItemEntry) == 0x10);

			~ConstructibleObjectMenu() override;  // 00

			// override (CraftingSubMenu)
			void Accept(CallbackProcessor* a_cbReg) override;     // 01
			void Unk_06(void) override;                           // 06
			void SetItemCardInfo(ItemCard* a_itemCard) override;  // 07

			// members
			BSTArray<ItemEntry> unk100;  // 100
			std::uint64_t       unk118;  // 118
			std::uint64_t       unk120;  // 120
			std::uint64_t       unk128;  // 128
			std::uint64_t       unk130;  // 130
			std::uint64_t       unk138;  // 138
			std::uint64_t       unk140;  // 140
			std::uint64_t       unk148;  // 148
			std::uint64_t       unk150;  // 150
			std::uint64_t       unk158;  // 158
		};
		static_assert(sizeof(ConstructibleObjectMenu) == 0x160);
	}
}


===============================================
File: include/RE/C/ContainerItemExtra.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	class TESForm;
	class TESGlobal;

	struct ContainerItemExtra  // COED
	{
	public:
		union Conditional
		{
			Conditional();
			~Conditional() = default;

			TESGlobal*   global;
			std::int32_t rank;
		};
		static_assert(sizeof(Conditional) == 0x8);

		ContainerItemExtra();
		ContainerItemExtra(TESForm* a_owner);
		~ContainerItemExtra() = default;

		TES_HEAP_REDEFINE_NEW();

		// members
		TESForm*      owner;        // 00
		Conditional   conditional;  // 08
		float         healthMult;   // 10
		std::uint32_t pad14;        // 14
	};
	static_assert(sizeof(ContainerItemExtra) == 0x18);
}


===============================================
File: include/RE/C/ContainerMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	struct BottomBar;
	struct ItemCard;
	struct ItemList;

	// menuDepth = 0
	// flags = kPausesGame | kUsesMenuContext | kDisablePauseMenu | kUpdateUsesCursor | kInventoryItemMenu | kCustomRendering
	// context = kItemMenu
	class ContainerMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_ContainerMenu;
		constexpr static std::string_view MENU_NAME = "ContainerMenu";

		enum class ContainerMode : std::uint32_t
		{
			kLoot = 0,
			kSteal = 1,
			kPickpocket = 2,
			kNPCMode = 3
		};

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                              \
	GFxValue        root;            /* 00 - "Menu_mc" */ \
	ItemList*       itemList;        /* 18 */             \
	ItemCard*       itemCard;        /* 20 */             \
	BottomBar*      bottomBar;       /* 28 */             \
	BSTArray<void*> unk60;           /* 30 */             \
	BSTArray<void*> unk78;           /* 48 */             \
	std::uint64_t   unk90;           /* 60 */             \
	std::uint64_t   unk98;           /* 68 */             \
	std::uint64_t   unkA0;           /* 70 */             \
	std::uint8_t    unkA8;           /* 78 */             \
	std::uint8_t    padA9;           /* 79 */             \
	std::uint16_t   padAA;           /* 7A */             \
	std::uint32_t   padAC;           /* 7C */             \
	std::int32_t    value;           /* 80 */             \
	std::uint32_t   unkB4;           /* 84 */             \
	std::uint8_t    unkB8;           /* 88 */             \
	bool            pcControlsReady; /* 89 */             \
	std::uint16_t   padBA;           /* 8A */             \
	std::uint32_t   padBC;           /* 8C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x90);

		~ContainerMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04
		void               PostDisplay() override;                           // 06

		[[nodiscard]] ContainerMode    GetContainerMode();
		[[nodiscard]] static RefHandle GetTargetRefHandle();

		[[nodiscard]] GFxValue  GetRoot() const noexcept;
		[[nodiscard]] ItemList* GetItemList() const noexcept;

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(ContainerMenu) == 0xC0);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(ContainerMenu) == 0xD0);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/C/ControlMap.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSInputDevice.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"
#include "RE/I/InputDevices.h"
#include "RE/P/PCGamepadType.h"
#include "RE/U/UserEvents.h"

namespace RE
{
	class UserEventEnabled;

	class ControlMap :
		public BSTSingletonSDM<ControlMap>,      // 00
		public BSTEventSource<UserEventEnabled>  // 08
	{
	public:
		using InputContextID = UserEvents::INPUT_CONTEXT_ID;
		using UEFlag = UserEvents::USER_EVENT_FLAG;

		enum : std::uint32_t
		{
			kInvalid = static_cast<std::uint8_t>(-1)
		};

		struct UserEventMapping
		{
		public:
			// members
			BSFixedString                           eventID;             // 00
			std::uint16_t                           inputKey;            // 08
			std::uint16_t                           modifier;            // 08
			std::int8_t                             indexInContext;      // 0C
			bool                                    remappable;          // 0D
			bool                                    linked;              // 0E
			stl::enumeration<UEFlag, std::uint32_t> userEventGroupFlag;  // 10
			std::uint32_t                           pad14;               // 14
		};
		static_assert(sizeof(UserEventMapping) == 0x18);

		struct InputContext
		{
		public:
			[[nodiscard]] static SKYRIM_REL_VR std::size_t GetNumDeviceMappings() noexcept
			{
#ifndef SKYRIM_CROSS_VR
				return INPUT_DEVICES::kTotal;
#else
				if SKYRIM_REL_VR_CONSTEXPR (REL::Module::IsVR()) {
					return INPUT_DEVICES::kTotal;
				} else {
					return static_cast<std::size_t>(INPUT_DEVICES::kVirtualKeyboard) + 1;
				}
#endif
			}

			// members
			BSTArray<UserEventMapping> deviceMappings[INPUT_DEVICES::kTotal];  // 00
		};
#ifdef ENABLE_SKYRIM_VR
		static_assert(sizeof(InputContext) == 0xA8);
#else
		static_assert(sizeof(InputContext) == 0x60);
#endif

		struct LinkedMapping
		{
		public:
			// members
			BSFixedString  linkedMappingName;     // 00
			InputContextID linkedMappingContext;  // 08
			INPUT_DEVICE   device;                // 0C
			InputContextID linkFromContext;       // 10
			std::uint32_t  pad14;                 // 14
			BSFixedString  linkFromName;          // 18
		};
		static_assert(sizeof(LinkedMapping) == 0x20);

		static ControlMap* GetSingleton();

		std::int8_t      AllowTextInput(bool a_allow);
		constexpr bool   AreControlsEnabled(UEFlag a_flags) const noexcept { return enabledControls.all(a_flags); }
		std::uint32_t    GetMappedKey(std::string_view a_eventID, INPUT_DEVICE a_device, InputContextID a_context = InputContextID::kGameplay) const;
		std::string_view GetUserEventName(std::uint32_t a_buttonID, INPUT_DEVICE a_device, InputContextID a_context = InputContextID::kGameplay) const;
		constexpr bool   IsActivateControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kActivate); }
		constexpr bool   IsConsoleControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kConsole); }
		constexpr bool   IsFightingControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kFighting); }
		constexpr bool   IsLookingControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kLooking); }
		constexpr bool   IsMenuControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kMenu); }
		constexpr bool   IsMainFourControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kMainFour); }
		constexpr bool   IsMovementControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kMovement); }
		constexpr bool   IsPOVSwitchControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kPOVSwitch); }
		constexpr bool   IsSneakingControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kSneaking); }
		constexpr bool   IsVATSControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kVATS); }
		constexpr bool   IsWheelZoomControlsEnabled() const noexcept { return enabledControls.all(UEFlag::kWheelZoom); }
		void             ToggleControls(UEFlag a_flags, bool a_enable);

		// members
		InputContext*                                    controlMap[InputContextID::kTotal];  // 060
		BSTArray<LinkedMapping>                          linkedMappings;                      // 0E8
		BSTArray<InputContextID>                         contextPriorityStack;                // 100
		stl::enumeration<UEFlag, std::uint32_t>          enabledControls;                     // 118
		stl::enumeration<UEFlag, std::uint32_t>          unk11C;                              // 11C
		std::int8_t                                      textEntryCount;                      // 120
		bool                                             ignoreKeyboardMouse;                 // 121
		bool                                             ignoreActivateDisabledEvents;        // 122
		std::uint8_t                                     pad123;                              // 123
		stl::enumeration<PC_GAMEPAD_TYPE, std::uint32_t> gamePadMapType;                      // 124
	};
	static_assert(sizeof(ControlMap) == 0x128);
}


===============================================
File: include/RE/C/CraftingMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"

namespace RE
{
	namespace CraftingSubMenus
	{
		class CraftingSubMenu;
	}

	// menuDepth = 0
	// flags = kUsesMenuContext | kDisablePauseMenu | kUpdateUsesCursor | kInventoryItemMenu | kDontHideCursorWhenTopmost
	// context = kItemMenu
	class CraftingMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_CraftingMenu;
		constexpr static std::string_view MENU_NAME = "Crafting Menu";

		~CraftingMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05
		void               PostDisplay() override;                                                // 06

		[[nodiscard]] inline CraftingSubMenus::CraftingSubMenu* GetCraftingSubMenu() const noexcept
		{
			return REL::RelocateMember<CraftingSubMenus::CraftingSubMenu*>(this, 0x30, 0x40);
		}

		inline void SetCraftingSubMenu(CraftingSubMenus::CraftingSubMenu* craftingSubMenu) noexcept
		{
			REL::RelocateMember<CraftingSubMenus::CraftingSubMenu*>(this, 0x30, 0x40) = craftingSubMenu;
		}

		// members
#ifndef SKYRIM_CROSS_VR
		CraftingSubMenus::CraftingSubMenu* subMenu;  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(CraftingMenu) == 0x38);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(CraftingMenu) == 0x48);
#endif
}


===============================================
File: include/RE/C/CraftingSubMenu.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTEvent.h"
#include "RE/F/FxDelegateHandler.h"
#include "RE/G/GFxValue.h"

namespace RE
{
	class GFxMovieView;
	class TESFurniture;
	struct ItemCard;
	struct TESFurnitureEvent;

	namespace CraftingSubMenus
	{
		class CraftingSubMenu :
			public FxDelegateHandler,               // 00
			public BSTEventSink<TESFurnitureEvent>  // 10
		{
		public:
			inline static constexpr auto RTTI = RTTI_CraftingSubMenus__CraftingSubMenu;

			~CraftingSubMenu() override;  // 00

			// add
			virtual void Unk_02(void);                                // 02 - { return; }
			virtual void Unk_03(void);                                // 03 - { return; }
			virtual bool HasItemPreview();                            // 04 - { return 1; }
			virtual bool ProcessUserEvent(BSFixedString* a_control);  // 05 - { return 0; }
			virtual void Unk_06(void);                                // 06 - { return; }
			virtual void SetItemCardInfo(ItemCard* a_itemCard);       // 07 - { return; }

			// members
			GFxMovieView* view;                   // 018
			TESFurniture* furniture;              // 020
			ItemCard*     itemCard;               // 028
			GFxValue*     unk030;                 // 030
			GFxValue      craftingMenu;           // 038
			GFxValue      itemList;               // 050
			GFxValue      entryList;              // 068
			GFxValue      itemInfo;               // 080
			GFxValue      bottomBarInfo;          // 098
			GFxValue      additionalDescription;  // 0B0
			GFxValue      menuName;               // 0C8
			GFxValue      buttonText;             // 0E0
			bool          unk0F8;                 // 0F8
			std::uint8_t  pad0F9;                 // 0F9
			std::uint16_t pad0FA;                 // 0FA
			std::uint32_t pad0FC;                 // 0FC
		};
		static_assert(sizeof(CraftingSubMenu) == 0x100);
	}
}


===============================================
File: include/RE/C/CreationClubMenu.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/G/GFxFunctionHandler.h"
#include "RE/I/IMenu.h"
#include "RE/I/ImageData.h"
#include "RE/M/MenuEventHandler.h"

namespace RE
{
	class MenuOpenCloseEvent;

	// menuDepth = 0
	// flags = kUsesMenuContext | kDisablePauseMenu | kUpdateUsesCursor | kInventoryItemMenu | kDontHideCursorWhenTopmost
	// context = kItemMenu
	class CreationClubMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                            // 00
		public MenuEventHandler,                 // 30
		public GFxFunctionHandler,               // 40
		public BSTEventSink<MenuOpenCloseEvent>  // 50
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_CreationClubMenu;
		constexpr static std::string_view MENU_NAME = "Creation Club Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT       \
	ImageData background; /* 00 */ \
	ImageData details;    /* 18 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x30);

		~CreationClubMenu() override;  // 00

		// override (IMenu)
		void AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05

#ifndef SKYRIM_CROSS_VR
		// override (MenuEventHandler)
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03

		// override (GFxFunctionHandler)
		void Call(Params& a_params) override;  // 01

		// override (BSTEventSink<MenuOpenCloseEvent>)
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<CreationClubMenu*>(this)->AsMenuEventHandler();
		}

		[[nodiscard]] GFxFunctionHandler* AsGFxFunctionHandler() noexcept
		{
			return &REL::RelocateMember<GFxFunctionHandler>(this, 0x40, 0x50);
		}

		[[nodiscard]] const GFxFunctionHandler* AsGFxFunctionHandler() const noexcept
		{
			return const_cast<CreationClubMenu*>(this)->AsGFxFunctionHandler();
		}

		[[nodiscard]] BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<MenuOpenCloseEvent>>(this, 0x50, 0x60);
		}

		[[nodiscard]] const BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() const noexcept
		{
			return const_cast<CreationClubMenu*>(this)->AsMenuOpenCloseEventSink();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x58, 0x68);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x58, 0x68);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 58, 68
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(CreationClubMenu) == 0x88);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(CreationClubMenu) == 0x98);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/C/CreditsMenu.h
===============================================
#pragma once

#include "RE/G/GFxFunctionHandler.h"
#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 10
	// flags = kPausesGame
	// context = kMenuMode
	class CreditsMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,              // 00
		public GFxFunctionHandler  // 30
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_CreditsMenu;
		constexpr static std::string_view MENU_NAME = "Credits Menu";

		~CreditsMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04

#ifndef SKYRIM_CROSS_VR
		// override (GFxFunctionHandler)
		void Call(Params& a_params) override;  // 01
#endif

		[[nodiscard]] GFxFunctionHandler* AsGFxFunctionHandler() noexcept
		{
			return &REL::RelocateMember<GFxFunctionHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const GFxFunctionHandler* AsGFxFunctionHandler() const noexcept
		{
			return const_cast<CreditsMenu*>(this)->AsGFxFunctionHandler();
		}
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(CreditsMenu) == 0x40);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(CreditsMenu) == 0x50);
#endif
}


===============================================
File: include/RE/C/Crime.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"

namespace RE
{
	class TESBoundObject;
	class TESFaction;
	class TESForm;

	namespace PackageNS
	{
		struct CRIME_TYPES
		{
			enum CRIME_TYPE : std::uint32_t
			{
				kNone = static_cast<std::underlying_type_t<CRIME_TYPE>>(-1),
				kSteal = 0,
				kPickpocket = 1,
				kTrespass = 2,
				kAttack = 3,
				kMurder = 4,
				kEscape = 5,
				kUnused = 6,

				kTotal = 7
			};
		};
		using CRIME_TYPE = CRIME_TYPES::CRIME_TYPE;
	}

	struct Crime
	{
	public:
		// members
		std::uint64_t           unk00;              // 00
		std::uint64_t           unk08;              // 08
		std::uint64_t           unk10;              // 10
		std::uint64_t           unk18;              // 18
		std::uint64_t           unk20;              // 20
		BSTArray<ActorHandle>   actorsKnowOfCrime;  // 28
		std::uint64_t           unk40;              // 40
		std::uint64_t           unk48;              // 48
		std::uint64_t           unk50;              // 50
		std::uint64_t           unk58;              // 58
		TESFaction*             crimeFaction;       // 60
		std::uint32_t           unk68;              // 68
		mutable BSReadWriteLock lock;               // 68
		std::uint32_t           unk74;              // 74
	};
	static_assert(sizeof(Crime) == 0x78);
}


===============================================
File: include/RE/C/CriticalHit.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class TESObjectREFR;
	class TESObjectWEAP;

	struct CriticalHit
	{
	public:
		struct Event
		{
		public:
			// members
			TESObjectREFR* aggressor;   // 00
			TESObjectWEAP* weapon;      // 08
			bool           sneakHit;    // 10
			std::uint8_t   pad11{ 0 };  // 11
			std::uint16_t  pad12{ 0 };  // 12
			std::uint32_t  pad14{ 0 };  // 14
		};
		static_assert(sizeof(Event) == 0x18);

		static BSTEventSource<CriticalHit::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/C/CrosshairPickData.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class bhkRigidBody;
	class bhkSimpleShapePhantom;

	class CrosshairPickData
	{
	public:
		static CrosshairPickData* GetSingleton()
		{
			REL::Relocation<CrosshairPickData**> singleton{ RELOCATION_ID(515446, 401585) };
			return *singleton;
		}

		// members
		std::uint32_t                    pad00;           // 00
		ObjectRefHandle                  target;          // 04
		ObjectRefHandle                  targetActor;     // 08
		ObjectRefHandle                  grabPickRef;     // 0C
		NiPoint3                         collisionPoint;  // 10
		std::uint32_t                    pad1C;           // 1C
		bhkRigidBody*                    targetCollider;  // 20
		NiPointer<bhkSimpleShapePhantom> pickCollider;    // 28
		std::uint32_t                    collisionInfo;   // 30
		std::uint8_t                     unk34;           // 34
		std::uint8_t                     unk35;           // 35
		std::uint16_t                    unk36;           // 36
	};
	static_assert(sizeof(CrosshairPickData) == 0x38);
}


===============================================
File: include/RE/C/CureEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/E/EffectArchetypes.h"
#include "RE/M/MagicSystem.h"

namespace RE
{
	class CureEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_CureEffect;
		inline static constexpr auto VTABLE = VTABLE_CureEffect;

		// override (ActiveEffect)
		virtual ~CureEffect();          // 13
		virtual void Start() override;  // 14

		// members
		MagicSystem::SpellType spellType;    // 90
		EffectArchetype        archetypeID;  // 94
	};
	static_assert(sizeof(CureEffect) == 0x98);
}


===============================================
File: include/RE/C/CursorMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"
#include "RE/M/MenuEventHandler.h"

namespace RE
{
	// menuDepth = 13
	// flags = kAllowSaving | kCustomRendering
	// context = kNone
	class CursorMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,            // 00
		public MenuEventHandler  // 30
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_CursorMenu;
		constexpr static std::string_view MENU_NAME = "Cursor Menu";

		~CursorMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04

		// override (MenuEventHandler)
#ifndef SKYRIM_CROSS_VR
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03
		bool ProcessMouseMove(MouseMoveEvent* a_event) override;    // 04
#endif

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<CursorMenu*>(this)->AsMenuEventHandler();
		}
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(CursorMenu) == 0x40);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(CursorMenu) == 0x50);
#endif
}


===============================================
File: include/RE/D/DBTraits.h
===============================================
#pragma once

namespace RE
{
	namespace BSModelDB
	{
		struct DBTraits
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSModelDB__DBTraits;

			struct ArgsType
			{
			public:
				// members
				std::uint32_t LODmult{ 0 };         // 0
				std::uint32_t texLoadLevel{ 3 };    // 4
				bool          unk8{ true };         // 8
				bool          unk9{ false };        // 9
				bool          unkA{ true };         // A
				bool          postProcess{ true };  // B
			};
			static_assert(sizeof(ArgsType) == 0xC);
		};
	}
}


===============================================
File: include/RE/D/DarknessEffect.h
===============================================
#pragma once

#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class DarknessEffect :
		public ValueModifierEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_DarknessEffect;
		inline static constexpr auto VTABLE = VTABLE_DarknessEffect;

		// override (ActiveEffect)
		virtual ~DarknessEffect();       // 13
		virtual void Start() override;   // 14
		virtual void Finish() override;  // 15
	};
	static_assert(sizeof(DarknessEffect) == 0x98);
}


===============================================
File: include/RE/D/DecalData.h
===============================================
#pragma once

namespace RE
{
	struct DECAL_DATA_DATA
	{
	public:
		enum Flag : std::uint8_t
		{
			kNone = 0,
			kParallax = 1 << 0,
			kAlphaBlending = 1 << 1,
			kAlphaTesting = 1 << 2,
			kNoSubtextures = 1 << 3
		};

		// members
		float         decalMinWidth;   // 00
		float         decalMaxWidth;   // 04
		float         decalMinHeight;  // 08
		float         decalMaxHeight;  // 0C
		float         depth;           // 10
		float         shininess;       // 14
		float         parallaxScale;   // 18
		std::int8_t   parallaxPasses;  // 1C
		Flag          flags;           // 1D
		std::uint16_t pad1E;           // 1E
		Color         color;           // 20
	};
	static_assert(sizeof(DECAL_DATA_DATA) == 0x24);

	struct DecalData
	{
	public:
		// members
		DECAL_DATA_DATA data;  // 00
	};
	static_assert(sizeof(DecalData) == 0x24);
}


===============================================
File: include/RE/D/DefaultObjectsReadyEvent.h
===============================================
#pragma once

namespace RE
{
	struct DefaultObjectsReadyEvent
	{
	public:
		struct Event
		{
		public:
		};
	};
}


===============================================
File: include/RE/D/DelayFunctor.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"

namespace RE
{
	namespace BSScript
	{
		class Variable;
	}

	class BSStorage;

	namespace SkyrimScript
	{
		class DelayFunctor : public BSIntrusiveRefCounted
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript__DelayFunctor;

			enum class FunctorType
			{
				kMoveTo = 0,
				kSetPosition = 6,
				kSetMotionType = 8,
				kDropObject = 12,
				kAttachAshPile = 14,
				kSendPlayerToJail = 19,
				kRemoveItem = 24
			};

			virtual ~DelayFunctor();  // 00

			// add
			virtual RE::BSScript::Variable operator()() = 0;                                                          // 01
			virtual bool                   IsLatent() const = 0;                                                      // 02
			virtual bool                   WantsRequeue() const;                                                      // 03 - { return false; }
			virtual bool                   SaveImpl(BSStorage& a_storage) const;                                      // 04
			virtual FunctorType            GetType() const = 0;                                                       // 05
			virtual bool                   LoadImpl(const BSStorage& a_storage, std::uint32_t a_arg2, bool& a_arg3);  // 06

			// members
			VMStackID stackID;  // 0C
		};
		static_assert(sizeof(DelayFunctor) == 0x10);
	}
}


===============================================
File: include/RE/D/DemoralizeEffect.h
===============================================
#pragma once

#include "RE/T/TargetValueModifierEffect.h"

namespace RE
{
	class DemoralizeEffect : public TargetValueModifierEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_DemoralizeEffect;
		inline static constexpr auto VTABLE = VTABLE_DemoralizeEffect;

		// override (TargetValueModifierEffect)
		~DemoralizeEffect() override;  // 13

		float GetTargetValue() const override;  // 21 - { return 0.0f; }
	};
	static_assert(sizeof(DemoralizeEffect) == 0x98);
}


===============================================
File: include/RE/D/DepthStencilDepthModes.h
===============================================
#pragma once

namespace RE
{
	namespace BSGraphics
	{
		enum class DepthStencilDepthMode
		{
			kDisabled = 0,
			kTest = 1,
			kWrite = 2,
			kTestWrite = 3,
			kTestEqual = 4,
			kTestGreaterEqual = 5,
			kTestGreater = 6
		};
	}
}


===============================================
File: include/RE/D/DetectLifeEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class DetectLifeEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_DetectLifeEffect;
		inline static constexpr auto VTABLE = VTABLE_DetectLifeEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;                    // 04
		virtual bool ShouldDispelOnDeath() const override;              // 10
		virtual bool GetAllowMultipleCastingSourceStacking() override;  // 11
		virtual ~DetectLifeEffect();                                    // 13
		virtual bool CheckCustomSkillUseConditions() const override;    // 17
	};
	static_assert(sizeof(DetectLifeEffect) == 0x90);
}


===============================================
File: include/RE/D/DetectionListener.h
===============================================
#pragma once

#include "RE/N/NiRefObject.h"

namespace RE
{
	class DetectionListener : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_DetectionListener;

		~DetectionListener() override;  // 00

		// add
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void);      // 03 - { return; }
		virtual void Unk_04(void);      // 04 - { return; }
	};
	static_assert(sizeof(DetectionListener) == 0x10);
}


===============================================
File: include/RE/D/DetectionPriorities.h
===============================================
#pragma once

namespace RE
{
	enum class DETECTION_PRIORITY
	{
		kNone = 0,
		kVeryLow = 1,
		kLow = 2,
		kNormal = 3,
		kHigh = 4,
		kCritical = 5
	};
}


===============================================
File: include/RE/D/DetectionState.h
===============================================
#pragma once

#include "RE/N/NiPoint3.h"
#include "RE/N/NiRefObject.h"

namespace RE
{
	class DetectionState : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_DetectionState;

		~DetectionState() override;  // 00

		// members
		std::int32_t level;  // 10
		std::uint8_t unk14;  // 14
		std::uint8_t unk15;  // 15
		std::uint8_t unk16;  // 16
		std::uint8_t pad17;  // 17
		float        unk18;  // 18
		NiPoint3     unk1C;  // 1C
		float        unk28;  // 28
		NiPoint3     unk2C;  // 2C
		float        unk38;  // 38
		NiPoint3     unk3C;  // 3C
	};
	static_assert(sizeof(DetectionState) == 0x48);
}


===============================================
File: include/RE/D/DevNull.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/L/Location.h"
#include "RE/S/Stream.h"

namespace RE
{
	namespace BSResource
	{
		class DevNull :
			public Location,                 // 00
			public BSTSingletonSDM<DevNull>  // 10
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource____DevNull;

			struct NullStream : public Stream
			{
			public:
				~NullStream() override;  // 00

				// override (Stream)
				ErrorCode DoOpen() override;                                                                                // 01 - { return ErrorCode::kNone; }
				void      DoClose() override;                                                                               // 02 - { return; }
				void      DoClone(BSTSmartPointer<Stream>& a_out) const override;                                           // 05
				ErrorCode DoRead(void* a_buffer, std::uint64_t a_toRead, std::uint64_t& a_read) const override;             // 06
				ErrorCode DoWrite(const void* a_buffer, std::uint64_t a_toWrite, std::uint64_t& a_written) const override;  // 07
				ErrorCode DoSeek(std::uint64_t a_toSeek, SeekMode a_mode, std::uint64_t& a_sought) const override;          // 08
			};
			static_assert(sizeof(NullStream) == 0x10);

			~DevNull() override;  // 00

			// override (Location)
			ErrorCode DoMount() override;                                                                                                      // 01 - { return ErrorCode::kNone; }
			void      DoUnmount() override;                                                                                                    // 02 - { return; }
			ErrorCode DoCreateStream(const char* a_path, BSTSmartPointer<Stream>& a_stream, Location*& a_location, bool a_readOnly) override;  // 03
			ErrorCode DoTraversePrefix(const char* a_path, LocationTraverser& a_traverser) override;                                           // 05 - { return ErrorCode::kNotExist; }

			// members
			std::uint8_t            pad11;       // 11
			std::uint16_t           pad12;       // 12
			std::uint32_t           pad14;       // 14
			BSTSmartPointer<Stream> nullReader;  // 18
			BSTSmartPointer<Stream> nullWriter;  // 20
		};
		static_assert(sizeof(DevNull) == 0x28);
	}
}


===============================================
File: include/RE/D/DeviceConnectEvent.h
===============================================
#pragma once

#include "RE/I/InputEvent.h"

namespace RE
{
	class DeviceConnectEvent : public InputEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_DeviceConnectEvent;

		~DeviceConnectEvent() override;  // 00

		// members
		bool          connected;  // 18
		std::uint8_t  pad19;      // 19
		std::uint16_t pad1A;      // 1A
		std::uint32_t pad1C;      // 1C
	};
	static_assert(sizeof(DeviceConnectEvent) == 0x20);
}


===============================================
File: include/RE/D/DialogueItem.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSString.h"
#include "RE/B/BSTList.h"
#include "RE/E/EmotionTypes.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class Actor;
	class BGSSoundDescriptorForm;
	class ExtraSayToTopicInfo;
	class TESIdleForm;
	class TESObjectREFR;
	class TESQuest;
	class TESTopic;
	class TESTopicInfo;

	class DialogueResponse
	{
	public:
		// members
		BSString                                     text;              // 00
		stl::enumeration<EmotionType, std::uint32_t> animFaceArchType;  // 10
		std::uint16_t                                percent;           // 14
		std::uint16_t                                pad16;             // 16
		BSFixedString                                voice;             // 18
		TESIdleForm*                                 speakerIdle;       // 20
		TESIdleForm*                                 listenIdle;        // 28
		BGSSoundDescriptorForm*                      voiceSound;        // 30
		bool                                         useEmotion;        // 38
		bool                                         soundLip;          // 39
		std::uint16_t                                pad3A;             // 3A
		std::uint32_t                                pad3C;             // 3C
	};
	static_assert(sizeof(DialogueResponse) == 0x40);

	class DialogueItem : public BSIntrusiveRefCounted
	{
	public:
		DialogueItem(TESQuest* a_quest, TESTopic* a_topic, TESTopicInfo* a_topicInfo, Actor* a_speaker)
		{
			Ctor(a_quest, a_topic, a_topicInfo, a_speaker);
		}

		~DialogueItem() = default;

		TES_HEAP_REDEFINE_NEW();

		// members
		std::uint32_t                          pad04{ 0 };                  // 04
		BSSimpleList<DialogueResponse*>        responses;                   // 08
		BSSimpleList<DialogueResponse*>::Node* currentResponse{ nullptr };  // 18
		TESTopicInfo*                          info{ nullptr };             // 20
		TESTopic*                              topic{ nullptr };            // 28
		TESQuest*                              quest{ nullptr };            // 30
		TESObjectREFR*                         speaker{ nullptr };          // 38
		ExtraSayToTopicInfo*                   extraData{ nullptr };        // 40

	private:
		DialogueItem* Ctor(TESQuest* a_quest, TESTopic* a_topic, TESTopicInfo* a_topicInfo, Actor* a_speaker)
		{
			using func_t = decltype(&DialogueItem::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(34413, 35220) };
			return func(this, a_quest, a_topic, a_topicInfo, a_speaker);
		}
	};
	static_assert(sizeof(DialogueItem) == 0x48);
}


===============================================
File: include/RE/D/DialogueMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class MenuOpenCloseEvent;

	// menuDepth = 3
	// flags = kUpdateUsesCursor | kDontHideCursorWhenTopmost
	// context = kMenuMode
	class DialogueMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                            // 00
		public BSTEventSink<MenuOpenCloseEvent>  // 30
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_DialogueMenu;
		constexpr static std::string_view MENU_NAME = "Dialogue Menu";

		struct Data
		{
			void*         unk00;  // 00
			std::uint64_t unk08;  // 08
		};
		static_assert(sizeof(Data) == 0x10);

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT BSTArray<Data> unk38; /* 00 */
			RUNTIME_DATA_CONTENT
		};

		~DialogueMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

#ifndef SKYRIM_CROSS_VR
		// override (BSTEventSink<MenuOpenCloseEvent>)
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<MenuOpenCloseEvent>>(this, 0x30, 0x40);
		}

		[[nodiscard]] const BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() const noexcept
		{
			return const_cast<DialogueMenu*>(this)->AsMenuOpenCloseEventSink();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x38, 0x48);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x38, 0x48);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 38, 48
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(DialogueMenu) == 0x50);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(DialogueMenu) == 0x60);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/D/DialoguePackage.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESPackage.h"

namespace RE
{
	class DialoguePackage : public TESPackage
	{
	public:
		inline static constexpr auto RTTI = RTTI_DialoguePackage;
		inline static constexpr auto VTABLE = VTABLE_DialoguePackage;
		inline static constexpr auto FORMTYPE = FormType::Package;

		~DialoguePackage() override;  // 00

		// override (TESPackage)
		void               SaveGame(BGSSaveFormBuffer* a_buf) override;      // 0E
		void               LoadGame(BGSLoadFormBuffer* a_buf) override;      // 0F
		void               InitLoadGame(BGSLoadFormBuffer* a_buf) override;  // 10 - { TESForm::InitLoadGame(a_buf); }
		void               Copy(TESForm* a_srcForm) override;                // 2F - { TESForm::Copy(a_srcForm); }
		[[nodiscard]] bool IsPackageOwner(Actor* a_actor) override;          // 3F

		// members
		std::uint32_t   unk0E0;  // 0E0
		ObjectRefHandle unk0E4;  // 0E4
		ActorHandle     unk0E8;  // 0E8
		ActorHandle     unk0EC;  // 0EC
		std::uint64_t   unk0F0;  // 0F0
		std::uint64_t   unk0F8;  // 0F8
	};
	static_assert(sizeof(DialoguePackage) == 0x100);
}


===============================================
File: include/RE/D/DialogueTypes.h
===============================================
#pragma once

namespace RE
{
	struct DIALOGUE_TYPES
	{
		enum DIALOGUE_TYPE
		{
			kPlayerDialogue = 0,
			kCommandDialogue = 1,

			kBranchedTotal = 2,

			kSceneDialogue = kBranchedTotal,
			kCombat = 3,
			kFavors = 4,
			kDetection = 5,
			kService = 6,
			kMiscellaneous = 7,

			kTotal = 8
		};
	};
	using DIALOGUE_TYPE = DIALOGUE_TYPES::DIALOGUE_TYPE;
}


===============================================
File: include/RE/D/DisarmEffect.h
===============================================
#pragma once

#include "RE/S/StaggerEffect.h"

namespace RE
{
	class DisarmEffect :
		public StaggerEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_DisarmEffect;
		inline static constexpr auto VTABLE = VTABLE_DisarmEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;  // 04
		virtual ~DisarmEffect();                      // 13
		virtual void Start() override;                // 14
	};
	static_assert(sizeof(DisarmEffect) == 0x90);
}


===============================================
File: include/RE/D/DisarmedEvent.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class Actor;

	struct DisarmedEvent
	{
	public:
		struct Event
		{
		public:
			// members
			Actor* source;  // 00
			Actor* target;  // 08
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<DisarmedEvent::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/D/DisguiseEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class DisguiseEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_DisguiseEffect;
		inline static constexpr auto VTABLE = VTABLE_DisguiseEffect;

		enum class State
		{
			kInitiate = 0,
			kWaiting,
			kNormal,
			kFail
		};

		// override (ActiveEffect)
		virtual void EvaluateConditions(float a_delta, bool a_forceUpdate) override;  // 05
		virtual void SaveGame(BGSSaveFormBuffer* a_buf) override;                     // 08
		virtual void LoadGame(BGSLoadFormBuffer* a_buf) override;                     // 09
		virtual void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;               // 0A
		virtual ~DisguiseEffect();                                                    // 13
		virtual void Start() override;                                                // 14
		virtual void Finish() override;                                               // 15

		// members
		DisguiseEffect::State state;  // 90
	};
	static_assert(sizeof(DisguiseEffect) == 0x98);
}


===============================================
File: include/RE/D/DispelEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class DispelEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_DispelEffect;
		inline static constexpr auto VTABLE = VTABLE_DispelEffect;

		// override (ActiveEffect)
		virtual ~DispelEffect();        // 13
		virtual void Start() override;  // 14
	};
	static_assert(sizeof(DispelEffect) == 0x90);
}


===============================================
File: include/RE/D/DoNothingUnhandledPolicy.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class DoNothingUnhandledPolicy
	{
	public:
		DoNothingUnhandledPolicy() = default;
		virtual ~DoNothingUnhandledPolicy() = default;  // 00
	};
	static_assert(sizeof(DoNothingUnhandledPolicy<void*>) == 0x8);
}


===============================================
File: include/RE/D/DragonSoulsGained.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	struct DragonSoulsGained
	{
	public:
		struct Event
		{
		public:
			// members
			float         souls;  // 00
			std::uint32_t pad04;  // 04
		};
		static_assert(sizeof(Event) == 0x08);

		static BSTEventSource<DragonSoulsGained::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/D/DropObjectFunctor.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/D/DelayFunctor.h"

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
	}

	namespace SkyrimScript
	{
		class DropObjectFunctor : public DelayFunctor
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript____DropObjectFunctor;

			~DropObjectFunctor() override;  // 00

			// override (DelayFunctor)
			RE::BSScript::Variable operator()() override;                                                              // 01
			bool                   IsLatent() const override;                                                          // 02 - { return true; }
			bool                   SaveImpl(BSStorage& a_storage) const override;                                      // 04
			FunctorType            GetType() const override;                                                           // 05 - { return 12; }
			bool                   LoadImpl(const BSStorage& a_storage, std::uint32_t a_arg2, bool& a_arg3) override;  // 06

			// members
			ObjectRefHandle                            dropper;      // 10
			FormID                                     itemToDrop;   // 14
			std::uint32_t                              countToDrop;  // 18
			std::uint32_t                              pad1C;        // 1C
			BSTSmartPointer<BSScript::IVirtualMachine> vm;           // 20
		};
		static_assert(sizeof(DropObjectFunctor) == 0x28);
	}
}


===============================================
File: include/RE/D/DualValueModifierEffect.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class DualValueModifierEffect :
		public ValueModifierEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_DualValueModifierEffect;
		inline static constexpr auto VTABLE = VTABLE_DualValueModifierEffect;

		// override (ActiveEffect)
		virtual bool IsCausingHealthDamage() override;             // 06
		virtual void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 08
		virtual void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 09
		virtual ~DualValueModifierEffect();                        // 13

		// override (ValueModifierEffect)
		virtual void ModifyActorValue(Actor* a_actor, float a_value, ActorValue a_actorValue) override;  // 20

		// add
		virtual ActorValue GetAdditionalActorValue() const;  // 21
		virtual float      GetSecondaryAVWeight() const;     // 22

		// members
		ActorValue secondaryActorValue;  // 98
		float      secondaryAVWeight;    // 9C
	};
	static_assert(sizeof(DualValueModifierEffect) == 0xA0);
}


===============================================
File: include/RE/E/Effect.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"
#include "RE/T/TESCondition.h"

namespace RE
{
	class EffectSetting;

	struct Effect
	{
	public:
		struct EffectItem  // EFIT
		{
		public:
			EffectItem();
			~EffectItem() = default;

			// members
			float         magnitude;  // 0
			std::uint32_t area;       // 4
			std::uint32_t duration;   // 8
		};
		static_assert(sizeof(EffectItem) == 0xC);

		Effect();
		~Effect() = default;

		TES_HEAP_REDEFINE_NEW();

		float         GetMagnitude() const;
		std::uint32_t GetArea() const;
		std::uint32_t GetDuration() const;
		bool          IsHostile() const;

		// members
		EffectItem     effectItem;  // 00 - EFIT
		std::uint32_t  pad0C;       // 0C
		EffectSetting* baseEffect;  // 10 - EFID
		float          cost;        // 18
		std::uint32_t  pad1C;       // 1C
		TESCondition   conditions;  // 20 - CTDA
	};
	static_assert(sizeof(Effect) == 0x28);
}


===============================================
File: include/RE/E/EffectArchetypes.h
===============================================
#pragma once

namespace RE
{
	struct EffectArchetypes
	{
		enum class ArchetypeID
		{
			kNone = static_cast<std::underlying_type_t<ArchetypeID>>(-1),
			kValueModifier = 0,
			kScript = 1,
			kDispel = 2,
			kCureDisease = 3,
			kAbsorb = 4,
			kDualValueModifier = 5,
			kCalm = 6,
			kDemoralize = 7,
			kFrenzy = 8,
			kDisarm = 9,
			kCommandSummoned = 10,
			kInvisibility = 11,
			kLight = 12,
			kDarkness = 13,
			kNightEye = 14,
			kLock = 15,
			kOpen = 16,
			kBoundWeapon = 17,
			kSummonCreature = 18,
			kDetectLife = 19,
			kTelekinesis = 20,
			kParalysis = 21,
			kReanimate = 22,
			kSoulTrap = 23,
			kTurnUndead = 24,
			kGuide = 25,
			kWerewolfFeed = 26,
			kCureParalysis = 27,
			kCureAddiction = 28,
			kCurePoison = 29,
			kConcussion = 30,
			kValueAndParts = 31,
			kAccumulateMagnitude = 32,
			kStagger = 33,
			kPeakValueModifier = 34,
			kCloak = 35,
			kWerewolf = 36,
			kSlowTime = 37,
			kRally = 38,
			kEnhanceWeapon = 39,
			kSpawnHazard = 40,
			kEtherealize = 41,
			kBanish = 42,
			kSpawnScriptedRef = 43,
			kDisguise = 44,
			kGrabActor = 45,
			kVampireLord = 46
		};
	};
	using EffectArchetype = EffectArchetypes::ArchetypeID;

	[[nodiscard]] std::string_view EffectArchetypeToString(EffectArchetype a_archetype) noexcept;
}

namespace std
{
	[[nodiscard]] inline std::string to_string(RE::EffectArchetype a_archetype)
	{
		return RE::EffectArchetypeToString(a_archetype).data();
	}
}

namespace fmt
{
	template <>
	struct formatter<RE::EffectArchetype>
	{
		template <class ParseContext>
		constexpr auto parse(ParseContext& a_ctx)
		{
			return a_ctx.begin();
		}

		template <class FormatContext>
		auto format(const RE::EffectArchetype& a_archetype, FormatContext& a_ctx)
		{
			return fmt::format_to(a_ctx.out(), "{}", RE::EffectArchetypeToString(a_archetype));
		}
	};
}

#ifdef __cpp_lib_format
namespace std
{
	template <class CharT>
	struct formatter<RE::EffectArchetype, CharT> : std::formatter<std::string_view, CharT>
	{
		template <class FormatContext>
		auto format(RE::EffectArchetype a_archetype, FormatContext& a_ctx)
		{
			return formatter<std::string_view, CharT>::format(RE::EffectArchetypeToString(a_archetype), a_ctx);
		}
	};
}
#endif


===============================================
File: include/RE/E/EffectSetting.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSMenuDisplayObject.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTList.h"
#include "RE/E/EffectArchetypes.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MagicSystem.h"
#include "RE/S/SoundLevels.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class EffectSetting :
		public TESForm,               // 000
		public TESFullName,           // 020
		public BGSMenuDisplayObject,  // 030
		public BGSKeywordForm         // 040
	{
	public:
		inline static constexpr auto RTTI = RTTI_EffectSetting;
		inline static constexpr auto VTABLE = VTABLE_EffectSetting;
		inline static constexpr auto FORMTYPE = FormType::MagicEffect;

		using Archetype = EffectArchetypes::ArchetypeID;
		using FilterValidation_t = bool(EffectSetting*, void*);

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct EffectSettingData  // DATA
		{
		public:
			enum class Flag
			{
				kNone = 0,
				kHostile = 1 << 0,
				kRecover = 1 << 1,
				kDetrimental = 1 << 2,
				kSnapToNavMesh = 1 << 3,
				kNoHitEvent = 1 << 4,
				kDispelWithKeywords = 1 << 8,
				kNoDuration = 1 << 9,
				kNoMagnitude = 1 << 10,
				kNoArea = 1 << 11,
				kFXPersist = 1 << 12,
				kGoryVisuals = 1 << 14,
				kHideInUI = 1 << 15,
				kNoRecast = 1 << 17,
				kPowerAffectsMagnitude = 1 << 21,
				kPowerAffectsDuration = 1 << 22,
				kPainless = 1 << 26,
				kNoHitEffect = 1 << 27,
				kNoDeathDispel = 1 << 28
			};

			// members
			stl::enumeration<Flag, std::uint32_t> flags;                  // 00
			float                                 baseCost;               // 04
			TESForm*                              associatedForm;         // 08
			ActorValue                            associatedSkill;        // 10
			ActorValue                            resistVariable;         // 14
			std::int16_t                          numCounterEffects;      // 18
			std::uint16_t                         pad1A;                  // 1A
			std::uint32_t                         pad1C;                  // 1C
			TESObjectLIGH*                        light;                  // 20
			float                                 taperWeight;            // 28
			std::uint32_t                         pad2C;                  // 2C
			TESEffectShader*                      effectShader;           // 30
			TESEffectShader*                      enchantShader;          // 38
			std::int32_t                          minimumSkill;           // 40
			std::int32_t                          spellmakingArea;        // 44
			float                                 spellmakingChargeTime;  // 48
			float                                 taperCurve;             // 4C
			float                                 taperDuration;          // 50
			float                                 secondAVWeight;         // 54
			Archetype                             archetype;              // 58
			ActorValue                            primaryAV;              // 5C
			BGSProjectile*                        projectileBase;         // 60
			BGSExplosion*                         explosion;              // 68
			MagicSystem::CastingType              castingType;            // 70
			MagicSystem::Delivery                 delivery;               // 74
			ActorValue                            secondaryAV;            // 78
			BGSArtObject*                         castingArt;             // 80
			BGSArtObject*                         hitEffectArt;           // 88
			BGSImpactDataSet*                     impactDataSet;          // 90
			float                                 skillUsageMult;         // 98
			std::uint32_t                         pad9C;                  // 9C
			BGSDualCastData*                      dualCastData;           // A0
			float                                 dualCastScale;          // A8
			std::uint32_t                         padAC;                  // AC
			BGSArtObject*                         enchantEffectArt;       // B0
			BGSReferenceEffect*                   hitVisuals;             // B8
			BGSReferenceEffect*                   enchantVisuals;         // C0
			SpellItem*                            equipAbility;           // C8
			TESImageSpaceModifier*                imageSpaceMod;          // D0
			BGSPerk*                              perk;                   // D8
			SOUND_LEVEL                           castingSoundLevel;      // E0
			float                                 aiScore;                // E4
			float                                 aiDelayTimer;           // E8
			std::uint32_t                         padEC;                  // EC
		};
		static_assert(sizeof(EffectSettingData) == 0xF0);

		struct SoundPair  // SNDD
		{
		public:
			// members
			MagicSystem::SoundID    id;     // 00
			std::uint32_t           pad04;  // 04
			BGSSoundDescriptorForm* sound;  // 08
		};
		static_assert(sizeof(SoundPair) == 0x10);

		~EffectSetting() override;  // 00

		// override (TESForm)
		void        ClearData() override;                // 05
		bool        Load(TESFile* a_mod) override;       // 06
		void        InitItemImpl() override;             // 13
		void        Copy(TESForm* a_srcForm) override;   // 2F
		const char* GetObjectTypeName() const override;  // 39

		// override (BGSKeywordForm)
		[[nodiscard]] bool HasKeyword(const BGSKeyword* a_keyword) const override;  // 04

		[[nodiscard]] constexpr Archetype    GetArchetype() const noexcept { return data.archetype; }
		[[nodiscard]] constexpr ActorValue   GetMagickSkill() const noexcept { return data.associatedSkill; }
		[[nodiscard]] constexpr std::int32_t GetMinimumSkillLevel() const noexcept { return data.minimumSkill; }
		[[nodiscard]] constexpr bool         HasArchetype(Archetype a_type) const noexcept { return data.archetype == a_type; }
		[[nodiscard]] bool                   HasKeyword(std::string_view a_editorID) { return HasKeywordString(a_editorID); }
		[[nodiscard]] bool                   IsDetrimental() const noexcept { return data.flags.all(EffectSettingData::Flag::kDetrimental); }
		[[nodiscard]] bool                   IsHostile() const noexcept { return data.flags.all(EffectSettingData::Flag::kHostile); }

		// members
		FilterValidation_t*          filterValidationFunction;   // 058
		void*                        filterValidationItem;       // 060
		EffectSettingData            data;                       // 068 - DATA
		BSSimpleList<EffectSetting*> counterEffects;             // 158 - ESCE
		BSTArray<SoundPair>          effectSounds;               // 168 - SNDD
		BSFixedString                magicItemDescription;       // 180 - DNAM
		std::int32_t                 effectLoadedCount;          // 188
		std::int32_t                 associatedItemLoadedCount;  // 18C
		TESCondition                 conditions;                 // 190
	};
	static_assert(sizeof(EffectSetting) == 0x198);
}


===============================================
File: include/RE/E/EmotionTypes.h
===============================================
#pragma once

namespace RE
{
	enum class EmotionType
	{
		kNeutral = 0,
		kAnger = 1,
		kDisgust = 2,
		kFear = 3,
		kSad = 4,
		kHappy = 5,
		kSurprise = 6,
		kPuzzled = 7,
	};
}


===============================================
File: include/RE/E/EnchantConstructMenu.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/C/CraftingSubMenu.h"
#include "RE/E/Effect.h"
#include "RE/F/FormTypes.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMessageBoxCallback.h"
#include "RE/M/MagicItemTraversalFunctor.h"

namespace RE
{
	class EnchantmentItem;
	class ExtraDataList;
	class InventoryEntryData;

	namespace CraftingSubMenus
	{
		class EnchantConstructMenu : public CraftingSubMenu
		{
		public:
			inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu;
			inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu;

			enum class FilterFlag
			{
				EnchantWeapon = 0x1,
				DisenchantWeapon = 0x2,
				EnchantArmor = 0x4,
				DisenchantArmor = 0x8,
				EffectWeapon = 0x10,
				EffectArmor = 0x20,
				SoulGem = 0x40,
			};

			enum class Category
			{
				Disenchant = 0,
				SoulGem = 1,
				Item = 2,
				Enchantment = 3,
			};

			class CategoryListEntry : public BSIntrusiveRefCounted
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__CategoryListEntry;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__CategoryListEntry;

				virtual ~CategoryListEntry();  // 00

				// add
				virtual void        ShowInItemCard(EnchantConstructMenu* a_menu);  // 01
				virtual void        Unk_02(void);                                  // 02
				virtual const char* GetName();                                     // 03
				virtual void        SetData(GFxValue* dataContainer);              // 04

				// members
				stl::enumeration<FilterFlag, std::uint32_t> filterFlag;  // 0C
				bool                                        selected;    // 10
				bool                                        enabled;     // 11
				std::uint16_t                               pad12;       // 12
				std::uint32_t                               pad14;       // 14
			};
			static_assert(sizeof(CategoryListEntry) == 0x18);

			class EnchantmentEntry : public CategoryListEntry
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__EnchantmentEntry;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__EnchantmentEntry;

				// members
				EnchantmentItem* data;          // 18
				float            magnitude;     // 20
				float            maxMagnitude;  // 24
			};
			static_assert(sizeof(EnchantmentEntry) == 0x28);

			class ItemChangeEntry : public CategoryListEntry
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__ItemChangeEntry;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__ItemChangeEntry;

				// members
				InventoryEntryData* data;  // 18
			};
			static_assert(sizeof(ItemChangeEntry) == 0x20);

			class CreateEffectFunctor : public MagicItemTraversalFunctor
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__CreateEffectFunctor;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__CreateEffectFunctor;

				~CreateEffectFunctor() override;  // 00

				// override (MagicItemTraversalFunctor)
				BSContainer::ForEachResult operator()(Effect* a_effect) override;  // 01

				// members
				BSTArray<Effect>  createdEffects;      // 10
				Effect*           costliestEffect;     // 28
				EnchantmentEntry* enchantmentParams;   // 30
				EnchantmentItem*  createdEnchantment;  // 38
				FormType          formType;            // 40
				TESForm*          baseObject;          // 48
				float             soulGemRatio;        // 50
				std::uint32_t     pad5C;               // 5C
			};
			static_assert(sizeof(CreateEffectFunctor) == 0x58);

			class EnchantMenuCallback : public IMessageBoxCallback
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__EnchantMenuCallback;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__EnchantMenuCallback;

				~EnchantMenuCallback() override;  // 00

				// members
				EnchantConstructMenu* subMenu;  // 10
			};
			static_assert(sizeof(EnchantMenuCallback) == 0x18);

			class EnchantMenuDisenchantCallback : public EnchantMenuCallback
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__EnchantMenuDisenchantCallback;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__EnchantMenuDisenchantCallback;

				~EnchantMenuDisenchantCallback() override;  // 00

				// override (EnchantMenuCallback)
				void Run(Message a_msg) override;  // 01
			};
			static_assert(sizeof(EnchantMenuDisenchantCallback) == 0x18);

			class EnchantMenuCraftCallback : public EnchantMenuCallback
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__EnchantMenuCraftCallback;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__EnchantMenuCraftCallback;

				~EnchantMenuCraftCallback() override;  // 00

				// override (EnchantMenuCallback)
				void Run(Message a_msg) override;  // 01
			};
			static_assert(sizeof(EnchantMenuCraftCallback) == 0x18);

			class EnchantMenuExitCallback : public EnchantMenuCallback
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__EnchantConstructMenu__EnchantMenuExitCallback;
				inline static constexpr auto VTABLE = VTABLE_CraftingSubMenus__EnchantConstructMenu__EnchantMenuExitCallback;

				~EnchantMenuExitCallback() override;  // 00

				// override (EnchantMenuCallback)
				void Run(Message a_msg) override;  // 01
			};
			static_assert(sizeof(EnchantMenuExitCallback) == 0x18);

			struct Selections
			{
			public:
				// members
				BSTSmartPointer<ItemChangeEntry>            item;                    // 00
				BSTSmartPointer<ItemChangeEntry>            soulGem;                 // 08
				BSTArray<BSTSmartPointer<EnchantmentEntry>> effects;                 // 10
				std::uint32_t                               numEnchantmentsAllowed;  // 28
				std::uint32_t                               pad2C;                   // 2C
			};
			static_assert(sizeof(Selections) == 0x30);

			~EnchantConstructMenu() override;  // 00

			// override (CraftingSubMenu)
			void Accept(CallbackProcessor* a_cbReg) override;          // 01
			[[nodiscard]] bool HasItemPreview() override;                            // 04 - { return currentCategory != Enchantment || craftItemPreview; }
			bool ProcessUserEvent(BSFixedString* a_control) override;  // 05
			void SetItemCardInfo(ItemCard* a_itemCard) override;       // 07

			void RenameItem(const char* a_name);
			void RenameItem_Impl(InventoryEntryData* a_entryData, ExtraDataList* a_extraList, const char* a_name);
			void UpdateInterface();

			// members
			stl::enumeration<FilterFlag, std::uint32_t>  filterDisenchant;        // 100
			stl::enumeration<FilterFlag, std::uint32_t>  filterDivider;           // 104
			stl::enumeration<FilterFlag, std::uint32_t>  filterItem;              // 108
			stl::enumeration<FilterFlag, std::uint32_t>  filterEnchantment;       // 10C
			stl::enumeration<FilterFlag, std::uint32_t>  filterSoulGem;           // 110
			std::uint32_t                                pad114;                  // 114
			BSTArray<BSTSmartPointer<CategoryListEntry>> listEntries;             // 118
			BSString                                     customName;              // 130
			GFxValue                                     inventoryLists;          // 140
			GFxValue                                     categories;              // 158
			Selections                                   selected;                // 170
			InventoryEntryData*                          craftItemPreview;        // 1A0
			CreateEffectFunctor                          createEffectFunctor;     // 1A8
			std::int32_t                                 sliderEnchantmentIndex;  // 200
			float                                        sliderMaxMagnitude;      // 204
			std::uint32_t                                highlightIndex;          // 208
			stl::enumeration<Category, std::uint32_t>    currentCategory;         // 20C
			stl::enumeration<FilterFlag, std::uint32_t>  enabledFilters;          // 210
			float                                        enchantmentCost;         // 214
			float                                        chargeAmount;            // 218
			bool                                         exiting;                 // 21C
			bool                                         sliderShown;             // 21D
			bool                                         hasHighlightedEntry;     // 21E
			std::uint8_t                                 pad21F;                  // 21F
		};
		static_assert(sizeof(EnchantConstructMenu) == 0x220);
	}
}


===============================================
File: include/RE/E/EnchantmentItem.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/M/MagicItem.h"
#include "RE/M/MagicSystem.h"

namespace RE
{
	class EnchantmentItem : public MagicItem
	{
	public:
		inline static constexpr auto RTTI = RTTI_EnchantmentItem;
		inline static constexpr auto VTABLE = VTABLE_EnchantmentItem;
		inline static constexpr auto FORMTYPE = FormType::Enchantment;

		enum class EnchantmentFlag
		{
			kNone = 0,
			kCostOverride = 1 << 0,
			kFoodItem = 1 << 1,
			kExtendDuration = 1 << 3
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		class Data  // ENIT
		{
		public:
			// members
			std::int32_t                                     costOverride;      // 00
			stl::enumeration<EnchantmentFlag, std::uint32_t> flags;             // 04
			MagicSystem::CastingType                         castingType;       // 08
			std::int32_t                                     chargeOverride;    // 0C
			MagicSystem::Delivery                            delivery;          // 10
			MagicSystem::SpellType                           spellType;         // 14
			float                                            chargeTime;        // 18
			std::uint32_t                                    pad1C;             // 1C
			EnchantmentItem*                                 baseEnchantment;   // 20
			BGSListForm*                                     wornRestrictions;  // 28
		};
		static_assert(sizeof(Data) == 0x30);

		~EnchantmentItem() override;  // 00

		// override (MagicItem)
		void                                   InitializeData() override;                                 // 04
		void                                   ClearData() override;                                      // 05
		void                                   InitItemImpl() override;                                   // 13
		[[nodiscard]] MagicSystem::SpellType   GetSpellType() const override;                             // 53 - { return data.spellType; }
		void                                   SetCastingType(MagicSystem::CastingType a_type) override;  // 54 - { data.castingType = a_type; }
		[[nodiscard]] MagicSystem::CastingType GetCastingType() const override;                           // 55 - { return data.castingType; }
		void                                   SetDelivery(MagicSystem::Delivery a_type) override;        // 56 - { if (Unk_58()) { data.delivery = a_type; } }
		[[nodiscard]] MagicSystem::Delivery    GetDelivery() const override;                              // 57 - { return data.delivery; }
		[[nodiscard]] float                    GetChargeTime() const override;                            // 64
		[[nodiscard]] ActorValue               GetAssociatedSkill() const override;                       // 66 - { return ActorValue::kEnchanting; }
		[[nodiscard]] std::uint32_t            GetChunkID() override;                                     // 68 - { return 'ENIT'; }
		void                                   CopyMagicItemData(MagicItem* a_src) override;              // 69
		[[nodiscard]] const MagicItem::Data*   GetData1() const override;                                 // 6C - { return &data; }
		[[nodiscard]] MagicItem::Data*         GetData2() override;                                       // 6D - { return &data; }
		[[nodiscard]] std::uint32_t            GetDataSize() const override;                              // 6E - { return 0x30; }
		void                                   InitFromChunk(TESFile* a_mod) override;                    // 6F
		void                                   InitChunk() override;                                      // 70

		// members
		Data data;  // 90 - ENIT
	};
	static_assert(sizeof(EnchantmentItem) == 0xC0);
}


===============================================
File: include/RE/E/EnhanceWeaponEffect.h
===============================================
#pragma once

#include "RE/A/ActorInventoryEvent.h"
#include "RE/A/ActorValues.h"
#include "RE/B/BSTEvent.h"
#include "RE/D/DualValueModifierEffect.h"

namespace RE
{
	class EnhanceWeaponEffect :
		public DualValueModifierEffect,           // 00
		public BSTEventSink<ActorInventoryEvent>  // A0
	{
	public:
		inline static constexpr auto RTTI = RTTI_EnhanceWeaponEffect;
		inline static constexpr auto VTABLE = VTABLE_EnhanceWeaponEffect;

		// override (ActiveEffect)
		virtual void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 0A
		virtual void Revert(BGSLoadFormBuffer* a_buf) override;          // 0B
		virtual void ClearTargetImpl() override;                         // 12
		virtual ~EnhanceWeaponEffect();                                  // 13
		virtual void Start() override;                                   // 14
		virtual void Finish() override;                                  // 15

		// override (DualValueModifierEffect)
		virtual ActorValue GetAdditionalActorValue() const override;  // 21
		virtual float      GetSecondaryAVWeight() const override;     // 22

		// override (BSTEventSink)
		virtual BSEventNotifyControl ProcessEvent(const ActorInventoryEvent* a_event, BSTEventSource<ActorInventoryEvent>* a_eventSource) override;  // 01

		// members
		ActorValue secondaryActorValue;  // A8
	};
	static_assert(sizeof(EnhanceWeaponEffect) == 0xB0);
}


===============================================
File: include/RE/E/ErrorCodes.h
===============================================
#pragma once

namespace RE
{
	namespace BSResource
	{
		enum class ErrorCode
		{
			kNone = 0,
			kNotExist = 1,
			kInvalidPath = 2,
			kFileError = 3,
			kInvalidType = 4,
			kMemoryError = 5,
			kBusy = 6,
			kInvalidParam = 7,
			kUnsupported = 8
		};
	}
}


===============================================
File: include/RE/E/ErrorLogger.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/B/BSTHashMap.h"

namespace RE
{
	namespace BSScript
	{
		struct LogEvent;

		class ErrorLogger : public BSTEventSource<LogEvent>
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__ErrorLogger;

			enum class Severity
			{
				kInfo,
				kWarning,
				kError,
				kFatal
			};

			struct PerThreadErrorCounts
			{
			public:
				// members
				std::uint32_t fatalCount;    // 0
				std::uint32_t errorCount;    // 4
				std::uint32_t warningCount;  // 8
			};
			static_assert(sizeof(PerThreadErrorCounts) == 0xC);

			virtual ~ErrorLogger();  // 00

			// add
			virtual void PostErrorImpl(const char* a_message, Severity a_severity) = 0;  // 01
			virtual void ResetImpl();                                                    // 02 - { return; }

			// members
			mutable BSSpinLock                              threadErrorsLock;  // 60
			BSTHashMap<std::uint32_t, PerThreadErrorCounts> threadErrors;      // 68
		};
		static_assert(sizeof(ErrorLogger) == 0x98);
	}
}


===============================================
File: include/RE/E/EtherealizationEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class EtherealizationEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_EtherealizationEffect;
		inline static constexpr auto VTABLE = VTABLE_EtherealizationEffect;

		// override (ActiveEffect)
		virtual ~EtherealizationEffect();  // 13
		virtual void Start() override;     // 14
		virtual void Finish() override;    // 15
	};
	static_assert(sizeof(EtherealizationEffect) == 0x90);
}


===============================================
File: include/RE/E/Explosion.h
===============================================
#pragma once

#include "RE/B/BSSoundHandle.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MagicSystem.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESObjectREFR.h"

namespace RE
{
	class BGSExplosion;
	class BGSMaterialType;
	class bhkCollisionObject;
	class bhkSimpleShapePhantom;
	class EffectSetting;
	class MagicItem;
	class QueuedFile;
	class NiPointLight;
	class NonActorMagicCaster;

	class Explosion : public TESObjectREFR
	{
	public:
		inline static constexpr auto RTTI = RTTI_Explosion;
		inline static constexpr auto VTABLE = VTABLE_Explosion;
		inline static constexpr auto FORMTYPE = FormType::Explosion;

		enum class Flags
		{
			kNone = 0,
			kIgnoreImageSpaceSwap = 1 << 4,
			kInWater = 1 << 5
		};

		~Explosion() override;  // 00

		// override (TESObjectREFR)
		void         SaveGame(BGSSaveFormBuffer* a_buf) override;                   // 0E
		void         Revert(BGSLoadFormBuffer* a_buf) override;                     // 12
		void         SetActorCause(ActorCause* a_cause) override;                   // 50 - { actorCause = a_cause; }
		ActorCause*  GetActorCause() const override;                                // 51 - { return actorCause; }
		MagicCaster* GetMagicCaster(MagicSystem::CastingSource a_source) override;  // 5C
		void         InitHavok() override;                                          // 66
		void         Release3DRelatedData() override;                               // 6B
#ifndef SKYRIM_CROSS_VR
		// This is where in the TESObjectREFR vtable compatibility with SkyrimVR breaks.
		[[nodiscard]] Explosion* AsExplosion() override;                                                // 8E
		bool                     OnAddCellPerformQueueReference(TESObjectCELL& a_cell) const override;  // 90 - { return false; }
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void Initialize();           // A2
		SKYRIM_REL_VR_VIRTUAL void Update(float a_delta);  // A3
		SKYRIM_REL_VR_VIRTUAL void FindTargets();          // A4

		struct EXPLOSION_RUNTIME_DATA
		{
#define EXPLOSION_RUNTIME_DATA_CONTENT \
			std::uint64_t                          unk98;             /* 098, 0A0 */ \
			float                                  startKeyTime;      /* 0A0 */ \
			float                                  endKeyTime;        /* 0A4 */ \
			float                                  hitKeyTime;        /* 0A8 */ \
			float                                  radius;            /* 0AC */ \
			float                                  imodRadius;        /* 0B0 */ \
			float                                  unkB4;             /* 0B4 */ \
			bhkSimpleShapePhantom*                 unkB8;             /* 0B8 */ \
			std::uint64_t                          unkC0;             /* 0C0 */ \
			std::uint64_t                          unkC8;             /* 0C8 */ \
			BSSoundHandle                          sound01;           /* 0D0 */ \
			BSSoundHandle                          sound02;           /* 0DC */ \
			NiPointer<NiPointLight>                light;             /* 0E8 */ \
			ActorHandle                            actorOwner;        /* 0F0 */ \
			ActorHandle                            unkF4;             /* 0F4 */ \
			std::uint32_t                          unkF8;             /* 0F8 */ \
			std::uint32_t                          padFC;             /* 0FC */ \
			NiPointer<ActorCause>                  actorCause;        /* 100 */ \
			NonActorMagicCaster*                   magicCaster;       /* 108 */ \
			TESObjectWEAP*                         weaponSource;      /* 110 */ \
			std::uint32_t                          unk118;            /* 118 */ \
			NiPoint3                               unk11C;            /* 11C */ \
			NiPoint3                               negativeVelocity;  /* 128 */ \
			float                                  damage;            /* 134 */ \
			float                                  unk138;            /* 138 */ \
			stl::enumeration<Flags, std::uint32_t> flags;             /* 13C */

			EXPLOSION_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline EXPLOSION_RUNTIME_DATA& GetExplosionRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<EXPLOSION_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		[[nodiscard]] inline const EXPLOSION_RUNTIME_DATA& GetExplosionRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<EXPLOSION_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		// members
		std::uint64_t                          unk98;             // 098
		float                                  startKeyTime;      // 0A0
		float                                  endKeyTime;        // 0A4
		float                                  hitKeyTime;        // 0A8
		float                                  radius;            // 0AC
		float                                  imodRadius;        // 0B0
		float                                  unkB4;             // 0B4
		bhkSimpleShapePhantom*                 unkB8;             // 0B8
		std::uint64_t                          unkC0;             // 0C0
		std::uint64_t                          unkC8;             // 0C8
		BSSoundHandle                          sound01;           // 0D0
		BSSoundHandle                          sound02;           // 0DC
		NiPointer<NiPointLight>                light;             // 0E8
		ActorHandle                            actorOwner;        // 0F0
		ActorHandle                            unkF4;             // 0F4
		std::uint32_t                          unkF8;             // 0F8
		std::uint32_t                          padFC;             // 0FC
		NiPointer<ActorCause>                  actorCause;        // 100
		NonActorMagicCaster*                   magicCaster;       // 108
		TESObjectWEAP*                         weaponSource;      // 110
		std::uint32_t                          unk118;            // 118
		NiPoint3                               unk11C;            // 11C
		NiPoint3                               negativeVelocity;  // 128
		float                                  damage;            // 134
		float                                  unk138;            // 138
		stl::enumeration<Flags, std::uint32_t> flags;             // 13C
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(Explosion) == 0x140);
#endif
}
#undef EXPLOSION_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/E/ExtraAction.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	enum class OBJECT_ACTION
	{
		kNone = 0,
		kUseDefault = 1 << 0,
		kActivate = 1 << 1,
		kOpen = 1 << 2,
		kOpenByDefault = 1 << 3
	};

	class TESObjectREFR;

	class ExtraAction : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAction;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAction;

		~ExtraAction() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kAction; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return unk10 != a_rhs->unk10; }

		// members
		stl::enumeration<OBJECT_ACTION, std::int8_t> action;     // 10
		std::uint8_t                                 pad11;      // 11
		std::uint16_t                                pad12;      // 12
		std::uint32_t                                pad14;      // 14
		TESObjectREFR*                               actionRef;  // 18
	};
	static_assert(sizeof(ExtraAction) == 0x20);
}


===============================================
File: include/RE/E/ExtraActivateLoopSound.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraActivateLoopSound : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraActivateLoopSound;
		inline static auto           EXTRADATATYPE = ExtraDataType::kActivateLoopSound;

		~ExtraActivateLoopSound() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kActivateLoopSound; }

		// members
		BSSoundHandle handle;  // 10
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(ExtraActivateLoopSound) == 0x20);
}


===============================================
File: include/RE/E/ExtraActivateRef.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct REF_ACTIVATE_DATA;

	class ExtraActivateRef : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraActivateRef;
		inline static auto           EXTRADATATYPE = ExtraDataType::kActivateRef;

		~ExtraActivateRef() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kActivateRef; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		BSSimpleList<REF_ACTIVATE_DATA*> parents;        // 10
		std::uint8_t                     activateFlags;  // 20
		std::uint8_t                     pad21;          // 21
		std::uint16_t                    pad22;          // 22
		std::uint32_t                    pad24;          // 24
	};
	static_assert(sizeof(ExtraActivateRef) == 0x28);
}


===============================================
File: include/RE/E/ExtraActivateRefChildren.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct REF_ACTIVATE_DATA;

	class ExtraActivateRefChildren : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraActivateRefChildren;
		inline static auto           EXTRADATATYPE = ExtraDataType::kActivateRefChildren;

		~ExtraActivateRefChildren() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kActivateRefChildren; }

		// members
		BSSimpleList<REF_ACTIVATE_DATA*> children;               // 10
		float                            activateChildrenTimer;  // 20
		std::uint32_t                    pad24;                  // 24
	};
	static_assert(sizeof(ExtraActivateRefChildren) == 0x28);
}


===============================================
File: include/RE/E/ExtraActorCause.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class ActorCause;

	class ExtraActorCause : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraActorCause;
		inline static auto           EXTRADATATYPE = ExtraDataType::kActorCause;

		~ExtraActorCause() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kActorCause; }

		// members
		NiPointer<ActorCause> actorCause;  // 10
	};
	static_assert(sizeof(ExtraActorCause) == 0x18);
}


===============================================
File: include/RE/E/ExtraAliasInstanceArray.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSBaseAlias;

	struct BGSRefAliasInstanceData
	{
		TESQuest*                    quest;              // 00
		const BGSBaseAlias*          alias;              // 08
		const BSTArray<TESPackage*>* instancedPackages;  // 10
	};
	static_assert(sizeof(BGSRefAliasInstanceData) == 0x18);

	class ExtraAliasInstanceArray : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAliasInstanceArray;
		inline static constexpr auto VTABLE = VTABLE_ExtraAliasInstanceArray;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAliasInstanceArray;

		ExtraAliasInstanceArray();
		~ExtraAliasInstanceArray() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kAliasInstanceArray; }

		// members
		BSTArray<BGSRefAliasInstanceData*> aliases;  // 10
		mutable BSReadWriteLock            lock;     // 28
	};
	static_assert(sizeof(ExtraAliasInstanceArray) == 0x30);
}


===============================================
File: include/RE/E/ExtraAlphaCutoff.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraAlphaCutoff : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAlphaCutoff;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAlphaCutoff;

		~ExtraAlphaCutoff() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kAlphaCutoff; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return unk10 != a_rhs->unk10; }

		// members
		std::int8_t   cutoff;          // 10
		std::int8_t   originalCutoff;  // 11
		std::uint16_t pad12;           // 12
		std::uint32_t pad14;           // 14
	};
	static_assert(sizeof(ExtraAlphaCutoff) == 0x18);
}


===============================================
File: include/RE/E/ExtraAmmo.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraAmmo : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAmmo;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAmmo;

		~ExtraAmmo() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kAmmo; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return unk18 != a_rhs->unk18 || unk10 != a_rhs->unk10; }

		// members
		std::uint64_t unk10;  // 10
		std::uint32_t unk18;  // 18
		std::uint32_t pad1C;  // 1C
	};
	static_assert(sizeof(ExtraAmmo) == 0x20);
}


===============================================
File: include/RE/E/ExtraAnimGraphManager.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BSAnimationGraphManager;

	class ExtraAnimGraphManager : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAnimGraphManager;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAnimGraphManager;

		~ExtraAnimGraphManager() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kAnimGraphManager; }

		// members
		BSTSmartPointer<BSAnimationGraphManager> animGraphMgr;  // 10
	};
	static_assert(sizeof(ExtraAnimGraphManager) == 0x18);
}


===============================================
File: include/RE/E/ExtraAnimNoteReceiver.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraAnimNoteReceiver : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAnimNoteReceiver;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAnimNoteReceiver;

		~ExtraAnimNoteReceiver() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kAnimNoteReceiver; }

		// members
		void* unk10;  // 10
	};
	static_assert(sizeof(ExtraAnimNoteReceiver) == 0x18);
}


===============================================
File: include/RE/E/ExtraAnimationSequencer.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSAnimationSequencer;

	class ExtraAnimationSequencer : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAnimationSequencer;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAnimationSequencer;

		~ExtraAnimationSequencer() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kAnimationSequencer; }

		// members
		BGSAnimationSequencer* sequencer;  // 10
	};
	static_assert(sizeof(ExtraAnimationSequencer) == 0x18);
}


===============================================
File: include/RE/E/ExtraAshPileRef.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraAshPileRef : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAshPileRef;
		inline static constexpr auto VTABLE = VTABLE_ExtraAshPileRef;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAshPileRef;

		ExtraAshPileRef();
		explicit ExtraAshPileRef(ObjectRefHandle a_ashPileRef);
		~ExtraAshPileRef() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kAshPileRef; }

		// members
		ObjectRefHandle ashPileRef;  // 10
		std::uint32_t   pad14;       // 14
	};
	static_assert(sizeof(ExtraAshPileRef) == 0x18);
}


===============================================
File: include/RE/E/ExtraAttachRef.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraAttachRef : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAttachRef;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAttachRef;

		~ExtraAttachRef() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kAttachRef; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return attachRef != a_rhs->attachRef; }

		// members
		ObjectRefHandle attachRef;  // 10
		std::uint32_t   pad14;      // 14
	};
	static_assert(sizeof(ExtraAttachRef) == 0x18);
}


===============================================
File: include/RE/E/ExtraAttachRefChildren.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraAttachRefChildren : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAttachRefChildren;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAttachRefChildren;

		~ExtraAttachRefChildren() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kAttachRefChildren; }

		// members
		BSSimpleList<ObjectRefHandle> children;  // 10
	};
	static_assert(sizeof(ExtraAttachRefChildren) == 0x20);
}


===============================================
File: include/RE/E/ExtraAttachedArrows3D.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSProjectile;
	class NiAVObject;

	class ExtraAttachedArrows3D : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraAttachedArrows3D;
		inline static auto           EXTRADATATYPE = ExtraDataType::kAttachedArrows3D;

		struct DataItem
		{
		public:
			// members
			NiPointer<NiAVObject> arrow3D;    // 00
			std::uint64_t         timeStamp;  // 08
			BGSProjectile*        source;     // 10
		};
		static_assert(sizeof(DataItem) == 0x18);

		~ExtraAttachedArrows3D() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kAttachedArrows3D; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		BSTArray<DataItem> data;           // 10
		std::uint16_t      nextStorage;    // 28
		std::uint16_t      oldestStorage;  // 2A
		std::uint32_t      pad2C;          // 2C
	};
	static_assert(sizeof(ExtraAttachedArrows3D) == 0x30);
}


===============================================
File: include/RE/E/ExtraBadPosition.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraBadPosition : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraBadPosition;
		inline static auto           EXTRADATATYPE = ExtraDataType::kBadPosition;

		~ExtraBadPosition() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kBadPosition; }
	};
	static_assert(sizeof(ExtraBadPosition) == 0x10);
}


===============================================
File: include/RE/E/ExtraBiped.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BipedAnim;

	class ExtraBiped : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraBiped;
		inline static auto           EXTRADATATYPE = ExtraDataType::kBiped;

		~ExtraBiped() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kBiped; }

		// members
		BSTSmartPointer<BipedAnim> biped;  // 10
	};
	static_assert(sizeof(ExtraBiped) == 0x18);
}


===============================================
File: include/RE/E/ExtraCachedScale.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraCachedScale : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCachedScale;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCachedScale;

		~ExtraCachedScale() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kCachedScale; }

		// members
		float scale3D;   // 10
		float refScale;  // 10
	};
	static_assert(sizeof(ExtraCachedScale) == 0x18);
}


===============================================
File: include/RE/E/ExtraCanTalkToPlayer.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraCanTalkToPlayer : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCanTalkToPlayer;
		inline static constexpr auto VTABLE = VTABLE_ExtraCanTalkToPlayer;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCanTalkToPlayer;

		ExtraCanTalkToPlayer();
		explicit ExtraCanTalkToPlayer(bool a_canTalk);
		~ExtraCanTalkToPlayer() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kCanTalkToPlayer; }

		// members
		bool          talk;   // 10
		std::uint8_t  pad11;  // 11
		std::uint16_t pad12;  // 12
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraCanTalkToPlayer) == 0x18);
}


===============================================
File: include/RE/E/ExtraCannotWear.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"

namespace RE
{
	class ExtraCannotWear : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCannotWear;
		inline static constexpr auto VTABLE = VTABLE_ExtraCannotWear;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCannotWear;

		ExtraCannotWear();
		~ExtraCannotWear() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kCannotWear; }
	};
	static_assert(sizeof(ExtraCannotWear) == 0x10);
}


===============================================
File: include/RE/E/ExtraCell3D.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiNode;

	class ExtraCell3D : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCell3D;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCell3D;

		~ExtraCell3D() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kCell3D; }

		// members
		NiPointer<NiNode> cellNode;  // 10
	};
	static_assert(sizeof(ExtraCell3D) == 0x18);
}


===============================================
File: include/RE/E/ExtraCellAcousticSpace.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSAcousticSpace;

	class ExtraCellAcousticSpace : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCellAcousticSpace;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCellAcousticSpace;

		~ExtraCellAcousticSpace() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCellAcousticSpace; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return space != a_rhs->space; }

		// members
		BGSAcousticSpace* space;  // 10
	};
	static_assert(sizeof(ExtraCellAcousticSpace) == 0x18);
}


===============================================
File: include/RE/E/ExtraCellGrassData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class AddCellGrassTask;
	class BSInstanceTriShape;

	struct CellGrassData
	{
		std::uint64_t                 grassTypeKey;   // 00
		BSFixedString                 grassModelKey;  // 08
		NiPointer<BSInstanceTriShape> triShape;       // 10
		BSTArray<void*>               unk18;          // 18
		BSTArray<void*>               unk30;          // 30
	};
	static_assert(sizeof(CellGrassData) == 0x48);

	class ExtraCellGrassData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCellGrassData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCellGrassData;

		~ExtraCellGrassData() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kCellGrassData; }

		// members
		BSTArray<CellGrassData*>    grassHandles;  // 10
		NiPointer<AddCellGrassTask> addGrassTask;  // 28
	};
	static_assert(sizeof(ExtraCellGrassData) == 0x30);
}


===============================================
File: include/RE/E/ExtraCellImageSpace.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESImageSpace;

	class ExtraCellImageSpace : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCellImageSpace;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCellImageSpace;

		~ExtraCellImageSpace() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCellImageSpace; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return imageSpace != a_rhs->imageSpace; }

		// members
		TESImageSpace* imageSpace;  // 10
	};
	static_assert(sizeof(ExtraCellImageSpace) == 0x18);
}


===============================================
File: include/RE/E/ExtraCellMusicType.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSMusicType;

	class ExtraCellMusicType : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCellMusicType;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCellMusicType;

		~ExtraCellMusicType() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCellMusicType; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return type != a_rhs->type; }

		// members
		BGSMusicType* type;  // 10
	};
	static_assert(sizeof(ExtraCellMusicType) == 0x18);
}


===============================================
File: include/RE/E/ExtraCellSkyRegion.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESRegion;

	class ExtraCellSkyRegion : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCellSkyRegion;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCellSkyRegion;

		~ExtraCellSkyRegion() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCellSkyRegion; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return skyRegion != a_rhs->skyRegion; }

		// members
		TESRegion* skyRegion;  // 10
	};
	static_assert(sizeof(ExtraCellSkyRegion) == 0x18);
}


===============================================
File: include/RE/E/ExtraCellWaterEnvMap.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	class ExtraCellWaterEnvMap : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCellWaterEnvMap;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCellWaterEnvMap;

		~ExtraCellWaterEnvMap() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCellWaterEnvMap; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		TESTexture waterEnvMap;  // 10
	};
	static_assert(sizeof(ExtraCellWaterEnvMap) == 0x20);
}


===============================================
File: include/RE/E/ExtraCellWaterType.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESWaterForm;

	class ExtraCellWaterType : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCellWaterType;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCellWaterType;

		~ExtraCellWaterType() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCellWaterType; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return water != a_rhs->water; }

		// members
		TESWaterForm* water;  // 10
	};
	static_assert(sizeof(ExtraCellWaterType) == 0x18);
}


===============================================
File: include/RE/E/ExtraCharge.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraCharge : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCharge;
		inline static constexpr auto VTABLE = VTABLE_ExtraCharge;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCharge;

		ExtraCharge();
		~ExtraCharge() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCharge; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return charge != a_rhs->charge; }

		// members
		float         charge;  // 10
		std::uint32_t pad14;   // 14
	};
	static_assert(sizeof(ExtraCharge) == 0x18);
}


===============================================
File: include/RE/E/ExtraCollisionData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/C/CollisionLayers.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct CollisionData
	{
		COL_LAYER layer;  // 0
	};
	static_assert(sizeof(CollisionData) == 0x4);

	class ExtraCollisionData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCollisionData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCollisionData;

		~ExtraCollisionData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCollisionData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		CollisionData* collisionData;  // 10
	};
	static_assert(sizeof(ExtraCollisionData) == 0x18);
}


===============================================
File: include/RE/E/ExtraCombatStyle.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESCombatStyle;

	class ExtraCombatStyle : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCombatStyle;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCombatStyle;

		~ExtraCombatStyle() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCombatStyle; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return combatStyle != a_rhs->combatStyle; }

		// members
		TESCombatStyle* combatStyle;  // 10
	};
	static_assert(sizeof(ExtraCombatStyle) == 0x18);
}


===============================================
File: include/RE/E/ExtraContainerChanges.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class InventoryChanges;

	class ExtraContainerChanges : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraContainerChanges;
		inline static constexpr auto VTABLE = VTABLE_ExtraContainerChanges;
		inline static auto           EXTRADATATYPE = ExtraDataType::kContainerChanges;

		ExtraContainerChanges();
		explicit ExtraContainerChanges(InventoryChanges* a_changes);
		~ExtraContainerChanges() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kContainerChanges; }

		// members
		InventoryChanges* changes;  // 10
	};
	static_assert(sizeof(ExtraContainerChanges) == 0x18);
}


===============================================
File: include/RE/E/ExtraCount.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraCount : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCount;
		inline static constexpr auto VTABLE = VTABLE_ExtraCount;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCount;

		ExtraCount();
		explicit ExtraCount(std::int16_t a_count);
		~ExtraCount() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kCount; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return return count != a_rhs->count; }

		// members
		std::int16_t  count;  // 10
		std::uint16_t pad12;  // 12
		std::int32_t  pad14;  // 14
	};
	static_assert(sizeof(ExtraCount) == 0x18);
}


===============================================
File: include/RE/E/ExtraCreatureAwakeSound.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraCreatureAwakeSound : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCreatureAwakeSound;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCreatureAwakeSound;

		~ExtraCreatureAwakeSound() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kCreatureAwakeSound; }

		// members
		BSSoundHandle handle;  // 10
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(ExtraCreatureAwakeSound) == 0x20);
}


===============================================
File: include/RE/E/ExtraCreatureMovementSound.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraCreatureMovementSound : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraCreatureMovementSound;
		inline static auto           EXTRADATATYPE = ExtraDataType::kCreatureMovementSound;

		~ExtraCreatureMovementSound() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kCreatureMovementSound; }

		// members
		BSSoundHandle handle;  // 10
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(ExtraCreatureMovementSound) == 0x20);
}


===============================================
File: include/RE/E/ExtraDataList.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/E/ExtraFlags.h"
#include "RE/E/ExtraLevCreaModifier.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MemoryManager.h"
#include "RE/S/SoulLevels.h"

namespace RE
{
	class InventoryChanges;
	class TESBoundObject;

	class BaseExtraList
	{
	public:
		struct PresenceBitfield
		{
		public:
			[[nodiscard]] bool HasType(std::uint32_t a_type) const;
			void               MarkType(std::uint32_t a_type, bool a_cleared);

			// members
			std::uint8_t bits[0x18];  // 00
		};
		static_assert(sizeof(PresenceBitfield) == 0x18);

		[[nodiscard]] BSExtraData*& GetData() noexcept;

		[[nodiscard]] const BSExtraData*& GetData() const noexcept;

		[[nodiscard]] PresenceBitfield*& GetPresence() noexcept;

		[[nodiscard]] const PresenceBitfield*& GetPresence() const noexcept;

#ifndef ENABLE_SKYRIM_AE
		~BaseExtraList();  // 00, virtual on AE 1.6.629 and later.

		// members
		BSExtraData*      data = nullptr;      // 00, 08
		PresenceBitfield* presence = nullptr;  // 08, 10
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(BaseExtraList) == 0x10);
#endif

	class ExtraDataList
	{
	public:
		template <class T>
		class iterator_base
		{
		public:
			using difference_type = std::ptrdiff_t;
			using value_type = T;
			using pointer = value_type*;
			using reference = value_type&;
			using iterator_category = std::forward_iterator_tag;

			constexpr iterator_base() noexcept :
				_cur(nullptr)
			{}

			constexpr iterator_base(pointer a_node) noexcept :
				_cur(a_node)
			{}

			constexpr iterator_base(const iterator_base& a_rhs) noexcept :
				_cur(a_rhs._cur)
			{}

			constexpr iterator_base(iterator_base&& a_rhs) noexcept :
				_cur(std::move(a_rhs._cur))
			{
				a_rhs._cur = nullptr;
			}

			~iterator_base() = default;

			constexpr iterator_base& operator=(const iterator_base& a_rhs) noexcept
			{
				if (this != std::addressof(a_rhs)) {
					_cur = a_rhs._cur;
				}
				return *this;
			}

			constexpr iterator_base& operator=(iterator_base&& a_rhs) noexcept
			{
				if (this != std::addressof(a_rhs)) {
					_cur = a_rhs._cur;
					a_rhs._cur = nullptr;
				}
				return *this;
			}

			[[nodiscard]] constexpr reference operator*() const noexcept { return *_cur; }
			[[nodiscard]] constexpr pointer   operator->() const noexcept { return _cur; }

			[[nodiscard]] constexpr friend bool operator==(const iterator_base& a_lhs, const iterator_base& a_rhs) noexcept { return a_lhs._cur == a_rhs._cur; }
			[[nodiscard]] constexpr friend bool operator!=(const iterator_base& a_lhs, const iterator_base& a_rhs) noexcept { return !(a_lhs == a_rhs); }

			// prefix
			constexpr iterator_base& operator++() noexcept
			{
				assert(_cur != nullptr);
				_cur = _cur->next;
				return *this;
			}

			// postfix
			[[nodiscard]] constexpr iterator_base operator++(int) noexcept
			{
				iterator_base tmp{ *this };
				++(*this);
				return tmp;
			}

			inline friend void swap(const iterator_base& a_lhs, const iterator_base& a_rhs) noexcept
			{
				std::swap(a_lhs._cur, a_rhs._cur);
			}

		private:
			pointer _cur;
		};

		using iterator = iterator_base<BSExtraData>;
		using const_iterator = iterator_base<const BSExtraData>;

		ExtraDataList();
		~ExtraDataList();

		TES_HEAP_REDEFINE_NEW();

		iterator       begin();
		const_iterator cbegin() const;
		const_iterator begin() const;
		iterator       end();
		const_iterator cend() const;
		const_iterator end() const;

		BSExtraData*       GetByType(ExtraDataType a_type);
		const BSExtraData* GetByType(ExtraDataType a_type) const;

		template <class T>
		inline T* GetByType()
		{
			return static_cast<T*>(GetByType(T::EXTRADATATYPE));
		}

		template <class T>
		inline const T* GetByType() const
		{
			return static_cast<const T*>(GetByType(T::EXTRADATATYPE));
		}

		bool HasType(ExtraDataType a_type) const;

		template <class T>
		inline bool HasType() const
		{
			return HasType(T::EXTRADATATYPE);
		}

		bool Remove(ExtraDataType a_type, BSExtraData* a_toRemove);

		template <class T>
		inline bool Remove(T* a_toRemove)
		{
			return Remove(T::EXTRADATATYPE, a_toRemove);
		}

		bool RemoveByType(ExtraDataType a_type);

		BSExtraData*          Add(BSExtraData* a_toAdd);
		ObjectRefHandle       GetAshPileRef();
		std::int32_t          GetCount() const;
		const char*           GetDisplayName(TESBoundObject* a_baseObject);
		BGSEncounterZone*     GetEncounterZone();
		ExtraTextDisplayData* GetExtraTextDisplayData();
		TESObjectREFR*        GetLinkedRef(BGSKeyword* a_keyword);
		TESForm*              GetOwner();
		SOUL_LEVEL            GetSoulLevel() const;
		ObjectRefHandle       GetTeleportLinkedDoor();
		void                  SetCount(std::uint16_t a_count);
		void                  SetEncounterZone(BGSEncounterZone* a_zone);
		void                  SetExtraFlags(ExtraFlags::Flag a_flags, bool a_enable);
		void                  SetInventoryChanges(InventoryChanges* a_changes);
		void                  SetOwner(TESForm* a_owner);

	private:
		[[nodiscard]] BSExtraData* GetByTypeImpl(ExtraDataType a_type) const;
		void         MarkType(std::uint32_t a_type, bool a_cleared);
		void         MarkType(ExtraDataType a_type, bool a_cleared);
		[[nodiscard]] BSReadWriteLock& GetLock() const noexcept;

		// members
		BaseExtraList           _extraData;  // 00
#ifndef ENABLE_SKYRIM_AE
		mutable BSReadWriteLock _lock;       // 10, 18; offset 18 only for AE versions .629 and later.
#endif
	};
}


===============================================
File: include/RE/E/ExtraDataTypes.h
===============================================
#pragma once

namespace RE
{
	class ExtraHavok;
	class ExtraCell3D;
	class ExtraCellWaterType;
	class ExtraRegionList;
	class ExtraSeenData;
	class ExtraEditorID;
	class ExtraCellMusicType;
	class ExtraCellSkyRegion;
	class ExtraProcessMiddleLow;
	class ExtraDetachTime;
	class ExtraPersistentCell;
	class ExtraAction;
	class ExtraStartingPosition;
	class ExtraAnimGraphManager;
	class ExtraBiped;
	class ExtraUsedMarkers;
	class ExtraDistantData;
	class ExtraRagDollData;
	class ExtraContainerChanges;
	class ExtraWorn;
	class ExtraWornLeft;
	class ExtraPackageStartLocation;
	class ExtraPackage;
	class ExtraTresPassPackage;
	class ExtraRunOncePacks;
	class ExtraReferenceHandle;
	class ExtraFollower;
	class ExtraLevCreaModifier;
	class ExtraGhost;
	class ExtraOriginalReference;
	class ExtraOwnership;
	class ExtraGlobal;
	class ExtraRank;
	class ExtraCount;
	class ExtraHealth;
	class ExtraTimeLeft;
	class ExtraCharge;
	class ExtraLight;
	class ExtraLock;
	class ExtraTeleport;
	class ExtraMapMarker;
	class ExtraLeveledCreature;
	class ExtraLeveledItem;
	class ExtraScale;
	class ExtraMissingLinkedRefIDs;
	class ExtraMagicCaster;
	class NonActorMagicTarget;
	class ExtraPlayerCrimeList;
	class ExtraEnableStateParent;
	class ExtraEnableStateChildren;
	class ExtraItemDropper;
	class ExtraDroppedItemList;
	class ExtraRandomTeleportMarker;
	class ExtraSavedHavokData;
	class ExtraCannotWear;
	class ExtraPoison;
	class ExtraMagicLight;
	class ExtraLastFinishedSequence;
	class ExtraSavedAnimation;
	class ExtraNorthRotation;
	class ExtraSpawnContainer;
	class ExtraFriendHits;
	class ExtraHeadingTarget;
	class ExtraRefractionProperty;
	class ExtraStartingWorldOrCell;
	class ExtraHotkey;
	class ExtraEditorRef3DData;
	class ExtraEditorRefMoveData;
	class ExtraInfoGeneralTopic;
	class ExtraHasNoRumors;
	class ExtraSound;
	class ExtraTerminalState;
	class ExtraLinkedRef;
	class ExtraLinkedRefChildren;
	class ExtraActivateRef;
	class ExtraActivateRefChildren;
	class ExtraCanTalkToPlayer;
	class ExtraObjectHealth;
	class ExtraCellImageSpace;
	class ExtraNavMeshPortal;
	class ExtraModelSwap;
	class ExtraRadius;
	class ExtraFactionChanges;
	class ExtraDismemberedLimbs;
	class ExtraActorCause;
	class ExtraMultiBound;
	class MultiBoundMarkerData;
	class ExtraMultiBoundRef;
	class ExtraReflectedRefs;
	class ExtraReflectorRefs;
	class ExtraEmittanceSource;
	class ExtraCombatStyle;
	class ExtraPrimitive;
	class ExtraOpenCloseActivateRef;
	class ExtraAnimNoteReceiver;
	class ExtraAmmo;
	class ExtraPatrolRefData;
	class ExtraPackageData;
	class ExtraOcclusionShape;
	class ExtraCollisionData;
	class ExtraSayTopicInfoOnceADay;
	class ExtraEncounterZone;
	class ExtraSayToTopicInfo;
	class ExtraOcclusionPlaneRefData;
	class ExtraPortalRefData;
	class ExtraPortal;
	class ExtraRoom;
	class ExtraHealthPerc;
	class ExtraRoomRefData;
	class ExtraGuardedRefData;
	class ExtraCreatureAwakeSound;
	class ExtraHorse;
	class ExtraIgnoredBySandbox;
	class ExtraCellAcousticSpace;
	class ExtraReservedMarkers;
	class ExtraWeaponIdleSound;
	class ExtraWaterLightRefs;
	class ExtraLitWaterRefs;
	class ExtraWeaponAttackSound;
	class ExtraActivateLoopSound;
	class ExtraPatrolRefInUseData;
	class ExtraAshPileRef;
	class ExtraCreatureMovementSound;
	class ExtraFollowerSwimBreadcrumbs;
	class ExtraAliasInstanceArray;
	class ExtraLocation;
	class ExtraLocationRefType;
	class ExtraPromotedRef;
	class ExtraAnimationSequencer;
	class ExtraOutfitItem;
	class ExtraLeveledItemBase;
	class ExtraLightData;
	class ExtraSceneData;
	class ExtraBadPosition;
	class ExtraHeadTrackingWeight;
	class ExtraFromAlias;
	class ExtraShouldWear;
	class ExtraFavorCost;
	class ExtraAttachedArrows3D;
	class ExtraTextDisplayData;
	class ExtraAlphaCutoff;
	class ExtraEnchantment;
	class ExtraSoul;
	class ExtraForcedTarget;
	class ExtraUniqueID;
	class ExtraFlags;
	class ExtraRefrPath;
	class ExtraDecalGroup;
	class ExtraLockList;
	class ExtraForcedLandingMarker;
	class ExtraLargeRefOwnerCells;
	class ExtraCellWaterEnvMap;
	class ExtraCellGrassData;
	class ExtraTeleportName;
	class ExtraInteraction;
	class ExtraWaterData;
	class ExtraWaterCurrentZoneData;
	class ExtraAttachRef;
	class ExtraAttachRefChildren;
	class ExtraGroupConstraint;
	class ExtraScriptedAnimDependence;
	class ExtraCachedScale;
	class ExtraRaceData;
	class ExtraGIDBuffer;
	class ExtraMissingRefIDs;
	class ExtraResourcesPreload;

	enum class ExtraDataType
	{
		kNone,                     // 0x00
		kHavok,                    // 0x01 - ExtraHavok
		kCell3D,                   // 0x02 - ExtraCell3D
		kCellWaterType,            // 0x03 - ExtraCellWaterType
		kRegionList,               // 0x04 - ExtraRegionList
		kSeenData,                 // 0x05 - ExtraSeenData
		kEditorID,                 // 0x06 - ExtraEditorID
		kCellMusicType,            // 0x07 - ExtraCellMusicType
		kCellSkyRegion,            // 0x08 - ExtraCellSkyRegion
		kProcessMiddleLow,         // 0x09 - ExtraProcessMiddleLow
		kDetachTime,               // 0x0A - ExtraDetachTime
		kPersistentCell,           // 0x0B - ExtraPersistentCell
		kUnk0C,                    // 0x0C
		kAction,                   // 0x0D - ExtraAction
		kStartingPosition,         // 0x0E - ExtraStartingPosition
		kUnk0F,                    // 0x0F
		kAnimGraphManager,         // 0x10 - ExtraAnimGraphManager
		kBiped,                    // 0x11 - ExtraBiped
		kUsedMarkers,              // 0x12 - ExtraUsedMarkers
		kDistantData,              // 0x13 - ExtraDistantData
		kRagDollData,              // 0x14 - ExtraRagDollData
		kContainerChanges,         // 0x15 - ExtraContainerChanges
		kWorn,                     // 0x16 - ExtraWorn
		kWornLeft,                 // 0x17 - ExtraWornLeft
		kPackageStartLocation,     // 0x18 - ExtraPackageStartLocation
		kPackage,                  // 0x19 - ExtraPackage
		kTresPassPackage,          // 0x1A - ExtraTresPassPackage
		kRunOncePacks,             // 0x1B - ExtraRunOncePacks
		kReferenceHandle,          // 0x1C - ExtraReferenceHandle
		kFollower,                 // 0x1D - ExtraFollower
		kLevCreaModifier,          // 0x1E - ExtraLevCreaModifier
		kGhost,                    // 0x1F - ExtraGhost
		kOriginalReference,        // 0x20 - ExtraOriginalReference
		kOwnership,                // 0x21 - ExtraOwnership
		kGlobal,                   // 0x22 - ExtraGlobal
		kRank,                     // 0x23 - ExtraRank
		kCount,                    // 0x24 - ExtraCount
		kHealth,                   // 0x25 - ExtraHealth
		kUnk26,                    // 0x26
		kTimeLeft,                 // 0x27 - ExtraTimeLeft
		kCharge,                   // 0x28 - ExtraCharge
		kLight,                    // 0x29 - ExtraLight
		kLock,                     // 0x2A - ExtraLock
		kTeleport,                 // 0x2B - ExtraTeleport
		kMapMarker,                // 0x2C - ExtraMapMarker
		kLeveledCreature,          // 0x2D - ExtraLeveledCreature
		kLeveledItem,              // 0x2E - ExtraLeveledItem
		kScale,                    // 0x2F - ExtraScale
		kMissingLinkedRefIDs,      // 0x30 - ExtraMissingLinkedRefIDs
		kMagicCaster,              // 0x31 - ExtraMagicCaster
		kNonActorMagicTarget,      // 0x32 - NonActorMagicTarget
		kUnk33,                    // 0x33
		kPlayerCrimeList,          // 0x34 - ExtraPlayerCrimeList
		kUnk35,                    // 0x35
		kEnableStateParent,        // 0x36 - ExtraEnableStateParent
		kEnableStateChildren,      // 0x37 - ExtraEnableStateChildren
		kItemDropper,              // 0x38 - ExtraItemDropper
		kDroppedItemList,          // 0x39 - ExtraDroppedItemList
		kRandomTeleportMarker,     // 0x3A - ExtraRandomTeleportMarker
		kUnk3B,                    // 0x3B
		kSavedHavokData,           // 0x3C - ExtraSavedHavokData
		kCannotWear,               // 0x3D - ExtraCannotWear
		kPoison,                   // 0x3E - ExtraPoison
		kMagicLight,               // 0x3F - ExtraMagicLight
		kLastFinishedSequence,     // 0x40 - ExtraLastFinishedSequence
		kSavedAnimation,           // 0x41 - ExtraSavedAnimation
		kNorthRotation,            // 0x42 - ExtraNorthRotation
		kSpawnContainer,           // 0x43 - ExtraSpawnContainer
		kFriendHits,               // 0x44 - ExtraFriendHits
		kHeadingTarget,            // 0x45 - ExtraHeadingTarget
		kUnk46,                    // 0x46
		kRefractionProperty,       // 0x47 - ExtraRefractionProperty
		kStartingWorldOrCell,      // 0x48 - ExtraStartingWorldOrCell
		kHotkey,                   // 0x49 - ExtraHotkey
		kEditorRef3DData,          // 0x4A - ExtraEditorRef3DData
		kEditorRefMoveData,        // 0x4B - ExtraEditorRefMoveData
		kInfoGeneralTopic,         // 0x4C - ExtraInfoGeneralTopic
		kHasNoRumors,              // 0x4D - ExtraHasNoRumors
		kSound,                    // 0x4E - ExtraSound
		kTerminalState,            // 0x4F - ExtraTerminalState
		kLinkedRef,                // 0x50 - ExtraLinkedRef
		kLinkedRefChildren,        // 0x51 - ExtraLinkedRefChildren
		kActivateRef,              // 0x52 - ExtraActivateRef
		kActivateRefChildren,      // 0x53 - ExtraActivateRefChildren
		kCanTalkToPlayer,          // 0x54 - ExtraCanTalkToPlayer
		kObjectHealth,             // 0x55 - ExtraObjectHealth
		kCellImageSpace,           // 0x56 - ExtraCellImageSpace
		kNavMeshPortal,            // 0x57 - ExtraNavMeshPortal
		kModelSwap,                // 0x58 - ExtraModelSwap
		kRadius,                   // 0x59 - ExtraRadius
		kUnk5A,                    // 0x5A
		kFactionChanges,           // 0x5B - ExtraFactionChanges
		kDismemberedLimbs,         // 0x5C - ExtraDismemberedLimbs
		kActorCause,               // 0x5D - ExtraActorCause
		kMultiBound,               // 0x5E - ExtraMultiBound
		kMultiBoundMarkerData,     // 0x5F - MultiBoundMarkerData
		kMultiBoundRef,            // 0x60 - ExtraMultiBoundRef
		kReflectedRefs,            // 0x61 - ExtraReflectedRefs
		kReflectorRefs,            // 0x62 - ExtraReflectorRefs
		kEmittanceSource,          // 0x63 - ExtraEmittanceSource
		kUnk64,                    // 0x64
		kCombatStyle,              // 0x65 - ExtraCombatStyle
		kUnk66,                    // 0x66
		kPrimitive,                // 0x67 - ExtraPrimitive
		kOpenCloseActivateRef,     // 0x68 - ExtraOpenCloseActivateRef
		kAnimNoteReceiver,         // 0x69 - ExtraAnimNoteReceiver
		kAmmo,                     // 0x6A - ExtraAmmo
		kPatrolRefData,            // 0x6B - ExtraPatrolRefData
		kPackageData,              // 0x6C - ExtraPackageData
		kOcclusionShape,           // 0x6D - ExtraOcclusionShape
		kCollisionData,            // 0x6E - ExtraCollisionData
		kSayTopicInfoOnceADay,     // 0x6F - ExtraSayTopicInfoOnceADay
		kEncounterZone,            // 0x70 - ExtraEncounterZone
		kSayTopicInfo,             // 0x71 - ExtraSayToTopicInfo
		kOcclusionPlaneRefData,    // 0x72 - ExtraOcclusionPlaneRefData
		kPortalRefData,            // 0x73 - ExtraPortalRefData
		kPortal,                   // 0x74 - ExtraPortal
		kRoom,                     // 0x75 - ExtraRoom
		kHealthPerc,               // 0x76 - ExtraHealthPerc
		kRoomRefData,              // 0x77 - ExtraRoomRefData
		kGuardedRefData,           // 0x78 - ExtraGuardedRefData
		kCreatureAwakeSound,       // 0x79 - ExtraCreatureAwakeSound
		kUnk7A,                    // 0x7A
		kHorse,                    // 0x7B - ExtraHorse
		kIgnoredBySandbox,         // 0x7C - ExtraIgnoredBySandbox
		kCellAcousticSpace,        // 0x7D - ExtraCellAcousticSpace
		kReservedMarkers,          // 0x7E - ExtraReservedMarkers
		kWeaponIdleSound,          // 0x7F - ExtraWeaponIdleSound
		kWaterLightRefs,           // 0x80 - ExtraWaterLightRefs
		kLitWaterRefs,             // 0x81 - ExtraLitWaterRefs
		kWeaponAttackSound,        // 0x82 - ExtraWeaponAttackSound
		kActivateLoopSound,        // 0x83 - ExtraActivateLoopSound
		kPatrolRefInUseData,       // 0x84 - ExtraPatrolRefInUseData
		kAshPileRef,               // 0x85 - ExtraAshPileRef
		kCreatureMovementSound,    // 0x86 - ExtraCreatureMovementSound
		kFollowerSwimBreadcrumbs,  // 0x87 - ExtraFollowerSwimBreadcrumbs
		kAliasInstanceArray,       // 0x88 - ExtraAliasInstanceArray
		kLocation,                 // 0x89 - ExtraLocation
		kUnk8A,                    // 0x8A
		kLocationRefType,          // 0x8B - ExtraLocationRefType
		kPromotedRef,              // 0x8C - ExtraPromotedRef
		kAnimationSequencer,       // 0x8D - ExtraAnimationSequencer
		kOutfitItem,               // 0x8E - ExtraOutfitItem
		kUnk8F,                    // 0x8F
		kLeveledItemBase,          // 0x90 - ExtraLeveledItemBase
		kLightData,                // 0x91 - ExtraLightData
		kSceneData,                // 0x92 - ExtraSceneData
		kBadPosition,              // 0x93 - ExtraBadPosition
		kHeadTrackingWeight,       // 0x94 - ExtraHeadTrackingWeight
		kFromAlias,                // 0x95 - ExtraFromAlias
		kShouldWear,               // 0x96 - ExtraShouldWear
		kFavorCost,                // 0x97 - ExtraFavorCost
		kAttachedArrows3D,         // 0x98 - ExtraAttachedArrows3D
		kTextDisplayData,          // 0x99 - ExtraTextDisplayData
		kAlphaCutoff,              // 0x9A - ExtraAlphaCutoff
		kEnchantment,              // 0x9B - ExtraEnchantment
		kSoul,                     // 0x9C - ExtraSoul
		kForcedTarget,             // 0x9D - ExtraForcedTarget
		kUnk9E,                    // 0x9E
		kUniqueID,                 // 0x9F - ExtraUniqueID
		kFlags,                    // 0xA0 - ExtraFlags
		kRefrPath,                 // 0xA1 - ExtraRefrPath
		kDecalGroup,               // 0xA2 - ExtraDecalGroup
		kLockList,                 // 0xA3 - ExtraLockList
		kForcedLandingMarker,      // 0xA4 - ExtraForcedLandingMarker
		kLargeRefOwnerCells,       // 0xA5 - ExtraLargeRefOwnerCells
		kCellWaterEnvMap,          // 0xA6 - ExtraCellWaterEnvMap
		kCellGrassData,            // 0xA7 - ExtraCellGrassData
		kTeleportName,             // 0xA8 - ExtraTeleportName
		kInteraction,              // 0xA9 - ExtraInteraction
		kWaterData,                // 0xAA - ExtraWaterData
		kWaterCurrentZoneData,     // 0xAB - ExtraWaterCurrentZoneData
		kAttachRef,                // 0xAC - ExtraAttachRef
		kAttachRefChildren,        // 0xAD - ExtraAttachRefChildren
		kGroupConstraint,          // 0xAE - ExtraGroupConstraint
		kScriptedAnimDependence,   // 0xAF - ExtraScriptedAnimDependence
		kCachedScale,              // 0xB0 - ExtraCachedScale
		kRaceData,                 // 0xB1 - ExtraRaceData
		kGIDBuffer,                // 0xB2 - ExtraGIDBuffer
		kMissingRefIDs,            // 0xB3 - ExtraMissingRefIDs
		kUnkB4,                    // 0xB4
		kResourcesPreload,         // 0xB5 - ExtraResourcesPreload
		kUnkB6,                    // 0xB6
		kUnkB7,                    // 0xB7
		kUnkB8,                    // 0xB8
		kUnkB9,                    // 0xB9
		kUnkBA,                    // 0xBA
		kUnkBB,                    // 0xBB
		kUnkBC,                    // 0xBC
		kUnkBD,                    // 0xBD
		kUnkBE,                    // 0xBE
		kUnkBF                     // 0xBF
	};
}


===============================================
File: include/RE/E/ExtraDecalGroup.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct BGSDecalGroup;

	class ExtraDecalGroup : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraDecalGroup;
		inline static auto           EXTRADATATYPE = ExtraDataType::kDecalGroup;

		~ExtraDecalGroup() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kDecalGroup; }

		// members
		BGSDecalGroup* decalGroup;  // 10
	};
	static_assert(sizeof(ExtraDecalGroup) == 0x18);
}


===============================================
File: include/RE/E/ExtraDetachTime.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraDetachTime : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraDetachTime;
		inline static auto           EXTRADATATYPE = ExtraDataType::kDetachTime;

		~ExtraDetachTime() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kDetachTime; }

		// members
		std::uint32_t time;   // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraDetachTime) == 0x18);
}


===============================================
File: include/RE/E/ExtraDismemberedLimbs.h
===============================================
#pragma once

#include "RE/B/BGSBodyPartDefs.h"
#include "RE/B/BSExtraData.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESForm;

	struct DismemberedLimb
	{
		BSTArray<TESForm*>                                         objects;  // 00
		stl::enumeration<BGSBodyPartDefs::LIMB_ENUM, std::uint8_t> limb;     // 18
		bool                                                       unk19;    // 19
		bool                                                       unk1A;    // 1A
		std::uint8_t                                               pad1B;    // 1B
		std::uint32_t                                              pad1C;    // 1C
	};
	static_assert(sizeof(DismemberedLimb) == 0x20);

	class ExtraDismemberedLimbs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraDismemberedLimbs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kDismemberedLimbs;

		~ExtraDismemberedLimbs() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kDismemberedLimbs; }

		// members
		std::uint16_t                                               limbs;             // 10
		bool                                                        eaten;             // 12
		std::uint8_t                                                unk13;             // 13
		std::uint32_t                                               unk14;             // 14
		TESForm*                                                    deathObject;       // 18
		BSTArray<DismemberedLimb*>                                  dismemberedLimbs;  // 20
		stl::enumeration<BGSBodyPartDefs::LIMB_ENUM, std::uint32_t> lastHitLimb;       // 38
		std::uint32_t                                               pad3C;             // 3C
	};
	static_assert(sizeof(ExtraDismemberedLimbs) == 0x40);
}


===============================================
File: include/RE/E/ExtraDistantData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class ExtraDistantData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraDistantData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kDistantData;

		~ExtraDistantData() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kDistantData; }

		// members
		NiPoint3      landNormal;  // 10
		std::uint32_t pad1C;       // 1C
	};
	static_assert(sizeof(ExtraDistantData) == 0x20);
}


===============================================
File: include/RE/E/ExtraDroppedItemList.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraDroppedItemList : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraDroppedItemList;
		inline static auto           EXTRADATATYPE = ExtraDataType::kDroppedItemList;

		~ExtraDroppedItemList() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 { return kDroppedItemList; }

		// members
		BSSimpleList<ObjectRefHandle> droppedItemList;  // 10
	};
	static_assert(sizeof(ExtraDroppedItemList) == 0x20);
}


===============================================
File: include/RE/E/ExtraEditorID.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSFixedString.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraEditorID : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEditorID;
		inline static auto           EXTRADATATYPE = ExtraDataType::kEditorID;

		~ExtraEditorID() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kEditorID; }

		// members
		BSFixedString editorID;  // 10
	};
	static_assert(sizeof(ExtraEditorID) == 0x18);
}


===============================================
File: include/RE/E/ExtraEditorRef3DData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSLines;
	class NiAVObject;

	class ExtraEditorRef3DData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEditorRef3DData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kEditorRef3DData;

		~ExtraEditorRef3DData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kEditorRef3DData; }

		// members
		NiPointer<NiAVObject> data3D;     // 10
		NiPointer<BSLines>    dataBound;  // 18
	};
	static_assert(sizeof(ExtraEditorRef3DData) == 0x20);
}


===============================================
File: include/RE/E/ExtraEditorRefMoveData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class ExtraEditorRefMoveData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEditorRefMoveData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kEditorRefMoveData;

		~ExtraEditorRefMoveData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kEditorRefMoveData; }

		// members
		NiPoint3      realAngle;     // 10
		NiPoint3      realLocation;  // 1C
		NiPoint3      oldLocation;   // 28
		std::uint32_t pad34;         // 34
	};
	static_assert(sizeof(ExtraEditorRefMoveData) == 0x38);
}


===============================================
File: include/RE/E/ExtraEmittanceSource.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESForm;

	class ExtraEmittanceSource : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEmittanceSource;
		inline static auto           EXTRADATATYPE = ExtraDataType::kEmittanceSource;

		~ExtraEmittanceSource() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kEmittanceSource; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return source != a_rhs->source; }

		// members
		TESForm* source;  // 10
	};
	static_assert(sizeof(ExtraEmittanceSource) == 0x18);
}


===============================================
File: include/RE/E/ExtraEnableStateChildren.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraEnableStateChildren : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEnableStateChildren;
		inline static auto           EXTRADATATYPE = ExtraDataType::kEnableStateChildren;

		~ExtraEnableStateChildren() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kEnableStateChildren; }

		// members
		BSSimpleList<ObjectRefHandle> children;  // 10
	};
	static_assert(sizeof(ExtraEnableStateChildren) == 0x20);
}


===============================================
File: include/RE/E/ExtraEnableStateParent.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraEnableStateParent : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEnableStateParent;
		inline static auto           EXTRADATATYPE = ExtraDataType::kEnableStateParent;

		~ExtraEnableStateParent() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kEnableStateParent; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return unk14 != a_rhs->unk14 || unk10 != a_rhs->unk10; }

		// members
		std::int8_t     flags;   // 10
		std::uint8_t    pad11;   // 11
		std::uint16_t   pad12;   // 12
		ObjectRefHandle parent;  // 14
	};
	static_assert(sizeof(ExtraEnableStateParent) == 0x18);
}


===============================================
File: include/RE/E/ExtraEnchantment.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class ExtraEnchantment : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEnchantment;
		inline static constexpr auto VTABLE = VTABLE_ExtraEnchantment;
		inline static auto           EXTRADATATYPE = ExtraDataType::kEnchantment;

		ExtraEnchantment();
		ExtraEnchantment(EnchantmentItem* a_enchantment, std::uint16_t a_charge, bool a_removeOnUnequip = false);
		~ExtraEnchantment() override = default;  // 00

		// override(BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kEnchantment; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return enchantment != a_rhs->enchantment || charge != a_rhs->charge || removeOnUnequip != a_rhs->removeOnUnequip; }

		// members
		EnchantmentItem* enchantment;      // 10
		std::uint16_t    charge;           // 18
		bool             removeOnUnequip;  // 1A
		std::uint8_t     pad1B;            // 1B
		std::uint32_t    pad1C;            // 1C
	};
	static_assert(sizeof(ExtraEnchantment) == 0x20);
}


===============================================
File: include/RE/E/ExtraEncounterZone.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSEncounterZone;

	class ExtraEncounterZone : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraEncounterZone;
		inline static constexpr auto VTABLE = VTABLE_ExtraEncounterZone;
		inline static constexpr auto EXTRADATATYPE = ExtraDataType::kEncounterZone;

		ExtraEncounterZone();
		explicit ExtraEncounterZone(BGSEncounterZone* a_zone);
		~ExtraEncounterZone() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kEncounterZone; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return zone != a_rhs->zone; }

		// members
		BGSEncounterZone* zone;  // 10
	};
	static_assert(sizeof(ExtraEncounterZone) == 0x18);
}


===============================================
File: include/RE/E/ExtraFactionChanges.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/F/FactionRank.h"

namespace RE
{
	class TESFaction;

	class ExtraFactionChanges : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraFactionChanges;
		inline static auto           EXTRADATATYPE = ExtraDataType::kFactionChanges;

		~ExtraFactionChanges() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kFactionChanges; }

		// members
		BSTArray<FACTION_RANK> factionChanges;      // 10
		TESFaction*            crimeFaction;        // 28
		bool                   removeCrimeFaction;  // 30
		std::uint8_t           pad31;               // 31
		std::uint16_t          pad32;               // 32
		std::uint32_t          pad34;               // 34
	};
	static_assert(sizeof(ExtraFactionChanges) == 0x38);
}


===============================================
File: include/RE/E/ExtraFavorCost.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraFavorCost : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraFavorCost;
		inline static auto           EXTRADATATYPE = ExtraDataType::kFavorCost;

		~ExtraFavorCost() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kFavorCost; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return cost != a_rhs->cost; }

		// members
		float         cost;   // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraFavorCost) == 0x18);
}


===============================================
File: include/RE/E/ExtraFlags.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraFlags : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraFlags;
		inline static auto           EXTRADATATYPE = ExtraDataType::kFlags;

		enum class Flag
		{
			kNone = 0,
			kBlockActivate = 1 << 0,
			kBlockPlayerActivate = 1 << 1,
			kBlockLoadEvents = 1 << 2,
			kBlockActivateText = 1 << 3,
			kPlayerHasTaken = 1 << 5
		};

		~ExtraFlags() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kFlags; }

		[[nodiscard]] constexpr bool IsActivationBlocked() const noexcept { return flags.all(Flag::kBlockActivate); }

		// members
		stl::enumeration<Flag, std::uint32_t> flags;  // 10
		std::uint32_t                         pad14;  // 14
	};
	static_assert(sizeof(ExtraFlags) == 0x18);
}


===============================================
File: include/RE/E/ExtraFollower.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraFollower : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraFollower;
		inline static auto           EXTRADATATYPE = ExtraDataType::kFollower;

		struct FollowerInfo
		{
			ActorHandle actor;                   // 0
			float       intendedFollowDistance;  // 4
		};
		static_assert(sizeof(FollowerInfo) == 0x8);

		~ExtraFollower() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kFollower; }

		// members
		BSTArray<FollowerInfo> actorFollowers;  // 10
	};
	static_assert(sizeof(ExtraFollower) == 0x28);
}


===============================================
File: include/RE/E/ExtraFollowerSwimBreadcrumbs.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	enum class BREADCRUMB_STATE
	{
		kInvalid = 0,
		kOnGround = 1,
		kInWater = 2
	};

	struct ExtraFollowerSwimBreadcrumb
	{
		NiPoint3      startLocation;   // 00
		std::uint32_t startNavMeshID;  // 0C
		NiPoint3      endLocation;     // 10
		std::uint32_t endNavMeshID;    // 1C
		bool          enteringWater;   // 20
		std::uint8_t  pad21;           // 21
		std::uint16_t pad22;           // 22
	};
	static_assert(sizeof(ExtraFollowerSwimBreadcrumb) == 0x24);

	class ExtraFollowerSwimBreadcrumbs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraFollowerSwimBreadcrumbs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kFollowerSwimBreadcrumbs;

		~ExtraFollowerSwimBreadcrumbs() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kFollowerSwimBreadcrumbs; }

		// members
		stl::enumeration<BREADCRUMB_STATE, std::uint32_t> leaderState;      // 10
		NiPoint3                                          leaderLocation;   // 14
		std::uint32_t                                     leaderNavMeshID;  // 20
		std::uint32_t                                     pad24;            // 24
		BSSimpleList<ExtraFollowerSwimBreadcrumb*>        crumbs;           // 28
	};
	static_assert(sizeof(ExtraFollowerSwimBreadcrumbs) == 0x38);
}


===============================================
File: include/RE/E/ExtraForcedLandingMarker.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraForcedLandingMarker : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraForcedLandingMarker;
		inline static auto           EXTRADATATYPE = ExtraDataType::kForcedLandingMarker;

		~ExtraForcedLandingMarker() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kForcedLandingMarker; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return landingMarker != a_rhs->landingMarker; }

		// members
		ObjectRefHandle landingMarker;  // 10
		std::uint32_t   pad14;          // 14
	};
	static_assert(sizeof(ExtraForcedLandingMarker) == 0x18);
}


===============================================
File: include/RE/E/ExtraForcedTarget.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	class ExtraForcedTarget : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraForcedTarget;
		inline static constexpr auto VTABLE = VTABLE_ExtraForcedTarget;
		inline static auto           EXTRADATATYPE = ExtraDataType::kForcedTarget;

		ExtraForcedTarget();
		explicit ExtraForcedTarget(ObjectRefHandle a_target);
		~ExtraForcedTarget() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kForcedTarget; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return target != a_rhs->target; }

		NiPointer<TESObjectREFR> GetTarget();

		// members
		ObjectRefHandle target;  // 10
		std::uint32_t   pad14;   // 14
	};
	static_assert(sizeof(ExtraForcedTarget) == 0x18);
}


===============================================
File: include/RE/E/ExtraFriendHits.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraFriendHits : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraFriendHits;
		inline static auto           EXTRADATATYPE = ExtraDataType::kFriendHits;

		~ExtraFriendHits() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kFriendHits; }

		// members
		BSTArray<AITimeStamp> hits;  // 10
	};
	static_assert(sizeof(ExtraFriendHits) == 0x28);
}


===============================================
File: include/RE/E/ExtraFromAlias.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraFromAlias : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraFromAlias;
		inline static auto           EXTRADATATYPE = ExtraDataType::kFromAlias;

		~ExtraFromAlias() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kFromAlias; }

		// members
		TESQuest*     quest;    // 10
		std::uint32_t aliasID;  // 18
		std::uint32_t pad1C;    // 1C
	};
	static_assert(sizeof(ExtraFromAlias) == 0x20);
}


===============================================
File: include/RE/E/ExtraGIDBuffer.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraGIDBuffer : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraGIDBuffer;
		inline static auto           EXTRADATATYPE = ExtraDataType::kGIDBuffer;

		~ExtraGIDBuffer() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kGIDBuffer; }

		// members
		std::int8_t* buffer;  // 10
	};
	static_assert(sizeof(ExtraGIDBuffer) == 0x18);
}


===============================================
File: include/RE/E/ExtraGhost.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraGhost : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraGhost;
		inline static auto           EXTRADATATYPE = ExtraDataType::kGhost;

		~ExtraGhost() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kGhost; }

		// members
		bool          ghost;  // 10
		std::uint8_t  pad11;  // 11
		std::uint16_t pad12;  // 12
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraGhost) == 0x18);
}


===============================================
File: include/RE/E/ExtraGlobal.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESGlobal;

	class ExtraGlobal : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraGlobal;
		inline static auto           EXTRADATATYPE = ExtraDataType::kGlobal;

		~ExtraGlobal() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kGlobal; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return global != a_rhs->global; }

		// members
		TESGlobal* global;  // 10
	};
	static_assert(sizeof(ExtraGlobal) == 0x18);
}


===============================================
File: include/RE/E/ExtraGroupConstraint.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class ExtraGroupConstraint : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraGroupConstraint;
		inline static auto           EXTRADATATYPE = ExtraDataType::kGroupConstraint;

		~ExtraGroupConstraint() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kGroupConstraint; }

		// members
		std::int32_t    constraintType;           // 10
		ObjectRefHandle entityB;                  // 14
		BSFixedString   attachNodeNameA;          // 18
		BSFixedString   attachNodeNameB;          // 20
		NiPoint3        constraintOffsetA;        // 28
		NiPoint3        constraintOffsetB;        // 34
		std::uint32_t   originalCollisionGroupB;  // 40
		float           dynamicMassScaleB;        // 44
	};
	static_assert(sizeof(ExtraGroupConstraint) == 0x48);
}


===============================================
File: include/RE/E/ExtraGuardedRefData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraGuardedRefData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraGuardedRefData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kGuardedRefData;

		struct GuardInfo
		{
			FormID        guard;  // 0
			std::uint32_t unk4;   // 4
			std::uint32_t unk8;   // 8
		};
		static_assert(sizeof(GuardInfo) == 0xC);

		~ExtraGuardedRefData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kGuardedRefData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		BSTArray<GuardInfo> guards;  // 10
	};
	static_assert(sizeof(ExtraGuardedRefData) == 0x28);
}


===============================================
File: include/RE/E/ExtraHasNoRumors.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraHasNoRumors : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHasNoRumors;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHasNoRumors;

		~ExtraHasNoRumors() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kHasNoRumors; }

		// members
		bool          noRumors;  // 10
		std::uint8_t  pad11;     // 11
		std::uint16_t pad12;     // 12
		std::uint32_t pad14;     // 14
	};
	static_assert(sizeof(ExtraHasNoRumors) == 0x18);
}


===============================================
File: include/RE/E/ExtraHavok.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class bhkWorld;
	class CellMopp;

	class ExtraHavok : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHavok;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHavok;

		~ExtraHavok() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kHavok; }

		// members
		NiPointer<bhkWorld> world;     // 10
		NiPointer<CellMopp> cellMopp;  // 18
	};
	static_assert(sizeof(ExtraHavok) == 0x20);
}


===============================================
File: include/RE/E/ExtraHeadTrackingWeight.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraHeadTrackingWeight : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHeadTrackingWeight;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHeadTrackingWeight;

		~ExtraHeadTrackingWeight() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kHeadTrackingWeight; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return weight != a_rhs->weight; }

		// members
		float         weight;  // 10
		std::uint32_t pad14;   // 14
	};
	static_assert(sizeof(ExtraHeadTrackingWeight) == 0x18);
}


===============================================
File: include/RE/E/ExtraHeadingTarget.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraHeadingTarget : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHeadingTarget;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHeadingTarget;

		~ExtraHeadingTarget() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kHeadingTarget; }

		// members
		ObjectRefHandle target;  // 10
		std::uint32_t   pad14;   // 14
	};
	static_assert(sizeof(ExtraHeadingTarget) == 0x18);
}


===============================================
File: include/RE/E/ExtraHealth.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraHealth : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHealth;
		inline static constexpr auto VTABLE = VTABLE_ExtraHealth;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHealth;

		ExtraHealth();
		explicit ExtraHealth(float a_health);
		~ExtraHealth() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kHealth; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return health != a_rhs->health; }

		// members
		float         health;  // 10
		std::uint32_t pad14;   // 14
	};
	static_assert(sizeof(ExtraHealth) == 0x18);
}


===============================================
File: include/RE/E/ExtraHealthPerc.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraHealthPerc : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHealthPerc;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHealthPerc;

		~ExtraHealthPerc() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kHealthPerc; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return unk10 != a_rhs->unk10; }

		// members
		std::uint32_t unk10;  // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraHealthPerc) == 0x18);
}


===============================================
File: include/RE/E/ExtraHorse.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraHorse : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHorse;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHorse;

		~ExtraHorse() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kHorse; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return horseRef != a_rhs->horseRef; }

		// members
		ObjectRefHandle horseRef;  // 10
		std::uint32_t   pad14;     // 14
	};
	static_assert(sizeof(ExtraHorse) == 0x18);
}


===============================================
File: include/RE/E/ExtraHotkey.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraHotkey : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraHotkey;
		inline static constexpr auto VTABLE = VTABLE_ExtraHotkey;
		inline static auto           EXTRADATATYPE = ExtraDataType::kHotkey;

		enum class Hotkey
		{
			kUnbound = static_cast<std::underlying_type_t<Hotkey>>(-1),
			kSlot1 = 0,
			kSlot2 = 1,
			kSlot3 = 2,
			kSlot4 = 3,
			kSlot5 = 4,
			kSlot6 = 5,
			kSlot7 = 6,
			kSlot8 = 7
		};

		ExtraHotkey();
		explicit ExtraHotkey(Hotkey a_hotkey);
		~ExtraHotkey() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kHotkey }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { hotkey != a_rhs->hotkey; }

		// members
		stl::enumeration<Hotkey, std::uint8_t> hotkey;  // 10
		std::uint8_t                           unk11;   // 11
		std::uint16_t                          unk12;   // 12
		std::uint32_t                          unk14;   // 14
	};
	static_assert(sizeof(ExtraHotkey) == 0x18);
}


===============================================
File: include/RE/E/ExtraIgnoredBySandbox.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraIgnoredBySandbox : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraIgnoredBySandbox;
		inline static auto           EXTRADATATYPE = ExtraDataType::kIgnoredBySandbox;

		~ExtraIgnoredBySandbox() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kIgnoredBySandbox; }
	};
	static_assert(sizeof(ExtraIgnoredBySandbox) == 0x10);
}


===============================================
File: include/RE/E/ExtraInfoGeneralTopic.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraInfoGeneralTopic : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraInfoGeneralTopic;
		inline static auto           EXTRADATATYPE = ExtraDataType::kInfoGeneralTopic;

		struct Data
		{
			std::uint64_t unk00;  // 00
			std::uint64_t unk08;  // 08
			std::uint64_t unk10;  // 10
			std::uint64_t unk18;  // 18
			std::uint64_t unk20;  // 20
			std::uint64_t unk28;  // 28
			std::uint64_t unk30;  // 30
			std::uint64_t unk38;  // 38
			std::uint64_t unk40;  // 40
			std::uint64_t unk48;  // 48
			std::uint64_t unk50;  // 50
		};
		static_assert(sizeof(Data) == 0x58);

		~ExtraInfoGeneralTopic() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kInfoGeneralTopic; }

		// members
		Data* unk10;  // 10
	};
	static_assert(sizeof(ExtraInfoGeneralTopic) == 0x18);
}


===============================================
File: include/RE/E/ExtraInteraction.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class RefrInteraction;

	class ExtraInteraction : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraInteraction;
		inline static auto           EXTRADATATYPE = ExtraDataType::kInteraction;

		~ExtraInteraction() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { reutrn kInteraction; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return unk10 != a_rhs->unk10; }

		// members
		BSTSmartPointer<RefrInteraction> interaction;  // 10
	};
	static_assert(sizeof(ExtraInteraction) == 0x18);
}


===============================================
File: include/RE/E/ExtraItemDropper.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraItemDropper : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraItemDropper;
		inline static auto           EXTRADATATYPE = ExtraDataType::kItemDropper;

		~ExtraItemDropper() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kItemDropper; }

		// members
		ObjectRefHandle dropper;  // 10
		std::uint32_t   pad14;    // 14
	};
	static_assert(sizeof(ExtraItemDropper) == 0x18);
}


===============================================
File: include/RE/E/ExtraLargeRefOwnerCells.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESForm;

	class ExtraLargeRefOwnerCells : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLargeRefOwnerCells;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLargeRefOwnerCells;

		~ExtraLargeRefOwnerCells() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kLargeRefOwnerCells; }

		// members
		BSTArray<TESForm*> ownerCells;  // 10
		std::uint64_t      unk28;       // 28
	};
	static_assert(sizeof(ExtraLargeRefOwnerCells) == 0x30);
}


===============================================
File: include/RE/E/ExtraLastFinishedSequence.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSFixedString.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraLastFinishedSequence : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLastFinishedSequence;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLastFinishedSequence;

		~ExtraLastFinishedSequence() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLastFinishedSequence; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return lastSequenceName != a_rhs->lastSequenceName; }

		// members
		BSFixedString lastSequenceName;  // 10
	};
	static_assert(sizeof(ExtraLastFinishedSequence) == 0x18);
}


===============================================
File: include/RE/E/ExtraLevCreaModifier.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	enum class LEV_CREA_MODIFIER
	{
		kEasy = 0,
		kMedium = 1,
		kHard = 2,
		kVeryHard = 3,
		kNone = 4
	};

	class ExtraLevCreaModifier : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLevCreaModifier;
		inline static constexpr auto VTABLE = VTABLE_ExtraLevCreaModifier;
		inline static constexpr auto EXTRADATATYPE = ExtraDataType::kLevCreaModifier;

		ExtraLevCreaModifier();
		explicit ExtraLevCreaModifier(LEV_CREA_MODIFIER a_modifier);
		~ExtraLevCreaModifier() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLevCreaModifier; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return modifier != a_rhs->modifier; }

		// members
		stl::enumeration<LEV_CREA_MODIFIER, std::uint32_t> modifier;  // 10
		std::uint32_t                                      pad14;     // 14
	};
	static_assert(sizeof(ExtraLevCreaModifier) == 0x18);
}


===============================================
File: include/RE/E/ExtraLeveledCreature.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class TESActorBase;

	class ExtraLeveledCreature : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLeveledCreature;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLeveledCreature;

		~ExtraLeveledCreature() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kLeveledCreature; }

		// members
		TESActorBase* originalBase;  // 10
		TESActorBase* templateBase;  // 18
	};
	static_assert(sizeof(ExtraLeveledCreature) == 0x20);
}


===============================================
File: include/RE/E/ExtraLeveledItem.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraLeveledItem : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLeveledItem;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLeveledItem;

		~ExtraLeveledItem() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kLeveledItem; }

		// members
		FormID        levItem;  // 10
		std::uint32_t pad14;    // 14
	};
	static_assert(sizeof(ExtraLeveledItem) == 0x18);
}


===============================================
File: include/RE/E/ExtraLeveledItemBase.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESLevItem;

	class ExtraLeveledItemBase : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLeveledItemBase;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLeveledItemBase;

		~ExtraLeveledItemBase() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLeveledItemBase; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return levItem != a_rhs->levItem; }

		// members
		TESLevItem* levItem;  // 10
	};
	static_assert(sizeof(ExtraLeveledItemBase) == 0x18);
}


===============================================
File: include/RE/E/ExtraLight.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiLight;

	struct REFR_LIGHT
	{
		NiPointer<NiLight> light;       // 00
		float              wantDimmer;  // 08
		std::uint32_t      pad0C;       // 0C
	};
	static_assert(sizeof(REFR_LIGHT) == 0x10);

	class ExtraLight : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLight;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLight;

		~ExtraLight() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kLight; }

		// members
		REFR_LIGHT* lightData;  // 10
	};
	static_assert(sizeof(ExtraLight) == 0x18);
}


===============================================
File: include/RE/E/ExtraLightData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct ExtraLightDataStruct
	{
		ExtraLightDataStruct();
		~ExtraLightDataStruct() = default;

		float         fov;              // 00
		float         fade;             // 04
		float         endDistanceCap;   // 08
		float         shadowDepthBias;  // 0C
		std::uint8_t  unk10;            // 10
		std::uint8_t  pad11;            // 11
		std::uint16_t pad12;            // 12
	};
	static_assert(sizeof(ExtraLightDataStruct) == 0x14);

	class ExtraLightData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLightData;
		inline static constexpr auto VTABLE = VTABLE_ExtraLightData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLightData;

		ExtraLightData();
		~ExtraLightData() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLightData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		ExtraLightDataStruct data;   // 10
		std::uint32_t        pad24;  // 24
	};
	static_assert(sizeof(ExtraLightData) == 0x28);
}


===============================================
File: include/RE/E/ExtraLinkedRef.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSKeyword;
	class TESObjectREFR;

	class ExtraLinkedRef : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLinkedRef;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLinkedRef;

		struct LinkedRef
		{
			BGSKeyword*    keyword;  // 00
			TESObjectREFR* refr;     // 08
		};
		static_assert(sizeof(LinkedRef) == 0x10);

		~ExtraLinkedRef() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLinkedRef; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		BSTSmallArray<LinkedRef> linkedRefs;  // 10
	};
	static_assert(sizeof(ExtraLinkedRef) == 0x30);
}


===============================================
File: include/RE/E/ExtraLinkedRefChildren.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSKeyword;

	class ExtraLinkedRefChildren : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLinkedRefChildren;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLinkedRefChildren;

		struct LinkedRefChild
		{
			BGSKeyword*     keyword;  // 00
			ObjectRefHandle refr;     // 08
			std::uint32_t   pad0C;    // 0C
		};
		static_assert(sizeof(LinkedRefChild) == 0x10);

		~ExtraLinkedRefChildren() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kLinkedRefChildren; }

		// members
		BSTSmallArray<LinkedRefChild> linkedChildren;  // 10
	};
	static_assert(sizeof(ExtraLinkedRefChildren) == 0x30);
}


===============================================
File: include/RE/E/ExtraLitWaterRefs.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESObjectREFR;

	class ExtraLitWaterRefs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLitWaterRefs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLitWaterRefs;

		~ExtraLitWaterRefs() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLitWaterRefs; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return refs != a_rhs->refs; }

		// members
		BSSimpleList<TESObjectREFR*> refs;  // 10
	};
	static_assert(sizeof(ExtraLitWaterRefs) == 0x20);
}


===============================================
File: include/RE/E/ExtraLocation.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSLocation;

	class ExtraLocation : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLocation;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLocation;

		~ExtraLocation() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLocation; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return location != a_rhs->location; }

		// members
		BGSLocation* location;  // 10
	};
	static_assert(sizeof(ExtraLocation) == 0x18);
}


===============================================
File: include/RE/E/ExtraLocationRefType.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSLocationRefType;

	class ExtraLocationRefType : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLocationRefType;
		inline static constexpr auto VTABLE = VTABLE_ExtraLocationRefType;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLocationRefType;

		~ExtraLocationRefType() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLocationRefType; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return locRefType != a_rhs->locRefType; }

		// members
		BGSLocationRefType* locRefType;  // 10
	};
	static_assert(sizeof(ExtraLocationRefType) == 0x18);
}


===============================================
File: include/RE/E/ExtraLock.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	enum class LOCK_LEVEL
	{
		kUnlocked = static_cast<std::underlying_type_t<LOCK_LEVEL>>(-1),
		kVeryEasy = 0,
		kEasy = 1,
		kAverage = 2,
		kHard = 3,
		kVeryHard = 4,
		kRequiresKey = 5
	};

	struct REFR_LOCK
	{
		enum class Flag
		{
			kNone = 0,
			kLocked = 1 << 0,
			kLeveled = 1 << 2
		};

		LOCK_LEVEL                   GetLockLevel(const TESObjectREFR* a_containerRef) const;
		[[nodiscard]] constexpr bool IsLocked() const noexcept { return flags.all(Flag::kLocked); }
		void                         SetLocked(bool a_locked);

		// members
		std::int8_t                          baseLevel;  // 00
		std::uint8_t                         pad01;      // 01
		std::uint16_t                        pad02;      // 02
		std::uint32_t                        pad04;      // 04
		TESKey*                              key;        // 08
		stl::enumeration<Flag, std::uint8_t> flags;      // 10
		std::uint8_t                         pad11;      // 11
		std::uint16_t                        pad12;      // 12
		std::uint32_t                        numTries;   // 14
		std::uint32_t                        unk18;      // 18
		std::uint32_t                        pad1C;      // 1C
	};
	static_assert(sizeof(REFR_LOCK) == 0x20);

	class ExtraLock : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLock;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLock;

		~ExtraLock() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kLock; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		REFR_LOCK* lock;  // 10
	};
	static_assert(sizeof(ExtraLock) == 0x18);
}


===============================================
File: include/RE/E/ExtraLockList.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESForm;

	class ExtraLockList : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraLockList;
		inline static auto           EXTRADATATYPE = ExtraDataType::kLockList;

		~ExtraLockList() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { reutrn kLockList; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return list != a_rhs->list; }

		// members
		TESForm* list;  // 10
	};
	static_assert(sizeof(ExtraLockList) == 0x18);
}


===============================================
File: include/RE/E/ExtraMagicCaster.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/M/MagicCaster.h"

namespace RE
{
	class ExtraMagicCaster :
		public BSExtraData,  // 00
		public MagicCaster   // 10
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraMagicCaster;
		inline static auto           EXTRADATATYPE = ExtraDataType::kMagicCaster;

		~ExtraMagicCaster() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kMagicCaster; }
	};
	static_assert(sizeof(ExtraMagicCaster) == 0x58);
}


===============================================
File: include/RE/E/ExtraMagicLight.h
===============================================
#pragma once

#include "RE/E/ExtraDataTypes.h"
#include "RE/E/ExtraLight.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiRefObject;

	class ExtraMagicLight : public ExtraLight
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraMagicLight;
		inline static auto           EXTRADATATYPE = ExtraDataType::kMagicLight;

		~ExtraMagicLight() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kMagicLight; }
	};
	static_assert(sizeof(ExtraMagicLight) == 0x18);
}


===============================================
File: include/RE/E/ExtraMapMarker.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	enum class MARKER_TYPE
	{
		kNone = 0,
		kCity = 1,
		kTown = 2,
		kSettlement = 3,
		kCave = 4,
		kCamp = 5,
		kFort = 6,
		kNordicRuin = 7,
		kDwemerRuin = 8,
		kShipwreck = 9,
		kGrove = 10,
		kLandmark = 11,
		kDragonLair = 12,
		kFarm = 13,
		kWoodMill = 14,
		kMine = 15,
		kImperialCamp = 16,
		kStormcloakCamp = 17,
		kDoomstone = 18,
		kWheatMill = 19,
		kSmelter = 20,
		kStable = 21,
		kImperialTower = 22,
		kClearing = 23,
		kPass = 24,
		kAltar = 25,
		kRock = 26,
		kLighthouse = 27,
		kOrcStronghold = 28,
		kGiantCamp = 29,
		kShack = 30,
		kNordicTower = 31,
		kNordicDwelling = 32,
		kDocks = 33,
		kShrine = 34,
		kRiftenCastle = 35,
		kRiftenCapitol = 36,
		kWindhelmCastle = 37,
		kWindhelmCapitol = 38,
		kWhiterunCastle = 39,
		kWhiterunCapitol = 40,
		kSolitudeCastle = 41,
		kSolitudeCapitol = 42,
		kMarkarthCastle = 43,
		kMarkarthCapitol = 44,
		kWinterholdCastle = 45,
		kWinterholdCapitol = 46,
		kMorthalCastle = 47,
		kMorthalCapitol = 48,
		kFalkreathCastle = 49,
		kFalkreathCapitol = 50,
		kDawnstarCastle = 51,
		kDawnstarCapitol = 52,
		kDLC02MiraakTemple = 53,
		kDLC02RavenRock = 54,
		kDLC02StandingStone = 55,
		kDLC02TelvanniTower = 56,
		kDLC02ToSkyrim = 57,
		kDLC02ToSolstheim = 58,
		kDLC02CastleKarstaag = 59,
		kTotalLocationTypes,

		kDoor = 61,
		kQuestTarget = 62,
		kQuestTargetDoor,
		kMultipleQuestTarget = kQuestTargetDoor,  // verify this
		kPlayerSet = 64,
		kYouAreHere = 65,
	};

	class MapMarkerData
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kVisible = 1 << 0,
			kCanTravelTo = 1 << 1,
			kShowAllHidden = 1 << 2,
			kUnk3 = 1 << 3,
			kUnk4 = 1 << 4,
			kUnk5 = 1 << 5,
			kUnk6 = 1 << 6,
			kUnk7 = 1 << 7
		};

		constexpr void SetHidden(bool a_value) noexcept { a_value ? flags.set(Flag::kShowAllHidden) : flags.reset(Flag::kShowAllHidden); }
		constexpr void SetVisible(bool a_value) noexcept { a_value ? flags.set(Flag::kVisible) : flags.reset(Flag::kVisible); }

		// members
		TESFullName                                  locationName;  // 00
		stl::enumeration<Flag, std::uint8_t>         flags;         // 10
		std::uint8_t                                 pad11;         // 11
		stl::enumeration<MARKER_TYPE, std::uint16_t> type;          // 12
		std::uint32_t                                pad14;         // 14
	};
	static_assert(sizeof(MapMarkerData) == 0x18);

	class ExtraMapMarker : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraMapMarker;
		inline static auto           EXTRADATATYPE = ExtraDataType::kMapMarker;

		~ExtraMapMarker() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kMapMarker; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		MapMarkerData* mapData;  // 10
	};
	static_assert(sizeof(ExtraMapMarker) == 0x18);
}


===============================================
File: include/RE/E/ExtraMissingLinkedRefIDs.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSKeyword;
	class TESObjectREFR;

	class ExtraMissingLinkedRefIDs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraMissingLinkedRefIDs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kMissingLinkedRefIDs;

		struct Entry
		{
		public:
			// members
			BGSKeyword*   keyword;      // 00
			FormID        linkedRefID;  // 08
			std::uint32_t pad0C;        // 0C
		};
		static_assert(sizeof(Entry) == 0x10);

		// a variation of a small array
		struct Array
		{
		public:
			using value_type = Entry;
			using size_type = std::uint32_t;
			using reference = value_type&;
			using iterator = Entry*;

			union Data
			{
				Entry* entryPtr;
				Entry  entry[1];
			};
			static_assert(sizeof(Data) == 0x10);

			reference operator[](size_type a_pos);
			iterator  begin() noexcept;
			iterator  end() noexcept;
			size_type size() const noexcept;

			// members
			Data          _data;   // 00
			std::uint32_t _size;   // 10
			std::uint32_t _pad14;  // 14
		};
		static_assert(sizeof(Array) == 0x18);

		~ExtraMissingLinkedRefIDs() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kMissingLinkedRefIDs; }

		TESObjectREFR* GetLinkedRef(BGSKeyword* a_keyword);

		// members
		Array entries;  // 10
	};
	static_assert(sizeof(ExtraMissingLinkedRefIDs) == 0x28);
}


===============================================
File: include/RE/E/ExtraMissingRefIDs.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct ActivateParentID
	{
		std::uint32_t refID;          // 0
		float         activateDelay;  // 4
	};
	static_assert(sizeof(ActivateParentID) == 0x8);

	class ExtraMissingRefIDs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraMissingRefIDs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kMissingRefIDs;

		~ExtraMissingRefIDs() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kMissingRefIDs; }

		// members
		ActivateParentID* IDs;     // 10
		std::uint32_t     numIDs;  // 18
		std::uint32_t     unk1C;   // 1C
		std::uint64_t     unk20;   // 20
	};
	static_assert(sizeof(ExtraMissingRefIDs) == 0x28);
}


===============================================
File: include/RE/E/ExtraModelSwap.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESForm;
	class TESModel;

	class ExtraModelSwap : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraModelSwap;
		inline static auto           EXTRADATATYPE = ExtraDataType::kModelSwap;

		~ExtraModelSwap() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kModelSwap; }

		// members
		TESModel* modelSwap;      // 10
		TESForm*  modelSwapForm;  // 18
	};
	static_assert(sizeof(ExtraModelSwap) == 0x20);
}


===============================================
File: include/RE/E/ExtraMultiBound.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSMultiBound;

	class ExtraMultiBound : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraMultiBound;
		inline static auto           EXTRADATATYPE = ExtraDataType::kMultiBound;

		~ExtraMultiBound() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kMultiBound; }

		// members
		NiPointer<BSMultiBound> bound;  // 10
	};
	static_assert(sizeof(ExtraMultiBound) == 0x18);
}


===============================================
File: include/RE/E/ExtraMultiBoundRef.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class ExtraMultiBoundRef : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraMultiBoundRef;
		inline static auto           EXTRADATATYPE = ExtraDataType::kMultiBoundRef;

		~ExtraMultiBoundRef() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kMultiBoundRef; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return boundRef != a_rhs->boundRef; }

		// members
		TESObjectREFR* boundRef;  // 10
	};
	static_assert(sizeof(ExtraMultiBoundRef) == 0x18);
}


===============================================
File: include/RE/E/ExtraNavMeshPortal.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class NavMesh;

	struct NAVMESH_PORTAL
	{
		union Nav
		{
			FormID   navMeshID;
			NavMesh* navMesh;
		};
		static_assert(sizeof(Nav) == 0x8);

		Nav           nav;       // 00
		std::uint16_t triIndex;  // 08
		std::uint16_t pad0A;     // 0A
		std::uint32_t pad0C;     // 0C
	};
	static_assert(sizeof(NAVMESH_PORTAL) == 0x10);

	class ExtraNavMeshPortal : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraNavMeshPortal;
		inline static auto           EXTRADATATYPE = ExtraDataType::kNavMeshPortal;

		~ExtraNavMeshPortal() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kNavMeshPortal; }

		// members
		NAVMESH_PORTAL portal;  // 10
	};
	static_assert(sizeof(ExtraNavMeshPortal) == 0x20);
}


===============================================
File: include/RE/E/ExtraNorthRotation.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraNorthRotation : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraNorthRotation;
		inline static constexpr auto VTABLE = VTABLE_ExtraNorthRotation;
		inline static auto           EXTRADATATYPE = ExtraDataType::kNorthRotation;

		ExtraNorthRotation();
		~ExtraNorthRotation() override = default;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kNorthRotation; }

		// members
		float         northRot;  // 10
		std::uint32_t pad14;     // 14
	};
	static_assert(sizeof(ExtraNorthRotation) == 0x18);
}


===============================================
File: include/RE/E/ExtraObjectHealth.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraObjectHealth : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraObjectHealth;
		inline static auto           EXTRADATATYPE = ExtraDataType::kObjectHealth;

		~ExtraObjectHealth() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kObjectHealth; }

		// members
		float         health;  // 10
		std::uint32_t pad14;   // 14
	};
	static_assert(sizeof(ExtraObjectHealth) == 0x18);
}


===============================================
File: include/RE/E/ExtraOcclusionPlaneRefData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct OcclusionPlaneLinkedRefData
	{
		ObjectRefHandle linkedRefs[4];  // 00
	};
	static_assert(sizeof(OcclusionPlaneLinkedRefData) == 0x10);

	class ExtraOcclusionPlaneRefData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraOcclusionPlaneRefData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kOcclusionPlaneRefData;

		~ExtraOcclusionPlaneRefData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kOcclusionPlaneRefData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		OcclusionPlaneLinkedRefData* data;  // 10
	};
	static_assert(sizeof(ExtraOcclusionPlaneRefData) == 0x18);
}


===============================================
File: include/RE/E/ExtraOcclusionShape.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSOcclusionShape;

	class ExtraOcclusionShape : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraOcclusionShape;
		inline static auto           EXTRADATATYPE = ExtraDataType::kOcclusionShape;

		~ExtraOcclusionShape() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kOcclusionShape; }

		// members
		NiPointer<BSOcclusionShape> shape;  // 10
	};
	static_assert(sizeof(ExtraOcclusionShape) == 0x18);
}


===============================================
File: include/RE/E/ExtraOpenCloseActivateRef.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraOpenCloseActivateRef : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraOpenCloseActivateRef;
		inline static auto           EXTRADATATYPE = ExtraDataType::kOpenCloseActivateRef;

		~ExtraOpenCloseActivateRef() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kOpenCloseActivateRef; }

		// members
		ObjectRefHandle activateRef;  // 10
		std::uint32_t   pad14;        // 14
	};
	static_assert(sizeof(ExtraOpenCloseActivateRef) == 0x18);
}


===============================================
File: include/RE/E/ExtraOriginalReference.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraOriginalReference : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraOriginalReference;
		inline static auto           EXTRADATATYPE = ExtraDataType::kOriginalReference;

		~ExtraOriginalReference() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kOriginalReference; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return reference != a_rhs->reference; }

		// members
		ObjectRefHandle reference;  // 10
		std::uint32_t   pad14;      // 14
	};
	static_assert(sizeof(ExtraOriginalReference) == 0x18);
}


===============================================
File: include/RE/E/ExtraOutfitItem.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraOutfitItem : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraOutfitItem;
		inline static auto           EXTRADATATYPE = ExtraDataType::kOutfitItem;

		~ExtraOutfitItem() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kOutfitItem; }

		// members
		FormID        id;     // 10 - BGSOutfit
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraOutfitItem) == 0x18);
}


===============================================
File: include/RE/E/ExtraOwnership.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESForm;

	class ExtraOwnership : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraOwnership;
		inline static constexpr auto VTABLE = VTABLE_ExtraOwnership;
		inline static auto           EXTRADATATYPE = ExtraDataType::kOwnership;

		ExtraOwnership();
		explicit ExtraOwnership(TESForm* a_owner);
		~ExtraOwnership() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kOwnership; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return owner != a_rhs->owner; }

		// members
		TESForm* owner;  // 10
	};
	static_assert(sizeof(ExtraOwnership) == 0x18);
}


===============================================
File: include/RE/E/ExtraPackage.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESPackage;

	class ExtraPackage : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPackage;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPackage;

		~ExtraPackage() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kPackage; }

		// members
		TESPackage*     unk10;           // 10
		std::int32_t    index;           // 18
		ObjectRefHandle target;          // 1C
		bool            actionComplete;  // 20
		bool            activated;       // 21
		bool            doneOnce;        // 22
		std::uint8_t    unk23;           // 23
		std::uint32_t   unk24;           // 24
	};
	static_assert(sizeof(ExtraPackage) == 0x28);
}


===============================================
File: include/RE/E/ExtraPackageData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ActorPackageData;

	class ExtraPackageData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPackageData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPackageData;

		~ExtraPackageData() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kPackageData; }

		// members
		ActorPackageData* actorPackageData;  // 10
	};
	static_assert(sizeof(ExtraPackageData) == 0x18);
}


===============================================
File: include/RE/E/ExtraPackageStartLocation.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class TESForm;

	struct WORLD_LOCATION
	{
		TESForm* locationForm;  // 00
		NiPoint3 locPt;         // 08
		float    zRot;          // 14
	};
	static_assert(sizeof(WORLD_LOCATION) == 0x18);

	class ExtraPackageStartLocation : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPackageStartLocation;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPackageStartLocation;

		~ExtraPackageStartLocation() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kPackageStartLocation; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		WORLD_LOCATION worldLoc;  // 10
	};
	static_assert(sizeof(ExtraPackageStartLocation) == 0x28);
}


===============================================
File: include/RE/E/ExtraPatrolRefData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct PatrolRefData
	{
		std::uint64_t unk00;  // 00
		std::uint64_t unk08;  // 08
		std::uint64_t unk10;  // 10
		std::uint64_t unk18;  // 18
		std::uint64_t unk20;  // 20
	};
	static_assert(sizeof(PatrolRefData) == 0x28);

	class ExtraPatrolRefData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPatrolRefData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPatrolRefData;

		~ExtraPatrolRefData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kPatrolRefData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		PatrolRefData* patrolData;  // 10
	};
	static_assert(sizeof(ExtraPatrolRefData) == 0x18);
}


===============================================
File: include/RE/E/ExtraPatrolRefInUseData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraPatrolRefInUseData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPatrolRefInUseData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPatrolRefInUseData;

		~ExtraPatrolRefInUseData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { reutrn kPatrolRefInUseData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return user != a_rhs->user; }

		// members
		std::uint32_t user;   // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraPatrolRefInUseData) == 0x18);
}


===============================================
File: include/RE/E/ExtraPersistentCell.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESObjectCELL;

	class ExtraPersistentCell : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPersistentCell;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPersistentCell;

		~ExtraPersistentCell() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kPersistentCell; }

		// members
		TESObjectCELL* persistentCell;  // 10
	};
	static_assert(sizeof(ExtraPersistentCell) == 0x18);
}


===============================================
File: include/RE/E/ExtraPlayerCrimeList.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct Crime;

	class ExtraPlayerCrimeList : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPlayerCrimeList;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPlayerCrimeList;

		~ExtraPlayerCrimeList() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kPlayerCrimeList; }

		// members
		BSSimpleList<Crime*>* crimes;  // 10
	};
	static_assert(sizeof(ExtraPlayerCrimeList) == 0x18);
}


===============================================
File: include/RE/E/ExtraPoison.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class AlchemyItem;

	class ExtraPoison : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPoison;
		inline static constexpr auto VTABLE = VTABLE_ExtraPoison;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPoison;

		ExtraPoison();
		ExtraPoison(AlchemyItem* a_poison, std::int32_t a_count);
		~ExtraPoison() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kPoison; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return poison != a_rhs->poison || count != a_rhs->count; }

		// members
		AlchemyItem*  poison;  // 10
		std::uint32_t count;   // 18
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(ExtraPoison) == 0x20);
}


===============================================
File: include/RE/E/ExtraPortal.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSPortal;

	class ExtraPortal : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPortal;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPortal;

		~ExtraPortal() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kPortal; }

		// members
		NiPointer<BSPortal> portal;  // 10
	};
	static_assert(sizeof(ExtraPortal) == 0x18);
}


===============================================
File: include/RE/E/ExtraPortalRefData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct PortalLinkedRefData
	{
		ObjectRefHandle linkedRefs[2];  // 0
	};
	static_assert(sizeof(PortalLinkedRefData) == 0x8);

	class ExtraPortalRefData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPortalRefData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPortalRefData;

		~ExtraPortalRefData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kPortalRefData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		PortalLinkedRefData* data;  // 10
	};
	static_assert(sizeof(ExtraPortalRefData) == 0x18);
}


===============================================
File: include/RE/E/ExtraPrimitive.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSPrimitive;

	class ExtraPrimitive : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPrimitive;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPrimitive;

		~ExtraPrimitive() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kPrimitive; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return primitive != a_rhs->primitive; }

		// members
		BGSPrimitive* primitive;  // 10
	};
	static_assert(sizeof(ExtraPrimitive) == 0x18);
}


===============================================
File: include/RE/E/ExtraProcessMiddleLow.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraProcessMiddleLow : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraProcessMiddleLow;
		inline static auto           EXTRADATATYPE = ExtraDataType::kProcessMiddleLow;

		~ExtraProcessMiddleLow() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kProcessMiddleLow; }

		// members
		std::uint32_t refCount;  // 10
		std::uint32_t pad14;     // 14
	};
	static_assert(sizeof(ExtraProcessMiddleLow) == 0x18);
}


===============================================
File: include/RE/E/ExtraPromotedRef.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class ExtraPromotedRef : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraPromotedRef;
		inline static auto           EXTRADATATYPE = ExtraDataType::kPromotedRef;

		~ExtraPromotedRef() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kPromotedRef };

		// members
		BSTArray<TESForm*> promotedRefOwners;  // 10
	};
	static_assert(sizeof(ExtraPromotedRef) == 0x28);
}


===============================================
File: include/RE/E/ExtraRaceData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class QueuedFile;

	class ExtraRaceData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRaceData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRaceData;

		~ExtraRaceData() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kRaceData; }

		// members
		NiPointer<QueuedFile> preloadedRaceData;  // 10
	};
	static_assert(sizeof(ExtraRaceData) == 0x18);
}


===============================================
File: include/RE/E/ExtraRadius.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraRadius : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRadius;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRadius;

		~ExtraRadius() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kRadius; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return radius != a_rhs->radius; }

		// members
		float         radius;  // 10
		std::uint32_t pad14;   // 14
	};
	static_assert(sizeof(ExtraRadius) == 0x18);
}


===============================================
File: include/RE/E/ExtraRagDollData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct RagDollBone
	{
		std::int8_t   boneID;   // 00
		std::uint8_t  pad01;    // 01
		std::uint16_t pad02;    // 02
		NiPoint3      bonePos;  // 04
		NiPoint3      boneRot;  // 10
	};
	static_assert(sizeof(RagDollBone) == 0x1C);

	struct RagDollData
	{
		std::int8_t   boneCount;  // 00
		std::uint8_t  pad01;      // 01
		std::uint16_t pad02;      // 02
		std::uint32_t pad04;      // 04
		RagDollBone*  bones;      // 08
		NiPoint3      bip01Rot;   // 10
		std::uint32_t pad1C;      // 1C
	};
	static_assert(sizeof(RagDollData) == 0x20);

	class ExtraRagDollData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRagDollData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRagDollData;

		~ExtraRagDollData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kRagDollData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		RagDollData* ragDollData;  // 10
	};
	static_assert(sizeof(ExtraRagDollData) == 0x18);
}


===============================================
File: include/RE/E/ExtraRandomTeleportMarker.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESObjectREFR;

	class ExtraRandomTeleportMarker : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRandomTeleportMarker;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRandomTeleportMarker;

		~ExtraRandomTeleportMarker() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kRandomTeleportMarker; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return marker != a_rhs->marker; }

		// members
		TESObjectREFR* marker;  // 10
	};
	static_assert(sizeof(ExtraRandomTeleportMarker) == 0x18);
}


===============================================
File: include/RE/E/ExtraRank.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraRank : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRank;
		inline static constexpr auto VTABLE = VTABLE_ExtraRank;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRank;

		ExtraRank();
		explicit ExtraRank(std::int32_t a_rank);
		~ExtraRank() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kRank; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return rank != a_rhs->rank; }

		// members
		std::int32_t  rank;   // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraRank) == 0x18);
}


===============================================
File: include/RE/E/ExtraReferenceHandle.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	class ExtraReferenceHandle : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraReferenceHandle;
		inline static constexpr auto VTABLE = VTABLE_ExtraReferenceHandle;
		inline static auto           EXTRADATATYPE = ExtraDataType::kReferenceHandle;

		ExtraReferenceHandle();
		explicit ExtraReferenceHandle(ObjectRefHandle a_containerRef);
		~ExtraReferenceHandle() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kReferenceHandle; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return containerRef != a_rhs->containerRef; }

		NiPointer<TESObjectREFR> GetOriginalReference();

		// members
		ObjectRefHandle containerRef;  // 10
		std::uint32_t   pad14;         // 14
	};
	static_assert(sizeof(ExtraReferenceHandle) == 0x18);
}


===============================================
File: include/RE/E/ExtraReflectedRefs.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraReflectedRefs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraReflectedRefs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kReflectedRefs;

		~ExtraReflectedRefs() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kReflectedRefs; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		BSTArray<ObjectRefHandle> refs;  // 10
	};
	static_assert(sizeof(ExtraReflectedRefs) == 0x28);
}


===============================================
File: include/RE/E/ExtraReflectorRefs.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraReflectorRefs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraReflectorRefs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kReflectorRefs;

		~ExtraReflectorRefs() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kReflectorRefs; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		BSTArray<ObjectRefHandle> refs;  // 10
	};
	static_assert(sizeof(ExtraReflectorRefs) == 0x28);
}


===============================================
File: include/RE/E/ExtraRefrPath.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class ExtraRefrPath : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRefrPath;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRefrPath;

		enum class PATH_TYPE
		{
		};

		~ExtraRefrPath() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kRefrPath; }

		// members
		NiPoint3                                   startPos;          // 10
		NiPoint3                                   startTangent;      // 1C
		NiPoint3                                   startEuler;        // 28
		NiPoint3                                   goalPos;           // 34
		NiPoint3                                   goalTangent;       // 40
		NiPoint3                                   goalEuler;         // 4C
		float                                      speed;             // 58
		float                                      maxRotSpeed;       // 5C
		float                                      currentParameter;  // 60
		stl::enumeration<PATH_TYPE, std::uint32_t> type;              // 64
	};
	static_assert(sizeof(ExtraRefrPath) == 0x68);
}


===============================================
File: include/RE/E/ExtraRefractionProperty.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraRefractionProperty : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRefractionProperty;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRefractionProperty;

		~ExtraRefractionProperty() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kRefractionProperty; }

		// members
		float         refractionPower;  // 10
		std::uint32_t unk14;            // 14
	};
	static_assert(sizeof(ExtraRefractionProperty) == 0x18);
}


===============================================
File: include/RE/E/ExtraRegionList.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESRegionList;

	class ExtraRegionList : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRegionList;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRegionList;

		~ExtraRegionList() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kRegionList; }

		// members
		TESRegionList* list;  // 10
	};
	static_assert(sizeof(ExtraRegionList) == 0x18);
}


===============================================
File: include/RE/E/ExtraReservedMarkers.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/M/MarkerUsedData.h"

namespace RE
{
	class ExtraReservedMarkers : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraReservedMarkers;
		inline static auto           EXTRADATATYPE = ExtraDataType::kReservedMarkers;

		~ExtraReservedMarkers() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kReservedMarkers; }

		// members
		BSTArray<MarkerUsedData> reservedMarkerArray;  // 10
		std::uint64_t            unk28;                // 28
	};
	static_assert(sizeof(ExtraReservedMarkers) == 0x30);
}


===============================================
File: include/RE/E/ExtraResourcesPreload.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraResourcesPreload : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraResourcesPreload;
		inline static auto           EXTRADATATYPE = ExtraDataType::kResourcesPreload;

		~ExtraResourcesPreload() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kResourcesPreload; }

		// members
		void* unk10;  // 10
	};
	static_assert(sizeof(ExtraResourcesPreload) == 0x18);
}


===============================================
File: include/RE/E/ExtraRoom.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSMultiBoundRoom;

	class ExtraRoom : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRoom;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRoom;

		~ExtraRoom() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kRoom; }

		// members
		NiPointer<BSMultiBoundRoom> room;  // 10
	};
	static_assert(sizeof(ExtraRoom) == 0x18);
}


===============================================
File: include/RE/E/ExtraRoomRefData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSLightingTemplate;
	class TESImageSpace;

	struct RoomRefData
	{
		BSSimpleList<ObjectRefHandle> portalList;        // 00
		BSSimpleList<ObjectRefHandle> roomList;          // 10
		std::int8_t                   master;            // 20
		std::uint8_t                  pad21;             // 21
		std::uint16_t                 pad22;             // 22
		std::uint32_t                 pad24;             // 24
		BGSLightingTemplate*          lightingTemplate;  // 28
		TESImageSpace*                imageSpace;        // 30
	};
	static_assert(sizeof(RoomRefData) == 0x38);

	class ExtraRoomRefData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRoomRefData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRoomRefData;

		~ExtraRoomRefData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kRoomRefData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		RoomRefData* data;  // 10
	};
	static_assert(sizeof(ExtraRoomRefData) == 0x18);
}


===============================================
File: include/RE/E/ExtraRunOncePacks.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct RunOncePackage
	{
		TESPackage*   package;  // 00
		std::int8_t   day;      // 08
		std::uint8_t  pad09;    // 09
		std::uint16_t pad0A;    // 0A
		std::uint32_t pad0C;    // 0C
	};
	static_assert(sizeof(RunOncePackage) == 0x10);

	class ExtraRunOncePacks : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraRunOncePacks;
		inline static auto           EXTRADATATYPE = ExtraDataType::kRunOncePacks;

		~ExtraRunOncePacks() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kRunOncePacks; }

		// members
		BSSimpleList<RunOncePackage*>* packages;  // 10
	};
	static_assert(sizeof(ExtraRunOncePacks) == 0x18);
}


===============================================
File: include/RE/E/ExtraSavedAnimation.h
===============================================
#pragma once

#include "RE/B/BGSLoadGameSubBuffer.h"
#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraSavedAnimation : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSavedAnimation;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSavedAnimation;

		~ExtraSavedAnimation() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kSavedAnimation; }

		// members
		BGSLoadGameSubBuffer animationBuffer;  // 10
	};
	static_assert(sizeof(ExtraSavedAnimation) == 0x18);
}


===============================================
File: include/RE/E/ExtraSavedHavokData.h
===============================================
#pragma once

#include "RE/B/BGSLoadGameSubBuffer.h"
#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraSavedHavokData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSavedHavokData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSavedHavokData;

		~ExtraSavedHavokData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kSavedHavokData; }

		// members
		BGSLoadGameSubBuffer havokBuffer;  // 10
	};
	static_assert(sizeof(ExtraSavedHavokData) == 0x18);
}


===============================================
File: include/RE/E/ExtraSayToTopicInfo.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSDialogueBranch;
	class DialogueItem;
	class TESTopic;

	class ExtraSayToTopicInfo : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSayToTopicInfo;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSayTopicInfo;

		~ExtraSayToTopicInfo() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kSayTopicInfo; }

		// members
		TESTopic*          topic;                // 10
		std::uint8_t       unk18;                // 18
		std::uint8_t       pad19;                // 19
		std::uint16_t      pad1A;                // 1A
		float              subtitleSpeechDelay;  // 1C
		BGSDialogueBranch* exclusiveBranch;      // 20
		BSSoundHandle      unk28;                // 28
		std::uint32_t      pad34;                // 34
		DialogueItem*      item;                 // 38
	};
	static_assert(sizeof(ExtraSayToTopicInfo) == 0x40);
}


===============================================
File: include/RE/E/ExtraSayTopicInfoOnceADay.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESTopicInfo;

	struct SayOnceTopicInfos
	{
		TESTopicInfo* info;       // 00
		std::int32_t  dateStamp;  // 08
		float         hourStamp;  // 0C
	};
	static_assert(sizeof(SayOnceTopicInfos) == 0x10);

	class ExtraSayTopicInfoOnceADay : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSayTopicInfoOnceADay;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSayTopicInfoOnceADay;

		~ExtraSayTopicInfoOnceADay() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kSayTopicInfoOnceADay; }

		// members
		BSSimpleList<SayOnceTopicInfos*>* saidOnceTopicInfos;  // 10
	};
	static_assert(sizeof(ExtraSayTopicInfoOnceADay) == 0x18);
}


===============================================
File: include/RE/E/ExtraScale.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraScale : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraScale;
		inline static auto           EXTRADATATYPE = ExtraDataType::kScale;

		~ExtraScale() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kScale; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return scale != a_rhs->scale; }

		// members
		float         scale;  // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraScale) == 0x18);
}


===============================================
File: include/RE/E/ExtraSceneData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSScene;

	class ExtraSceneData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSceneData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSceneData;

		~ExtraSceneData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kSceneData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return unk10 != a_rhs->unk10; }

		// members
		BGSScene* scene;  // 10
	};
	static_assert(sizeof(ExtraSceneData) == 0x18);
}


===============================================
File: include/RE/E/ExtraScriptedAnimDependence.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTTuple.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraScriptedAnimDependence : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraScriptedAnimDependence;
		inline static auto           EXTRADATATYPE = ExtraDataType::kScriptedAnimDependence;

		~ExtraScriptedAnimDependence() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kScriptedAnimDependence; }

		// members
		BSTArray<BSTTuple<ObjectRefHandle, std::uint32_t>> dependentManagers;  // 10
	};
	static_assert(sizeof(ExtraScriptedAnimDependence) == 0x28);
}


===============================================
File: include/RE/E/ExtraSeenData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class SeenData;

	class ExtraSeenData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSeenData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSeenData;

		~ExtraSeenData() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kSeenData; }

		// members
		SeenData* seenData;  // 10
	};
	static_assert(sizeof(ExtraSeenData) == 0x18);
}


===============================================
File: include/RE/E/ExtraShouldWear.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraShouldWear : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraShouldWear;
		inline static auto           EXTRADATATYPE = ExtraDataType::kShouldWear;

		~ExtraShouldWear() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kShouldWear; }

		// members
		std::uint64_t unk10;  // 10
	};
	static_assert(sizeof(ExtraShouldWear) == 0x18);
}


===============================================
File: include/RE/E/ExtraSoul.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/S/SoulLevels.h"

namespace RE
{
	class ExtraSoul : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSoul;
		inline static constexpr auto VTABLE = VTABLE_ExtraSoul;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSoul;

		ExtraSoul();
		explicit ExtraSoul(SOUL_LEVEL a_level);
		~ExtraSoul() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { reutrn kSoul; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return soul != a_rhs->soul; }

		[[nodiscard]] SOUL_LEVEL GetContainedSoul() const;

		// members
		stl::enumeration<SOUL_LEVEL, std::uint8_t> soul;   // 10
		std::uint8_t                               pad11;  // 11
		std::uint16_t                              pad12;  // 12
		std::uint32_t                              pad14;  // 14
	};
	static_assert(sizeof(ExtraSoul) == 0x18);
}


===============================================
File: include/RE/E/ExtraSound.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraSound : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSound;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSound;

		~ExtraSound() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kSound; }

		// members
		BSSoundHandle handle;  // 10
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(ExtraSound) == 0x20);
}


===============================================
File: include/RE/E/ExtraSpawnContainer.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraSpawnContainer : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraSpawnContainer;
		inline static auto           EXTRADATATYPE = ExtraDataType::kSpawnContainer;

		~ExtraSpawnContainer() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kSpawnContainer; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return container != a_rhs->container; }

		// members
		ObjectRefHandle container;  // 10
		std::uint32_t   pad14;      // 14
	};
	static_assert(sizeof(ExtraSpawnContainer) == 0x18);
}


===============================================
File: include/RE/E/ExtraStartingPosition.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class BGSLocation;

	struct FILE_POS_ROT
	{
		NiPoint3 pos;  // 00
		NiPoint3 rot;  // 0C
	};
	static_assert(sizeof(FILE_POS_ROT) == 0x18);

	class ExtraStartingPosition : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraStartingPosition;
		inline static auto           EXTRADATATYPE = ExtraDataType::kStartingPosition;

		~ExtraStartingPosition() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kStartingPosition; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return location != a_rhs->location || startPosition.pos != a_rhs->startPosition.pos || startPosition.rot != a_rhs->startPosition.rot; }

		// members
		FILE_POS_ROT startPosition;  // 10
		BGSLocation* location;       // 28
	};
	static_assert(sizeof(ExtraStartingPosition) == 0x30);
}


===============================================
File: include/RE/E/ExtraStartingWorldOrCell.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESForm;

	class ExtraStartingWorldOrCell : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraStartingWorldOrCell;
		inline static auto           EXTRADATATYPE = ExtraDataType::kStartingWorldOrCell;

		~ExtraStartingWorldOrCell() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kStartingWorldOrCell; }

		// members
		TESForm* startingWorldOrCell;  // 10
	};
	static_assert(sizeof(ExtraStartingWorldOrCell) == 0x18);
}


===============================================
File: include/RE/E/ExtraTeleport.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	struct DoorTeleportData
	{
		ObjectRefHandle linkedDoor;  // 00
		NiPoint3        position;    // 04
		NiPoint3        rotation;    // 10
		std::int8_t     flags;       // 1C
		std::uint8_t    pad1D;       // 1D
		std::uint16_t   pad1E;       // 1E
	};
	static_assert(sizeof(DoorTeleportData) == 0x20);

	class ExtraTeleport : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraTeleport;
		inline static auto           EXTRADATATYPE = ExtraDataType::kTeleport;

		~ExtraTeleport() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kTeleport; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		DoorTeleportData* teleportData;  // 10
	};
	static_assert(sizeof(ExtraTeleport) == 0x18);
}


===============================================
File: include/RE/E/ExtraTeleportName.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSMessage;

	class ExtraTeleportName : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraTeleportName;
		inline static auto           EXTRADATATYPE = ExtraDataType::kTeleportName;

		~ExtraTeleportName() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kTeleportName; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return message != a_rhs->message; }

		// members
		BGSMessage* message;  // 10
	};
	static_assert(sizeof(ExtraTeleportName) == 0x18);
}


===============================================
File: include/RE/E/ExtraTerminalState.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraTerminalState : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraTerminalState;
		inline static auto           EXTRADATATYPE = ExtraDataType::kTerminalState;

		~ExtraTerminalState() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kTerminalState; }

		// members
		std::uint64_t unk10;  // 10
	};
	static_assert(sizeof(ExtraTerminalState) == 0x18);
}


===============================================
File: include/RE/E/ExtraTextDisplayData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSFixedString.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class BGSMessage;
	class TESBoundObject;
	class TESQuest;

	class ExtraTextDisplayData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraTextDisplayData;
		inline static constexpr auto VTABLE = VTABLE_ExtraTextDisplayData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kTextDisplayData;

		enum class DisplayDataType
		{
			kUninitialized = -1,
			kCustomName = -2
		};

		ExtraTextDisplayData();
		explicit ExtraTextDisplayData(const char* a_name);
		ExtraTextDisplayData(TESBoundObject* a_form, float a_temperFactor);
		~ExtraTextDisplayData() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kTextDisplayData; }

		const char* GetDisplayName(TESBoundObject* a_form, float a_temperFactor);
		bool        IsPlayerSet() const;
		void        SetName(const char* a_name);

		// members
		BSFixedString                                   displayName;       // 10
		BGSMessage*                                     displayNameText;   // 18
		TESQuest*                                       ownerQuest;        // 20
		stl::enumeration<DisplayDataType, std::int32_t> ownerInstance;     // 28
		float                                           temperFactor;      // 2C
		std::uint16_t                                   customNameLength;  // 30 - length w/o temper string, only valid if ownerInstance is kCustomName
		std::uint16_t                                   pad32;             // 32
		std::uint32_t                                   pad34;             // 34
	};
	static_assert(sizeof(ExtraTextDisplayData) == 0x38);
}


===============================================
File: include/RE/E/ExtraTimeLeft.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraTimeLeft : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraTimeLeft;
		inline static auto           EXTRADATATYPE = ExtraDataType::kTimeLeft;

		~ExtraTimeLeft() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kTimeLeft; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return time != a_rhs->time; }

		// members
		float         time;   // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(ExtraTimeLeft) == 0x18);
}


===============================================
File: include/RE/E/ExtraTresPassPackage.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TrespassPackage;

	class ExtraTresPassPackage : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraTresPassPackage;
		inline static auto           EXTRADATATYPE = ExtraDataType::kTresPassPackage;

		~ExtraTresPassPackage() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kTresPassPackage; }

		// members
		TrespassPackage* pack;   // 10
		std::uint64_t    unk18;  // 18
	};
	static_assert(sizeof(ExtraTresPassPackage) == 0x20);
}


===============================================
File: include/RE/E/ExtraUniqueID.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraUniqueID : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraUniqueID;
		inline static constexpr auto VTABLE = VTABLE_ExtraUniqueID;
		inline static auto           EXTRADATATYPE = ExtraDataType::kUniqueID;

		ExtraUniqueID();
		ExtraUniqueID(FormID a_baseID, std::uint16_t a_uniqueID);
		~ExtraUniqueID() override = default;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kUniqueID; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return uniqueID != a_rhs->uniqueID || baseID != a_rhs->baseID; }

		// members
		FormID        baseID;    // 10
		std::uint16_t uniqueID;  // 14
		std::uint16_t pad16;     // 16
	};
	static_assert(sizeof(ExtraUniqueID) == 0x18);
}


===============================================
File: include/RE/E/ExtraUsedMarkers.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTArray.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/M/MarkerUsedData.h"

namespace RE
{
	class ExtraUsedMarkers : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraUsedMarkers;
		inline static auto           EXTRADATATYPE = ExtraDataType::kUsedMarkers;

		~ExtraUsedMarkers() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kUsedMarkers; }

		// members
		BSTArray<MarkerUsedData> usedMarkers;  // 10
	};
	static_assert(sizeof(ExtraUsedMarkers) == 0x28);
}


===============================================
File: include/RE/E/ExtraWaterCurrentZoneData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTHashMap.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	namespace BSCurrent
	{
		struct Action;
	}

	class TESObjectCELL;

	class ExtraWaterCurrentZoneData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraWaterCurrentZoneData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kWaterCurrentZoneData;

		~ExtraWaterCurrentZoneData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kWaterCurrentZoneData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		BSTHashMap<ObjectRefHandle, BSCurrent::Action*> referenceToActionMap;  // 10
		BSCurrent::Action*                              cellAction;            // 40
		TESObjectCELL*                                  affectedCell;          // 48
		NiPoint3                                        angularVelocity;       // 50
		NiPoint3                                        linearVelocity;        // 5C
	};
	static_assert(sizeof(ExtraWaterCurrentZoneData) == 0x68);
}


===============================================
File: include/RE/E/ExtraWaterData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/H/hkRefPtr.h"

namespace RE
{
	namespace BSCurrent
	{
		struct ActionArray
		{
			__m128*       buffer;         // 00
			std::uint32_t bufferSize;     // 08
			std::uint32_t effectiveSize;  // 0C
			std::uint32_t count;          // 10
			std::uint32_t pad14;          // 14
		};
		static_assert(sizeof(ActionArray) == 0x18);
	}

	class hkReferencedObject;

	class ExtraWaterData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraWaterData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kWaterData;

		~ExtraWaterData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kWaterData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		std::uint64_t                unk10;         // 10
		hkRefPtr<hkReferencedObject> unk18;         // 18
		BSCurrent::ActionArray*      currentArray;  // 20
	};
	static_assert(sizeof(ExtraWaterData) == 0x28);
}


===============================================
File: include/RE/E/ExtraWaterLightRefs.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class TESObjectREFR;

	class ExtraWaterLightRefs : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraWaterLightRefs;
		inline static auto           EXTRADATATYPE = ExtraDataType::kWaterLightRefs;

		~ExtraWaterLightRefs() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { return kWaterLightRefs; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02 - { return refs != a_rhs->refs; }

		// members
		BSSimpleList<TESObjectREFR*> refs;  // 10
	};
	static_assert(sizeof(ExtraWaterLightRefs) == 0x20);
}


===============================================
File: include/RE/E/ExtraWeaponAttackSound.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraWeaponAttackSound : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraWeaponAttackSound;
		inline static auto           EXTRADATATYPE = ExtraDataType::kWeaponAttackSound;

		~ExtraWeaponAttackSound() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kWeaponAttackSound; }

		// members
		BSSoundHandle handle;  // 10
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(ExtraWeaponAttackSound) == 0x20);
}


===============================================
File: include/RE/E/ExtraWeaponIdleSound.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraWeaponIdleSound : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraWeaponIdleSound;
		inline static auto           EXTRADATATYPE = ExtraDataType::kWeaponIdleSound;

		~ExtraWeaponIdleSound() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kWeaponIdleSound; }

		// members
		BSSoundHandle handle;  // 10
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(ExtraWeaponIdleSound) == 0x20);
}


===============================================
File: include/RE/E/ExtraWorn.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraWorn : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraWorn;
		inline static auto           EXTRADATATYPE = ExtraDataType::kWorn;

		~ExtraWorn() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kWorn; }
	};
	static_assert(sizeof(ExtraWorn) == 0x10);
}


===============================================
File: include/RE/E/ExtraWornLeft.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	class ExtraWornLeft : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_ExtraWornLeft;
		inline static auto           EXTRADATATYPE = ExtraDataType::kWornLeft;

		~ExtraWornLeft() override;  // 00

		// override (BSExtraData)
		[[nodiscard]] ExtraDataType GetType() const override;  // 01 - { return kWorn; }
	};
	static_assert(sizeof(ExtraWornLeft) == 0x10);
}


===============================================
File: include/RE/F/FOCollisionListener.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/bhkBackfaceContactListener.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class ActorCause;
	class bhkRigidBody;
	class TESObjectREFR;

	class FOCollisionListener :
		public bhkBackfaceContactListener,           // 00
		public BSTSingletonSDM<FOCollisionListener>  // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_FOCollisionListener;
		inline static constexpr auto VTABLE = VTABLE_FOCollisionListener;

		struct ObjectDamageImpactData
		{
		public:
			// members
			NiPointer<bhkRigidBody> body;        // 00
			float                   damage;      // 04
			std::uint32_t           pad08;       // 08
			NiPointer<ActorCause>   actorCause;  // 10
		};
		static_assert(sizeof(ObjectDamageImpactData) == 0x18);

		// override (bhkBackfaceContactListener)
		void ContactPointCallback(const hkpContactPointEvent&) override;  // 00

		~FOCollisionListener() override;  // 00

		static FOCollisionListener* GetSingleton()
		{
			REL::Relocation<FOCollisionListener**> singleton{ RELOCATION_ID(514284, 400444) };
			return *singleton;
		}

		// members
		BSTArray<ObjectDamageImpactData> damageImpacts;  // 10
	};
	static_assert(sizeof(FOCollisionListener) == 0x28);
}


===============================================
File: include/RE/F/FORM.h
===============================================
#pragma once

namespace RE
{
	struct FORM
	{
	public:
		// members
		std::uint32_t form;            // 00
		std::uint32_t length;          // 04
		std::uint32_t flags;           // 08
		FormID        formID;          // 0C
		std::uint32_t versionControl;  // 10
		std::uint16_t formVersion;     // 14
		std::uint16_t vcVersion;       // 16
	};
	static_assert(sizeof(FORM) == 0x18);

	struct FORM_GROUP
	{
	public:
		// members
		FORM          groupData;    // 00
		std::uint64_t groupOffset;  // 18
	};
	static_assert(sizeof(FORM_GROUP) == 0x20);
}


===============================================
File: include/RE/F/FORM_ENUM_STRING.h
===============================================
#pragma once

namespace RE
{
	enum class FormType;

	struct FORM_ENUM_STRING
	{
	public:
		[[nodiscard]] static std::span<FORM_ENUM_STRING, 138> GetFormEnumString()
		{
			REL::Relocation<FORM_ENUM_STRING(*)[138]> formEnumString{ RELOCATION_ID(501008, 359120) };
			return { *formEnumString };
		}

		// members
		FormType      formType;    // 00
		const char*   formString;  // 08
		std::uint32_t formCode;    // 10
	};
	static_assert(sizeof(FORM_ENUM_STRING) == 0x18);
}


===============================================
File: include/RE/F/FactionRank.h
===============================================
#pragma once

namespace RE
{
	class TESFaction;

	struct FACTION_RANK  // SNAM
	{
	public:
		// members
		TESFaction*   faction;     // 00
		std::int8_t   rank;        // 08
		std::uint8_t  pad09{ 0 };  // 09
		std::uint16_t pad0A{ 0 };  // 0A
		std::uint32_t pad0C{ 0 };  // 0C
	};
	static_assert(sizeof(FACTION_RANK) == 0x10);
}


===============================================
File: include/RE/F/FaderMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 3
	// flags = kAlwaysOpen | kAllowSaving | kCustomRendering
	// context = kNone
	class FaderMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_FaderMenu;
		constexpr static std::string_view MENU_NAME = "Fader Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                  \
	void*         unk30; /* 00 - smart ptr */ \
	std::uint8_t  unk38; /* 08 */             \
	std::uint8_t  unk39; /* 09 */             \
	std::uint16_t pad3A; /* 0A */             \
	std::uint32_t pad3C; /* 0C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x10);

		~FaderMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30 - smart ptr
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(FaderMenu) == 0x40);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(FaderMenu) == 0x50);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/F/FastTravelConfirmCallback.h
===============================================
#pragma once

#include "RE/I/IMessageBoxCallback.h"

namespace RE
{
	class MapMenu;

	class FastTravelConfirmCallback : public IMessageBoxCallback
	{
	public:
		inline static constexpr auto RTTI = RTTI___FastTravelConfirmCallback;
		inline static constexpr auto VTABLE = VTABLE___FastTravelConfirmCallback;

		~FastTravelConfirmCallback() override;  // 00

		// override (IMessageBoxCallback)
		void Run(Message a_msg) override;  //01

		// members
		MapMenu*     mapMenu;     // 10
		std::int32_t cursorPosX;  // 18
		std::int32_t cursorPosY;  // 1C
	};
	static_assert(sizeof(FastTravelConfirmCallback) == 0x20);
}


===============================================
File: include/RE/F/FavoritesHandler.h
===============================================
#pragma once

#include "RE/M/MenuEventHandler.h"

namespace RE
{
	struct FavoritesHandler : public MenuEventHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_FavoritesHandler;

		~FavoritesHandler() override;  // 00

		// override
		bool CanProcess(InputEvent* a_event) override;      // 01
		bool ProcessKinect(KinectEvent* a_event) override;  // 02
		bool ProcessButton(ButtonEvent* a_event) override;  // 05
	};
	static_assert(sizeof(FavoritesHandler) == 0x10);
}


===============================================
File: include/RE/F/FavoritesMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"
#include "RE/M/MenuEventHandler.h"

namespace RE
{
	class InventoryEntryData;
	class TESForm;

	// menuDepth = 3
	// flags = kPausesGame | kUpdateUsesCursor | kInventoryItemMenu | kCustomRendering
	// context = kFavorites
	class FavoritesMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,            // 00
		public MenuEventHandler  // 30
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_FavoritesMenu;
		constexpr static std::string_view MENU_NAME = "FavoritesMenu";

		struct Entry
		{
			TESForm*            item;       // 00
			InventoryEntryData* entryData;  // 08
		};
		static_assert(sizeof(Entry) == 0x10);

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                              \
	GFxValue        root;            /* 00 - "Menu_mc" */ \
	BSTArray<Entry> favorites;       /* 18 */             \
	std::uint16_t   unk70;           /* 30 */             \
	bool            pcControlsReady; /* 32 */             \
	bool            isVampire;       /* 33 */             \
	std::uint32_t   pad74;           /* 34 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x38);

		~FavoritesMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

		// override (MenuEventHandler)
#ifndef SKYRIM_CROSS_VR
		bool CanProcess(InputEvent* a_event) override;      // 01
		bool ProcessKinect(KinectEvent* a_event) override;  // 02
		bool ProcessButton(ButtonEvent* a_event) override;  // 05
#endif

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<FavoritesMenu*>(this)->AsMenuEventHandler();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x50);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x50);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 40, 50
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(FavoritesMenu) == 0x78);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(FavoritesMenu) == 0x88);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/F/FightReactions.h
===============================================
#pragma once

namespace RE
{
	enum class FIGHT_REACTION
	{
		kNeutral = 0,
		kEnemy = 1,
		kAlly = 2,
		kFriend = 3
	};
}


===============================================
File: include/RE/F/FileID.h
===============================================
#pragma once

namespace RE
{
	namespace BSResource
	{
		struct FileID
		{
		public:
			// members
			std::uint32_t file;    // 0
			char          ext[4];  // 0
		};
		static_assert(sizeof(FileID) == 0x8);
	}
}


===============================================
File: include/RE/F/FirstPersonState.h
===============================================
#pragma once

#include "RE/N/NiPoint3.h"
#include "RE/P/PlayerInputHandler.h"
#include "RE/T/TESCameraState.h"

namespace RE
{
	class NiNode;

	class FirstPersonState :
		public TESCameraState,     // 00
		public PlayerInputHandler  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_FirstPersonState;
		inline static constexpr auto VTABLE = VTABLE_FirstPersonState;

		~FirstPersonState() override;  // 00

		// override (TESCameraState)
		void Begin() override;                                               // 01
		void End() override;                                                 // 02
		void Update(BSTSmartPointer<TESCameraState>& a_nextState) override;  // 03
		void GetRotation(NiQuaternion& a_rotation) override;                 // 04
		void GetTranslation(NiPoint3& a_translation) override;               // 05
		void SaveGame(BGSSaveFormBuffer* a_buf) override;                    // 06
		void LoadGame(BGSLoadFormBuffer* a_buf) override;                    // 07
		void Revert(BGSLoadFormBuffer* a_buf) override;                      // 08

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                          // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_movementData) override;  // 04

		// members
		NiPoint3      lastPosition;             // 30
		NiPoint3      lastFrameSpringVelocity;  // 3C
		NiPoint3      dampeningOffset;          // 48
		std::uint32_t pad54;                    // 54
		NiAVObject*   firstPersonCameraObj;     // 58
		NiNode*       firstPersonFOVControl;    // 60
		float         sittingRotation;          // 68
		float         unk6C;                    // 6C
		float         unk70;                    // 70
		float         currentPitchOffset;       // 74 - [-100, 100]
		float         targetPitchOffset;        // 78 - [-100, 100]
		float         unk7C;                    // 7C
		std::uint32_t unk80;                    // 80
		bool          cameraOverride;           // 84
		bool          cameraPitchOverride;      // 85
		std::uint16_t unk86;                    // 86
		std::uint64_t unk88;                    // 88
	};
	static_assert(sizeof(FirstPersonState) == 0x90);
}


===============================================
File: include/RE/F/FixedStrings.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	class FixedStrings
	{
	public:
		static FixedStrings* GetSingleton()
		{
			using func_t = decltype(&FixedStrings::GetSingleton);
			REL::Relocation<func_t> func{ RELOCATION_ID(11308, 11437) };
			return func();
		}

		// members
		BSFixedString npcRoot;                               // 0x000 - "NPCRoot[Root]"
		BSFixedString npc;                                   // 0x008 - "NPC"
		BSFixedString npcHead;                               // 0x010 - "NPCHead[Head]"
		BSFixedString npcPelvis_Pelv;                        // 0x018 - "NPCPelvis[Pelv]"
		BSFixedString npcSpine;                              // 0x020 - "NPCSpine[Spn0]"
		BSFixedString npcSpine1;                             // 0x028 - "NPCSpine1[Spn1]"
		BSFixedString npcSpine2;                             // 0x030 - "NPCSpine2[Spn2]"
		BSFixedString npcLFoot;                              // 0x038 - "NPCLFoot[Lft]"
		BSFixedString npcRFoot;                              // 0x040 - "NPCRFoot[Rft]"
		BSFixedString npcLCalf;                              // 0x048 - "NPCLCalf[LClf]"
		BSFixedString npcRCalf;                              // 0x050 - "NPCRCalf[RClf]"
		BSFixedString specialIdle_Cast;                      // 0x058 - "SpecialIdle_Cast"
		BSFixedString specialIdle_AreaEffect;                // 0x060 - "SpecialIdle_AreaEffect"
		BSFixedString attachSound;                           // 0x068 - "AttachSound"
		BSFixedString soundMarker;                           // 0x070 - "SoundMarker"
		BSFixedString skinnedDecalNode;                      // 0x078 - "SkinnedDecalNode"
		BSFixedString decalNode;                             // 0x080 - "DecalNode"
		BSFixedString modelSwapNode;                         // 0x088 - "ModelSwapNode"
		BSFixedString open;                                  // 0x090 - "Open"
		BSFixedString close;                                 // 0x098 - "Close"
		BSFixedString dvpg;                                  // 0x0A0 - "DVPG"
		BSFixedString prn;                                   // 0x0A8 - "Prn"
		BSFixedString weapon;                                // 0x0B0 - "Weapon"
		BSFixedString weaponSword;                           // 0x0B8 - "WeaponSword"
		BSFixedString weaponDagger;                          // 0x0C0 - "WeaponDagger"
		BSFixedString weaponAxe;                             // 0x0C8 - "WeaponAxe"
		BSFixedString weaponMace;                            // 0x0D0 - "WeaponMace"
		BSFixedString shield;                                // 0x0D8 - "Shield"
		BSFixedString weaponBack;                            // 0x0E0 - "WeaponBack"
		BSFixedString weaponBow;                             // 0x0E8 - "WeaponBow"
		BSFixedString quiver;                                // 0x0F0 - "Quiver"
		BSFixedString editorMarker;                          // 0x0F8 - "EditorMarker"
		BSFixedString editorMarker0;                         // 0x100 - "EditorMarker:0"
		BSFixedString editorMarker1;                         // 0x108 - "EditorMarker:1"
		BSFixedString editorMarker2;                         // 0x110 - "EditorMarker:2"
		BSFixedString arrowQuiver;                           // 0x118 - "ArrowQuiver"
		BSFixedString markerSource;                          // 0x120 - "MarkerSource"
		BSFixedString markerTarget;                          // 0x128 - "MarkerTarget"
		BSFixedString attachLight;                           // 0x130 - "AttachLight"
		BSFixedString skin;                                  // 0x138 - "skin"
		BSFixedString faceGenEars;                           // 0x140 - "FaceGenEars"
		BSFixedString unequip;                               // 0x148 - "Unequip"
		BSFixedString laserSight;                            // 0x150 - "LaserSight"
		BSFixedString aimSight;                              // 0x158 - "AimSight"
		BSFixedString decal;                                 // 0x160 - "Decal"
		BSFixedString permanentDecal;                        // 0x168 - "PermanentDecal"
		BSFixedString grabLeft;                              // 0x170 - "grabLeft"
		BSFixedString grabRight;                             // 0x178 - "grabRight"
		BSFixedString arrow0;                                // 0x180 - "Arrow:0"
		BSFixedString arrowBone;                             // 0x188 - "ArrowBone"
		BSFixedString bsFaceGenNiNodeSkinned;                // 0x190 - "BSFaceGenNiNodeSkinned"
		BSFixedString entryPoint;                            // 0x198 - "EntryPoint"
		BSFixedString npcLUpperArm;                          // 0x1A0 - "NPCLUpperArm[LUar]"
		BSFixedString npcLForearm;                           // 0x1A8 - "NPCLForearm[LLar]"
		BSFixedString npcRUpperArm;                          // 0x1B0 - "NPCRUpperArm[RUar]"
		BSFixedString npcLookNode;                           // 0x1B8 - "NPCLookNode[Look]"
		BSFixedString npcTail1;                              // 0x1C0 - "NPCTail1"
		BSFixedString npcTailHub;                            // 0x1C8 - "NPCTailHub"
		BSFixedString npcPelvis;                             // 0x1D0 - "NPCPelvis"
		BSFixedString talking;                               // 0x1D8 - "Talking"
		BSFixedString camera1st;                             // 0x1E0 - "Camera1st[Cam1]"
		BSFixedString camera3rd;                             // 0x1E8 - "Camera3rd[Cam3]"
		BSFixedString headMeshForExport_FaceGenAndMorphs_0;  // 0x1F0 - "HeadMeshForExport_FaceGenAndMorphs:0"
		BSFixedString pinnedLimb;                            // 0x1F8 - "PinnedLimb"
		BSFixedString backpack;                              // 0x200 - "Backpack"
		BSFixedString projectileNode;                        // 0x208 - "ProjectileNode"
		BSFixedString blastRadiusNode;                       // 0x210 - "BlastRadiusNode"
		BSFixedString torchFire;                             // 0x218 - "TorchFire"
		BSFixedString lightOn;                               // 0x220 - "##LightOn"
		BSFixedString npcCOM;                                // 0x228 - "NPCCOM[COM]"
		BSFixedString skinAttachment;                        // 0x230 - "SkinAttachment"
		BSFixedString npcNeck;                               // 0x238 - "NPCNeck[Neck]"
		BSFixedString nifRound;                              // 0x240 - "##NifRound"
		BSFixedString scb;                                   // 0x248 - "Scb"
		BSFixedString upperBody;                             // 0x250 - "UpperBody"
		BSFixedString lightOff;                              // 0x258 - "##LightOff"
		BSFixedString npcHeadMagicNode;                      // 0x260 - "NPCHeadMagicNode[Hmag]"
		BSFixedString npcLMagicNode;                         // 0x268 - "NPCLMagicNode[LMag]"
		BSFixedString npcRMagicNode;                         // 0x270 - "NPCRMagicNode[RMag]"
		BSFixedString magicLeft;                             // 0x278 - "MagicLeft"
		BSFixedString magicRight;                            // 0x280 - "MagicRight"
		BSFixedString magicOther;                            // 0x288 - "MagicOther"
		BSFixedString cameraControl;                         // 0x290 - "CameraControl"
		BSFixedString npcRoot1;                              // 0x298 - "NPCRoot[Root]"
		BSFixedString saddleBone;                            // 0x2A0 - "SaddleBone"
		BSFixedString perchFireNode;                         // 0x2A8 - "PerchFireNode"
		BSFixedString graphDeleting;                         // 0x2B0 - "GraphDeleting"
		BSFixedString isBlocking;                            // 0x2B8 - "IsBlocking"
		BSFixedString isShouting;                            // 0x2C0 - "IsShouting"
		BSFixedString isPlayer;                              // 0x2C8 - "IsPlayer"
		BSFixedString isnpc;                                 // 0x2D0 - "IsNPC"
		BSFixedString iIsPlayer;                             // 0x2D8 - "iIsPlayer"
		BSFixedString fScale;                                // 0x2E0 - "fScale"
		BSFixedString femaleOffset;                          // 0x2E8 - "FemaleOffset"
		BSFixedString isFirstPerson;                         // 0x2F0 - "IsFirstPerson"
		BSFixedString i1stPerson;                            // 0x2F8 - "i1stPerson"
		BSFixedString fIsFirstPerson;                        // 0x300 - "fIsFirstPerson"
		BSFixedString bHumanoidFootIKEnable;                 // 0x308 - "bHumanoidFootIKEnable"
		BSFixedString iSyncIdleLocomotion;                   // 0x310 - "iSyncIdleLocomotion"
		BSFixedString iSyncTurnState;                        // 0x318 - "iSyncTurnState"
		BSFixedString isAttackReady;                         // 0x320 - "IsAttackReady"
		BSFixedString bVoiceReady;                           // 0x328 - "bVoiceReady"
		BSFixedString bMLh_Ready;                            // 0x330 - "bMLh_Ready"
		BSFixedString bMRh_Ready;                            // 0x338 - "bMRh_Ready"
		BSFixedString bEquipOK;                              // 0x340 - "bEquipOk"
		BSFixedString hitFrame;                              // 0x348 - "HitFrame"
		BSFixedString isSprinting;                           // 0x350 - "IsSprinting"
		BSFixedString iSyncSprintState;                      // 0x358 - "iSyncSprintState"
		BSFixedString weapAdj;                               // 0x360 - "weapAdj"
		BSFixedString weaponSpeedMult;                       // 0x368 - "weaponSpeedMult"
		BSFixedString leftWeaponSpeedMult;                   // 0x370 - "leftWeaponSpeedMult"
		BSFixedString bowZoom;                               // 0x378 - "BowZoom"
		BSFixedString bBowZoomed;                            // 0x380 - "bBowZoomed"
		BSFixedString iLeftHandType;                         // 0x388 - "iLeftHandType"
		BSFixedString iRightHandType;                        // 0x390 - "iRightHandType"
		BSFixedString iLeftHandEquipped;                     // 0x398 - "iLeftHandEquipped"
		BSFixedString iRightHandEquipped;                    // 0x3A0 - "iRightHandEquipped"
		BSFixedString bLeftHand;                             // 0x3A8 - "bLeftHand"
		BSFixedString bRightHand;                            // 0x3B0 - "bRightHand"
		BSFixedString fIdleTimer;                            // 0x3B8 - "fIdleTimer"
		BSFixedString injured;                               // 0x3C0 - "Injured"
		BSFixedString land;                                  // 0x3C8 - "Land"
		BSFixedString bCrashLand;                            // 0x3D0 - "bCrashLand"
		BSFixedString landTypeIndex;                         // 0x3D8 - "LandTypeIndex"
		BSFixedString actorResponse;                         // 0x3E0 - "ActorResponse"
		BSFixedString playerCharacterResponse;               // 0x3E8 - "PlayerCharacterResponse"
		BSFixedString tailPitchCurrent;                      // 0x3F0 - "TailPitchCurrent"
		BSFixedString tailPitchMax;                          // 0x3F8 - "TailPitchMax"
		BSFixedString tailYawCurrent;                        // 0x400 - "TailYawCurrent"
		BSFixedString tailYawMax;                            // 0x408 - "TailYawMax"
		BSFixedString lookAtHeadingMaxAngle;                 // 0x410 - "LookAtHeadingMaxAngle"
		BSFixedString english;                               // 0x418 - "English"
		BSFixedString russian;                               // 0x420 - "Russian"
		BSFixedString polish;                                // 0x428 - "Polish"
		BSFixedString mLh_SpellFire_Event;                   // 0x430 - "MLh_SpellFire_Event"
		BSFixedString mRh_SpellFire_Event;                   // 0x438 - "MRh_SpellFire_Event"
		BSFixedString voice_SpellFire_Event;                 // 0x440 - "Voice_SpellFire_Event"
		BSFixedString arrowRelease;                          // 0x448 - "arrowRelease"
		BSFixedString endAnim;                               // 0x450 - "EndAnim"
		BSFixedString stopEffect;                            // 0x458 - "StopEffect"
		BSFixedString tweenEntryDirection;                   // 0x460 - "TweenEntryDirection"
		BSFixedString tweenPosition;                         // 0x468 - "TweenPosition"
		BSFixedString tweenRotation;                         // 0x470 - "TweenRotation"
		BSFixedString hasTweenSpeed;                         // 0x478 - "HasTweenSpeed"
		BSFixedString tweenSpeed;                            // 0x480 - "TweenSpeed"
		BSFixedString bTweenUpdate;                          // 0x488 - "bTweenUpdate"
		BSFixedString targetLocation;                        // 0x490 - "TargetLocation"
		BSFixedString movementDirection;                     // 0x498 - "MovementDirection"
		BSFixedString fCastStrength;                         // 0x4A0 - "fCastStrength"
		BSFixedString staggerMagnitude;                      // 0x4A8 - "staggerMagnitude"
		BSFixedString staggerDirection;                      // 0x4B0 - "staggerDirection"
		BSFixedString isBusy;                                // 0x4B8 - "IsBusy"
		BSFixedString imod;                                  // 0x4C0 - "Imod"
		BSFixedString rimod;                                 // 0x4C8 - "Rimod"
		BSFixedString distToGoal;                            // 0x4D0 - "DistToGoal"
		BSFixedString preHitFrame;                           // 0x4D8 - "preHitFrame"
		BSFixedString weaponSwing;                           // 0x4E0 - "weaponSwing"
		BSFixedString weaponLeftSwing;                       // 0x4E8 - "weaponLeftSwing"
		BSFixedString attackWinStart;                        // 0x4F0 - "AttackWinStart"
		BSFixedString attackWinEnd;                          // 0x4F8 - "AttackWinEnd"
		BSFixedString velocityZ;                             // 0x500 - "VelocityZ"
		BSFixedString speed;                                 // 0x508 - "Speed"
		BSFixedString turnDelta;                             // 0x510 - "TurnDelta"
		BSFixedString direction;                             // 0x518 - "Direction"
		BSFixedString speedSampled;                          // 0x520 - "SpeedSampled"
		BSFixedString horseSpeedSampled;                     // 0x528 - "HorseSpeedSampled"
		BSFixedString lookAtOutOfRange;                      // 0x530 - "LookAtOutOfRange"
		BSFixedString aimHeadingMax;                         // 0x538 - "AimHeadingMax"
		BSFixedString aimPitchMax;                           // 0x540 - "AimPitchMax"
		BSFixedString aimHeadingCurrent;                     // 0x548 - "AimHeadingCurrent"
		BSFixedString aimPitchCurrent;                       // 0x550 - "AimPitchCurrent"
		BSFixedString iSyncForwardState;                     // 0x558 - "iSyncForwardState"
		BSFixedString iSyncStrafeState;                      // 0x560 - "iSyncStrafeState"
		BSFixedString bAnimationDriven;                      // 0x568 - "bAnimationDriven"
		BSFixedString bAllowRotation;                        // 0x570 - "bAllowRotation"
		BSFixedString bIsSynced;                             // 0x578 - "bIsSynced"
		BSFixedString bSpeedSynced;                          // 0x580 - "bSpeedSynced"
		BSFixedString bDisableInterp;                        // 0x588 - "bDisableInterp"
		BSFixedString iGetUpType;                            // 0x590 - "iGetUpType"
		BSFixedString objectActivated;                       // 0x598 - "ObjectActivated"
		BSFixedString fFlameProjectileLength;                // 0x5A0 - "fFlameProjectileLength"
		BSFixedString pairedKillTarget;                      // 0x5A8 - "PairedKillTarget"
		BSFixedString bAimActive;                            // 0x5B0 - "bAimActive"
		BSFixedString turnDynamic;                           // 0x5B8 - "TurnDynamic"
		BSFixedString bForceIdleStop;                        // 0x5C0 - "bForceIdleStop"
		BSFixedString constraintOffset;                      // 0x5C8 - "ConstraintOffset"
		BSFixedString left;                                  // 0x5D0 - "Left"
		BSFixedString pickup;                                // 0x5D8 - "PickUp"
		BSFixedString pathTweenerStart;                      // 0x5E0 - "PathTweenerStart"
		BSFixedString pathTweenerEnd;                        // 0x5E8 - "PathTweenerEnd"
	};
	static_assert(sizeof(FixedStrings) == 0x5F0);
}


===============================================
File: include/RE/F/FlameProjectile.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/P/Projectile.h"

namespace RE
{
	class FlameProjectile : public Projectile
	{
	public:
		inline static constexpr auto RTTI = RTTI_FlameProjectile;
		inline static constexpr auto VTABLE = VTABLE_FlameProjectile;
		inline static constexpr auto FORMTYPE = FormType::ProjectileFlame;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~FlameProjectile() override;  // 00

		// override (Projectile)
		void SaveGame(BGSSaveFormBuffer* a_buf) override;        // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;        // 0F
		void InitLoadGame(BGSLoadFormBuffer* a_buf) override;    // 10
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 11
		void Revert(BGSLoadFormBuffer* a_buf) override;          // 12
#ifndef SKYRIM_CROSS_VR
		bool IsFlameProjectile() override;               // A4 - { return 1; }
		void Process3D() override;               // A9
		void UpdateImpl(float a_delta) override;  // AB
		bool RunTargetPick() override;               // B7
		void AddImpact(TESObjectREFR* a_ref, const NiPoint3& a_targetLoc, const NiPoint3& a_velocity, hkpCollidable* a_collidable, std::int32_t a_arg6, std::uint32_t a_arg7) override;               // BD
		void Handle3DLoaded() override;           // C0 - { flags = flags & 0xFFFFFFCC | 8; }
		bool ShouldUseDesiredTarget() override;               // C1
#endif

		struct FLAME_RUNTIME_DATA
		{
#define FLAME_RUNTIME_DATA_CONTENT \
			float expirationTimer;  /* 1D8 */ \
			float coneAngle;        /* 1DC */

			FLAME_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline FLAME_RUNTIME_DATA& GetFlameRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<FLAME_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		[[nodiscard]] inline const FLAME_RUNTIME_DATA& GetFlameRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<FLAME_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		FLAME_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(FlameProjectile) == 0x1E0);
#endif
}
#undef FLAME_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/F/FormTraits.h
===============================================
#pragma once

#include "RE/A/Actor.h"
#include "RE/A/ActorValueInfo.h"
#include "RE/A/AlchemyItem.h"
#include "RE/A/ArrowProjectile.h"
#include "RE/B/BGSAcousticSpace.h"
#include "RE/B/BGSAction.h"
#include "RE/B/BGSAddonNode.h"
#include "RE/B/BGSApparatus.h"
#include "RE/B/BGSArtObject.h"
#include "RE/B/BGSAssociationType.h"
#include "RE/B/BGSBodyPartData.h"
#include "RE/B/BGSCameraPath.h"
#include "RE/B/BGSCameraShot.h"
#include "RE/B/BGSCollisionLayer.h"
#include "RE/B/BGSColorForm.h"
#include "RE/B/BGSConstructibleObject.h"
#include "RE/B/BGSDebris.h"
#include "RE/B/BGSDefaultObjectManager.h"
#include "RE/B/BGSDialogueBranch.h"
#include "RE/B/BGSDualCastData.h"
#include "RE/B/BGSEncounterZone.h"
#include "RE/B/BGSEquipSlot.h"
#include "RE/B/BGSExplosion.h"
#include "RE/B/BGSFootstep.h"
#include "RE/B/BGSFootstepSet.h"
#include "RE/B/BGSHazard.h"
#include "RE/B/BGSHeadPart.h"
#include "RE/B/BGSIdleMarker.h"
#include "RE/B/BGSImpactData.h"
#include "RE/B/BGSImpactDataSet.h"
#include "RE/B/BGSKeyword.h"
#include "RE/B/BGSLensFlare.h"
#include "RE/B/BGSLightingTemplate.h"
#include "RE/B/BGSListForm.h"
#include "RE/B/BGSLocation.h"
#include "RE/B/BGSLocationRefType.h"
#include "RE/B/BGSMaterialObject.h"
#include "RE/B/BGSMaterialType.h"
#include "RE/B/BGSMenuIcon.h"
#include "RE/B/BGSMessage.h"
#include "RE/B/BGSMovableStatic.h"
#include "RE/B/BGSMovementType.h"
#include "RE/B/BGSMusicTrackFormWrapper.h"
#include "RE/B/BGSMusicType.h"
#include "RE/B/BGSNote.h"
#include "RE/B/BGSOutfit.h"
#include "RE/B/BGSPerk.h"
#include "RE/B/BGSProjectile.h"
#include "RE/B/BGSRagdoll.h"
#include "RE/B/BGSReferenceEffect.h"
#include "RE/B/BGSRelationship.h"
#include "RE/B/BGSReverbParameters.h"
#include "RE/B/BGSScene.h"
#include "RE/B/BGSShaderParticleGeometryData.h"
#include "RE/B/BGSSoundCategory.h"
#include "RE/B/BGSSoundDescriptorForm.h"
#include "RE/B/BGSSoundOutput.h"
#include "RE/B/BGSStaticCollection.h"
#include "RE/B/BGSStoryManagerBranchNode.h"
#include "RE/B/BGSStoryManagerEventNode.h"
#include "RE/B/BGSStoryManagerQuestNode.h"
#include "RE/B/BGSTalkingActivator.h"
#include "RE/B/BGSTextureSet.h"
#include "RE/B/BGSVoiceType.h"
#include "RE/B/BGSVolumetricLighting.h"
#include "RE/B/BarrierProjectile.h"
#include "RE/B/BeamProjectile.h"
#include "RE/C/Character.h"
#include "RE/C/ConeProjectile.h"
#include "RE/E/EffectSetting.h"
#include "RE/E/EnchantmentItem.h"
#include "RE/F/FlameProjectile.h"
#include "RE/G/GrenadeProjectile.h"
#include "RE/H/Hazard.h"
#include "RE/I/IngredientItem.h"
#include "RE/M/MissileProjectile.h"
#include "RE/N/NavMesh.h"
#include "RE/N/NavMeshInfoMap.h"
#include "RE/P/PlayerCharacter.h"
#include "RE/S/Script.h"
#include "RE/S/ScrollItem.h"
#include "RE/S/SpellItem.h"
#include "RE/T/TESAmmo.h"
#include "RE/T/TESClass.h"
#include "RE/T/TESClimate.h"
#include "RE/T/TESCombatStyle.h"
#include "RE/T/TESEffectShader.h"
#include "RE/T/TESEyes.h"
#include "RE/T/TESFaction.h"
#include "RE/T/TESFlora.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFurniture.h"
#include "RE/T/TESGlobal.h"
#include "RE/T/TESGrass.h"
#include "RE/T/TESIdleForm.h"
#include "RE/T/TESImageSpace.h"
#include "RE/T/TESImageSpaceModifier.h"
#include "RE/T/TESKey.h"
#include "RE/T/TESLandTexture.h"
#include "RE/T/TESLevCharacter.h"
#include "RE/T/TESLevItem.h"
#include "RE/T/TESLevSpell.h"
#include "RE/T/TESLoadScreen.h"
#include "RE/T/TESNPC.h"
#include "RE/T/TESObjectACTI.h"
#include "RE/T/TESObjectANIO.h"
#include "RE/T/TESObjectARMA.h"
#include "RE/T/TESObjectARMO.h"
#include "RE/T/TESObjectBOOK.h"
#include "RE/T/TESObjectCELL.h"
#include "RE/T/TESObjectCONT.h"
#include "RE/T/TESObjectDOOR.h"
#include "RE/T/TESObjectLAND.h"
#include "RE/T/TESObjectLIGH.h"
#include "RE/T/TESObjectMISC.h"
#include "RE/T/TESObjectREFR.h"
#include "RE/T/TESObjectSTAT.h"
#include "RE/T/TESObjectTREE.h"
#include "RE/T/TESObjectWEAP.h"
#include "RE/T/TESPackage.h"
#include "RE/T/TESQuest.h"
#include "RE/T/TESRace.h"
#include "RE/T/TESRegion.h"
#include "RE/T/TESShout.h"
#include "RE/T/TESSoulGem.h"
#include "RE/T/TESSound.h"
#include "RE/T/TESTopic.h"
#include "RE/T/TESTopicInfo.h"
#include "RE/T/TESWaterForm.h"
#include "RE/T/TESWeather.h"
#include "RE/T/TESWordOfPower.h"
#include "RE/T/TESWorldSpace.h"

#define SKSE_FORMTRAITS(a_elem)                                         \
	case a_elem::FORMTYPE:                                              \
		if constexpr (std::is_convertible_v<const a_elem*, const T*>) { \
			return static_cast<const a_elem*>(this);                    \
		}                                                               \
		break

namespace RE
{
	template <class T, class>
	T* TESForm::As() noexcept
	{
		return const_cast<T*>(
			static_cast<const TESForm*>(this)->As<T>());
	}

	template <class T, class>
	const T* TESForm::As() const noexcept
	{
		switch (GetFormType()) {
			SKSE_FORMTRAITS(TESForm);
			SKSE_FORMTRAITS(BGSKeyword);
			SKSE_FORMTRAITS(BGSLocationRefType);
			SKSE_FORMTRAITS(BGSAction);
			SKSE_FORMTRAITS(BGSTextureSet);
			SKSE_FORMTRAITS(BGSMenuIcon);
			SKSE_FORMTRAITS(TESGlobal);
			SKSE_FORMTRAITS(TESClass);
			SKSE_FORMTRAITS(TESFaction);
			SKSE_FORMTRAITS(BGSHeadPart);
			SKSE_FORMTRAITS(TESEyes);
			SKSE_FORMTRAITS(TESRace);
			SKSE_FORMTRAITS(TESSound);
			SKSE_FORMTRAITS(BGSAcousticSpace);
			SKSE_FORMTRAITS(EffectSetting);
			SKSE_FORMTRAITS(Script);
			SKSE_FORMTRAITS(TESLandTexture);
			SKSE_FORMTRAITS(EnchantmentItem);
			SKSE_FORMTRAITS(SpellItem);
			SKSE_FORMTRAITS(ScrollItem);
			SKSE_FORMTRAITS(TESObjectACTI);
			SKSE_FORMTRAITS(BGSTalkingActivator);
			SKSE_FORMTRAITS(TESObjectARMO);
			SKSE_FORMTRAITS(TESObjectBOOK);
			SKSE_FORMTRAITS(TESObjectCONT);
			SKSE_FORMTRAITS(TESObjectDOOR);
			SKSE_FORMTRAITS(IngredientItem);
			SKSE_FORMTRAITS(TESObjectLIGH);
			SKSE_FORMTRAITS(TESObjectMISC);
			SKSE_FORMTRAITS(BGSApparatus);
			SKSE_FORMTRAITS(TESObjectSTAT);
			SKSE_FORMTRAITS(BGSStaticCollection);
			SKSE_FORMTRAITS(BGSMovableStatic);
			SKSE_FORMTRAITS(TESGrass);
			SKSE_FORMTRAITS(TESObjectTREE);
			SKSE_FORMTRAITS(TESFlora);
			SKSE_FORMTRAITS(TESFurniture);
			SKSE_FORMTRAITS(TESObjectWEAP);
			SKSE_FORMTRAITS(TESAmmo);
			SKSE_FORMTRAITS(TESNPC);
			SKSE_FORMTRAITS(TESLevCharacter);
			SKSE_FORMTRAITS(TESKey);
			SKSE_FORMTRAITS(AlchemyItem);
			SKSE_FORMTRAITS(BGSIdleMarker);
			SKSE_FORMTRAITS(BGSNote);
			SKSE_FORMTRAITS(BGSConstructibleObject);
			SKSE_FORMTRAITS(BGSProjectile);
			SKSE_FORMTRAITS(BGSHazard);
			SKSE_FORMTRAITS(TESSoulGem);
			SKSE_FORMTRAITS(TESLevItem);
			SKSE_FORMTRAITS(TESWeather);
			SKSE_FORMTRAITS(TESClimate);
			SKSE_FORMTRAITS(BGSShaderParticleGeometryData);
			SKSE_FORMTRAITS(BGSReferenceEffect);
			SKSE_FORMTRAITS(TESRegion);
			SKSE_FORMTRAITS(NavMeshInfoMap);
			SKSE_FORMTRAITS(TESObjectCELL);
			SKSE_FORMTRAITS(TESObjectREFR);
			SKSE_FORMTRAITS(Character);
			SKSE_FORMTRAITS(MissileProjectile);
			SKSE_FORMTRAITS(ArrowProjectile);
			SKSE_FORMTRAITS(GrenadeProjectile);
			SKSE_FORMTRAITS(BeamProjectile);
			SKSE_FORMTRAITS(FlameProjectile);
			SKSE_FORMTRAITS(ConeProjectile);
			SKSE_FORMTRAITS(BarrierProjectile);
			SKSE_FORMTRAITS(Hazard);
			SKSE_FORMTRAITS(TESWorldSpace);
			SKSE_FORMTRAITS(TESObjectLAND);
			SKSE_FORMTRAITS(NavMesh);
			SKSE_FORMTRAITS(TESTopic);
			SKSE_FORMTRAITS(TESTopicInfo);
			SKSE_FORMTRAITS(TESQuest);
			SKSE_FORMTRAITS(TESIdleForm);
			SKSE_FORMTRAITS(TESPackage);
			SKSE_FORMTRAITS(TESCombatStyle);
			SKSE_FORMTRAITS(TESLoadScreen);
			SKSE_FORMTRAITS(TESLevSpell);
			SKSE_FORMTRAITS(TESObjectANIO);
			SKSE_FORMTRAITS(TESWaterForm);
			SKSE_FORMTRAITS(TESEffectShader);
			SKSE_FORMTRAITS(BGSExplosion);
			SKSE_FORMTRAITS(BGSDebris);
			SKSE_FORMTRAITS(TESImageSpace);
			SKSE_FORMTRAITS(TESImageSpaceModifier);
			SKSE_FORMTRAITS(BGSListForm);
			SKSE_FORMTRAITS(BGSPerk);
			SKSE_FORMTRAITS(BGSBodyPartData);
			SKSE_FORMTRAITS(BGSAddonNode);
			SKSE_FORMTRAITS(ActorValueInfo);
			SKSE_FORMTRAITS(BGSCameraShot);
			SKSE_FORMTRAITS(BGSCameraPath);
			SKSE_FORMTRAITS(BGSVoiceType);
			SKSE_FORMTRAITS(BGSMaterialType);
			SKSE_FORMTRAITS(BGSImpactData);
			SKSE_FORMTRAITS(BGSImpactDataSet);
			SKSE_FORMTRAITS(TESObjectARMA);
			SKSE_FORMTRAITS(BGSEncounterZone);
			SKSE_FORMTRAITS(BGSLocation);
			SKSE_FORMTRAITS(BGSMessage);
			SKSE_FORMTRAITS(BGSRagdoll);
			SKSE_FORMTRAITS(BGSDefaultObjectManager);
			SKSE_FORMTRAITS(BGSLightingTemplate);
			SKSE_FORMTRAITS(BGSMusicType);
			SKSE_FORMTRAITS(BGSFootstep);
			SKSE_FORMTRAITS(BGSFootstepSet);
			SKSE_FORMTRAITS(BGSStoryManagerBranchNode);
			SKSE_FORMTRAITS(BGSStoryManagerQuestNode);
			SKSE_FORMTRAITS(BGSStoryManagerEventNode);
			SKSE_FORMTRAITS(BGSDialogueBranch);
			SKSE_FORMTRAITS(BGSMusicTrackFormWrapper);
			SKSE_FORMTRAITS(TESWordOfPower);
			SKSE_FORMTRAITS(TESShout);
			SKSE_FORMTRAITS(BGSEquipSlot);
			SKSE_FORMTRAITS(BGSRelationship);
			SKSE_FORMTRAITS(BGSScene);
			SKSE_FORMTRAITS(BGSAssociationType);
			SKSE_FORMTRAITS(BGSOutfit);
			SKSE_FORMTRAITS(BGSArtObject);
			SKSE_FORMTRAITS(BGSMaterialObject);
			SKSE_FORMTRAITS(BGSMovementType);
			SKSE_FORMTRAITS(BGSSoundDescriptorForm);
			SKSE_FORMTRAITS(BGSDualCastData);
			SKSE_FORMTRAITS(BGSSoundCategory);
			SKSE_FORMTRAITS(BGSSoundOutput);
			SKSE_FORMTRAITS(BGSCollisionLayer);
			SKSE_FORMTRAITS(BGSColorForm);
			SKSE_FORMTRAITS(BGSReverbParameters);
			SKSE_FORMTRAITS(BGSLensFlare);
			SKSE_FORMTRAITS(BGSVolumetricLighting);
		default:
			break;
		}

		return nullptr;
	}
}

#undef SKSE_FORMTRAITS


===============================================
File: include/RE/F/FormTypes.h
===============================================
#pragma once

namespace RE
{
	class TESForm;
	class BGSKeyword;
	class BGSLocationRefType;
	class BGSAction;
	class BGSTextureSet;
	class BGSMenuIcon;
	class TESGlobal;
	class TESClass;
	class TESFaction;
	class BGSHeadPart;
	class TESEyes;
	class TESRace;
	class TESSound;
	class BGSAcousticSpace;
	class EffectSetting;
	class Script;
	class TESLandTexture;
	class EnchantmentItem;
	class SpellItem;
	class ScrollItem;
	class TESObjectACTI;
	class BGSTalkingActivator;
	class TESObjectARMO;
	class TESObjectBOOK;
	class TESObjectCONT;
	class TESObjectDOOR;
	class IngredientItem;
	class TESObjectLIGH;
	class TESObjectMISC;
	class BGSApparatus;
	class TESObjectSTAT;
	class BGSStaticCollection;
	class BGSMovableStatic;
	class TESGrass;
	class TESObjectTREE;
	class TESFlora;
	class TESFurniture;
	class TESObjectWEAP;
	class TESAmmo;
	class TESNPC;
	class TESLevCharacter;
	class TESKey;
	class AlchemyItem;
	class BGSIdleMarker;
	class BGSNote;
	class BGSConstructibleObject;
	class BGSProjectile;
	class BGSHazard;
	class TESSoulGem;
	class TESLevItem;
	class TESWeather;
	class TESClimate;
	class BGSShaderParticleGeometryData;
	class BGSReferenceEffect;
	class TESRegion;
	class NavMeshInfoMap;
	class TESObjectCELL;
	class TESObjectREFR;
	class Actor;
	class Character;
	class PlayerCharacter;
	class MissileProjectile;
	class ArrowProjectile;
	class GrenadeProjectile;
	class BeamProjectile;
	class FlameProjectile;
	class ConeProjectile;
	class BarrierProjectile;
	class Hazard;
	class TESWorldSpace;
	class TESObjectLAND;
	class NavMesh;
	class TESTopic;
	class TESTopicInfo;
	class TESQuest;
	class TESIdleForm;
	class TESPackage;
	class DialoguePackage;
	class TESCombatStyle;
	class TESLoadScreen;
	class TESLevSpell;
	class TESObjectANIO;
	class TESWaterForm;
	class TESEffectShader;
	class BGSExplosion;
	class BGSDebris;
	class TESImageSpace;
	class TESImageSpaceModifier;
	class BGSListForm;
	class BGSPerk;
	class BGSBodyPartData;
	class BGSAddonNode;
	class ActorValueInfo;
	class BGSCameraShot;
	class BGSCameraPath;
	class BGSVoiceType;
	class BGSMaterialType;
	class BGSImpactData;
	class BGSImpactDataSet;
	class TESObjectARMA;
	class BGSEncounterZone;
	class BGSLocation;
	class BGSMessage;
	class BGSRagdoll;
	class BGSDefaultObjectManager;
	class BGSLightingTemplate;
	class BGSMusicType;
	class BGSFootstep;
	class BGSFootstepSet;
	class BGSStoryManagerBranchNode;
	class BGSStoryManagerQuestNode;
	class BGSStoryManagerEventNode;
	class BGSDialogueBranch;
	class BGSMusicTrackFormWrapper;
	class TESWordOfPower;
	class TESShout;
	class BGSEquipSlot;
	class BGSRelationship;
	class BGSScene;
	class BGSAssociationType;
	class BGSOutfit;
	class BGSArtObject;
	class BGSMaterialObject;
	class BGSMovementType;
	class BGSSoundDescriptorForm;
	class BGSDualCastData;
	class BGSSoundCategory;
	class BGSSoundOutput;
	class BGSCollisionLayer;
	class BGSColorForm;
	class BGSReverbParameters;
	class BGSLensFlare;

	enum class FormType
	{
		None = 0,                    //	00 NONE TESForm
		PluginInfo,                  //	01 TES4
		FormGroup,                   //	02 GRUP
		GameSetting,                 //	03 GMST
		Keyword,                     //	04 KYWD	BGSKeyword
		LocationRefType,             //	05 LCRT	BGSLocationRefType
		Action,                      //	06 AACT	BGSAction
		TextureSet,                  //	07 TXST	BGSTextureSet
		MenuIcon,                    //	08 MICN	BGSMenuIcon
		Global,                      //	09 GLOB	TESGlobal
		Class,                       //	0A CLAS	TESClass
		Faction,                     //	0B FACT	TESFaction
		HeadPart,                    //	0C HDPT	BGSHeadPart
		Eyes,                        //	0D EYES	TESEyes
		Race,                        //	0E RACE	TESRace
		Sound,                       //	0F SOUN	TESSound
		AcousticSpace,               //	10 ASPC	BGSAcousticSpace
		Skill,                       //	11 SKIL
		MagicEffect,                 //	12 MGEF	EffectSetting
		Script,                      //	13 SCPT	Script
		LandTexture,                 //	14 LTEX	TESLandTexture
		Enchantment,                 //	15 ENCH	EnchantmentItem
		Spell,                       //	16 SPEL	SpellItem
		Scroll,                      //	17 SCRL	ScrollItem
		Activator,                   //	18 ACTI	TESObjectACTI
		TalkingActivator,            //	19 TACT	BGSTalkingActivator
		Armor,                       //	1A ARMO	TESObjectARMO
		Book,                        //	1B BOOK	TESObjectBOOK
		Container,                   //	1C CONT	TESObjectCONT
		Door,                        //	1D DOOR	TESObjectDOOR
		Ingredient,                  //	1E INGR	IngredientItem
		Light,                       //	1F LIGH	TESObjectLIGH
		Misc,                        //	20 MISC TESObjectMISC
		Apparatus,                   //	21 APPA	BGSApparatus
		Static,                      //	22 STAT	TESObjectSTAT
		StaticCollection,            //	23 SCOL BGSStaticCollection
		MovableStatic,               //	24 MSTT	BGSMovableStatic
		Grass,                       //	25 GRAS	TESGrass
		Tree,                        //	26 TREE	TESObjectTREE
		Flora,                       //	27 FLOR	TESFlora
		Furniture,                   //	28 FURN	TESFurniture
		Weapon,                      //	29 WEAP	TESObjectWEAP
		Ammo,                        //	2A AMMO	TESAmmo
		NPC,                         //	2B NPC_	TESNPC
		LeveledNPC,                  //	2C LVLN	TESLevCharacter
		KeyMaster,                   //	2D KEYM	TESKey
		AlchemyItem,                 //	2E ALCH	AlchemyItem
		IdleMarker,                  //	2F IDLM	BGSIdleMarker
		Note,                        //	30 NOTE	BGSNote
		ConstructibleObject,         //	31 COBJ	BGSConstructibleObject
		Projectile,                  //	32 PROJ	BGSProjectile
		Hazard,                      //	33 HAZD	BGSHazard
		SoulGem,                     //	34 SLGM	TESSoulGem
		LeveledItem,                 //	35 LVLI	TESLevItem
		Weather,                     //	36 WTHR	TESWeather
		Climate,                     //	37 CLMT	TESClimate
		ShaderParticleGeometryData,  //	38 SPGD	BGSShaderParticleGeometryData
		ReferenceEffect,             //	39 RFCT	BGSReferenceEffect
		Region,                      //	3A REGN	TESRegion
		Navigation,                  //	3B NAVI	NavMeshInfoMap
		Cell,                        //	3C CELL	TESObjectCELL
		Reference,                   //	3D REFR	TESObjectREFR
		ActorCharacter,              //	3E ACHR	Actor / Character / PlayerCharacter
		ProjectileMissile,           //	3F PMIS	MissileProjectile
		ProjectileArrow,             //	40 PARW	ArrowProjectile
		ProjectileGrenade,           //	41 PGRE	GrenadeProjectile
		ProjectileBeam,              //	42 PBEA	BeamProjectile
		ProjectileFlame,             //	43 PFLA	FlameProjectile
		ProjectileCone,              //	44 PCON	ConeProjectile
		ProjectileBarrier,           //	45 PBAR	BarrierProjectile
		PlacedHazard,                //	46 PHZD	Hazard
		WorldSpace,                  //	47 WRLD	TESWorldSpace
		Land,                        //	48 LAND	TESObjectLAND
		NavMesh,                     //	49 NAVM	NavMesh
		TLOD,                        //	4A TLOD
		Dialogue,                    //	4B DIAL	TESTopic
		Info,                        //	4C INFO	TESTopicInfo
		Quest,                       //	4D QUST	TESQuest
		Idle,                        //	4E IDLE	TESIdleForm
		Package,                     //	4F PACK	TESPackage / DialoguePackage
		CombatStyle,                 //	50 CSTY	TESCombatStyle
		LoadScreen,                  //	51 LSCR	TESLoadScreen
		LeveledSpell,                //	52 LVSP	TESLevSpell
		AnimatedObject,              //	53 ANIO	TESObjectANIO
		Water,                       //	54 WATR	TESWaterForm
		EffectShader,                //	55 EFSH	TESEffectShader
		TOFT,                        //	56 TOFT
		Explosion,                   //	57 EXPL	BGSExplosion
		Debris,                      //	58 DEBR	BGSDebris
		ImageSpace,                  //	59 IMGS	TESImageSpace
		ImageAdapter,                //	5A IMAD	TESImageSpaceModifier
		FormList,                    //	5B FLST	BGSListForm
		Perk,                        //	5C PERK	BGSPerk
		BodyPartData,                //	5D BPTD	BGSBodyPartData
		AddonNode,                   //	5E ADDN	BGSAddonNode
		ActorValueInfo,              //	5F AVIF	ActorValueInfo
		CameraShot,                  //	60 CAMS	BGSCameraShot
		CameraPath,                  //	61 CPTH	BGSCameraPath
		VoiceType,                   //	62 VTYP	BGSVoiceType
		MaterialType,                //	63 MATT	BGSMaterialType
		Impact,                      //	64 IPCT	BGSImpactData
		ImpactDataSet,               //	65 IPDS	BGSImpactDataSet
		Armature,                    //	66 ARMA	TESObjectARMA
		EncounterZone,               //	67 ECZN	BGSEncounterZone
		Location,                    //	68 LCTN	BGSLocation
		Message,                     //	69 MESG	BGSMessage
		Ragdoll,                     //	6A RGDL	BGSRagdoll
		DefaultObject,               //	6B DOBJ BGSDefaultObjectManager
		LightingMaster,              //	6C LGTM	BGSLightingTemplate
		MusicType,                   //	6D MUSC	BGSMusicType
		Footstep,                    //	6E FSTP	BGSFootstep
		FootstepSet,                 //	6F FSTS	BGSFootstepSet
		StoryManagerBranchNode,      //	70 SMBN	BGSStoryManagerBranchNode
		StoryManagerQuestNode,       //	71 SMQN	BGSStoryManagerQuestNode
		StoryManagerEventNode,       //	72 SMEN	BGSStoryManagerEventNode
		DialogueBranch,              //	73 DLBR	BGSDialogueBranch
		MusicTrack,                  //	74 MUST	BGSMusicTrackFormWrapper
		DialogueView,                //	75 DLVW
		WordOfPower,                 //	76 WOOP	TESWordOfPower
		Shout,                       //	77 SHOU	TESShout
		EquipSlot,                   //	78 EQUP	BGSEquipSlot
		Relationship,                //	79 RELA	BGSRelationship
		Scene,                       //	7A SCEN	BGSScene
		AssociationType,             //	7B ASTP	BGSAssociationType
		Outfit,                      //	7C OTFT	BGSOutfit
		ArtObject,                   //	7D ARTO	BGSArtObject
		MaterialObject,              //	7E MATO	BGSMaterialObject
		MovementType,                //	7F MOVT	BGSMovementType
		SoundRecord,                 //	80 SNDR	BGSSoundDescriptorForm
		DualCastData,                //	81 DUAL	BGSDualCastData
		SoundCategory,               //	82 SNCT	BGSSoundCategory
		SoundOutputModel,            //	83 SOPM	BGSSoundOutput
		CollisionLayer,              //	84 COLL	BGSCollisionLayer
		ColorForm,                   //	85 CLFM	BGSColorForm
		ReverbParam,                 //	86 REVB	BGSReverbParameters
		LensFlare,                   //	87 LENS BGSLensFlare
		LensSprite,                  //	88 LSPR
		VolumetricLighting,          //	89 VOLI BGSVolumetricLighting

		Max  //	8A
	};

	[[nodiscard]] std::string_view FormTypeToString(FormType a_formType) noexcept;
	[[nodiscard]] FormType         StringToFormType(std::string_view a_formType);
}

namespace std
{
	[[nodiscard]] inline std::string to_string(RE::FormType a_formType)
	{
		return RE::FormTypeToString(a_formType).data();
	}
}

namespace fmt
{
	template <>
	struct formatter<RE::FormType>
	{
		template <class ParseContext>
		constexpr auto parse(ParseContext& a_ctx)
		{
			return a_ctx.begin();
		}

		template <class FormatContext>
		auto format(const RE::FormType& a_formType, FormatContext& a_ctx)
		{
			return fmt::format_to(a_ctx.out(), "{}", RE::FormTypeToString(a_formType));
		}
	};
}

#ifdef __cpp_lib_format
namespace std
{
	template <class CharT>
	struct formatter<RE::FormType, CharT> : std::formatter<std::string_view, CharT>
	{
		template <class FormatContext>
		auto format(RE::FormType a_formType, FormatContext& a_ctx)
		{
			return formatter<std::string_view, CharT>::format(RE::FormTypeToString(a_formType), a_ctx);
		}
	};
}
#endif


===============================================
File: include/RE/F/FragmentSystem.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTHashMap.h"

namespace RE
{
	namespace SkyrimScript
	{
		class FragmentSystem
		{
		public:
			BSTHashMap<UnkKey, UnkValue> unk000;  // 000
			mutable BSSpinLock           unk030;  // 030
			BSTHashMap<UnkKey, UnkValue> unk038;  // 038
			mutable BSSpinLock           unk068;  // 068
			BSTHashMap<UnkKey, UnkValue> unk070;  // 070
			mutable BSSpinLock           unk0A0;  // 0A0
			BSTHashMap<UnkKey, UnkValue> unk0A8;  // 0A8
			mutable BSSpinLock           unk0D8;  // 0D8
			BSTHashMap<UnkKey, UnkValue> unk0E0;  // 0E0
			mutable BSSpinLock           unk110;  // 110
		};
		static_assert(sizeof(FragmentSystem) == 0x118);
	}
}


===============================================
File: include/RE/F/FreeCameraState.h
===============================================
#pragma once

#include "RE/B/BSTPoint.h"
#include "RE/N/NiPoint3.h"
#include "RE/P/PlayerInputHandler.h"
#include "RE/T/TESCameraState.h"

namespace RE
{
	class NiNode;

	class FreeCameraState :
		public TESCameraState,     // 00
		public PlayerInputHandler  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_FreeCameraState;
		inline static constexpr auto VTABLE = VTABLE_FreeCameraState;

		~FreeCameraState() override;  // 00

		// override (TESCameraState)
		void Begin() override;                                               // 01
		void End() override;                                                 // 02
		void Update(BSTSmartPointer<TESCameraState>& a_nextState) override;  // 03
		void GetRotation(NiQuaternion& a_rotation) override;                 // 04
		void GetTranslation(NiPoint3& a_translation) override;               // 05

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                          // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_movementData) override;  // 04

		// members
		NiPoint3         translation;    // 30
		BSTPoint2<float> rotationInput;  // 3C
		BSTPoint2<float> unk44;          // 44
		std::uint16_t    unk4C;          // 4C
		bool             useRunSpeed;    // 4E
		std::uint8_t     unk4F;          // 4F
	};
	static_assert(sizeof(FreeCameraState) == 0x50);
}


===============================================
File: include/RE/F/FrenzyEffect.h
===============================================
#pragma once

#include "RE/T/TargetValueModifierEffect.h"

namespace RE
{
	class FrenzyEffect : public TargetValueModifierEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_FrenzyEffect;
		inline static constexpr auto VTABLE = VTABLE_FrenzyEffect;

		// override (TargetValueModifierEffect)
		~FrenzyEffect() override;  // 13

		void  Start() override;                 // 14
		void  Finish() override;                // 15
		float GetTargetValue() const override;  // 21 - { return 3.0f; }
	};
	static_assert(sizeof(FrenzyEffect) == 0x98);
}


===============================================
File: include/RE/F/FunctionArguments.h
===============================================
#pragma once

#include "RE/I/IFunctionArguments.h"
#include "RE/T/TypeTraits.h"
#include "RE/Z/ZeroFunctionArguments.h"

namespace RE
{
	namespace BSScript
	{
		namespace Impl
		{
			template <class... Args, std::size_t... I>
			void CopyArgsImpl(std::tuple<Args...>& a_tuple, BSScrapArray<Variable>& a_dst, std::index_sequence<I...>)
			{
				(a_dst[I].Pack(std::get<I>(a_tuple)), ...);
			}

			template <class... Args>
			void CopyArgs(std::tuple<Args...>& a_tuple, BSScrapArray<Variable>& a_dst)
			{
				CopyArgsImpl(a_tuple, a_dst, std::index_sequence_for<Args...>{});
			}
		}

		template <class Enable, class... Args>
		class FunctionArguments;

		template <class... Args>
		class FunctionArguments<
			std::enable_if_t<
				std::conjunction_v<
					is_return_convertible<Args>...>>,
			Args...> :
			public IFunctionArguments
		{
		private:
			using super = IFunctionArguments;

		public:
			FunctionArguments(Args&&... a_args) :
				super(),
				_args(std::forward<Args>(a_args)...)
			{}

			FunctionArguments() :
				super(),
				_args()
			{}

			FunctionArguments(const FunctionArguments& a_rhs) :
				super(),
				_args(a_rhs._args)
			{}

			FunctionArguments(FunctionArguments&& a_rhs) :
				super(),
				_args(std::move(a_rhs._args))
			{}

			~FunctionArguments() override = default;  // 00

			bool operator()(BSScrapArray<Variable>& a_dst) const override  // 01
			{
				a_dst.resize(sizeof...(Args));
				auto& args = const_cast<std::add_lvalue_reference_t<std::decay_t<decltype(_args)>>>(_args);
				Impl::CopyArgs(args, a_dst);
				return true;
			}

		protected:
			std::tuple<std::decay_t<Args>...> _args;
		};
	}

	template <class... Args>
	using FunctionArguments = BSScript::FunctionArguments<void, Args...>;

	template <class... Args>
	inline BSScript::IFunctionArguments* MakeFunctionArguments(Args&&... a_args)
	{
		return new FunctionArguments<Args...>(std::forward<Args>(a_args)...);
	}

	template <>
	inline BSScript::IFunctionArguments* MakeFunctionArguments()
	{
		return new BSScript::ZeroFunctionArguments();
	}
}


===============================================
File: include/RE/F/FunctionMessage.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	namespace BSScript
	{
		class Stack;

		namespace Internal
		{
			class IFuncCallQuery;

			struct FunctionMessage
			{
			public:
				enum class Type
				{
					kInvalid = 0,
					kCall = 1,
					kReturn = 2
				};

				// members
				Type                            type;       // 00
				std::uint32_t                   pad04;      // 04
				BSTSmartPointer<Stack>          stack;      // 08
				BSTSmartPointer<IFuncCallQuery> funcQuery;  // 10
			};
			static_assert(sizeof(FunctionMessage) == 0x18);
		}
	}
}


===============================================
File: include/RE/F/FxDelegate.h
===============================================
#pragma once

#include "RE/F/FxDelegateHandler.h"
#include "RE/G/GFxExternalInterface.h"
#include "RE/G/GHash.h"
#include "RE/G/GPtr.h"
#include "RE/G/GString.h"

namespace RE
{
	class FxResponseArgsBase;
	class GFxMovieView;

	class FxDelegate : public GFxExternalInterface
	{
	public:
		inline static constexpr auto RTTI = RTTI_FxDelegate;

		struct CallbackDefn
		{
		public:
			// members
			GPtr<FxDelegateHandler>        handler{ nullptr };   // 00
			FxDelegateHandler::CallbackFn* callback{ nullptr };  // 08
		};
		static_assert(sizeof(CallbackDefn) == 0x10);

		struct CallbackHashFunctor
		{
		public:
			UPInt operator()(const GString& a_data) const;
		};
		static_assert(std::is_empty_v<CallbackHashFunctor>);

		using CallbackHash = GHash<GString, CallbackDefn, CallbackHashFunctor>;

		FxDelegate() = default;
		~FxDelegate() override = default;  // 00

		// override (GFxExternalInterface)
		void Callback(GFxMovieView* a_movieView, const char* a_methodName, const GFxValue* a_args, std::uint32_t a_argCount) override;  // 01

		static void Invoke(GFxMovieView* a_movieView, const char* a_methodName, FxResponseArgsBase& a_args);  // Call a method registered with the AS2 GameDelegate instance
		static void Invoke2(GFxMovieView* a_movieView, const char* a_methodName, FxResponseArgsBase& a_args);

		void RegisterHandler(FxDelegateHandler* a_callback);
		void UnregisterHandler(FxDelegateHandler* a_callback);

		// members
		CallbackHash callbacks;  // 18
	};
	static_assert(sizeof(FxDelegate) == 0x20);
}


===============================================
File: include/RE/F/FxDelegateArgs.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"

namespace RE
{
	class FxDelegateHandler;
	class FxResponseArgsBase;
	class GFxMovieView;

	class FxDelegateArgs
	{
	public:
		FxDelegateArgs(GFxValue a_responseID, FxDelegateHandler* a_handler, GFxMovieView* a_movie, const GFxValue* a_vals, std::uint32_t a_numArgs);

		void                             Respond(FxResponseArgsBase& a_params) const;
		const GFxValue&                  operator[](UPInt a_pos) const;
		[[nodiscard]] FxDelegateHandler* GetHandler() const;
		[[nodiscard]] GFxMovieView*      GetMovie() const;
		[[nodiscard]] std::uint32_t      GetArgCount() const;

	protected:
		// members
		GFxValue           _responseID;  // 00
		FxDelegateHandler* _handler;     // 18
		GFxMovieView*      _movieView;   // 20
		const GFxValue*    _args;        // 28
		std::uint32_t      _numArgs;     // 30
		std::uint32_t      _pad34;       // 34
	};
	static_assert(sizeof(FxDelegateArgs) == 0x38);
}


===============================================
File: include/RE/F/FxDelegateHandler.h
===============================================
#pragma once

#include "RE/G/GRefCountBase.h"
#include "RE/G/GStats.h"

namespace RE
{
	class FxDelegateArgs;
	class GString;

	class FxDelegateHandler : public GRefCountBase<FxDelegateHandler, GStatGroups::kGStat_Default_Mem>
	{
	public:
		inline static constexpr auto RTTI = RTTI_FxDelegateHandler;

		using CallbackFn = void(const FxDelegateArgs& a_params);

		class CallbackProcessor
		{
		public:
			inline static constexpr auto RTTI = RTTI_FxDelegateHandler__CallbackProcessor;

			virtual ~CallbackProcessor() = default;  // 00

			// add
			virtual void Process(const GString& a_methodName, CallbackFn* a_method) = 0;  // 01
		};
		static_assert(sizeof(CallbackProcessor) == 0x8);

		~FxDelegateHandler() override = default;  // 00

		// add
		virtual void Accept(CallbackProcessor* a_cbReg) = 0;  // 01
	};
	static_assert(sizeof(FxDelegateHandler) == 0x10);
}


===============================================
File: include/RE/F/FxResponseArgs.h
===============================================
#pragma once

#include "RE/F/FxResponseArgsBase.h"
#include "RE/G/GFxValue.h"

namespace RE
{
	template <std::uint32_t SIZE>
	class FxResponseArgs : public FxResponseArgsBase
	{
	public:
		FxResponseArgs() :
			FxResponseArgsBase(),
			_values{},
			_index(1),
			_pad(0)
		{}

		~FxResponseArgs() override = default;  // 00

		// override (FxResponseArgsBase)
		std::uint32_t GetValues(GFxValue** a_params) override  // 01
		{
			*a_params = _values;
			return _index;
		}

		void Add(const GFxValue& a_val)
		{
			if (_index > SIZE) {
				assert(false);  // insertion out of bounds
				return;
			}
			_values[_index++] = a_val;
		}

	private:
		GFxValue      _values[SIZE + 1];  // 08 - includes response data
		std::uint32_t _index;             // ??
		std::uint32_t _pad;               // ??
	};
	static_assert(sizeof(FxResponseArgs<1>) == 0x40);

	template <std::size_t N>
	class FxResponseArgsEx : public FxResponseArgsBase
	{
	private:
		static constexpr std::size_t O = 1;

		using super = FxResponseArgsBase;
		using container_type = std::array<GFxValue, N + O>;

		static_assert(N + O <= static_cast<std::size_t>((std::numeric_limits<std::uint32_t>::max)()));

	public:
		using value_type = typename container_type::value_type;
		using size_type = typename container_type::size_type;
		using difference_type = typename container_type::difference_type;
		using reference = typename container_type::reference;
		using const_reference = typename container_type::const_reference;
		using pointer = typename container_type::pointer;
		using const_pointer = typename container_type::const_pointer;
		using iterator = typename container_type::iterator;
		using const_iterator = typename container_type::const_iterator;
		using reverse_iterator = typename container_type::reverse_iterator;
		using const_reverse_iterator = typename container_type::const_reverse_iterator;

		FxResponseArgsEx() :
			super(),
			_args()
		{}

		FxResponseArgsEx(const FxResponseArgsEx&) = default;
		FxResponseArgsEx(FxResponseArgsEx&&) = default;

		FxResponseArgsEx(const std::array<GFxValue, N>& a_args) :
			super(),
			_args()
		{
			for (std::size_t i = 0; i < N; ++i) {
				_args[i + O] = a_args[i];
			}
		}

		FxResponseArgsEx(std::array<GFxValue, N>&& a_args) :
			super(),
			_args()
		{
			for (std::size_t i = 0; i < N; ++i) {
				_args[i + O] = std::move(a_args[i]);
			}
		}

		~FxResponseArgsEx() override = default;

		FxResponseArgsEx& operator=(const FxResponseArgsEx&) = default;
		FxResponseArgsEx& operator=(FxResponseArgsEx&&) = default;

		[[nodiscard]] constexpr reference       at(size_type a_pos) { return _args.at(a_pos); }
		[[nodiscard]] constexpr const_reference at(size_type a_pos) const { return _args.at(a_pos); }

		[[nodiscard]] constexpr reference       operator[](size_type a_pos) { return _args[a_pos + O]; }
		[[nodiscard]] constexpr const_reference operator[](size_type a_pos) const { return _args[a_pos + O]; }

		[[nodiscard]] constexpr reference       front() { return _args.front(); }
		[[nodiscard]] constexpr const_reference front() const { return _args.front(); }

		[[nodiscard]] constexpr reference       back() { return _args.back(); }
		[[nodiscard]] constexpr const_reference back() const { return _args.back(); }

		[[nodiscard]] constexpr pointer       data() noexcept { return _args.data(); }
		[[nodiscard]] constexpr const_pointer data() const noexcept { return _args.data(); }

		[[nodiscard]] constexpr iterator       begin() noexcept { return ++_args.begin(); }
		[[nodiscard]] constexpr const_iterator begin() const noexcept { return ++_args.begin(); }
		[[nodiscard]] constexpr const_iterator cbegin() const noexcept { return ++_args.cbegin(); }

		[[nodiscard]] constexpr iterator       end() noexcept { return _args.end(); }
		[[nodiscard]] constexpr const_iterator end() const noexcept { return _args.end(); }
		[[nodiscard]] constexpr const_iterator cend() const noexcept { return _args.cend(); }

		[[nodiscard]] constexpr reverse_iterator       rbegin() noexcept { return _args.rbegin(); }
		[[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept { return _args.rbegin(); }
		[[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept { return _args.crbegin(); }

		[[nodiscard]] constexpr reverse_iterator       rend() noexcept { return --_args.rend(); }
		[[nodiscard]] constexpr const_reverse_iterator rend() const noexcept { return --_args.rend(); }
		[[nodiscard]] constexpr const_reverse_iterator crend() const noexcept { return --_args.crend(); }

		[[nodiscard]] constexpr bool empty() const noexcept { return begin() == end(); }

		[[nodiscard]] constexpr size_type size() const noexcept { return _args.size() - O; }

		[[nodiscard]] constexpr size_type max_size() const noexcept { return size(); }

	protected:
		std::uint32_t GetValues(GFxValue** a_params) override  // 01
		{
			*a_params = _args.data();
			return static_cast<std::uint32_t>(_args.size());
		}

	private:
		container_type _args;
	};

	template <std::size_t N>
	FxResponseArgsEx(const std::array<GFxValue, N>&) -> FxResponseArgsEx<N>;

	template <std::size_t N>
	FxResponseArgsEx(std::array<GFxValue, N>&&) -> FxResponseArgsEx<N>;
}


===============================================
File: include/RE/F/FxResponseArgsBase.h
===============================================
#pragma once

namespace RE
{
	class GFxValue;

	class FxResponseArgsBase
	{
	public:
		FxResponseArgsBase() = default;
		FxResponseArgsBase(const FxResponseArgsBase&) = default;
		FxResponseArgsBase(FxResponseArgsBase&&) = default;

		virtual ~FxResponseArgsBase() = default;  // 00

		FxResponseArgsBase& operator=(const FxResponseArgsBase&) = default;
		FxResponseArgsBase& operator=(FxResponseArgsBase&&) = default;

		// add
		virtual std::uint32_t GetValues(GFxValue** a_params) = 0;  // 01
	};
	static_assert(sizeof(FxResponseArgsBase) == 0x8);
}


===============================================
File: include/RE/G/GASActionBufferData.h
===============================================
#pragma once

#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GRefCountBase.h"

namespace RE
{
	class GASActionBufferData :
		public GRefCountBase<GASActionBufferData, GFxStatMovieData::kGFxStatMD_ActionOps_Mem>
	{
	public:
		~GASActionBufferData() override;  // 00

		// members
		void*         buffer;  // 10
		std::uint64_t size;    // 18
		std::uint32_t unk20;   // 20
		std::uint32_t pad24;   // 24
	};
	static_assert(sizeof(GASActionBufferData) == 0x28);
}


===============================================
File: include/RE/G/GASDoAction.h
===============================================
#pragma once

#include "RE/G/GASExecuteTag.h"

namespace RE
{
	class GASActionBufferData;

	class GASDoAction : public GASExecuteTag
	{
	public:
		~GASDoAction() override;  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;                       // 01
		void Execute2(GFxSprite* a_sprite, std::int32_t a_arg2) override;  // 02
		bool Unk_04() override;                                            // 04 - { return 1; }

		// members
		GPtr<GASActionBufferData> data;  // 08
	};
	static_assert(sizeof(GASDoAction) == 0x10);
}


===============================================
File: include/RE/G/GASDoInitAction.h
===============================================
#pragma once

#include "RE/G/GASDoAction.h"

namespace RE
{
	class GASDoInitAction : public GASDoAction
	{
	public:
		virtual ~GASDoInitAction();  // 00

		// override (GASExecuteTag)
		void Execute1(GFxSprite* a_sprite) override;  // 01
		bool Unk_04() override;                       // 04 - { return 0; }
	};
	static_assert(sizeof(GASDoInitAction) == 0x10);
}


===============================================
File: include/RE/G/GASEnvironment.h
===============================================
#pragma once

#include "RE/G/GFxLogBase.h"
#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GNewOverrideBase.h"

namespace RE
{
	class GASGlobalContext;
	class GFxSprite;

	class GASStringContext
	{
	public:
		GASGlobalContext* globalContext;  // 00
		std::uint8_t      version;        // 08
		std::uint8_t      pad09[7];       // 09
		std::uint64_t     unk10;
		std::uint64_t     unk18;
		std::uint64_t     unk20;
		std::uint64_t     unk28;
	};
	static_assert(sizeof(GASStringContext) == 0x30);

	class GASEnvironment :
		public GFxLogBase<GASEnvironment>,                                       // 000
		public GNewOverrideBase<GFxStatMovieViews::kGFxStatMV_ActionScript_Mem>  // 008
	{
	public:
		~GASEnvironment() override;  // 00

		// override (GFxLogBase)
		bool IsVerboseActionErrors() const override;  // 01 - { return (sprite->GetMovieRoot()->flags & (1 << 6)) == 0; }

		// members
		void*             unk010;         // 010
		std::uint64_t     unk018;         // 018
		void*             unk020;         // 020
		void*             unk028;         // 028 - size is 0x408
		std::uint64_t     unk030;         // 030
		void*             unk038;         // 038
		void*             unk040;         // 040
		void*             unk048;         // 048
		std::uint64_t     unk050[19];     // 050
		GFxSprite*        sprite;         // 0E8
		GASGlobalContext* globalContext;  // 0F0 - struct
		std::uint8_t      version;        // 0F8
		std::uint8_t      pad0F9[7];      // 0F9
		std::uint64_t     pad100[20];     // 0A0
	};
#ifndef __INTELLISENSE__
	static_assert(sizeof(GASEnvironment) == 0x1A0);
#endif
}


===============================================
File: include/RE/G/GASExecuteTag.h
===============================================
#pragma once

namespace RE
{
	class GFxSprite;

	class GASExecuteTag
	{
	public:
		virtual ~GASExecuteTag();  // 00

		// add
		virtual void Execute1(GFxSprite* a_sprite);                       // 01 - {}
		virtual void Execute2(GFxSprite* a_sprite, std::int32_t a_arg2);  // 02 - { Execute1(); }
		virtual bool Unk_03(void);                                        // 03 - { return 0; }
		virtual bool Unk_04();                                            // 04 - { return 0; }
		virtual bool Unk_05(void);                                        // 05 - { return 0; }
		virtual void Unk_06(void);                                        // 06 - {}
		virtual void Unk_07(void);                                        // 07 - {}
	};
	static_assert(sizeof(GASExecuteTag) == 0x8);
}


===============================================
File: include/RE/G/GASFunctionObject.h
===============================================
#pragma once

#include "RE/G/GASObject.h"

namespace RE
{
	class GASFunctionObject : public GASObject
	{
	public:
		~GASFunctionObject() override;  // 02

		// override (GASObject)
		void GASObjectInterface_02(void) override;  // 02 - { return 23; }
		void GASObjectInterface_0C(void) override;  // 0C

		// add
		virtual void Unk_09(void);  // 09 - pure (GetExecutionContext?)
		virtual void Unk_0A(void);  // 0A - pure (Execute?)
		virtual void Unk_0B(void);  // 0B - pure
		virtual void Unk_0C(void);  // 0C - pure
		virtual void Unk_0D(void);  // 0D
		virtual void Unk_0E(void);  // 0E
		virtual void Unk_0F(void);  // 0F
		virtual void Unk_10(void);  // 10 - pure
	};
	static_assert(sizeof(GASFunctionObject) == 0x68);
}


===============================================
File: include/RE/G/GASGlobalContext.h
===============================================
#pragma once

#include "RE/G/GASStringBuiltinManager.h"
#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GRefCountBaseNTS.h"

namespace RE
{
	class GASGlobalObject;
	class GFxMovieRoot;

	class GASGlobalContext :
		public GRefCountBaseNTS<GASGlobalContext, GFxStatMovieViews::kGFxStatMV_ActionScript_Mem>,  // 000
		public GASStringBuiltinManager                                                              // 010
	{
	public:
		~GASGlobalContext() override;

		// members
		std::uint64_t    unk500;        // 500
		std::uint64_t    unk508;        // 508
		std::uint64_t    unk510;        // 510
		GFxMovieRoot*    unk518;        // 518
		GMemoryHeap*     heap;          // 520
		std::uint64_t    unk528;        // 528
		std::uint64_t    unk530;        // 530
		std::uint64_t    unk538;        // 538
		std::uint64_t    unk540;        // 540
		std::uint64_t    unk548;        // 548
		GASGlobalObject* globalObject;  // 550
		std::uint64_t    unk558;        // 558
		std::uint64_t    unk560;        // 560
	};
	static_assert(sizeof(GASGlobalContext) == 0x568);
}


===============================================
File: include/RE/G/GASObject.h
===============================================
#pragma once

#include "RE/G/GASObjectInterface.h"
#include "RE/G/GASRefCountBase.h"

namespace RE
{
	class GASObject :
		public GASRefCountBase<GASObject>,  // 00
		public GASObjectInterface           // 20
	{
	public:
		// override (GASRefCountBase)
		void Unk_00(void) override;  // 00
		void Unk_01(void) override;  // 01

		~GASObject() override;  // 02

		// override (GASObjectInterface)
		void GASObjectInterface_01(void) override;                                           // 01
		void GASObjectInterface_02(void) override;                                           // 02
		void GASObjectInterface_03(void) override;                                           // 03
		void GASObjectInterface_04(void) override;                                           // 04
		void GASObjectInterface_05(void) override;                                           // 05
		void GASObjectInterface_06(void) override;                                           // 06
		void GASObjectInterface_07(void) override;                                           // 07
		void GASObjectInterface_08(void) override;                                           // 08
		void GASObjectInterface_09(void) override;                                           // 09
		void GASObjectInterface_0A(void) override;                                           // 0A
		void GASObjectInterface_0B(void) override;                                           // 0B
		void Set__proto__(GASStringContext* a_stringContext, GASObject* a_object) override;  // 0D
		void GASObjectInterface_12(void) override;                                           // 12
		void GASObjectInterface_13(void) override;                                           // 13
		void GASObjectInterface_14(void) override;                                           // 14

		// add
		virtual void Unk_03(void);  // 03
		virtual void Unk_04(void);  // 04
		virtual void Unk_05(void);  // 05
		virtual void Unk_06(void);  // 06
		virtual void Unk_07(void);  // 07
		virtual void Unk_08(void);  // 08

		// members
		std::uint64_t unk38;  // 38 - properties
		std::uint64_t unk40;  // 40 - __resolve handler
		std::uint64_t unk48;  // 48
		std::uint64_t unk50;  // 50
		std::uint64_t unk58;  // 58
		std::uint64_t unk60;  // 60
	};
	static_assert(sizeof(GASObject) == 0x68);
}


===============================================
File: include/RE/G/GASObjectInterface.h
===============================================
#pragma once

#include "RE/G/GPtr.h"

namespace RE
{
	class GASGlobalContext;
	class GASObject;
	class GASStringContext;
	struct GASString;

	class GASObjectInterface
	{
	public:
		virtual ~GASObjectInterface();  // 00

		// add
		virtual void GASObjectInterface_01(void);                                           // 01
		virtual void GASObjectInterface_02(void);                                           // 02
		virtual void GASObjectInterface_03(void);                                           // 03 - pure
		virtual void GASObjectInterface_04(void);                                           // 04 - pure
		virtual void GASObjectInterface_05(void);                                           // 05 - pure
		virtual void GASObjectInterface_06(void);                                           // 06 - pure
		virtual void GASObjectInterface_07(void);                                           // 07 - pure
		virtual void GASObjectInterface_08(void);                                           // 08 - pure
		virtual void GASObjectInterface_09(void);                                           // 09 - pure
		virtual void GASObjectInterface_0A(void);                                           // 0A - pure
		virtual void GASObjectInterface_0B(void);                                           // 0B - pure
		virtual void GASObjectInterface_0C(void);                                           // 0C
		virtual void Set__proto__(GASStringContext* a_stringContext, GASObject* a_object);  // 0D - pure
		virtual void GASObjectInterface_0E(void);                                           // 0E
		virtual void GASObjectInterface_0F(void);                                           // 0F
		virtual void GASObjectInterface_10(void);                                           // 10
		virtual void GASObjectInterface_11(void);                                           // 11
		virtual void GASObjectInterface_12(void);                                           // 12
		virtual void GASObjectInterface_13(void);                                           // 13
		virtual void GASObjectInterface_14(void);                                           // 14

		// members
		std::uint64_t unk08;      // 08
		GASObject*    __proto__;  // 10 - smart pointer
	};
	static_assert(sizeof(GASObjectInterface) == 0x18);
}


===============================================
File: include/RE/G/GASRefCountBase.h
===============================================
#pragma once

#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GRefCountBaseGC.h"

namespace RE
{
	template <typename T>
	class GASRefCountBase : public GRefCountBaseGC<GFxStatMovieViews::kGFxStatMV_ActionScript_Mem>
	{
	public:
	};
	// size == 0x20
}


===============================================
File: include/RE/G/GASStringBuiltinManager.h
===============================================
#pragma once

#include "RE/G/GString.h"

namespace RE
{
	class GASStringManager;

	class GASStringBuiltinManager
	{
	public:
		// members
		std::uint64_t     unk000[157];    // 000
		GASStringManager* stringManager;  // 4E8
	};
	static_assert(sizeof(GASStringBuiltinManager) == 0x4F0);
}


===============================================
File: include/RE/G/GASStringManager.h
===============================================
#pragma once

#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GRefCountBase.h"
#include "RE/G/GStringHash.h"

namespace RE
{
	struct GASString
	{
	public:
		const char*   str;       // 00
		GASString*    next;      // 08
		std::int32_t  refCount;  // 10
		std::int32_t  hash;      // 14
		std::uint32_t size;      // 18
		std::uint32_t pad1C;     // 1C
	};

	class GASStringManager : public GRefCountBase<GASStringManager, GFxStatMovieViews::kGFxStatMV_ActionScript_Mem>
	{
	public:
		~GASStringManager() override;  // 00

		// members
		GStringHash<GASString> unk10;  // 10
		GMemoryHeap*           heap;   // 18
		std::uint64_t          unk20;  // 20
		void*                  unk28;  // 28
		std::uint64_t          unk30;  // 30
		std::uint64_t          unk38;  // 38
		std::uint64_t          unk40;  // 40
		std::uint64_t          unk48;  // 48
		std::uint64_t          unk50;  // 50
	};
	static_assert(sizeof(GASStringManager) == 0x58);
}


===============================================
File: include/RE/G/GASUserDefinedFunctionObject.h
===============================================
#pragma once

#include "RE/G/GASFunctionObject.h"
#include "RE/G/GFxFunctionHandler.h"
#include "RE/G/GPtr.h"

namespace RE
{
	class GASUserDefinedFunctionObject : public GASFunctionObject
	{
	public:
		// override (GASFunctionObject)
		void Unk_01(void) override;  // 01

		~GASUserDefinedFunctionObject() override;  // 02

		void Unk_09(void) override;  // 09
		void Unk_0A(void) override;  // 0A
		void Unk_0B(void) override;  // 0B - { return handler == nullptr; }
		void Unk_0C(void) override;  // 0C - { return 0; }
		void Unk_10(void) override;  // 10 - { return -1; }

		// members
		GPtr<GFxFunctionHandler> handler;   // 68
		void*                    userData;  // 70
	};
	static_assert(sizeof(GASUserDefinedFunctionObject) == 0x78);
}


===============================================
File: include/RE/G/GAcquireInterface.h
===============================================
#pragma once

namespace RE
{
	class GAcquireInterface
	{
	public:
		virtual ~GAcquireInterface() = default;  // 00

		virtual bool CanAcquire();        // 01
		virtual bool TryAcquire();        // 02
		virtual bool TryAcquireCommit();  // 03
		virtual bool TryAcquireCancel();  // 04
	};
	static_assert(sizeof(GAcquireInterface) == 0x8);
}


===============================================
File: include/RE/G/GAllocator.h
===============================================
#pragma once

#include "RE/G/GAllocatorBaseGH.h"
#include "RE/G/GAllocatorBaseLH.h"
#include "RE/G/GConstructorMov.h"
#include "RE/G/GStats.h"

namespace RE
{
	template <class T, std::uint32_t SID = GStatGroup::kGStat_Default_Mem>
	struct GAllocatorGH : GAllocatorBaseGH<SID>, GConstructorMov<T>
	{};

	template <class T, std::uint32_t SID = GStatGroup::kGStat_Default_Mem>
	struct GAllocatorLH : GAllocatorBaseLH<SID>, GConstructorMov<T>
	{};
}


===============================================
File: include/RE/G/GAllocatorBaseGH.h
===============================================
#pragma once

#include "RE/G/GMemory.h"
#include "RE/G/GStats.h"

namespace RE
{
	template <std::uint32_t SID = GStatGroup::kGStat_Default_Mem>
	class GAllocatorBaseGH
	{
	public:
		enum
		{
			kStatID = SID
		};

		static void* Alloc([[maybe_unused]] const void* a_heapAddr, UPInt a_size)
		{
			return GMemory::Alloc(a_size);
		}

		static void* Realloc(void* a_ptr, UPInt a_newSize)
		{
			return GMemory::Realloc(a_ptr, a_newSize);
		}

		static void Free(void* a_ptr)
		{
			GMemory::Free(a_ptr);
		}
	};
	static_assert(sizeof(GAllocatorBaseGH<>) == 0x1);
}


===============================================
File: include/RE/G/GAllocatorBaseLH.h
===============================================
#pragma once

#include "RE/G/GMemory.h"
#include "RE/G/GStats.h"

namespace RE
{
	template <std::uint32_t SID = GStatGroup::kGStat_Default_Mem>
	class GAllocatorBaseLH
	{
	public:
		enum
		{
			kStatID = SID
		};

		static void* Alloc(const void* a_heapAddr, UPInt a_size)
		{
			return GMemory::AllocAutoHeap(a_heapAddr, a_size);
		}

		static void* Realloc(void* a_ptr, UPInt a_newSize)
		{
			return GMemory::Realloc(a_ptr, a_newSize);
		}

		static void Free(void* a_ptr)
		{
			GMemory::Free(a_ptr);
		}
	};
	static_assert(sizeof(GAllocatorBaseLH<>) == 0x1);
}


===============================================
File: include/RE/G/GArray.h
===============================================
#pragma once

#include "RE/G/GAllocator.h"
#include "RE/G/GArrayBase.h"
#include "RE/G/GArrayData.h"
#include "RE/G/GArrayDefaultPolicy.h"
#include "RE/G/GStats.h"

namespace RE
{
	template <class T, std::uint32_t SID = GStatGroup::kGStat_Default_Mem, class SizePolicy = GArrayDefaultPolicy>
	class GArray : public GArrayBase<GArrayData<T, GAllocatorGH<T, SID>, SizePolicy>>
	{
	public:
		using ValueType = T;
		using AllocatorType = GAllocatorGH<T, SID>;
		using SizePolicyType = SizePolicy;
		using SelfType = GArray<T, SID, SizePolicy>;
		using BaseType = GArrayBase<GArrayData<T, GAllocatorGH<T, SID>, SizePolicy>>;

		GArray() :
			BaseType()
		{}

		GArray(std::int32_t a_size) :
			BaseType(a_size)
		{}

		GArray(const SizePolicyType& a_policy) :
			BaseType()
		{
			SetSizePolicy(a_policy);
		}

		GArray(const SelfType& a_array) :
			BaseType(a_array)
		{}

		const SelfType& operator=(const SelfType& a_array)
		{
			BaseType::operator=(a_array);
			return *this;
		}
	};
	static_assert(sizeof(GArray<void*>) == 0x18);
}


