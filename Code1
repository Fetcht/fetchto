===============================================
File: include/RE/A/AIFormulas.h
===============================================
#pragma once

namespace RE
{
	class Actor;
	class TESForm;

	namespace AIFormulas
	{
		std::int32_t ComputePickpocketSuccess(float a_thiefSkill, float a_targetSkill, std::uint32_t a_valueStolen, float a_weightStolen, Actor* a_thief, Actor* a_target, bool a_isDetected, TESForm* a_itemPickpocketing);
	}
}


===============================================
File: include/RE/A/AIProcess.h
===============================================
#pragma once

#include "RE/A/ActorPackage.h"
#include "RE/B/BGSDefaultObjectManager.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	enum class RESET_3D_FLAGS;
	class Actor;
	class bhkCharacterController;
	class BipedAnim;
	class HighProcess;
	class NiAVObject;
	class NiPoint3;
	class TESForm;
	class TESShout;
	struct HighProcessData;
	struct MiddleHighProcessData;

	enum class PROCESS_TYPE
	{
		kNone = static_cast<std::underlying_type_t<PROCESS_TYPE>>(-1),
		kHigh = 0,
		kMiddleHigh = 1,
		kMiddleLow = 2,
		kLow = 3
	};

	class MiddleLowProcessData
	{
	public:
		// members
		std::int32_t hourPackageEvaluated;  // 0
	};
	static_assert(sizeof(MiddleLowProcessData) == 0x4);

	struct CachedValueData
	{
	public:
		// members
		bool          dirty;  // 0
		std::uint8_t  pad1;   // 1
		std::uint16_t pad2;   // 2
		float         value;  // 4
	};
	static_assert(sizeof(CachedValueData) == 0x8);

	struct CachedValues
	{
	public:
		enum class Flags
		{
			kNone = 0,
			kRadius = 1 << 0,
			kWidth = 1 << 1,
			kLength = 1 << 2,
			kDPS = 1 << 3,
			kMedicineEffectivenessMult = 1 << 4,
			kEyeLevel = 1 << 9,
			kConditionPreventsRun = 1 << 10,
			kForwardLength = 1 << 11,
			kActorIsGhost = 1 << 20,
			kHealthDamaged = 1 << 21,
			kMagickaPointsDamaged = 1 << 22,
			kStaminaDamaged = 1 << 23,
			kOwnerIsNPC = 1 << 25,
			kOwnerIsUndead = 1 << 26,
			kOwnerIsInCombatantFaction = 1 << 27
		};

		enum class BooleanValue
		{
			kNone = 0,
			kConditionPreventsRun = 1 << 0,
			kOwnerIsNPC = 1 << 1,
			kOwnerIsUndead = 1 << 2,
			kOwnerIsInCombatantFaction = 1 << 3
		};

		float                                         cachedRadius;              // 00
		float                                         cachedWidth;               // 04
		float                                         cachedLength;              // 08
		float                                         cachedForwardLength;       // 0C
		float                                         cachedDPS;                 // 10
		float                                         cachedEyeLevel;            // 14
		float                                         cachedWalkSpeed;           // 18
		float                                         cachedRunSpeed;            // 1C
		float                                         cachedJogSpeed;            // 20
		float                                         cachedFastWalkSpeed;       // 24
		stl::enumeration<BooleanValue, std::uint32_t> booleanValues;             // 28
		stl::enumeration<Flags, std::uint32_t>        flags;                     // 2C
		BSTArray<CachedValueData>                     actorValueCache;           // 30
		BSTArray<CachedValueData>                     permanentActorValueCache;  // 48
	};
	static_assert(sizeof(CachedValues) == 0x60);

	struct ObjectstoAcquire
	{
	public:
		// members
		std::uint64_t unk00;  // 00
		std::uint64_t unk08;  // 08
		std::uint64_t unk10;  // 10
		std::uint64_t unk18;  // 18
		std::uint64_t unk20;  // 20
	};
	static_assert(sizeof(ObjectstoAcquire) == 0x28);

	class AIProcess
	{
	public:
		enum class LowProcessFlags : std::uint8_t
		{
			kNone = 0,
			kTargetActivated = 1 << 0,
			kCurrentActionComplete = 1 << 1,
			kAlert = 1 << 3,
			kFollower = 1 << 4,
			kPackageDoneOnce = 1 << 5,
			kPackageIdleDone = 1 << 6
		};

		struct Hands
		{
			enum Hand : std::uint32_t
			{
				kLeft,
				kRight,
				kTotal
			};
		};
		using Hand = Hands::Hand;

		struct Data0B8
		{
		public:
			// members
			void*         unk00;  // 00
			Data0B8*      unk08;  // 08
			void*         unk10;  // 10
			void*         unk18;  // 18
			std::uint64_t unk20;  // 20
			void*         unk28;  // 28
			std::uint32_t unk30;  // 30
			std::uint32_t pad34;  // 34
		};
		static_assert(sizeof(Data0B8) == 0x38);

		void                    ClearActionHeadtrackTarget(bool a_defaultHold);
		void                    ClearMuzzleFlashes();
		float                   GetCachedHeight() const;
		bhkCharacterController* GetCharController();
		ActorHandle             GetCommandingActor() const;
		TESShout*               GetCurrentShout();
		TESForm*                GetEquippedLeftHand();
		TESForm*                GetEquippedRightHand();
		ObjectRefHandle         GetHeadtrackTarget() const;
		[[nodiscard]] bool      GetIsSummonedCreature() const noexcept;
		NiAVObject*             GetMagicNode(const BSTSmartPointer<BipedAnim>& a_biped) const;
		ObjectRefHandle         GetOccupiedFurniture() const;
		TESPackage*             GetRunningPackage() const;
		Actor*                  GetUserData() const;
		float                   GetVoiceRecoveryTime() const;
		NiAVObject*             GetWeaponNode(const BSTSmartPointer<BipedAnim>& a_biped) const;
		bool                    InHighProcess() const;
		bool                    InMiddleHighProcess() const;
		bool                    InMiddleLowProcess() const;
		bool                    InLowProcess() const;
		bool                    IsArrested() const;
		bool                    IsGhost() const;
		void                    KnockExplosion(Actor* a_actor, const NiPoint3& a_location, float a_magnitude);
		bool                    PlayIdle(Actor* a_actor, TESIdleForm* a_idle, TESObjectREFR* a_target);
		void                    SetActorsDetectionEvent(Actor* a_actor, const NiPoint3& a_location, std::int32_t a_soundLevel, TESObjectREFR* a_ref);
		void                    SetArrested(bool a_arrested);
		void                    SetCachedHeight(float a_height);
		void                    SetHeadtrackTarget(Actor* a_owner, NiPoint3& a_targetPosition);
		void                    Set3DUpdateFlag(RESET_3D_FLAGS a_flags);
		bool                    SetupSpecialIdle(Actor* a_actor, DEFAULT_OBJECT a_action, TESIdleForm* a_idle, bool a_arg5, bool a_arg6, TESObjectREFR* a_target);
		void                    StopCurrentIdle(Actor* a_actor, bool a_forceIdleStop);
		void                    Update3DModel(Actor* a_actor);

		// members
		MiddleLowProcessData*                           middleLow;                      // 000
		MiddleHighProcessData*                          middleHigh;                     // 008
		HighProcessData*                                high;                           // 010
		ActorPackage                                    currentPackage;                 // 018
		float                                           unk048;                         // 048
		std::uint32_t                                   unk04C;                         // 04C
		CachedValues*                                   cachedValues;                   // 050
		std::int32_t                                    numberItemsActivate;            // 058
		std::uint32_t                                   pad05C;                         // 05C
		BSSimpleList<ObjectstoAcquire*>                 objects;                        // 060
		BSSimpleList<TESObjectREFR*>                    genericLocations;               // 070
		ObjectstoAcquire*                               acquireObject;                  // 080
		ObjectstoAcquire*                               savedAcquireObject;             // 088
		float                                           essentialDownTimer;             // 090
		float                                           deathTime;                      // 094
		float                                           trackedDamage;                  // 098
		std::uint32_t                                   pad09C;                         // 09C
		BSTArray<TESForm*>                              forms;                          // 0A0
		Data0B8                                         unk0B8;                         // 0B8
		TESForm*                                        equippedObjects[Hand::kTotal];  // 0F0
		std::uint64_t                                   unk100;                         // 100
		std::uint64_t                                   unk108;                         // 108
		RefHandle                                       followTarget;                   // 110
		RefHandle                                       target;                         // 114
		std::uint64_t                                   unk118;                         // 118
		std::uint64_t                                   unk120;                         // 120
		std::uint64_t                                   unk128;                         // 128
		std::uint32_t                                   unk130;                         // 130
		std::uint16_t                                   unk134;                         // 134
		stl::enumeration<LowProcessFlags, std::uint8_t> lowProcessFlags;                // 136
		stl::enumeration<PROCESS_TYPE, std::uint8_t>    processLevel;                   // 137
		bool                                            skippedTimeStampForPathing;     // 138
		bool                                            ignoringCombat;                 // 139
		bool                                            endAlarmOnActor;                // 13A
		bool                                            escortingPlayer;                // 13B
		std::uint32_t                                   pad13C;                         // 13C

	protected:
		void Update3DModel_Impl(Actor* a_actor);
	};
	static_assert(sizeof(AIProcess) == 0x140);
}


===============================================
File: include/RE/A/AITimeStamp.h
===============================================
#pragma once

namespace RE
{
	struct AITimeStamp
	{
	public:
		// members
		float timeStamp;  // 0
	};
	static_assert(sizeof(AITimeStamp) == 0x4);
}


===============================================
File: include/RE/A/AITimer.h
===============================================
#pragma once

namespace RE
{
	struct AITimer
	{
		//members
		float aiTimer;  // 00
		float timer;    // 04
	};
	static_assert(sizeof(AITimer) == 0x08);
}


===============================================
File: include/RE/A/AbsorbEffect.h
===============================================
#pragma once

#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class AbsorbEffect : public ValueModifierEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_AbsorbEffect;
		inline static constexpr auto VTABLE = VTABLE_AbsorbEffect;

		// override (ValueModifierEffect)
		~AbsorbEffect() override;  // 13

		void ModifyOnStart() override;                                                  // 1B
		void ModifyOnUpdate(float a_delta) override;                                    // 1D
		void ModifyOnFinish(Actor* a_caster, Actor* a_target, float a_value) override;  // 1F
	};
	static_assert(sizeof(AbsorbEffect) == 0x98);
}


===============================================
File: include/RE/A/AbstractHeap.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/I/IMemoryHeap.h"

namespace RE
{
	class HeapBlock;
	class HeapBlockFreeHead;

	class AbstractHeap : public IMemoryHeap
	{
	public:
		inline static constexpr auto RTTI = RTTI_AbstractHeap;

		~AbstractHeap() override;  // 00

		// override (IMemoryHeap)
		void          GetMemoryStats(MemoryStats* a_stats) override;                                 // 02
		void*         AllocateAlignImpl(std::size_t a_size, std::uint32_t a_alignment) override;     // 04
		void*         TryAllocateImpl(std::size_t a_size, std::uint32_t a_alignment) override;       // 06
		const char*   GetName() const override;                                                      // 07 - { return name; }
		bool          PointerInHeap(const void* a_pointer) const override;                           // 0A
		void          GetHeapStats(HeapStats* a_stats, bool a_fullBlockInfo) override;               // 0C
		bool          ShouldTrySmallBlockPools(std::size_t a_size, MEM_CONTEXT a_context) override;  // 0D - { return true; }
		std::uint32_t GetPageSize() const override;                                                  // 0E - { return pageSize; }

		// add
		virtual void*       DoHeapAllocation(std::size_t a_size, std::size_t a_initialSize) = 0;                       // 0F
		virtual void        DoHeapFree(void* a_ptr) = 0;                                                               // 10
		virtual std::size_t CreateMorePages(void* a_memory, std::size_t a_currentSize, std::size_t a_requestedBytes);  // 11 - { return 0; }
		virtual std::size_t CleanExtraPages(void* a_memory, std::size_t a_currentSize, std::size_t a_freeBytes);       // 12 - { return 0; }
		virtual void        DecommitPages(HeapBlock* a_block);                                                         // 13 - { return; }
		virtual void        CommitPages(HeapBlock*, std::size_t);                                                      // 14 - { return; }

		// members
		BSCriticalSection  criticalSection;     // 008
		const char*        name;                // 030
		std::size_t        minFreeBlockSize;    // 038
		std::uint32_t      pageSize;            // 040
		std::uint32_t      pageSizeFlag;        // 040
		std::size_t        memHeapSize;         // 048
		std::size_t        initialSize;         // 050
		std::size_t        currentSize;         // 058
		std::size_t        wastedMemory;        // 060
		std::size_t        memAllocated;        // 068
		std::size_t        memAllocatedHigh;    // 070
		std::size_t        blockMemAllocated;   // 078
		char*              memHeap;             // 080
		std::int32_t       numBlocks;           // 088
		std::uint32_t      pad08C;              // 08C
		HeapBlock*         blockHead;           // 090
		HeapBlock*         blockTail;           // 098
		std::int32_t       numFreeBlocks;       // 0A0
		bool               allowDecommits;      // 0A4
		bool               supportsSwapping;    // 0A5
		std::uint16_t      pad0A0;              // 0A6
		HeapBlock*         smallFreeLists[32];  // 0A8
		HeapBlockFreeHead* largeFreeTrees[32];  // 1A8
	};
	static_assert(sizeof(AbstractHeap) == 0x2A8);
}


===============================================
File: include/RE/A/AccumulatingValueModifierEffect.h
===============================================
#pragma once

#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class AccumulatingValueModifierEffect :
		public ValueModifierEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_AccumulatingValueModifierEffect;
		inline static constexpr auto VTABLE = VTABLE_AccumulatingValueModifierEffect;

		// override (ActiveEffect)
		virtual void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 08
		virtual void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 09
		virtual ~AccumulatingValueModifierEffect();                // 13
		virtual void Start() override;                             // 14
		virtual void Finish() override;                            // 15

		// override (ValueModifierEffect)
		virtual bool ShouldModifyOnStart() override;                                            // 1A
		virtual bool ShouldModifyOnUpdate() const override;                                     // 1C
		virtual void ModifyOnUpdate(float a_delta) override;                                    // 1D
		virtual void ModifyOnFinish(Actor* a_caster, Actor* a_target, float a_value) override;  // 1F

		// members
		float accumulatedMagnitude;  // 98
		float maximumMagnitude;      // 9C
		float holdTimer;             // A0
	};
	static_assert(sizeof(AccumulatingValueModifierEffect) == 0xA8);
}


===============================================
File: include/RE/A/ActionInput.h
===============================================
#pragma once

#include "RE/A/ActorState.h"
#include "RE/B/BGSAction.h"
#include "RE/B/BGSAnimationSequencer.h"

namespace RE
{
	class ActionInput
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActionInput;
		inline static constexpr auto VTABLE = VTABLE_ActionInput;

		virtual ~ActionInput();  // 00

		// add
		virtual ActorState*            GetSourceActorState() const;  // 01 - { return nullptr; }
		virtual void                   Unk_02(void);                 // 02 - { return 0; }
		virtual BGSAnimationSequencer* GetSourceSequencer() const;   // 03 - { return nullptr; }

		// members
		NiPointer<TESObjectREFR> source;  // 08
		NiPointer<TESObjectREFR> target;  // 10
		BGSAction*               action;  // 18
		uint32_t                 unk20;   // 20
	};
	static_assert(sizeof(ActionInput) == 0x28);
}


===============================================
File: include/RE/A/ActionOutput.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	class TESIdleForm;

	class ActionOutput
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActionOutput;

		// members
		BSFixedString      animEvent;        // 00
		BSFixedString      targetAnimEvent;  // 08
		int32_t            result;           // 10
		TESIdleForm*       sequence;         // 18
		const TESIdleForm* animObjIdle;      // 20
		uint32_t           sequenceIndex;    // 28
	};
	static_assert(sizeof(ActionOutput) == 0x30);
}


===============================================
File: include/RE/A/ActivateHandler.h
===============================================
#pragma once

#include "RE/H/HeldStateHandler.h"

namespace RE
{
	struct ActivateHandler : public HeldStateHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActivateHandler;

		~ActivateHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04

		constexpr inline void SetHeldButtonActionSuccess(bool a_success) noexcept { heldButtonActionSuccess = a_success; }

		// members
		std::uint8_t  unk18;                    // 18
		std::uint8_t  unk19;                    // 19
		bool          heldButtonActionSuccess;  // 1A
		bool          disabled;                 // 1B
		std::uint32_t unk1C;                    // 1C
	};
	static_assert(sizeof(ActivateHandler) == 0x20);
}


===============================================
File: include/RE/A/ActiveEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffectReferenceEffectController.h"
#include "RE/B/BSContainer.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTList.h"
#include "RE/M/MagicSystem.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class Actor;
	class BGSLoadFormBuffer;
	class BGSSaveFormBuffer;
	class EffectSetting;
	class MagicItem;
	class MagicTarget;
	class NiNode;
	class NiPoint3;
	class ReferenceEffect;
	class TESBoundObject;
	struct Effect;

	class ActiveEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActiveEffect;
		inline static constexpr auto VTABLE = VTABLE_ActiveEffect;
		inline static constexpr auto VMTYPEID = static_cast<VMTypeID>(142);

		class ForEachHitEffectVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_ActiveEffect__ForEachHitEffectVisitor;

			virtual ~ForEachHitEffectVisitor();  // 00

			// add
			virtual BSContainer::ForEachResult operator()(ReferenceEffect* a_hitEffect) = 0;  // 01
		};

		enum class Flag
		{
			kHasConditions = 1 << 7,
			kEnchanting = 1 << 8,
			kRecovers = 1 << 9,
			kDual = 1 << 12,
			kInactive = 1 << 15,
			kDispelled = 1 << 18
		};

		enum class ConditionStatus
		{
			kNA = static_cast<std::underlying_type_t<ConditionStatus>>(-1),
			kFalse = 0,
			kTrue = 1,
		};

		// add
		virtual void           AdjustForPerks(Actor* a_caster, MagicTarget* a_target);    // 00
		virtual void           OnAdd(MagicTarget* a_target);                              // 01
		virtual void           OnRemove();                                                // 02 - { return; }
		virtual TESObjectREFR* GetVisualsTarget();                                        // 03 - { return target ? target->GetTargetStatsObject() : 0; }
		virtual void           Update(float a_delta);                                     // 04 - { return; }
		virtual void           EvaluateConditions(float a_delta, bool a_forceUpdate);     // 05
		virtual bool           IsCausingHealthDamage();                                   // 06 - { return 0; }
		virtual void           SetLocation(const NiPoint3& a_location);                   // 07 - { return; }
		virtual void           SaveGame(BGSSaveFormBuffer* a_buf);                        // 08
		virtual void           LoadGame(BGSLoadFormBuffer* a_buf);                        // 09
		virtual void           FinishLoadGame(BGSLoadFormBuffer* a_buf);                  // 0A
		virtual void           Revert(BGSLoadFormBuffer* a_buf);                          // 0B - { castingSource = 4; }
		virtual std::int32_t   Compare(ActiveEffect* a_otherEffect);                      // 0C
		virtual void           HandleEvent(const BSFixedString& a_eventName);             // 0D - { return; }
		virtual void           SwitchAttachedRoot(NiNode* a_root, NiNode* a_attachRoot);  // 0E - { return; }
		virtual void           HandleQueuedStart();                                       // 0F - { return; }
		virtual bool           ShouldDispelOnDeath() const;                               // 10 - { return effect->baseEffect->data.flags.any(EffectSetting::EffectSettingData::Flag::kNoDeathDispel); }
		virtual bool           GetAllowMultipleCastingSourceStacking();                   // 11 - { return 0; }
		virtual void           ClearTargetImpl();                                         // 12 - { return; }

		virtual ~ActiveEffect();  // 13

		virtual void  Start();                                                   // 14 - { return; }
		virtual void  Finish();                                                  // 15 - { return; }
		virtual bool  CanFinish();                                               // 16
		virtual bool  CheckCustomSkillUseConditions() const;                     // 17 - { return 1; }
		virtual float GetCustomSkillUseMagnitudeMultiplier(float a_mult) const;  // 18 - { return 1.0; }

		void                               Dispel(bool a_force);
		[[nodiscard]] EffectSetting*       GetBaseObject() noexcept;
		[[nodiscard]] const EffectSetting* GetBaseObject() const noexcept;
		NiPointer<Actor>                   GetCasterActor() const;
		float                              GetMagnitude() const;
		Actor*                             GetTargetActor();
		const Actor*                       GetTargetActor() const;

		ActiveEffectReferenceEffectController            hitEffectController;  // 08
		BSSoundHandle                                    persistentSound;      // 28
		ActorHandle                                      caster;               // 34
		NiPointer<NiNode>                                sourceNode;           // 38
		MagicItem*                                       spell;                // 40
		Effect*                                          effect;               // 48
		MagicTarget*                                     target;               // 50
		TESBoundObject*                                  source;               // 58
		BSSimpleList<ReferenceEffect*>*                  hitEffects;           // 60
		MagicItem*                                       displacementSpell;    // 68
		float                                            elapsedSeconds;       // 70
		float                                            duration;             // 74
		float                                            magnitude;            // 78
		stl::enumeration<Flag, std::uint32_t>            flags;                // 7C
		stl::enumeration<ConditionStatus, std::uint32_t> conditionStatus;      // 80
		std::uint16_t                                    usUniqueID;           // 84
		std::uint16_t                                    pad86;                // 86
		MagicSystem::CastingSource                       castingSource;        // 88
		std::uint32_t                                    pad8C;                // 8C
	};
	static_assert(sizeof(ActiveEffect) == 0x90);
}


===============================================
File: include/RE/A/ActiveEffectFactory.h
===============================================
#pragma once

#include "RE/E/Effect.h"
#include "RE/M/MagicCaster.h"
#include "RE/M/MagicItem.h"
#include "RE/M/MagicSystem.h"

namespace RE
{
	namespace ActiveEffectFactory
	{
		bool CheckCast(MagicCaster* a_caster, MagicItem* a_spell, Effect* a_effect, MagicSystem::CannotCastReason& a_reason);
	}
}


===============================================
File: include/RE/A/ActiveEffectReferenceEffectController.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/N/NiPoint3.h"
#include "RE/R/ReferenceEffectController.h"

namespace RE
{
	class ActiveEffect;

	class ActiveEffectReferenceEffectController : public ReferenceEffectController
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActiveEffectReferenceEffectController;
		inline static constexpr auto VTABLE = VTABLE_ActiveEffectReferenceEffectController;

		~ActiveEffectReferenceEffectController() override;  // 00

		// override (ReferenceEffectController)
		void             HandleEvent(const BSFixedString& a_event) override;                 // 01 - return { effect->HandleEvent(a_event); }
		float            GetElapsedTime() override;                                          // 02 - return { effect->elapsedSeconds; }
		float            GetScale() override;                                                // 03
		void             SwitchAttachedRoot(NiNode* a_root, NiNode* a_attachRoot) override;  // 04 - return { effect->SwitchAttachedRoot(a_root, a_attachRoot); }
		const NiPoint3&  GetSourcePosition() override;                                       // 05
		bool             GetUseSourcePosition() override;                                    // 06
		bool             GetNoInitialFlare() override;                                       // 07
		bool             GetEffectPersists() override;                                       // 08
		bool             GetGoryVisuals() override;                                          // 09
		void             RemoveHitEffect(ReferenceEffect* a_refEffect) override;             // 0A
		TESObjectREFR*   GetTargetReference() override;                                      // 0B
		BGSArtObject*    GetHitEffectArt() override;                                         // 0C
		TESEffectShader* GetHitEffectShader() override;                                      // 0D
		bool             GetManagerHandlesSaveLoad() override;                               // 0E - { return false; }
		bool             EffectShouldFaceTarget() override;                                  // 17
		TESObjectREFR*   GetFacingTarget() override;                                         // 18
		void             SetWindPoint(const NiPoint3& a_point) override;                     // 1E - { windPoint = a_point; }
		const NiPoint3&  GetWindPoint() override;                                            // 1F - { return windPoint; }
		bool             GetAllowNo3D() override;                                            // 20
		void             SaveGame(BGSSaveGameBuffer* a_buf) override;                        // 21
		void             LoadGame(BGSLoadGameBuffer* a_buf) override;                        // 22

		// members
		ActiveEffect*   effect;     // 08
		ObjectRefHandle target;     // 10
		NiPoint3        windPoint;  // 14
	};
	static_assert(sizeof(ActiveEffectReferenceEffectController) == 0x20);
}


===============================================
File: include/RE/A/Actor.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/A/ActiveEffect.h"
#include "RE/A/ActorState.h"
#include "RE/A/ActorValueOwner.h"
#include "RE/A/ActorValues.h"
#include "RE/B/BGSBipedObjectForm.h"
#include "RE/B/BGSEntryPointPerkEntry.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSPointerHandleSmartPointer.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BSTTuple.h"
#include "RE/D/DetectionPriorities.h"
#include "RE/E/EmotionTypes.h"
#include "RE/F/FormTypes.h"
#include "RE/I/IPostAnimationChannelUpdateFunctor.h"
#include "RE/M/MagicSystem.h"
#include "RE/M/MagicTarget.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESNPC.h"
#include "RE/T/TESObjectREFR.h"

namespace RE
{
	class ActorMagicCaster;
	class ActorMover;
	class AIProcess;
	class bhkCharacterController;
	class bhkCharacterMoveFinishEvent;
	class BipedAnim;
	class BSTransformDeltaEvent;
	class CombatController;
	class CombatGroup;
	class ExtraDataList;
	class InventoryEntryData;
	class MovementControllerNPC;
	class MovementMessageActorCollision;
	class NiRefObject;
	class PackageLocation;
	class PerkEntryVisitor;
	class TrespassPackage;
	struct ActorMotionFeedbackData;
	struct ActorMotionFeedbackOutput;

	enum class ACTOR_CRITICAL_STAGE
	{
		kNone = 0,
		kGooStart = 1,
		kGooEnd = 2,
		kDisintegrateStart = 3,
		kDisintegrateEnd = 4,

		kTotal
	};

	struct Modifiers
	{
	public:
		// members
		float modifiers[ACTOR_VALUE_MODIFIERS::kTotal];  // 0
	};
	static_assert(sizeof(Modifiers) == 0xC);

	struct ActorValueStorage
	{
	public:
		template <class T>
		struct LocalMap
		{
		public:
			T* operator[](ActorValue a_actorValue)
			{
				return GetAt(static_cast<char>(a_actorValue));
			}

			const T* operator[](ActorValue a_actorValue) const
			{
				return GetAt(static_cast<char>(a_actorValue));
			}

			// members
			BSFixedString actorValues;  // 00
			T*            entries;      // 08

		private:
			[[nodiscard]] T* GetAt(char a_actorValue) const
			{
				auto akVals = actorValues.data();
				if (akVals && entries) {
					std::uint32_t idx = 0;
					while (akVals[idx] != '\0') {
						if (akVals[idx] == a_actorValue) {
							break;
						}
						++idx;
					}

					if (akVals[idx] != '\0') {
						return std::addressof(entries[idx]);
					}
				}
				return 0;
			}
		};
		static_assert(sizeof(LocalMap<float>) == 0x10);

		// members
		LocalMap<float>     baseValues;  // 00
		LocalMap<Modifiers> modifiers;   // 10
	};
	static_assert(sizeof(ActorValueStorage) == 0x20);

	NiSmartPointer(Actor);

    class Actor :
#ifndef ENABLE_SKYRIM_AE
            public TESObjectREFR,                              // 000
            public MagicTarget,                                // 098, 0A0
            public ActorValueOwner,                            // 0B0, 0B8
            public ActorState,                                 // 0B8, 0C0
            public BSTEventSink<BSTransformDeltaEvent>,        // 0C8, 0D0
            public BSTEventSink<bhkCharacterMoveFinishEvent>,  // 0D0, 0D8
            public IPostAnimationChannelUpdateFunctor          // 0D8, 0E0
#else
            public TESObjectREFR  // 000
#endif
	{
	private:
		using EntryPoint = BGSEntryPointPerkEntry::EntryPoint;

	public:
		inline static constexpr auto RTTI = RTTI_Actor;
		inline static constexpr auto FORMTYPE = FormType::ActorCharacter;

		struct SlotTypes
		{
			enum
			{
				kLeftHand = 0,
				kRightHand,
				kUnknown,
				kPowerOrShout,

				kTotal
			};
		};

		enum class BOOL_BITS
		{
			kNone = 0,
			kDelayUpdateScenegraph = 1 << 0,
			kProcessMe = 1 << 1,
			kMurderAlarm = 1 << 2,
			kHasSceneExtra = 1 << 3,
			kHeadingFixed = 1 << 4,
			kSpeakingDone = 1 << 5,
			kIgnoreChangeAnimationCall = 1 << 6,
			kSoundFileDone = 1 << 7,
			kVoiceFileDone = 1 << 8,
			kInTempChangeList = 1 << 9,
			kDoNotRunSayToCallback = 1 << 10,
			kDead = 1 << 11,
			kForceGreetingPlayer = 1 << 12,
			kForceUpdateQuestTarget = 1 << 13,
			kSearchingInCombat = 1 << 14,
			kAttackOnNextTheft = 1 << 15,
			kEvpBuffered = 1 << 16,
			kResetAI = 1 << 17,
			kInWater = 1 << 18,
			kSwimming = 1 << 19,
			kVoicePausedByScript = 1 << 20,
			kWasInFrustrum = 1 << 21,
			kShouldRotateToTrack = 1 << 22,
			kSetOnDeath = 1 << 23,
			kDoNotPadVoice = 1 << 24,
			kFootIKInRange = 1 << 25,
			kPlayerTeammate = 1 << 26,
			kGivePlayerXP = 1 << 27,
			kSoundCallbackSuccess = 1 << 28,
			kUseEmotion = 1 << 29,
			kGuard = 1 << 30,
			kParalyzed = 1 << 31
		};

		enum class BOOL_FLAGS
		{
			kNone = 0,
			kScenePackage = 1 << 0,
			kIsAMount = 1 << 1,
			kMountPointClear = 1 << 2,
			kGettingOnOffMount = 1 << 3,
			kInRandomScene = 1 << 4,
			kNoBleedoutRecovery = 1 << 5,
			kInBleedoutAnimation = 1 << 6,
			kCanDoFavor = 1 << 7,
			kShouldAnimGraphUpdate = 1 << 8,
			kCanSpeakToEssentialDown = 1 << 9,
			kBribedByPlayer = 1 << 10,
			kAngryWithPlayer = 1 << 11,
			kIsTrespassing = 1 << 12,
			kCanSpeak = 1 << 13,
			kIsInKillMove = 1 << 14,
			kAttackOnSight = 1 << 15,
			kIsCommandedActor = 1 << 16,
			kForceOneAnimgraphUpdate = 1 << 17,
			kEssential = 1 << 18,
			kProtected = 1 << 19,
			kAttackingDisabled = 1 << 20,
			kCastingDisabled = 1 << 21,
			kSceneHeadTrackRotation = 1 << 22,
			kForceIncMinBoneUpdate = 1 << 23,
			kCrimeSearch = 1 << 24,
			kMovingIntoLoadedArea = 1 << 25,
			kDoNotShowOnStealthMeter = 1 << 26,
			kMovementBlocked = 1 << 27,
			kAllowInstantFurniturePopInPlayerCell = 1 << 28,
			kForceAnimGraphUpdate = 1 << 29,
			kCheckAddEffectDualCast = 1 << 30,
			kUnderwater = 1 << 31
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kLifeState = 1 << 10,
				kPackageExtraData = 1 << 11,
				kMerchantContainer = 1 << 12,
				kDismemberedLimbs = 1 << 17,
				kLeveledActor = 1 << 18,
				kDispModifiers = 1 << 19,
				kTempModifiers = 1 << 20,
				kDamageModifiers = 1 << 21,
				kOverrideModifiers = 1 << 22,
				kPermanentModifiers = 1 << 23,
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kStartsDead = 1 << 9,
				kPersistent = 1 << 10,
				kInitiallyDisabled = 1 << 11,
				kIgnored = 1 << 12,
				kNoAIAcquire = 1 << 25,
				kDontHavokSettle = 1 << 29
			};
		};

		class ForEachSpellVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_Actor__ForEachSpellVisitor;

			virtual ~ForEachSpellVisitor() = default;  // 00

			// add
			virtual BSContainer::ForEachResult Visit(SpellItem* a_spell) = 0;  // 01
		};

		~Actor() override;  // 000

		// override (TESObjectREFR)
		void                                 SaveGame(BGSSaveFormBuffer* a_buf) override;                                                                                                                                                                          // 00E
		void                                 LoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                                                                                          // 00F
		void                                 InitLoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                                                                                      // 010
		void                                 FinishLoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                                                                                    // 011
		void                                 Revert(BGSLoadFormBuffer* a_buf) override;                                                                                                                                                                            // 012
		void                                 InitItemImpl() override;                                                                                                                                                                                              // 013
		void                                 SetDelete(bool a_set) override;                                                                                                                                                                                       // 023
		void                                 Predestroy() override;                                                                                                                                                                                                // 03B
		[[nodiscard]] BGSLocation*           GetEditorLocation1() const override;                                                                                                                                                                                  // 03C - { return editorLocation; }
		[[nodiscard]] bool                   GetEditorLocation2(NiPoint3& a_outPos, NiPoint3& a_outRot, TESForm*& a_outWorldOrCell, TESObjectCELL* a_fallback) override;                                                                                           // 03D
		void                                 ForceEditorLocation(BGSLocation* a_location) override;                                                                                                                                                                // 03E - { editorLocation = a_location; }
		void                                 Update3DPosition(bool a_warp) override;                                                                                                                                                                               // 03F
		void                                 UpdateSoundCallBack(bool a_endSceneAction) override;                                                                                                                                                                  // 040
		bool                                 SetDialogueWithPlayer(bool a_flag, bool a_forceGreet, TESTopicInfo* a_topic) override;                                                                                                                                // 041
		[[nodiscard]] BGSAnimationSequencer* GetSequencer(void) const override;                                                                                                                                                                                    // 045 - { return currentProcess->high->animSequencer; }
		[[nodiscard]] bool                   HasKeywordHelper(const BGSKeyword* a_keyword) const override;                                                                                                                                                         // 048
		[[nodiscard]] TESPackage*            CheckForCurrentAliasPackage() override;                                                                                                                                                                               // 049 - { return 0; }
		[[nodiscard]] BGSScene*              GetCurrentScene() const override;                                                                                                                                                                                     // 04A
		void                                 SetCurrentScene(BGSScene* a_scene) override;                                                                                                                                                                          // 04B
		bool                                 UpdateInDialogue(DialogueResponse* a_response, bool a_unused) override;                                                                                                                                               // 04C
		[[nodiscard]] BGSDialogueBranch*     GetExclusiveBranch() const override;                                                                                                                                                                                  // 04D - { return exclusiveBranch; }
		void                                 SetExclusiveBranch(BGSDialogueBranch* a_branch) override;                                                                                                                                                             // 04E - { exclusiveBranch = a_arg1; }
		void                                 PauseCurrentDialogue(void) override;                                                                                                                                                                                  // 04F
		[[nodiscard]] NiPoint3               GetStartingAngle() const override;                                                                                                                                                                                    // 052
		[[nodiscard]] NiPoint3               GetStartingLocation() const override;                                                                                                                                                                                 // 053
		ObjectRefHandle                      RemoveItem(TESBoundObject* a_item, std::int32_t a_count, ITEM_REMOVE_REASON a_reason, ExtraDataList* a_extraList, TESObjectREFR* a_moveToRef, const NiPoint3* a_dropLoc = 0, const NiPoint3* a_rotate = 0) override;  // 056
		bool                                 AddWornItem(TESBoundObject* a_item, std::int32_t a_count, bool a_forceEquip, std::uint32_t a_arg4, std::uint32_t a_arg5) override;                                                                                    // 057
		void                                 DoTrap1(TrapData& a_data) override;                                                                                                                                                                                   // 058
		void                                 DoTrap2(TrapEntry* a_trap, TargetEntry* a_target) override;                                                                                                                                                           // 059
		void                                 AddObjectToContainer(TESBoundObject* a_object, ExtraDataList* a_extraList, std::int32_t a_count, TESObjectREFR* a_fromRefr) override;                                                                                 // 05A
		[[nodiscard]] NiPoint3               GetLookingAtLocation() const override;                                                                                                                                                                                // 05B
		[[nodiscard]] MagicCaster*           GetMagicCaster(MagicSystem::CastingSource a_source) override;                                                                                                                                                         // 05C
		[[nodiscard]] MagicTarget*           GetMagicTarget() override;                                                                                                                                                                                            // 05D - { return static_cast<MagicTarget*>(this); }
		[[nodiscard]] bool                   IsChild() const override;                                                                                                                                                                                             // 05E - { return false; }
		BSFaceGenAnimationData*              GetFaceGenAnimationData() override;                                                                                                                                                                                   // 063
		bool                                 DetachHavok(NiAVObject* a_obj3D) override;                                                                                                                                                                            // 065
		void                                 InitHavok() override;                                                                                                                                                                                                 // 066
		void                                 Unk_67(void) override;                                                                                                                                                                                                // 067 - related to vampire lord cape
		void                                 Unk_68(void) override;                                                                                                                                                                                                // 068
		void                                 Unk_69(void) override;                                                                                                                                                                                                // 069
		NiAVObject*                          Load3D(bool a_arg1) override;                                                                                                                                                                                         // 06A
		void                                 Set3D(NiAVObject* a_object, bool a_queue3DTasks = true) override;                                                                                                                                                     // 06C
		bool                                 PopulateGraphProjectsToLoad(void) const override;                                                                                                                                                                     // 072
		[[nodiscard]] NiPoint3               GetBoundMin() const override;                                                                                                                                                                                         // 073
		[[nodiscard]] NiPoint3               GetBoundMax() const override;                                                                                                                                                                                         // 074
		void                                 Unk_75(void) override;                                                                                                                                                                                                // 075 - "ActorValue GetWeaponSkill()"? really weird call, only works for right hand, and defaults to 1
		void                                 Unk_78(void) override;                                                                                                                                                                                                // 078
		void                                 ModifyAnimationUpdateData(BSAnimationUpdateData& a_data) override;                                                                                                                                                    // 079
		bool                                 ShouldSaveAnimationOnUnloading() const override;                                                                                                                                                                      // 07A - { return false; }
		bool                                 ShouldSaveAnimationOnSaving() const override;                                                                                                                                                                         // 07B
		bool                                 ShouldPerformRevert() const override;                                                                                                                                                                                 // 07C
		void                                 UpdateAnimation(float a_delta) override;                                                                                                                                                                              // 07D
		void                                 RemoveWeapon(BIPED_OBJECT equipIndex) override;                                                                                                                                                                                                // 082
#ifndef SKYRIM_CROSS_VR
		// Override functions past where Skyrim VR breaks compatibility.
		void                   SetObjectReference(TESBoundObject* a_object) override;                                         // 084
		void                   MoveHavok(bool a_forceRec) override;                                                           // 085
		void                   GetLinearVelocity(NiPoint3& a_velocity) const override;                                        // 086
		void                   SetActionComplete(bool a_set) override;                                                        // 087
		void                   Disable() override;                                                                            // 089
		void                   ResetInventory(bool a_leveledOnly) override;                                                   // 08A
		NiNode*                 GetFireNode() override;                                                                         // 08B
		void                    SetFireNode(NiNode* a_fireNode) override;                                                                         // 08C
		bool                   OnAddCellPerformQueueReference(TESObjectCELL& a_cell) const override;                          // 090
		void                   DoMoveToHigh() override;                                                                       // 091
		void                   TryMoveToMiddleLow() override;                                                                 // 092
		bool                   TryChangeSkyCellActorsProcessLevel() override;                                                 // 093
		void                    TryUpdateActorLastSeenTime() override;                                                                         // 095
		void                   Unk_96(void) override;                                                                         // 096
		void                   SetParentCell(TESObjectCELL* a_cell) override;                                                 // 098
		[[nodiscard]] bool     IsDead(bool a_notEssential = true) const override;                                             // 099
		bool                   ProcessInWater(hkpCollidable* a_collidable, float a_waterHeight, float a_deltaTime) override;  // 09C
		bool                   ApplyCurrent(float a_velocityTime, const hkVector4& a_velocity) override;                      // 09D
		[[nodiscard]] TESAmmo* GetCurrentAmmo() const override;                                                               // 09E
		void                   UnequipItem(std::uint64_t a_arg1, TESBoundObject* a_object) override;                          // 0A1
#endif

		// override (MagicTarget)
#ifndef ENABLE_SKYRIM_AE
		[[nodiscard]] Actor*                       GetTargetStatsObject() override;      // 002 - { return this; }
		[[nodiscard]] bool                         MagicTargetIsActor() const override;  // 003 - { return true; }
		[[nodiscard]] BSSimpleList<ActiveEffect*>* GetActiveEffectList() override;       // 007
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void                Unk_A2(void);                                                                                                                                                                          // 0A2
		SKYRIM_REL_VR_VIRTUAL void                PlayPickUpSound(TESBoundObject* a_object, bool a_pickup, bool a_use);                                                                                                                  // 0A3
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float GetHeading(bool a_ignoreRaceSettings) const;                                                                                                                                           // 0A4
		SKYRIM_REL_VR_VIRTUAL void                SetAvoidanceDisabled(bool a_set);                                                                                                                                                      // 0A5 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                DrawWeaponMagicHands(bool a_draw);                                                                                                                                                     // 0A6
		SKYRIM_REL_VR_VIRTUAL void                DetachCharController();                                                                                                                                                                // 0A7
		SKYRIM_REL_VR_VIRTUAL void                RemoveCharController();                                                                                                                                                                // 0A8
		SKYRIM_REL_VR_VIRTUAL void                SetPosition(const NiPoint3& a_pos, bool a_updateCharController);                                                                                                                       // 0A9
		SKYRIM_REL_VR_VIRTUAL void                KillDying();                                                                                                                                                                           // 0AA
		SKYRIM_REL_VR_VIRTUAL void                Resurrect(bool a_resetInventory, bool a_attach3D);                                                                                                                                     // 0AB
		SKYRIM_REL_VR_VIRTUAL bool                PutActorOnMountQuick();                                                                                                                                                                // 0AC
		SKYRIM_REL_VR_VIRTUAL void                Update(float a_delta);                                                                                                                                                                 // 0AD
		SKYRIM_REL_VR_VIRTUAL void                UpdateNoAI(float a_delta);                                                                                                                                                             // 0AE - { return UpdateActor3DPosition(); }
		SKYRIM_REL_VR_VIRTUAL void                UpdateCharacterControllerSimulationSettings(bhkCharacterController& a_controller);                                                                                                     // 0AF
		SKYRIM_REL_VR_VIRTUAL void                PotentiallyFixRagdollState();                                                                                                                                                          // 0B0
		SKYRIM_REL_VR_VIRTUAL void                UpdateNonRenderSafe(float a_delta);                                                                                                                                                    // 0B1
		SKYRIM_REL_VR_VIRTUAL void                OnItemEquipped(bool a_playAnim);                                                                                                                                                       // 0B2
		SKYRIM_REL_VR_VIRTUAL void                Unk_B3(void);                                                                                                                                                                          // 0B3 - { return 1; }
		SKYRIM_REL_VR_VIRTUAL void                Unk_B4(void);                                                                                                                                                                          // 0B4
		SKYRIM_REL_VR_VIRTUAL void                SetCrimeGoldValue(TESFaction* a_faction, bool a_violent, std::uint32_t a_amount);                                                                                                      // 0B5
		SKYRIM_REL_VR_VIRTUAL void                ModCrimeGoldValue(TESFaction* a_faction, bool a_violent, std::int32_t a_amount);                                                                                                       // 0B6
		SKYRIM_REL_VR_VIRTUAL void                RemoveCrimeGoldValue(TESFaction* a_faction, bool a_violent, std::int32_t a_amount);                                                                                                    // 0B7
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL std::uint32_t GetCrimeGoldValue(const TESFaction* a_faction) const;                                                                                                                          // 0B8
		SKYRIM_REL_VR_VIRTUAL void                        GoToPrison(TESFaction* a_faction, bool a_removeInventory, bool a_realJail);                                                                                                    // 0B9 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                        ServePrisonTime();                                                                                                                                                             // 0BA - { return; }
		SKYRIM_REL_VR_VIRTUAL void                        PayFine(TESFaction* a_faction, bool a_goToJail, bool a_removeStolenItems);                                                                                                     // 0BB - { return; }
		SKYRIM_REL_VR_VIRTUAL bool                        GetCannibal();                                                                                                                                                                 // 0BC - { return false; }
		SKYRIM_REL_VR_VIRTUAL void                        SetCannibal(bool a_set);                                                                                                                                                       // 0BD - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool          GetVampireFeed();                                                                                                                                                              // 0BE - { return false; }
		SKYRIM_REL_VR_VIRTUAL void                        SetVampireFeed(bool a_set);                                                                                                                                                    // 0BF - { return; }
		SKYRIM_REL_VR_VIRTUAL void                        InitiateVampireFeedPackage(Actor* a_target, TESObjectREFR* a_furniture);                                                                                                       // 0C0 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                        InitiateCannibalPackage(Actor* a_target);                                                                                                                                      // 0C1 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                        GetEyeVector(NiPoint3& a_origin, NiPoint3& a_direction, bool a_includeCameraOffset);                                                                                           // 0C2
		SKYRIM_REL_VR_VIRTUAL void                        SetRefraction(bool a_enable, float a_refraction);                                                                                                                              // 0C3
		SKYRIM_REL_VR_VIRTUAL void                        Unk_C4(void);                                                                                                                                                                  // 0C4 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                        Unk_C5(void);                                                                                                                                                                  // 0C5 - { return 1; }
		SKYRIM_REL_VR_VIRTUAL void                        Unk_C6(void);                                                                                                                                                                  // 0C6
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float         GetAcrobatics() const;                                                                                                                                                         // 0C7 - { return 1.0; }
		SKYRIM_REL_VR_VIRTUAL bhkCharacterController* Move(float a_arg2, const NiPoint3& a_position);                                                                                                                                    // 0C8
		SKYRIM_REL_VR_VIRTUAL void                    Unk_C9(void);                                                                                                                                                                      // 0C9
		SKYRIM_REL_VR_VIRTUAL void                    OnArmorActorValueChanged();                                                                                                                                                        // 0CA - { return; }
		SKYRIM_REL_VR_VIRTUAL ObjectRefHandle         DropObject(const TESBoundObject* a_object, ExtraDataList* a_extraList, std::int32_t a_count, const NiPoint3* a_dropLoc = 0, const NiPoint3* a_rotate = 0);                         // 0CB
		SKYRIM_REL_VR_VIRTUAL void                    PickUpObject(TESObjectREFR* a_object, std::int32_t a_count, bool a_arg3 = false, bool a_playSound = true);                                                                         // 0CC
		SKYRIM_REL_VR_VIRTUAL void                    AttachArrow(const BSTSmartPointer<BipedAnim>& a_biped);                                                                                                                            // 0CD
		SKYRIM_REL_VR_VIRTUAL void                    DetachArrow(const BSTSmartPointer<BipedAnim>& a_biped);                                                                                                                            // 0CE
		SKYRIM_REL_VR_VIRTUAL bool                    AddShout(TESShout* a_shout);                                                                                                                                                       // 0CF
		SKYRIM_REL_VR_VIRTUAL void                    UnlockWord(TESWordOfPower* a_power);                                                                                                                                               // 0D0 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                    Unk_D1(void);                                                                                                                                                                      // 0D1
		SKYRIM_REL_VR_VIRTUAL std::uint32_t      UseAmmo(std::uint32_t a_shotCount);                                                                                                                                                     // 0D2
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool CalculateCachedOwnerIsInCombatantFaction() const;                                                                                                                                       // 0D3
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL CombatGroup* GetCombatGroup() const;                                                                                                                                                         // 0D4
		SKYRIM_REL_VR_VIRTUAL void                       SetCombatGroup(CombatGroup* a_group);                                                                                                                                           // 0D5
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool         CheckValidTarget(TESObjectREFR& a_target);                                                                                                                                      // 0D6
		SKYRIM_REL_VR_VIRTUAL bool                       InitiateTresPassPackage(TrespassPackage* a_trespassPackage);                                                                                                                    // 0D7 - { return 0; }
		SKYRIM_REL_VR_VIRTUAL void                       InitiateDialogue(Actor* a_target, PackageLocation* a_loc1, PackageLocation* a_loc2);                                                                                            // 0D8
		SKYRIM_REL_VR_VIRTUAL void                       SetSize(float a_size);                                                                                                                                                          // 0D9
		SKYRIM_REL_VR_VIRTUAL void                       EndDialogue();                                                                                                                                                                  // 0DA
		SKYRIM_REL_VR_VIRTUAL Actor*                    SetUpTalkingActivatorActor(Actor* a_target, Actor*& a_activator);                                                                                                                // 0DB
		SKYRIM_REL_VR_VIRTUAL void                      InitiateSpectator(Actor* a_target);                                                                                                                                              // 0DC - { return; }
		SKYRIM_REL_VR_VIRTUAL void                      InitiateFlee(TESObjectREFR* a_fleeRef, bool a_runOnce, bool a_knows, bool a_combatMode, TESObjectCELL* a_cell, TESObjectREFR* a_ref, float a_fleeFromDist, float a_fleeToDist);  // 0DD
		SKYRIM_REL_VR_VIRTUAL void                      InitiateGetUpPackage();                                                                                                                                                          // 0DE
		SKYRIM_REL_VR_VIRTUAL void                      PutCreatedPackage(TESPackage* a_package, bool a_tempPackage, bool a_createdPackage, bool a_allowFromFurniture);                                                                  // 0DF
		SKYRIM_REL_VR_VIRTUAL void                      UpdateAlpha();                                                                                                                                                                   // 0E0
		SKYRIM_REL_VR_VIRTUAL void                      SetAlpha(float a_alpha = 1.0);                                                                                                                                                   // 0E1
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       GetAlpha();                                                                                                                                                                      // 0E2
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool        IsInCombat() const;                                                                                                                                                              // 0E3
		SKYRIM_REL_VR_VIRTUAL void                      UpdateCombat();                                                                                                                                                                  // 0E4
		SKYRIM_REL_VR_VIRTUAL void                      StopCombat();                                                                                                                                                                    // 0E5
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       CalcArmorRating();                                                                                                                                                               // 0E6 - { return 0.0; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       GetArmorBaseFactorSum();                                                                                                                                                         // 0E7 - { return 0.0; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       CalcUnarmedDamage();                                                                                                                                                             // 0E8 - { return 0; }
		SKYRIM_REL_VR_VIRTUAL void                      Unk_E9(void);                                                                                                                                                                    // 0E9 - { return 0; }
		SKYRIM_REL_VR_VIRTUAL void                      Unk_EA(void);                                                                                                                                                                    // 0EA - { return 0; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       GetRunSpeed();                                                                                                                                                                   // 0EB
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       GetJogSpeed();                                                                                                                                                                   // 0EC
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       GetFastWalkSpeed();                                                                                                                                                              // 0ED
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float       GetWalkSpeed();                                                                                                                                                                  // 0EE
		SKYRIM_REL_VR_VIRTUAL void                      WeaponSwingCallBack();                                                                                                                                                           // 0EF
		SKYRIM_REL_VR_VIRTUAL void                      SetActorStartingPosition();                                                                                                                                                      // 0F0
		SKYRIM_REL_VR_VIRTUAL bool                      MoveToHigh();                                                                                                                                                                    // 0F1
		SKYRIM_REL_VR_VIRTUAL bool                      MovetoLow();                                                                                                                                                                     // 0F2
		SKYRIM_REL_VR_VIRTUAL bool                      MovetoMiddleLow();                                                                                                                                                               // 0F3
		SKYRIM_REL_VR_VIRTUAL bool                      MoveToMiddleHigh();                                                                                                                                                              // 0F4
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool        HasBeenAttacked() const;                                                                                                                                                         // 0F5
		SKYRIM_REL_VR_VIRTUAL void                      SetBeenAttacked(bool a_set);                                                                                                                                                     // 0F6
		SKYRIM_REL_VR_VIRTUAL void                      UseSkill(ActorValue a_av, float a_points, TESForm* a_arg3);                                                                                                                      // 0F7 - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool        IsAtPoint(const NiPoint3& a_point, float a_radius, bool a_expandRadius, bool a_alwaysTestHeight);                                                                                // 0F8
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool        IsInFaction(const TESFaction* faction) const;                                                                                                                                    // 0F9
		SKYRIM_REL_VR_VIRTUAL void                      ForEachPerk(PerkEntryVisitor& a_visitor) const;                                                                                                                                  // 0FA
		SKYRIM_REL_VR_VIRTUAL void                      AddPerk(BGSPerk* a_perk, std::uint32_t a_rank = 0);                                                                                                                              // 0FB - { return; }
		SKYRIM_REL_VR_VIRTUAL void                      RemovePerk(BGSPerk* a_perk);                                                                                                                                                     // 0FC - { return; }
		SKYRIM_REL_VR_VIRTUAL void                      ApplyTemporaryPerk(BGSPerk* a_perk);                                                                                                                                             // 0FD - { return; }
		SKYRIM_REL_VR_VIRTUAL void                      RemoveTemporaryPerk(BGSPerk* a_perk);                                                                                                                                            // 0FE - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool        HasPerkEntries(EntryPoint a_entryType) const;                                                                                                                                    // 0FF
		SKYRIM_REL_VR_VIRTUAL void                      ForEachPerkEntry(EntryPoint a_entryType, PerkEntryVisitor& a_visitor) const;                                                                                                     // 100
		SKYRIM_REL_VR_VIRTUAL void                      ApplyPerksFromBase();                                                                                                                                                            // 101
		SKYRIM_REL_VR_VIRTUAL void                      StartPowerAttackCoolDown();                                                                                                                                                      // 102 - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool        IsPowerAttackCoolingDown() const;                                                                                                                                                // 103 - { return false; }
		SKYRIM_REL_VR_VIRTUAL void                      HandleHealthDamage(Actor* a_attacker, float a_damage);                                                                                                                           // 104
		SKYRIM_REL_VR_VIRTUAL void                      Unk_105(void);                                                                                                                                                                   // 105
		SKYRIM_REL_VR_VIRTUAL void                      Unk_106(void);                                                                                                                                                                   // 106 - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool        QSpeakingDone() const;                                                                                                                                                           // 107 - { return ~(unk0E0 >> 5) & 1; }
		SKYRIM_REL_VR_VIRTUAL void                      SetSpeakingDone(bool a_set);                                                                                                                                                     // 108
		SKYRIM_REL_VR_VIRTUAL void                      CreateMovementController();                                                                                                                                                      // 109
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL EmotionType GetEmotionType();                                                                                                                                                                // 10A - { return unk16C; }
		SKYRIM_REL_VR_VIRTUAL void                      SetEmotionType(EmotionType a_emotionType);                                                                                                                                       // 10B - { unk16C = a_arg1; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL std::uint32_t GetEmotionValue();                                                                                                                                                             // 10C - { return unk170; }
		SKYRIM_REL_VR_VIRTUAL void                        SetEmotionValue(std::uint32_t a_emotionValue);                                                                                                                                 // 10D - { unk170 = a_arg1; }
		SKYRIM_REL_VR_VIRTUAL void                        KillImpl(Actor* a_attacker, float a_damage, bool a_sendEvent, bool a_ragdollInstant);                                                                                          // 10E
		SKYRIM_REL_VR_VIRTUAL bool                        DrinkPotion(AlchemyItem* a_potion, ExtraDataList* a_extralist);                                                                                                                // 10F
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool          CheckCast(MagicItem* a_spell, bool a_dualCast, MagicSystem::CannotCastReason* a_reason);                                                                                       // 110
		SKYRIM_REL_VR_VIRTUAL void                        CheckTempModifiers();                                                                                                                                                          // 111 - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL std::int32_t GetCurrentShoutLevel();                                                                                                                                                         // 112 - return -1 on error
		SKYRIM_REL_VR_VIRTUAL void                       SetLastRiddenMount(ActorHandle a_mount);                                                                                                                                        // 113 - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL ActorHandle  QLastRiddenMount() const;                                                                                                                                                       // 114 - { return {}; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool         CalculateCachedOwnerIsUndead() const;                                                                                                                                           // 115
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool         CalculateCachedOwnerIsNPC() const;                                                                                                                                              // 116
		SKYRIM_REL_VR_VIRTUAL void                       Unk_117(void);                                                                                                                                                                  // 117 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                       InitValues();                                                                                                                                                                   // 118
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL const BSFixedString& GetResponseString() const;                                                                                                                                              // 119 - { return "ActorResponse"; }
		SKYRIM_REL_VR_VIRTUAL void                               ModifyMovementData(float a_delta, NiPoint3& a_arg3, NiPoint3& a_arg4);                                                                                                  // 11A
		SKYRIM_REL_VR_VIRTUAL void                               UpdateCombatControllerSettings();                                                                                                                                       // 11B
		SKYRIM_REL_VR_VIRTUAL void                               UpdateFadeSettings(bhkCharacterController* a_controller);                                                                                                               // 11C
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool                 ComputeMotionFeedbackSpeedAndDirection(const ActorMotionFeedbackData& a_data, float a_delta, ActorMotionFeedbackOutput& a_output);                                      // 11D
		SKYRIM_REL_VR_VIRTUAL bool                               UpdateFeedbackGraphSpeedAndDirection(const ActorMotionFeedbackOutput& a_output);                                                                                        // 11E
		SKYRIM_REL_VR_VIRTUAL void                               UpdateActor3DPosition();                                                                                                                                                // 11F
		SKYRIM_REL_VR_VIRTUAL void                               PrecacheData();                                                                                                                                                         // 120
		SKYRIM_REL_VR_VIRTUAL void                               WornArmorChanged(void);                                                                                                                                                 // 121
		SKYRIM_REL_VR_VIRTUAL void                               ProcessTracking(float a_delta, NiAVObject* a_obj3D);                                                                                                                    // 122
		SKYRIM_REL_VR_VIRTUAL void                               Unk_123(void);                                                                                                                                                          // 123
		SKYRIM_REL_VR_VIRTUAL void                               CreateActorMover();                                                                                                                                                     // 124
		SKYRIM_REL_VR_VIRTUAL void                               DestroyActorMover();                                                                                                                                                    // 125
		SKYRIM_REL_VR_VIRTUAL bool                               ShouldRespondToActorCollision(const MovementMessageActorCollision& a_msg, const ActorHandlePtr& a_target);                                                              // 126
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL float                CheckClampDamageModifier(ActorValue a_av, float a_delta);                                                                                                               // 127

		static NiPointer<Actor> LookupByHandle(RefHandle a_refHandle);
		static bool             LookupByHandle(RefHandle a_refHandle, NiPointer<Actor>& a_refrOut);

		bool                                    AddAnimationGraphEventSink(BSTEventSink<BSAnimationGraphEvent>* a_sink) const;
		void                                    AddCastPower(SpellItem* a_power);
		bool                                    AddSpell(SpellItem* a_spell);
		void                                    AddToFaction(TESFaction* a_faction, std::int8_t a_rank);
		void                                    AddWornOutfit(BGSOutfit* a_outfit, bool a_forceUpdate);
		void                                    AllowBleedoutDialogue(bool a_canTalk);
		void                                    AllowPCDialogue(bool a_talk);
		void                                    CastPermanentMagic(bool a_wornItemEnchantments, bool a_baseSpells, bool a_raceSpells, bool a_everyActorAbility);
		[[nodiscard]] bool                      CanAttackActor(Actor* a_actor);
		[[nodiscard]] bool                      CanFlyHere() const;
		[[nodiscard]] bool                      CanOfferServices() const;
		[[nodiscard]] bool                      CanPickpocket() const;
		[[nodiscard]] bool                      CanTalkToPlayer() const;
		[[nodiscard]] bool                      CanUseIdle(TESIdleForm* a_idle) const;
		void                                    ClearArrested();
		void                                    ClearExpressionOverride();
		inline void                             ClearExtraArrows() { RemoveExtraArrows3D(); }
		[[nodiscard]] ActorHandle               CreateRefHandle();
		bool                                    Decapitate();
		void                                    DeselectSpell(SpellItem* a_spell);
		void                                    DispelAlteredStates(RE::EffectArchetype a_exception);
		void                                    DispelWornItemEnchantments();
		void                                    DoReset3D(bool a_updateWeight);
		void                                    EnableAI(bool a_enable);
		void                                    EndInterruptPackage(bool a_skipDialogue);
		void                                    EvaluatePackage(bool a_immediate = false, bool a_resetAI = false);
		[[nodiscard]] TESNPC*                   GetActorBase();
		[[nodiscard]] const TESNPC*             GetActorBase() const;
		[[nodiscard]] bool                      IsLeveled() const;
		[[nodiscard]] float                     GetActorValueModifier(ACTOR_VALUE_MODIFIER a_modifier, ActorValue a_value) const;
		[[nodiscard]] float                     GetAimAngle() const;
		[[nodiscard]] float                     GetAimHeading() const;
		[[nodiscard]] InventoryEntryData*       GetAttackingWeapon();
		[[nodiscard]] const InventoryEntryData* GetAttackingWeapon() const;
		[[nodiscard]] bhkCharacterController*   GetCharController() const;
		uint32_t                                GetCollisionFilterInfo(uint32_t& a_outCollisionFilterInfo);
		[[nodiscard]] NiPointer<Actor>          GetCommandingActor() const;
		[[nodiscard]] TESFaction*               GetCrimeFaction();
		[[nodiscard]] const TESFaction*         GetCrimeFaction() const;
		[[nodiscard]] TESPackage*               GetCurrentPackage();
		[[nodiscard]] const TESPackage*         GetCurrentPackage() const;
		[[nodiscard]] TESShout*                 GetCurrentShout();
		[[nodiscard]] const TESShout*           GetCurrentShout() const;
		[[nodiscard]] InventoryEntryData*       GetEquippedEntryData(bool a_leftHand) const;
		[[nodiscard]] TESForm*                  GetEquippedObject(bool a_leftHand) const;
		[[nodiscard]] float                     GetEquippedWeight();
		[[nodiscard]] std::int32_t              GetFactionRank(TESFaction* a_faction, bool a_isPlayer);
		[[nodiscard]] std::int32_t              GetGoldAmount(bool a_noInit = false);
		[[nodiscard]] ActorHandle               GetHandle();
		[[nodiscard]] NiAVObject*               GetHeadPartObject(BGSHeadPart::HeadPartType a_type);
		[[nodiscard]] float                     GetHeight();
		[[nodiscard]] Actor*                    GetKiller() const;
		[[nodiscard]] std::uint16_t             GetLevel() const;
		[[nodiscard]] bool                      GetMount(NiPointer<Actor>& a_outMount);
		[[nodiscard]] bool                      GetMountedBy(NiPointer<Actor>& a_outRider);
		[[nodiscard]] double                    GetMoveDirectionRelativeToFacing();
		[[nodiscard]] ObjectRefHandle           GetOccupiedFurniture() const;
		[[nodiscard]] TESRace*                  GetRace() const;
		[[nodiscard]] bool                      GetRider(NiPointer<Actor>& a_outRider);
		[[nodiscard]] TESObjectARMO*            GetSkin() const;
		[[nodiscard]] TESObjectARMO*            GetSkin(BGSBipedObjectForm::BipedObjectSlot a_slot, bool a_noInit = false);
		[[nodiscard]] SOUL_LEVEL                GetSoulSize() const;
		[[nodiscard]] TESFaction*               GetVendorFaction();
		[[nodiscard]] const TESFaction*         GetVendorFaction() const;
		[[nodiscard]] float                     GetVoiceRecoveryTime();
        [[nodiscard]] float                     GetWarmthRating() const;
		[[nodiscard]] TESObjectARMO*            GetWornArmor(BGSBipedObjectForm::BipedObjectSlot a_slot, bool a_noInit = false);
		[[nodiscard]] TESObjectARMO*            GetWornArmor(FormID a_formID, bool a_noInit = false);
		[[nodiscard]] bool                      HasKeywordString(std::string_view a_formEditorID);
		[[nodiscard]] bool                      HasLineOfSight(TESObjectREFR* a_ref, bool& a_arg2);
		[[nodiscard]] bool                      HasOutfitItems(BGSOutfit* a_outfit);
		[[nodiscard]] bool                      HasPerk(BGSPerk* a_perk) const;
		[[nodiscard]] bool                      HasShout(TESShout* a_shout) const;
		[[nodiscard]] bool                      HasSpell(SpellItem* a_spell) const;
		void                                    InterruptCast(bool a_restoreMagicka) const;
        [[nodiscard]] bool                      IsAttacking() const;
		[[nodiscard]] bool                      IsAIEnabled() const;
		[[nodiscard]] bool                      IsAlarmed() const;
		[[nodiscard]] bool                      IsAMount() const;
		[[nodiscard]] bool                      IsAnimationDriven() const;
		[[nodiscard]] bool                      IsBeingRidden() const;
		[[nodiscard]] bool                      IsBlocking() const;
		[[nodiscard]] bool                      IsCasting(MagicItem* a_spell) const;
		[[nodiscard]] bool                      IsCommandedActor() const;
		[[nodiscard]] bool                      IsCurrentShout(SpellItem* a_power);
		[[nodiscard]] bool                      IsEssential() const;
		[[nodiscard]] bool                      IsFactionInCrimeGroup(const TESFaction* a_faction) const;
		[[nodiscard]] bool                      IsGhost() const;
		[[nodiscard]] bool                      IsGuard() const;
		[[nodiscard]] bool                      IsHostileToActor(Actor* a_actor);
		[[nodiscard]] bool                      IsInCastPowerList(SpellItem* a_power);
		[[nodiscard]] constexpr bool            IsInKillMove() const noexcept { return GetActorRuntimeData().boolFlags.all(BOOL_FLAGS::kIsInKillMove); }
		[[nodiscard]] bool                      IsInMidair() const;
		[[nodiscard]] bool                      IsInRagdollState() const;
		[[nodiscard]] bool                      IsLimbGone(std::uint32_t a_limb);
		[[nodiscard]] bool                      IsMoving() const;
		[[nodiscard]] bool                      IsOnMount() const;
		[[nodiscard]] bool                      IsOverEncumbered() const;
		[[nodiscard]] bool                      IsPlayerTeammate() const;
		[[nodiscard]] bool                      IsProtected() const;
		[[nodiscard]] bool                      IsRunning() const;
		[[nodiscard]] bool                      IsSneaking() const;
		[[nodiscard]] bool                      IsPointSubmergedMoreThan(const NiPoint3& a_pos, TESObjectCELL* a_cell, float a_waterLevel);
		[[nodiscard]] bool                      IsSummoned() const noexcept;
		[[nodiscard]] bool                      IsTrespassing() const;
		void                                    KillImmediate();
		void                                    PlayASound(BSSoundHandle& a_result, FormID a_formID, bool a_unk03, std::uint32_t a_flags);
		void                                    ProcessVATSAttack(MagicCaster* a_caster, bool a_hasTargetAnim, TESObjectREFR* a_target, bool a_leftHand);
		void                                    RemoveAnimationGraphEventSink(BSTEventSink<BSAnimationGraphEvent>* a_sink) const;
		void                                    RemoveCastScroll(SpellItem* a_spell, MagicSystem::CastingSource a_source);
		void                                    RemoveExtraArrows3D();
		void                                    RemoveOutfitItems(BGSOutfit* a_outfit);
		bool                                    RemoveSpell(SpellItem* a_spell);
		[[nodiscard]] std::int32_t              RequestDetectionLevel(Actor* a_target, DETECTION_PRIORITY a_priority = DETECTION_PRIORITY::kNormal);
		bool                                    SetDefaultOutfit(BGSOutfit* a_outfit, bool a_update3D);
		void                                    SetLifeState(ACTOR_LIFE_STATE a_lifeState);
		bool                                    SetSleepOutfit(BGSOutfit* a_outfit, bool a_update3D);
		void                                    SetRotationX(float a_angle);
		void                                    SetRotationZ(float a_angle);
		void                                    StealAlarm(TESObjectREFR* a_ref, TESForm* a_object, std::int32_t a_num, std::int32_t a_total, TESForm* a_owner, bool a_allowWarning);
		void                                    StopAlarmOnActor();
		void                                    StopInteractingQuick(bool a_unk02);
		void                                    StopMoving(float a_delta);
		void                                    SwitchRace(TESRace* a_race, bool a_player);
		void                                    TrespassAlarm(TESObjectREFR* a_ref, TESForm* a_ownership, std::int32_t a_crime);
		void                                    UpdateArmorAbility(TESForm* a_armor, ExtraDataList* a_extraData);
		void                                    UpdateAwakeSound(NiAVObject* a_obj3D);
		void                                    Update3DModel();
		void                                    UpdateHairColor();
		void                                    UpdateSkinColor();
		void                                    UpdateWeaponAbility(TESForm* a_weapon, ExtraDataList* a_extraData, bool a_leftHand);
		void                                    VisitArmorAddon(TESObjectARMO* a_armor, TESObjectARMA* a_arma, std::function<void(bool a_firstPerson, NiAVObject& a_obj)> a_visitor);
		bool                                    VisitFactions(std::function<bool(TESFaction* a_faction, std::int8_t a_rank)> a_visitor);
		void                                    VisitSpells(ForEachSpellVisitor& a_visitor);
		[[nodiscard]] std::uint8_t              WhoIsCasting();
		bool                                    WouldBeStealing(const TESObjectREFR* a_target) const;

		struct ACTOR_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT \
			stl::enumeration<BOOL_BITS, std::uint32_t>            boolBits;                           /* 0E0 */ \
			float                                                 updateTargetTimer;                  /* 0E4 */ \
			stl::enumeration<ACTOR_CRITICAL_STAGE, std::uint32_t> criticalStage;                      /* 0E8 */ \
			std::uint32_t                                         pad0EC;                             /* 0EC */ \
			AIProcess*                                            currentProcess;                     /* 0F0 */ \
			ObjectRefHandle                                       dialogueItemTarget;                 /* 0F8 */ \
			ActorHandle                                           currentCombatTarget;                /* 0FC */ \
			ActorHandle                                           myKiller;                           /* 100 */ \
			float                                                 checkMyDeadBodyTimer;               /* 104 */ \
			float                                                 voiceTimer;                         /* 108 */ \
			float                                                 underWaterTimer;                    /* 10C */ \
			std::int32_t                                          thiefCrimeStamp;                    /* 110 */ \
			std::int32_t                                          actionValue;                        /* 114 */ \
			float                                                 timerOnAction;                      /* 118 */ \
			std::uint32_t                                         unk11C;                             /* 11C */ \
			NiPoint3                                              editorLocCoord;                     /* 120 */ \
			float                                                 editorLocRot;                       /* 12C */ \
			TESForm*                                              editorLocForm;                      /* 130 */ \
			BGSLocation*                                          editorLocation;                     /* 138 */ \
			ActorMover*                                           actorMover;                         /* 140 */ \
			BSTSmartPointer<MovementControllerNPC>                movementController;                 /* 148 */ \
			TESPackage*                                           unk150;                             /* 150 */ \
			CombatController*                                     combatController;                   /* 158 */ \
			TESFaction*                                           vendorFaction;                      /* 160 */ \
			AITimeStamp                                           calculateVendorFactionTimer;        /* 168 */ \
			EmotionType                                           emotionType;                        /* 16C */ \
			std::uint32_t                                         emotionValue;                       /* 170 */ \
			std::uint32_t                                         unk174;                             /* 174 */ \
			std::uint32_t                                         unk178;                             /* 178 */ \
			std::uint32_t                                         intimidateBribeDayStamp;            /* 17C */ \
			std::uint64_t                                         unk180;                             /* 180 */ \
			BSTSmallArray<SpellItem*>                             addedSpells;                        /* 188 */ \
			ActorMagicCaster*                                     magicCasters[SlotTypes::kTotal];    /* 1A0 */ \
			MagicItem*                                            selectedSpells[SlotTypes::kTotal];  /* 1C0 */ \
			TESForm*                                              selectedPower;                      /* 1E0 */ \
			std::uint32_t                                         unk1E8;                             /* 1E8 */ \
			std::uint32_t                                         pad1EC;                             /* 1EC */ \
			TESRace*                                              race;                               /* 1F0 */ \
			float                                                 equippedWeight;                     /* 1F8 */ \
			stl::enumeration<BOOL_FLAGS, std::uint32_t>           boolFlags;                          /* 1FC */ \
			ActorValueStorage                                     avStorage;                          /* 200 */ \
			BGSDialogueBranch*                                    exclusiveBranch;                    /* 220 */ \
			Modifiers                                             healthModifiers;                    /* 228 */ \
			Modifiers                                             magickaModifiers;                   /* 234 */ \
			Modifiers                                             staminaModifiers;                   /* 240 */ \
			Modifiers                                             voicePointsModifiers;               /* 24C */ \
			float                                                 lastUpdate;                         /* 258 */ \
			std::uint32_t                                         lastSeenTime;                       /* 25C */ \
			BSTSmartPointer<BipedAnim>                            biped;                              /* 260 */ \
			float                                                 armorRating;                        /* 268 */ \
			float                                                 armorBaseFactorSum;                 /* 26C */ \
			std::int8_t                                           soundCallBackSet;                   /* 271 */ \
			std::uint8_t                                          unk271;                             /* 270 */ \
			std::uint8_t                                          unk272;                             /* 272 */ \
			std::uint8_t                                          unk273;                             /* 273 */ \
			std::uint32_t                                         unk274;                             /* 274 */ \
			std::uint64_t                                         unk278;                             /* 278 */ \
			std::uint64_t                                         unk280;                             /* 280 */ \
			WinAPI::CRITICAL_SECTION                              unk288;                             /* 288 - havok related */

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline ACTOR_RUNTIME_DATA& GetActorRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<ACTOR_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0xE0, 0xE8);
		}

		[[nodiscard]] inline const ACTOR_RUNTIME_DATA& GetActorRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<ACTOR_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0xE0, 0xE8);
		}

        [[nodiscard]] inline MagicTarget* AsMagicTarget() noexcept {
            return &REL::RelocateMemberIfNewer<MagicTarget>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
        }

        [[nodiscard]] inline const MagicTarget* AsMagicTarget() const noexcept {
            return &REL::RelocateMemberIfNewer<MagicTarget>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
        }

        [[nodiscard]] inline ActorValueOwner* AsActorValueOwner() noexcept {
            return &REL::RelocateMemberIfNewer<ActorValueOwner>(SKSE::RUNTIME_SSE_1_6_629, this, 0xB0, 0xB8);
        }

        [[nodiscard]] inline const ActorValueOwner* AsActorValueOwner() const noexcept {
            return &REL::RelocateMemberIfNewer<ActorValueOwner>(SKSE::RUNTIME_SSE_1_6_629, this, 0xB0, 0xB8);
        }

        [[nodiscard]] inline ActorState* AsActorState() noexcept {
            return &REL::RelocateMemberIfNewer<ActorState>(SKSE::RUNTIME_SSE_1_6_629, this, 0xB8, 0xC0);
        }

        [[nodiscard]] inline const ActorState* AsActorState() const noexcept {
            return &REL::RelocateMemberIfNewer<ActorState>(SKSE::RUNTIME_SSE_1_6_629, this, 0xB8, 0xC0);
        }

        [[nodiscard]] inline BSTEventSink<BSTransformDeltaEvent>* AsBSTransformDeltaEventSink() noexcept {
            return &REL::RelocateMemberIfNewer<BSTEventSink<BSTransformDeltaEvent>>(SKSE::RUNTIME_SSE_1_6_629, this, 0xC8, 0xD0);
        }

        [[nodiscard]] inline const BSTEventSink<BSTransformDeltaEvent>* AsBSTransformDeltaEventSink() const noexcept {
            return &REL::RelocateMemberIfNewer<BSTEventSink<BSTransformDeltaEvent>>(SKSE::RUNTIME_SSE_1_6_629, this, 0xC8, 0xD0);
        }

        [[nodiscard]] inline BSTEventSink<bhkCharacterMoveFinishEvent>* AsCharacterMoveFinishEventSink() noexcept {
            return &REL::RelocateMemberIfNewer<BSTEventSink<bhkCharacterMoveFinishEvent>>(SKSE::RUNTIME_SSE_1_6_629, this, 0xD0, 0xD8);
        }

        [[nodiscard]] inline const BSTEventSink<bhkCharacterMoveFinishEvent>* AsCharacterMoveFinishEventSink() const noexcept {
            return &REL::RelocateMemberIfNewer<BSTEventSink<bhkCharacterMoveFinishEvent>>(SKSE::RUNTIME_SSE_1_6_629, this, 0xD0, 0xD8);
        }

        [[nodiscard]] inline IPostAnimationChannelUpdateFunctor* AsIPostAnimationChannelUpdateFunctor() noexcept {
            return &REL::RelocateMemberIfNewer<IPostAnimationChannelUpdateFunctor>(SKSE::RUNTIME_SSE_1_6_629, this, 0xD8, 0xE0);
        }

        [[nodiscard]] inline const IPostAnimationChannelUpdateFunctor* AsIPostAnimationChannelUpdateFunctor() const noexcept {
            return &REL::RelocateMemberIfNewer<IPostAnimationChannelUpdateFunctor>(SKSE::RUNTIME_SSE_1_6_629, this, 0xD8, 0xE0);
        }

		// members
#ifndef ENABLE_SKYRIM_AE
		RUNTIME_DATA_CONTENT
#endif

	private:
		void        CalculateCurrentVendorFaction() const;
		float       CalcEquippedWeight();
		TESFaction* GetCrimeFactionImpl() const;
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(Actor) == 0x2B0);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/A/ActorCause.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class ActorCause
	{
	public:
		std::int32_t DecRefCount() const
		{
			stl::atomic_ref myRefCount{ refCount };
			return --myRefCount;
		}

		std::int32_t IncRefCount() const
		{
			stl::atomic_ref myRefCount{ refCount };
			return ++myRefCount;
		}

		[[nodiscard]] std::int32_t GetRefCount() const noexcept { return refCount; }

		// members
		ActorHandle                   actor;         // 00
		NiPoint3                      origin;        // 04
		std::uint32_t                 actorCauseID;  // 10
		volatile mutable std::int32_t refCount;      // 14
	};
	static_assert(sizeof(ActorCause) == 0x18);
}


===============================================
File: include/RE/A/ActorEquipManager.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"

namespace RE
{
	class Actor;
	class BGSEquipSlot;
	class ExtraDataList;
	class SpellItem;
	class TESBoundObject;
	class TESShout;

	class ActorEquipManager : public BSTSingletonSDM<ActorEquipManager>
	{
	public:
		static ActorEquipManager* GetSingleton();

		void EquipObject(Actor* a_actor, TESBoundObject* a_object, ExtraDataList* a_extraData = nullptr, std::uint32_t a_count = 1, const BGSEquipSlot* a_slot = nullptr, bool a_queueEquip = true, bool a_forceEquip = false, bool a_playSounds = true, bool a_applyNow = false);
		void EquipShout(Actor* a_actor, TESShout* a_shout);
		void EquipSpell(Actor* a_actor, SpellItem* a_spell, const BGSEquipSlot* a_slot = nullptr);
		bool UnequipObject(Actor* a_actor, TESBoundObject* a_object, ExtraDataList* a_extraData = nullptr, std::uint32_t a_count = 1, const BGSEquipSlot* a_slot = nullptr, bool a_queueEquip = true, bool a_forceEquip = false, bool a_playSounds = true, bool a_applyNow = false, const BGSEquipSlot* a_slotToReplace = nullptr);

		// members
		bool unk01;  // 01
	};
	static_assert(sizeof(ActorEquipManager) == 0x2);
}


===============================================
File: include/RE/A/ActorInventoryEvent.h
===============================================
#pragma once

#include "RE/B/BipedObjects.h"
#include "RE/I/InventoryEvent.h"

namespace RE
{
	struct ActorInventoryEvent
	{
	public:
		// members
		const INVENTORY_EVENT event;       // 00
		BIPED_OBJECT          equipIndex;  // 04
	};
	static_assert(sizeof(ActorInventoryEvent) == 0x08);
}


===============================================
File: include/RE/A/ActorKill.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class Actor;

	struct ActorKill
	{
	public:
		struct Event
		{
		public:
			// members
			Actor* killer;  // 00
			Actor* victim;  // 08
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<Event>* GetEventSource();
	};
}


===============================================
File: include/RE/A/ActorKnowledge.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/F/FightReactions.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class DetectionListener;
	class DetectionState;

	class ActorKnowledge : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorKnowledge;

		enum class FLAGS
		{
			kNone = 0
		};

		~ActorKnowledge() override;  // 00

		// members
		ActorHandle                                     owner;                        // 10
		ActorHandle                                     target;                       // 14
		stl::enumeration<FIGHT_REACTION, std::uint32_t> factionFightReaction;         // 18
		AITimeStamp                                     shouldAttackTargetTimeStamp;  // 1C
		NiPointer<DetectionState>                       detectionState;               // 20
		BSTArray<NiPointer<DetectionListener>>          listeners;                    // 28
		stl::enumeration<FLAGS, std::uint32_t>          flags;                        // 40
		AITimeStamp                                     detectionQueuedTimeStamp;     // 44
	};
	static_assert(sizeof(ActorKnowledge) == 0x48);
}


===============================================
File: include/RE/A/ActorMagicCaster.h
===============================================
#pragma once

#include "RE/B/BGSLoadGameSubBuffer.h"
#include "RE/B/BSTEvent.h"
#include "RE/M/MagicCaster.h"
#include "RE/R/RefAttachTechniqueInput.h"
#include "RE/S/SimpleAnimationGraphManagerHolder.h"

namespace RE
{
	class BGSArtObject;
	class BGSArtObjectCloneTask;
	class BSLight;
	class ReferenceEffectController;

	struct BSAnimationGraphEvent;

	class ActorMagicCaster :
		public MagicCaster,                         // 00
		public SimpleAnimationGraphManagerHolder,   // 48
		public BSTEventSink<BSAnimationGraphEvent>  // 60
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorMagicCaster;

		using InterruptHandler_t = void(Actor*);

		enum class Flags
		{
			kNone = 0,
			kDualCasting = 1 << 0,
			kSkipCheckCast = 1 << 1,
			kStartCloneTask = 1 << 2,
			kCastingArtAttached = 1 << 3,
			kCheckDeferredInterrupt = 1 << 4,
			kDeferInterrupt = 1 << 5
		};

		~ActorMagicCaster() override;  // 00

		// override (MagicCaster)
		void                       RequestCastImpl() override;                                                                                                                           // 03
		bool                       StartChargeImpl() override;                                                                                                                           // 04
		void                       StartReadyImpl() override;                                                                                                                            // 05
		void                       StartCastImpl() override;                                                                                                                             // 06
		void                       FinishCastImpl() override;                                                                                                                            // 07 - { return; }
		void                       InterruptCastImpl(bool a_depleteEnergy) override;                                                                                                     // 08 - { return; }
		void                       SpellCast(bool a_doCast, std::uint32_t a_arg2, MagicItem* a_spell) override;                                                                          // 09 - { return; }
		bool                       CheckCast(MagicItem* a_spell, bool a_dualCast, float* a_alchStrength, MagicSystem::CannotCastReason* a_reason, bool a_useBaseValueForCost) override;  // 0A
		TESObjectREFR*             GetCasterStatsObject() const override;                                                                                                                // 0B - { return actor; }
		Actor*                     GetCasterAsActor() const override;                                                                                                                    // 0C - { return actor; }
		NiNode*                    GetMagicNode() override;                                                                                                                              // 0E - { return magicNode; }
		void                       ClearMagicNode() override;                                                                                                                            // 0F - { magicNode = 0; }
		void                       SetCurrentSpellImpl(MagicItem* a_spell) override;                                                                                                     // 10 - { return; }
		void                       SelectSpellImpl() override;                                                                                                                           // 11 - { return; }
		void                       DeselectSpellImpl() override;                                                                                                                         // 12 - { return; }
		void                       SetSkipCheckCast() override;                                                                                                                          // 13 - { return; }
		void                       SetCastingTimerForCharge() override;                                                                                                                  // 14
		MagicSystem::CastingSource GetCastingSource() const override;                                                                                                                    // 15 - { return castingSource; }
		bool                       GetIsDualCasting() const override;                                                                                                                    // 16 - { return flags & 1; }
		void                       SetDualCasting(bool a_set) override;                                                                                                                  // 17
		void                       SaveGame(BGSSaveGameBuffer* a_buf) override;                                                                                                          // 18
		void                       LoadGame(BGSLoadGameBuffer* a_buf) override;                                                                                                          // 19
		void                       FinishLoadGame(BGSLoadGameBuffer* a_buf) override;                                                                                                    // 1A
		void                       PrepareSound(MagicSystem::SoundID a_sound, MagicItem* a_spell) override;                                                                              // 1B
		void                       AdjustActiveEffect(ActiveEffect* a_activeEffect, float a_power, bool a_arg3) override;                                                                // 1C

		// add
		virtual void Update(float a_delta);  // 1D

		void CheckAttachCastingArt()
		{
			using func_t = decltype(&ActorMagicCaster::CheckAttachCastingArt);
			REL::Relocation<func_t> func{ RELOCATION_ID(33403, 34185) };
			return func(this);
		}

		// members
		RefAttachTechniqueInput                castingArtData;               // 64
		NiPointer<BGSArtObjectCloneTask>       cloneTask;                    // B0
		Actor*                                 actor;                        // B8
		NiNode*                                magicNode;                    // C0
		NiPointer<BSLight>                     light;                        // C8
		InterruptHandler_t*                    interruptHandler;             // D0
		BGSLoadGameSubBuffer                   loadGameSubBuffer;            // D8
		BGSArtObject*                          castingArt;                   // E0
		ReferenceEffectController*             weaponEnchantmentController;  // E8
		float                                  costCharged;                  // F0
		MagicSystem::CastingSource             castingSource;                // F4
		stl::enumeration<Flags, std::uint32_t> flags;                        // F8
	};
	static_assert(sizeof(ActorMagicCaster) == 0x100);
}


===============================================
File: include/RE/A/ActorMover.h
===============================================
#pragma once

namespace RE
{
	class Actor;

	class ActorMover
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorMover;

		virtual ~ActorMover();  // 00

		// add
		virtual void Unk_01(void);  // 01 - { return; }
		virtual void Unk_02(void);  // 02 - { return 0; }
		virtual void Unk_03(void);  // 03 - { return 0; }

		// members
		Actor* actor;  // 08
	};
	static_assert(sizeof(ActorMover) == 0x10);
}


===============================================
File: include/RE/A/ActorPackage.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSPointerHandle.h"

namespace RE
{
	class ActorPackageData;
	class TESPackage;

	class ActorPackage
	{
	public:
		enum class ACTOR_PACKAGE_FLAG
		{
			kNone = 0,
			kSaveLoadSharedPackage = 1 << 0
		};

		// members
		mutable BSSpinLock                                packageLock;            // 00
		TESPackage*                                       package;                // 08
		ActorPackageData*                                 data;                   // 10
		ObjectRefHandle                                   target;                 // 18
		std::int32_t                                      currentProcedureIndex;  // 1C
		float                                             packageStartTime;       // 20
		std::uint32_t                                     modifiedPackageFlag;    // 24
		std::uint16_t                                     modifiedInterruptFlag;  // 28
		stl::enumeration<ACTOR_PACKAGE_FLAG, std::int8_t> actorPackageFlags;      // 2A
		std::int8_t                                       preferredSpeed;         // 2B
		std::uint32_t                                     pad2C;                  // 2C
	};
	static_assert(sizeof(ActorPackage) == 0x30);
}


===============================================
File: include/RE/A/ActorSpeedChannel.h
===============================================
#pragma once

namespace RE
{
	template <class T, class Val>
	class ActorSpeedChannel
	{
	public:
		// members
		std::uint32_t unk00;  // 00
		Val           val;    // 04
		T*            type;   // ??
	};
	static_assert(sizeof(ActorSpeedChannel<void, float>) == 0x10);
}


===============================================
File: include/RE/A/ActorState.h
===============================================
#pragma once

#include "RE/I/IMovementState.h"

namespace RE
{
	enum class ACTOR_LIFE_STATE : std::uint32_t
	{
		kAlive = 0,
		kDying = 1,
		kDead = 2,
		kUnconcious = 3,
		kReanimate = 4,
		kRecycle = 5,
		kRestrained = 6,
		kEssentialDown = 7,
		kBleedout = 8
	};

	enum class ATTACK_STATE_ENUM : std::uint32_t
	{
		kNone = 0,
		kDraw = 1,
		kSwing = 2,
		kHit = 3,
		kNextAttack = 4,
		kFollowThrough = 5,
		kBash = 6,
		kBowDraw = 8,
		kBowAttached = 9,
		kBowDrawn = 10,
		kBowReleasing = 11,
		kBowReleased = 12,
		kBowNextAttack = 13,
		kBowFollowThrough = 14,
		kFire = 15,
		kFiring = 16,
		kFired = 17
	};

	enum class FLY_STATE : std::uint32_t
	{
		kNone = 0,
		kTakeOff = 1,
		kCruising = 2,
		kHovering = 3,
		kLanding = 4,
		kPerching = 5,
		kAction = 6
	};

	enum class KNOCK_STATE_ENUM : std::uint32_t
	{
		kNormal = 0,
		kExplode = 1,
		kExplodeLeadIn = 2,
		kOut = 3,
		kOutLeadIn = 4,
		kQueued = 5,
		kGetUp = 6,
		kDown = 7,
		kWaitForTaskQueue = 8
	};

	enum class SIT_SLEEP_STATE : std::uint32_t
	{
		kNormal = 0,
		kWantToSit = 1,
		kWaitingForSitAnim = 2,

		kIsSitting = 3,
		kRidingMount = static_cast<std::underlying_type_t<SIT_SLEEP_STATE>>(kIsSitting),

		kWantToStand = 4,

		kWantToSleep = 5,
		kWaitingForSleepAnim = 6,
		kIsSleeping = 7,
		kWantToWake = 8
	};

	enum class WEAPON_STATE : std::uint32_t
	{
		kSheathed = 0,
		kWantToDraw = 1,
		kDrawing = 2,
		kDrawn = 3,
		kWantToSheathe = 4,
		kSheathing = 5
	};

	class ActorState : public IMovementState
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorState;

		struct ActorState1
		{
		public:
			// members
			std::uint32_t     movingBack: 1;        // 0:00
			std::uint32_t     movingForward: 1;     // 0:01
			std::uint32_t     movingRight: 1;       // 0:02
			std::uint32_t     movingLeft: 1;        // 0:03
			std::uint32_t     unk04: 2;             // 0:04
			std::uint32_t     walking: 1;           // 0:06
			std::uint32_t     running: 1;           // 0:07
			std::uint32_t     sprinting: 1;         // 0:08
			std::uint32_t     sneaking: 1;          // 0:09
			std::uint32_t     swimming: 1;          // 0:10
			std::uint32_t     unk11: 3;             // 0:11
			SIT_SLEEP_STATE   sitSleepState: 4;     // 0:14
			FLY_STATE         flyState: 3;          // 0:18
			ACTOR_LIFE_STATE  lifeState: 4;         // 0:21
			KNOCK_STATE_ENUM  knockState: 3;        // 0:25
			ATTACK_STATE_ENUM meleeAttackState: 4;  // 0:28
		};
		static_assert(sizeof(ActorState1) == 0x4);

		struct ActorState2
		{
		public:
			// members
			std::uint32_t talkingToPlayer: 1;  // 0:00
			std::uint32_t forceRun: 1;         // 0:01
			std::uint32_t forceSneak: 1;       // 0:02
			std::uint32_t headTracking: 1;     // 0:03
			std::uint32_t reanimating: 1;      // 0:04
			WEAPON_STATE  weaponState: 3;      // 0:05
			std::uint32_t wantBlocking: 1;     // 0:08
			std::uint32_t flightBlocked: 1;    // 0:09
			std::uint32_t recoil: 2;           // 0:10
			std::uint32_t allowFlying: 1;      // 0:12
			std::uint32_t staggered: 1;        // 0:13
			std::uint32_t unk14: 18;           // 0:14
		};
		static_assert(sizeof(ActorState2) == 0x4);

		~ActorState() override;  // 00

		// override (IMovementState)
		void  Unk_01(void) override;          // 01 - { return 0; }
		void  Unk_02(void) override;          // 02 - { return; }
		void  Unk_03(void) override;          // 03 - { return; }
		void  Unk_04(void) override;          // 04 - { return; }
		float DoGetMovementSpeed() override;  // 05 - { return 0.0; }
		void  Unk_06(void) override;          // 06 - { return 0.0; }
		void  Unk_07(void) override;          // 07 - { return; }
		void  Unk_08(void) override;          // 08 - { return 0; }

		// add
		virtual void Unk_14(void);  // 14
		virtual void Unk_15(void);  // 15

		[[nodiscard]] ATTACK_STATE_ENUM GetAttackState() const noexcept { return actorState1.meleeAttackState; }
		[[nodiscard]] FLY_STATE         GetFlyState() const noexcept { return actorState1.flyState; }
		[[nodiscard]] KNOCK_STATE_ENUM  GetKnockState() const noexcept { return actorState1.knockState; }
		[[nodiscard]] ACTOR_LIFE_STATE  GetLifeState() const noexcept { return actorState1.lifeState; }
		[[nodiscard]] SIT_SLEEP_STATE   GetSitSleepState() const noexcept { return actorState1.sitSleepState; }
		[[nodiscard]] WEAPON_STATE      GetWeaponState() const noexcept { return actorState2.weaponState; }

		[[nodiscard]] bool IsBleedingOut() const noexcept
		{
			switch (GetLifeState()) {
			case ACTOR_LIFE_STATE::kEssentialDown:
			case ACTOR_LIFE_STATE::kBleedout:
				return true;
			default:
				return false;
			}
		}

		[[nodiscard]] bool IsFlying() const noexcept
		{
			switch (GetFlyState()) {
			case FLY_STATE::kNone:
			case FLY_STATE::kPerching:
				return false;
			default:
				return true;
			}
		}

		[[nodiscard]] bool IsSneaking() const noexcept { return static_cast<bool>(actorState1.sneaking); }
		[[nodiscard]] bool IsSprinting() const noexcept { return static_cast<bool>(actorState1.sprinting); }
		[[nodiscard]] bool IsSwimming() const noexcept { return static_cast<bool>(actorState1.swimming); }
		[[nodiscard]] bool IsUnconscious() const noexcept { return GetLifeState() == ACTOR_LIFE_STATE::kUnconcious; }
		[[nodiscard]] bool IsWalking() const noexcept { return actorState1.walking; }

		[[nodiscard]] bool IsWeaponDrawn() const noexcept
		{
			switch (GetWeaponState()) {
			case WEAPON_STATE::kDrawn:
			case WEAPON_STATE::kWantToSheathe:
			case WEAPON_STATE::kSheathing:
				return true;
			default:
				return false;
			}
		}

		// members
		ActorState1 actorState1;  // 08
		ActorState2 actorState2;  // 0C
	};
	static_assert(sizeof(ActorState) == 0x10);
}


===============================================
File: include/RE/A/ActorTargetCheck.h
===============================================
#pragma once

#include "RE/P/ProcessLists.h"

namespace RE
{
	class ActorTargetCheck : public ProcessLists::GetActorsFilter
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorTargetCheck;

		~ActorTargetCheck() override;  // 00

		// override (GetActorsFilter)
		bool IsValid(Actor* a_actor) override;  // 01

		// members
		std::uint64_t unk08;  // 08
		std::uint64_t unk10;  // 10
		std::uint64_t unk18;  // 18
	};
	static_assert(sizeof(ActorTargetCheck) == 0x20);
}


===============================================
File: include/RE/A/ActorValueInfo.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"

namespace RE
{
	class BGSSkillPerkTreeNode;

	class ActorValueInfo :
		public TESForm,         // 000
		public TESFullName,     // 020
		public TESDescription,  // 030
		public TESIcon          // 040
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorValueInfo;
		inline static constexpr auto VTABLE = VTABLE_ActorValueInfo;
		inline static constexpr auto FORMTYPE = FormType::ActorValueInfo;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Skill  // AVSK
		{
			float useMult;        // 00
			float offsetMult;     // 04
			float improveMult;    // 08
			float improveOffset;  // 0C
		};
		static_assert(sizeof(Skill) == 0x10);

		~ActorValueInfo() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// override (TESIcon)
		[[nodiscard]] const char* GetDefaultPath() const override;  // 06 - { return "Textures\\"; }

		// members
		const char*           enumName;       // 050
		BSFixedString         abbreviation;   // 058 - ANAM
		std::uint32_t         flags;          // 060
		std::uint32_t         unk064;         // 064
		std::uint64_t         unk068;         // 068
		std::uint32_t         unk070;         // 070
		std::uint32_t         unk074;         // 074
		std::uint32_t         unk078;         // 078
		std::uint32_t         unk07C;         // 07C
		std::uint32_t         unk080;         // 080
		std::uint32_t         unk084;         // 084
		std::uint32_t         unk088;         // 088
		std::uint32_t         unk08C;         // 08C
		std::uint32_t         unk090;         // 090
		std::uint32_t         unk094;         // 094
		std::uint32_t         unk098;         // 098
		std::uint32_t         unk09C;         // 09C
		std::uint32_t         unk0A0;         // 0A0
		std::uint32_t         unk0A4;         // 0A4
		std::uint32_t         unk0A8;         // 0A8
		std::uint32_t         unk0AC;         // 0AC
		std::uint64_t         unk0B0;         // 0B0
		std::uint64_t         unk0B8;         // 0B8
		std::uint64_t         unk0C0;         // 0C0
		std::uint64_t         unk0C8;         // 0C8
		std::uint64_t         unk0D0;         // 0D0
		std::uint64_t         unk0D8;         // 0D8
		std::uint64_t         unk0E0;         // 0E0
		std::uint64_t         unk0E8;         // 0E8
		std::uint64_t         unk0F0;         // 0F0
		std::uint64_t         unk0F8;         // 0F8
		std::uint64_t         unk100;         // 100
		Skill*                skill;          // 108 - AVSK
		std::uint32_t         unk110;         // 110
		std::uint32_t         unk114;         // 114
		BGSSkillPerkTreeNode* perkTree;       // 118
		std::uint32_t         perkTreeWidth;  // 120
		std::uint32_t         unk124;         // 124 - CNAM
	};
	static_assert(sizeof(ActorValueInfo) == 0x128);
}


===============================================
File: include/RE/A/ActorValueList.h
===============================================
#pragma once

#include "RE/A/ActorValueInfo.h"
#include "RE/A/ActorValues.h"

namespace RE
{
	class ActorValueList
	{
	public:
		[[nodiscard]] static ActorValueList* GetSingleton()
		{
			REL::Relocation<ActorValueList**> singleton{ RELOCATION_ID(514139, 400267) };
			return *singleton;
		}

		[[nodiscard]] ActorValueInfo* GetActorValue(ActorValue a_actorValue) const;
		[[nodiscard]] ActorValue      LookupActorValueByName(std::string_view a_enumName) const;

		// members
		std::uint32_t   unk00;                                                // 00
		std::uint32_t   pad04;                                                // 04
		ActorValueInfo* actorValues[stl::to_underlying(ActorValue::kTotal)];  // 08
	};
}

namespace std
{
	[[nodiscard]] inline std::string to_string(RE::ActorValue a_actorValue)
	{
		auto* info = RE::ActorValueList::GetSingleton()->GetActorValue(a_actorValue);
		return info ? info->enumName : "None";
	}

#ifdef __cpp_lib_format
	template <class CharT>
	struct formatter<RE::ActorValue, CharT> : formatter<std::string_view, CharT>
	{
		template <class FormatContext>
		auto format(RE::ActorValue a_actorValue, FormatContext& a_ctx)
		{
			auto* info = RE::ActorValueList::GetSingleton()->GetActorValue(a_actorValue);
			return formatter<std::string_view, CharT>::format(info ? info->enumName : "None", a_ctx);
		}
	};
#endif
}

namespace fmt
{
	template <>
	struct formatter<RE::ActorValue>
	{
		template <class ParseContext>
		constexpr auto parse(ParseContext& a_ctx)
		{
			return a_ctx.begin();
		}

		template <class FormatContext>
		auto format(const RE::ActorValue& a_actorValue, FormatContext& a_ctx)
		{
			auto* info = RE::ActorValueList::GetSingleton()->GetActorValue(a_actorValue);
			return fmt::format_to(a_ctx.out(), "{}", info ? info->enumName : "None");
		}
	};
}


===============================================
File: include/RE/A/ActorValueMeter.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/H/HUDMeter.h"

namespace RE
{
	class ActorValueMeter : public HUDMeter
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorValueMeter;

		~ActorValueMeter() override;  // 00

		// override (HUDMeter)
		bool  ProcessMessage(UIMessage* a_message) override;  // 02
		float GetFillPct() override;                          // 05

		// members
		ActorValue    actorValue;  // 48
		std::uint32_t pad4C;       // 4C
	};
	static_assert(sizeof(ActorValueMeter) == 0x50);
}


===============================================
File: include/RE/A/ActorValueOwner.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"

namespace RE
{
	class ActorValueOwner
	{
	public:
		inline static constexpr auto RTTI = RTTI_ActorValueOwner;

		virtual ~ActorValueOwner();  // 00

		// add
		virtual float              GetActorValue(ActorValue a_akValue);                                                      // 01 - { return 0.0; }
		virtual float              GetPermanentActorValue(ActorValue a_akValue);                                             // 02 - { return 0.0; }
		virtual float              GetBaseActorValue(ActorValue a_akValue);                                                  // 03 - { return 0.0; }
		virtual void               SetBaseActorValue(ActorValue a_akValue, float a_value);                                   // 04 - { return; }
		virtual void               ModActorValue(ActorValue a_akValue, float a_value);                                       // 05 - { return; }
		virtual void               RestoreActorValue(ACTOR_VALUE_MODIFIER a_modifier, ActorValue a_akValue, float a_value);  // 06 - { return; }
		virtual void               SetActorValue(ActorValue a_akValue, float a_value);                                       // 07 - { SetBaseActorValue(a_akValue, a_value); }
		[[nodiscard]] virtual bool GetIsPlayerOwner() const;                                                                 // 08 - { return false; }

		[[nodiscard]] float GetArmorRatingSkillMultiplier(float a_skillLevel) const;
		[[nodiscard]] float GetClampedActorValue(ActorValue a_akValue) const;
	};
	static_assert(sizeof(ActorValueOwner) == 0x8);
}


===============================================
File: include/RE/A/ActorValues.h
===============================================
#pragma once

namespace RE
{
	enum class ActorValue
	{
		kNone = static_cast<std::underlying_type_t<ActorValue>>(-1),
		kAggression = 0,
		kConfidence = 1,
		kEnergy = 2,
		kMorality = 3,
		kMood = 4,
		kAssistance = 5,
		kOneHanded = 6,
		kTwoHanded = 7,
		kArchery = 8,
		kBlock = 9,
		kSmithing = 10,
		kHeavyArmor = 11,
		kLightArmor = 12,
		kPickpocket = 13,
		kLockpicking = 14,
		kSneak = 15,
		kAlchemy = 16,
		kSpeech = 17,
		kAlteration = 18,
		kConjuration = 19,
		kDestruction = 20,
		kIllusion = 21,
		kRestoration = 22,
		kEnchanting = 23,
		kHealth = 24,
		kMagicka = 25,
		kStamina = 26,
		kHealRate = 27,
		kMagickaRate = 28,
		kStaminaRate = 29,
		kSpeedMult = 30,
		kInventoryWeight = 31,
		kCarryWeight = 32,
		kCriticalChance = 33,
		kMeleeDamage = 34,
		kUnarmedDamage = 35,
		kMass = 36,
		kVoicePoints = 37,
		kVoiceRate = 38,
		kDamageResist = 39,
		kPoisonResist = 40,
		kResistFire = 41,
		kResistShock = 42,
		kResistFrost = 43,
		kResistMagic = 44,
		kResistDisease = 45,
		kPerceptionCondition = 46,
		kEnduranceCondition = 47,
		kLeftAttackCondition = 48,
		kRightAttackCondition = 49,
		kLeftMobilityCondition = 50,
		kRightMobilityCondition = 51,
		kBrainCondition = 52,
		kParalysis = 53,
		kInvisibility = 54,
		kNightEye = 55,
		kDetectLifeRange = 56,
		kWaterBreathing = 57,
		kWaterWalking = 58,
		kIgnoreCrippledLimbs = 59,
		kFame = 60,
		kInfamy = 61,
		kJumpingBonus = 62,
		kWardPower = 63,
		kRightItemCharge = 64,
		kArmorPerks = 65,
		kShieldPerks = 66,
		kWardDeflection = 67,
		kVariable01 = 68,
		kVariable02 = 69,
		kVariable03 = 70,
		kVariable04 = 71,
		kVariable05 = 72,
		kVariable06 = 73,
		kVariable07 = 74,
		kVariable08 = 75,
		kVariable09 = 76,
		kVariable10 = 77,
		kBowSpeedBonus = 78,
		kFavorActive = 79,
		kFavorsPerDay = 80,
		kFavorsPerDayTimer = 81,
		kLeftItemCharge = 82,
		kAbsorbChance = 83,
		kBlindness = 84,
		kWeaponSpeedMult = 85,
		kShoutRecoveryMult = 86,
		kBowStaggerBonus = 87,
		kTelekinesis = 88,
		kFavorPointsBonus = 89,
		kLastBribedIntimidated = 90,
		kLastFlattered = 91,
		kMovementNoiseMult = 92,
		kBypassVendorStolenCheck = 93,
		kBypassVendorKeywordCheck = 94,
		kWaitingForPlayer = 95,
		kOneHandedModifier = 96,
		kTwoHandedModifier = 97,
		kMarksmanModifier = 98,
		kBlockModifier = 99,
		kSmithingModifier = 100,
		kHeavyArmorModifier = 101,
		kLightArmorModifier = 102,
		kPickpocketModifier = 103,
		kLockpickingModifier = 104,
		kSneakingModifier = 105,
		kAlchemyModifier = 106,
		kSpeechcraftModifier = 107,
		kAlterationModifier = 108,
		kConjurationModifier = 109,
		kDestructionModifier = 110,
		kIllusionModifier = 111,
		kRestorationModifier = 112,
		kEnchantingModifier = 113,
		kOneHandedSkillAdvance = 114,
		kTwoHandedSkillAdvance = 115,
		kMarksmanSkillAdvance = 116,
		kBlockSkillAdvance = 117,
		kSmithingSkillAdvance = 118,
		kHeavyArmorSkillAdvance = 119,
		kLightArmorSkillAdvance = 120,
		kPickpocketSkillAdvance = 121,
		kLockpickingSkillAdvance = 122,
		kSneakingSkillAdvance = 123,
		kAlchemySkillAdvance = 124,
		kSpeechcraftSkillAdvance = 125,
		kAlterationSkillAdvance = 126,
		kConjurationSkillAdvance = 127,
		kDestructionSkillAdvance = 128,
		kIllusionSkillAdvance = 129,
		kRestorationSkillAdvance = 130,
		kEnchantingSkillAdvance = 131,
		kLeftWeaponSpeedMultiply = 132,
		kDragonSouls = 133,
		kCombatHealthRegenMultiply = 134,
		kOneHandedPowerModifier = 135,
		kTwoHandedPowerModifier = 136,
		kMarksmanPowerModifier = 137,
		kBlockPowerModifier = 138,
		kSmithingPowerModifier = 139,
		kHeavyArmorPowerModifier = 140,
		kLightArmorPowerModifier = 141,
		kPickpocketPowerModifier = 142,
		kLockpickingPowerModifier = 143,
		kSneakingPowerModifier = 144,
		kAlchemyPowerModifier = 145,
		kSpeechcraftPowerModifier = 146,
		kAlterationPowerModifier = 147,
		kConjurationPowerModifier = 148,
		kDestructionPowerModifier = 149,
		kIllusionPowerModifier = 150,
		kRestorationPowerModifier = 151,
		kEnchantingPowerModifier = 152,
		kDragonRend = 153,
		kAttackDamageMult = 154,
		kHealRateMult = 155,
		kMagickaRateMult = 156,
		kStaminaRateMult = 157,
		kWerewolfPerks = 158,
		kVampirePerks = 159,
		kGrabActorOffset = 160,
		kGrabbed = 161,
		kDEPRECATED05 = 162,
		kReflectDamage = 163,

		kTotal
	};

	struct ACTOR_VALUE_MODIFIERS
	{
		enum ACTOR_VALUE_MODIFIER : std::uint32_t
		{
			kPermanent = 0,
			kTemporary = 1,
			kDamage = 2,

			kTotal = 3
		};
	};
	using ACTOR_VALUE_MODIFIER = ACTOR_VALUE_MODIFIERS::ACTOR_VALUE_MODIFIER;
}


===============================================
File: include/RE/A/AddCallbackVisitor.h
===============================================
#pragma once

#include "RE/F/FxDelegate.h"
#include "RE/F/FxDelegateHandler.h"

namespace RE
{
	class AddCallbackVisitor : public FxDelegateHandler::CallbackProcessor
	{
	public:
		inline static constexpr auto RTTI = RTTI_AddCallbackVisitor;

		AddCallbackVisitor(FxDelegateHandler* a_handler, FxDelegate::CallbackHash* a_hash);
		~AddCallbackVisitor() override = default;  // 00

		// override (FxDelegateHandler::CallbackProcessor)
		void Process(const GString& a_methodName, FxDelegateHandler::CallbackFn* a_method) override;  // 01

		// members
		FxDelegateHandler*        handler;  // 08
		FxDelegate::CallbackHash* hash;     // 10
	};
	static_assert(sizeof(AddCallbackVisitor) == 0x18);
}


===============================================
File: include/RE/A/AlchemyItem.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSMessageIcon.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MagicItem.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	class AlchemyItem :
		public MagicItem,                  // 000
		public TESModelTextureSwap,        // 090
		public TESIcon,                    // 0C8
		public BGSMessageIcon,             // 0D8
		public TESWeightForm,              // 0F0
		public BGSEquipType,               // 100
		public BGSDestructibleObjectForm,  // 110
		public BGSPickupPutdownSounds      // 120
	{
	public:
		inline static constexpr auto RTTI = RTTI_AlchemyItem;
		inline static constexpr auto VTABLE = VTABLE_AlchemyItem;
		inline static constexpr auto FORMTYPE = FormType::AlchemyItem;

		enum class AlchemyFlag
		{
			kNone = 0,
			kCostOverride = 1 << 0,
			kFoodItem = 1 << 1,
			kExtendDuration = 1 << 3,
			kMedicine = 1 << 16,
			kPoison = 1 << 17
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kMedicine = 1 << 29
			};
		};

		class Data  // ENIT
		{
		public:
			std::int32_t                                 costOverride;      // 00
			stl::enumeration<AlchemyFlag, std::uint32_t> flags;             // 04
			SpellItem*                                   addictionItem;     // 08
			float                                        addictionChance;   // 10
			std::uint32_t                                pad14;             // 14
			BGSSoundDescriptorForm*                      consumptionSound;  // 18
		};
		static_assert(sizeof(Data) == 0x20);

		~AlchemyItem() override;  // 00

		// override (MagicItem)
		void                                   InitializeData() override;                                             // 04
		void                                   ClearData() override;                                                  // 05
		void                                   InitItemImpl() override;                                               // 13
		[[nodiscard]] MagicSystem::SpellType   GetSpellType() const override;                                         // 53 - { return MagicType::kAlchemy; }
		[[nodiscard]] MagicSystem::CastingType GetCastingType() const override;                                       // 55 - { return CastType::kFireAndForget; }
		[[nodiscard]] MagicSystem::Delivery    GetDelivery() const override;                                          // 57 - { return TargetType::kSelf; }
		[[nodiscard]] bool                     IsFood() const override;                                               // 5D - { return ((GetData()->flags) & 2) && !IsPoison(); }
		[[nodiscard]] bool                     IsPoison() const override;                                             // 61 - { return ((GetData()->flags) >> 17) & 1; }
		[[nodiscard]] bool                     IsMedicine() const override;                                           // 62 - { return ((GetData()->flags) >> 8) >> 8; }
		[[nodiscard]] ActorValue               GetAssociatedSkill() const override;                                   // 66 - { return ActorValue::kConfidence; }
		[[nodiscard]] std::uint32_t            GetChunkID() override;                                                 // 68 - { return 'ENIT'; }
		void                                   CopyMagicItemData(MagicItem* a_src) override;                          // 69
		void                                   LoadMagicItemChunk(TESFile* a_mod, std::uint32_t a_chunkID) override;  // 6A
		[[nodiscard]] const MagicItem::Data*   GetData1() const override;                                             // 6C - { return &effectData; }
		[[nodiscard]] MagicItem::Data*         GetData2() override;                                                   // 6D - { return &effectData; }
		[[nodiscard]] std::uint32_t            GetDataSize() const override;                                          // 6E - { return 0x20; }
		void                                   InitFromChunk(TESFile* a_mod) override;                                // 6F
		void                                   InitChunk() override;                                                  // 70

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05

		// members
		Data    data;         // 138 - ENIT
		TESIcon messageIcon;  // 158
	};
	static_assert(sizeof(AlchemyItem) == 0x168);
}


===============================================
File: include/RE/A/AlchemyMenu.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/C/CraftingSubMenu.h"
#include "RE/I/IMessageBoxCallback.h"

namespace RE::CraftingSubMenus
{
	class AlchemyMenu : public CraftingSubMenu
	{
	public:
		inline static constexpr auto RTTI = RTTI_CraftingSubMenus__AlchemyMenu;

		class QuitMenuCallback : public IMessageBoxCallback
		{
		public:
			inline static constexpr auto RTTI = RTTI_CraftingSubMenus__AlchemyMenu__QuitMenuCallback;

			~QuitMenuCallback() override;  // 00

				// override (IMessageBoxCallback)
				void Run(Message a_msg) override;  // 01

			// members
			AlchemyMenu* subMenu;  // 10
		};
		static_assert(sizeof(QuitMenuCallback) == 0x18);

		class UsableEffectMap
		{
		public:
			std::uint32_t ingredientIndex;               // 00
			std::uint32_t effectIndex;                   // 04
			std::uint32_t nextCompatibleEffectMapIndex;  // 08
		};
		static_assert(sizeof(UsableEffectMap) == 0xC);

			class MenuIngredientEntry
			{
			public:
				InventoryEntryData* ingredient;       // 00
				std::uint8_t        effect1FilterID;  // 09
				std::uint8_t        effect2FilterID;  // 0A
				std::uint8_t        effect3FilterID;  // 0B
				std::uint8_t        effect4FilterID;  // 0C
				std::uint8_t        isSelected;       // 0D
				std::uint8_t        isNotGreyed;      // 0E
				std::uint16_t       padE;             // 0F
			};
			static_assert(sizeof(MenuIngredientEntry) == 0x10);

		class PotionCreationData
		{
		public:
			BSTArray<UsableEffectMap>      usableEffectsMaps;  // 0
			BSTArray<MenuIngredientEntry>* ingredientEntries;  // 18
		};
		static_assert(sizeof(PotionCreationData) == 0x20);

		~AlchemyMenu() override;  // 00

			// override (CraftingSubMenu)
			void Accept(CallbackProcessor* a_cbReg) override;          // 01
			bool ProcessUserEvent(BSFixedString* a_control) override;  // 05

		// members
		RE::BSTArray<MenuIngredientEntry> ingredientsEntries;       // 100
		std::int32_t                      unk118;                   // 118
		std::int32_t                      unk11c;                   // 11c
		std::uint32_t                     ingredientIndex1;         // 120
		std::uint32_t                     ingredientIndex2;         // 124
		std::uint32_t                     ingredientIndex3;         // 128
		std::uint32_t                     unk12c;                   // 12c
		std::uint32_t                     selectedIngredientCount;  // 130
		std::uint32_t                     unk134;                   // 134
		PotionCreationData                potionCreationData;       // 138
		RE::GFxValue                      unk158;                   // 158
		std::uint64_t                     unk170;                   // 170
		RE::TESForm*                      outputPotion;             // 178
		RE::TESForm*                      outputPotion2;            // 180
		std::uint32_t                     unk188;                   // 188
		std::uint32_t                     unk18c;                   // 18c
		RE::BSFixedString                 newRecipeFormatString;    // 190
		std::uint64_t                     playerHasPurityPerk;      // 198
	};
	static_assert(sizeof(AlchemyMenu) == 0x1A0);
}


===============================================
File: include/RE/A/AnimationFileManagerSingleton.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"
#include "RE/H/hkbContext.h"
#include "RE/I/IAnimationClipLoaderSingleton.h"

namespace RE
{
	class hkbClipGenerator;

	class AnimationFileManagerSingleton :
		public IAnimationClipLoaderSingleton,
		public BSTSingletonSDM<AnimationFileManagerSingleton>
	{
	public:
		inline static auto RTTI = RTTI_AnimationFileManagerSingleton;
		inline static auto VTABLE = VTABLE_AnimationFileManagerSingleton;

		virtual ~AnimationFileManagerSingleton() override;  // 00

		// override (IAnimationClipLoaderSingleton)
		virtual void          Unk_01(void) override;                                                                                // 01
		virtual std::uint64_t Load(const hkbContext& a_context, hkbClipGenerator* a_clipGenerator, std::uint64_t a_arg4) override;  // 02
		virtual void          Unk_03(void) override;                                                                                // 03
		virtual void          Unk_04(void) override;                                                                                // 04
		virtual void          Unk_05(void) override;                                                                                // 05
	};
}


===============================================
File: include/RE/A/AnimationObjects.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiAVObject;
	class QueuedAnimationObject;
	class TESObjectANIO;

	class AnimationObject
	{
	public:
		//members
		ObjectRefHandle                  handle;          // 00
		std::uint32_t                    pad04;           // 04
		TESObjectANIO*                   object;          // 08
		NiPointer<NiAVObject>            attachedObject;  // 10
		NiPointer<QueuedAnimationObject> queuedObject;    // 18
		bool                             visible;         // 20
		std::uint8_t                     pad21;           // 21
		std::uint16_t                    pad22;           // 22
		std::uint32_t                    pad24;           // 24
	};
	static_assert(sizeof(AnimationObject) == 0x28);

	class AnimationObjects : public BSTSingletonSDM<AnimationObjects>
	{
	public:
		[[nodiscard]] static AnimationObjects* GetSingleton()
		{
			REL::Relocation<AnimationObjects**> singleton{ RELOCATION_ID(514179, 400328) };
			return *singleton;
		}

		// members
		std::uint8_t                               pad01;             // 01
		std::uint16_t                              pad02;             // 02
		std::uint32_t                              pad04;             // 04
		BSTArray<BSTSmartPointer<AnimationObject>> animationObjects;  // 08
		BSSpinLock                                 lock;              // 20
	};
	static_assert(sizeof(AnimationObjects) == 0x28);
}


===============================================
File: include/RE/A/Archive.h
===============================================
#pragma once

#include "RE/B/BSArchive.h"
#include "RE/B/BSFile.h"
#include "RE/N/NiRefObject.h"

namespace RE
{
	class Archive :
		public BSArchive,   // 190
		public BSFile,      // 000
		public NiRefObject  // 180
	{
	public:
		inline static constexpr auto RTTI = RTTI_Archive;

		~Archive() override;  // 00

		// members
		std::uint64_t unk1C0;  // 1C0
		std::uint64_t unk1C8;  // 1C8
		std::uint64_t unk1D0;  // 1D0
		std::uint64_t unk1D8;  // 1D8
		std::uint64_t unk1E0;  // 1E0
		std::uint64_t unk1E8;  // 1E8
		std::uint64_t unk1F0;  // 1F0
		std::uint64_t unk1F8;  // 1F8
		std::uint64_t unk200;  // 200
		std::uint64_t unk208;  // 208
		std::uint64_t unk210;  // 210
		std::uint64_t unk218;  // 218
		std::uint64_t unk220;  // 220
		std::uint64_t unk228;  // 228
	};
	static_assert(sizeof(Archive) == 0x230);
}


===============================================
File: include/RE/A/ArmorRatingVisitor.h
===============================================
#pragma once

#include "RE/A/ArmorRatingVisitorBase.h"
#include "RE/B/BSTArray.h"

namespace RE
{
	class ArmorRatingVisitor : public ArmorRatingVisitorBase
	{
	public:
		inline static constexpr auto RTTI = RTTI___ArmorRatingVisitor;

		~ArmorRatingVisitor() override;  // 00

		// override (ArmorRatingVisitorBase)
		bool HaveNotVisitedArmor(TESObjectARMO* a_armor) override;  // 04
		void VisitArmor(TESObjectARMO* a_armor) override;           // 05

		// members
		BSScrapArray<TESObjectARMO*> armors;  // 20
	};
	static_assert(sizeof(ArmorRatingVisitor) == 0x40);
}


===============================================
File: include/RE/A/ArmorRatingVisitorBase.h
===============================================
#pragma once

#include "RE/I/InventoryChanges.h"

namespace RE
{
	class ArmorRatingVisitorBase : public InventoryChanges::IItemChangeVisitor
	{
	public:
		inline static constexpr auto RTTI = RTTI___ArmorRatingVisitorBase;

		virtual ~ArmorRatingVisitorBase();  // 00

		// override (InventoryChanges::IItemChangeVisitor)
		BSContainer::ForEachResult Visit(InventoryEntryData* a_entryData) override;  // 01

		// add
		virtual bool HaveNotVisitedArmor(TESObjectARMO* a_armor);  // 04 - { return true; }
		virtual void VisitArmor(TESObjectARMO* a_armor);           // 05 - { return; }

		// members
		Actor* actor;             // 08
		float  armorSum;          // 10
		float  armorPerks;        // 14
		float  lightArmorRating;  // 18
		float  heavyArmorRating;  // 1C
	};
	static_assert(sizeof(ArmorRatingVisitorBase) == 0x20);
}


===============================================
File: include/RE/A/Array.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/T/TypeInfo.h"
#include "RE/V/Variable.h"

namespace RE
{
	namespace BSScript
	{
		class Array : public BSIntrusiveRefCounted
		{
		public:
			using value_type = Variable;
			using size_type = std::uint32_t;
			using difference_type = std::int32_t;
			using reference = value_type&;
			using const_reference = const value_type&;
			using pointer = value_type*;
			using const_pointer = const value_type*;
			using iterator = value_type*;
			using const_iterator = const value_type*;
			using reverse_iterator = std::reverse_iterator<iterator>;
			using const_reverse_iterator = std::reverse_iterator<const_iterator>;

			~Array();

			[[nodiscard]] reference       operator[](size_type a_pos);
			[[nodiscard]] const_reference operator[](size_type a_pos) const;

			[[nodiscard]] reference       front();
			[[nodiscard]] const_reference front() const;

			[[nodiscard]] reference       back();
			[[nodiscard]] const_reference back() const;

			[[nodiscard]] pointer       data() noexcept;
			[[nodiscard]] const_pointer data() const noexcept;

			[[nodiscard]] iterator       begin() noexcept;
			[[nodiscard]] const_iterator begin() const noexcept;
			[[nodiscard]] const_iterator cbegin() const noexcept;

			[[nodiscard]] iterator       end() noexcept;
			[[nodiscard]] const_iterator end() const noexcept;
			[[nodiscard]] const_iterator cend() const noexcept;

			[[nodiscard]] reverse_iterator       rbegin() noexcept;
			[[nodiscard]] const_reverse_iterator rbegin() const noexcept;
			[[nodiscard]] const_reverse_iterator crbegin() const noexcept;

			[[nodiscard]] reverse_iterator       rend() noexcept;
			[[nodiscard]] const_reverse_iterator rend() const noexcept;
			[[nodiscard]] const_reverse_iterator crend() const noexcept;

			[[nodiscard]] bool empty() const noexcept;

			[[nodiscard]] size_type size() const noexcept;

			[[nodiscard]] size_type max_size() const noexcept;

			[[nodiscard]] TypeInfo&       type_info();
			[[nodiscard]] const TypeInfo& type_info() const;

			[[nodiscard]] TypeInfo::RawType type() const;

		private:
			static inline constexpr size_type MAX_SIZE = 128;

			// members
			[[maybe_unused]] std::uint32_t _pad04;        // 04
			TypeInfo                       _elementType;  // 08
			std::uint32_t                  _size;         // 10
			[[maybe_unused]] std::uint32_t _pad14;        // 14
			mutable BSSpinLock             _lock;         // 18
			Variable                       _data[0];      // 20
		};
		static_assert(sizeof(Array) == 0x20);
	}
}


===============================================
File: include/RE/A/ArrowProjectile.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/M/MissileProjectile.h"

namespace RE
{
	class AlchemyItem;
	class EnchantmentItem;

	class ArrowProjectile : public MissileProjectile
	{
	public:
		inline static constexpr auto RTTI = RTTI_ArrowProjectile;
		inline static constexpr auto VTABLE = VTABLE_ArrowProjectile;
		inline static constexpr auto FORMTYPE = FormType::ProjectileArrow;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~ArrowProjectile() override;  // 00

		// override (MissileProjectile)
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
#ifndef SKYRIM_CROSS_VR
		void  PostLoad3D(NiAVObject* a_root) override;                        // AA
		void UpdateImpl(float a_delta) override;           // AB
		bool ProcessImpacts() override;                        // AC
		void Update3D() override;                        // AD
		float GetPowerSpeedMult() const override;                        // AF
		float GetWeaponSpeedMult() const override;                        // B0
		bool  GetStopMainSoundAfterImpact() override;                        // B1 - { return 1; }
		float GetGravity() override;                        // B5
		bool  ShouldBeLimited() override;                        // B9 - { return (unk1CC >> 22) & 1; }
		void  AddImpact(TESObjectREFR* a_ref, const NiPoint3& a_targetLoc, const NiPoint3& a_velocity, hkpCollidable* a_collidable, std::int32_t a_arg6, std::uint32_t a_arg7) override;                        // BD
		void Handle3DLoaded() override;                    // C0
		void Unk_C2(void) override;                        // C2 - { return 1; }
		void Unk_C3(void) override;                        // C3 - { return 1; }
#endif

		struct ARROW_RUNTIME_DATA
		{
#define ARROW_RUNTIME_DATA_CONTENT  \
	EnchantmentItem* enchantItem; /* 1E0, 1E8 */ \
	AlchemyItem*     poison; /* 1E8 */

			ARROW_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline ARROW_RUNTIME_DATA& GetArrowRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<ARROW_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1E0, 0x1E8);
		}

		[[nodiscard]] inline const ARROW_RUNTIME_DATA& GetArrowRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<ARROW_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1E0, 0x1E8);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		ARROW_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(ArrowProjectile) == 0x1F0);
#endif
}
#undef ARROW_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/A/AsyncStream.h
===============================================
#pragma once

#include "RE/S/StreamBase.h"

namespace RE
{
	namespace BSResource
	{
		class AsyncStream : public StreamBase
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource__AsyncStream;

			virtual ~AsyncStream() = default;  // 00

			// add
			virtual void Unk_05(void);  // 05
			virtual void Unk_06(void);  // 06
			virtual void Unk_07(void);  // 07
			virtual void Unk_08(void);  // 08
			virtual void Unk_09(void);  // 09
			virtual void Unk_0A(void);  // 0A

			// members
			std::uint32_t minPacketSize;  // 10
			std::uint32_t pad14;          // 14
		};
		static_assert(sizeof(AsyncStream) == 0x18);
	}
}


===============================================
File: include/RE/A/Atmosphere.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"
#include "RE/S/SkyObject.h"

namespace RE
{
	class BSFogProperty;
	class BSTriShape;
	class NiNode;

	class Atmosphere : public SkyObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_Atmosphere;
		inline static constexpr auto VTABLE = VTABLE_Atmosphere;

		~Atmosphere() override;  // 00

		// override (SkyObject)
		void Update(Sky* a_sky, float a_arg2) override;  // 03

		// add
		virtual void Unk_04(void);  // 04

		// members
		NiPointer<BSTriShape>    atmosphere;         // 10
		NiPointer<BSFogProperty> fog;                // 18
		NiPointer<NiNode>        skyQuadNode;        // 20
		NiPointer<BSTriShape>    skyQuad;            // 28
		bool                     updateFogDistance;  // 30
		std::uint8_t             pad31;              // 31
		std::uint16_t            pad32;              // 31
		std::uint32_t            pad34;              // 34
	};
	static_assert(sizeof(Atmosphere) == 0x38);
}


===============================================
File: include/RE/A/AttachAshPileFunctor.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/D/DelayFunctor.h"

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
	}

	class TESBoundObject;

	namespace SkyrimScript
	{
		class AttachAshPileFunctor : public DelayFunctor
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript____AttachAshPileFunctor;

			~AttachAshPileFunctor() override;  // 00

			// override (DelayFunctor)
			RE::BSScript::Variable operator()() override;                                                              // 01
			bool                   IsLatent() const override;                                                          // 02 - { return false; }
			bool                   SaveImpl(BSStorage& a_storage) const override;                                      // 04
			FunctorType            GetType() const override;                                                           // 05 - { return 14; }
			bool                   LoadImpl(const BSStorage& a_storage, std::uint32_t a_arg2, bool& a_arg3) override;  // 06

			// members
			ActorHandle                                targetActor;  // 10
			std::uint32_t                              pad14;        // 14
			TESBoundObject*                            ashObject;    // 18
			BSTSmartPointer<BSScript::IVirtualMachine> vm;           // 20
		};
		static_assert(sizeof(AttachAshPileFunctor) == 0x28);
	}
}


===============================================
File: include/RE/A/AttachLightHitEffectVisitor.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class NiAVObject;

	class AttachLightHitEffectVisitor : public ActiveEffect::ForEachHitEffectVisitor
	{
	public:
		inline static constexpr auto RTTI = RTTI___AttachLightHitEffectVisitor;

		~AttachLightHitEffectVisitor() override;  // 00

		// override (ActiveEffect::ForEachHitEffectVisitor)
		BSContainer::ForEachResult operator()(ReferenceEffect* a_hitEffect) override;  // 01

		// members
		NiAVObject*   attachRoot;       // 08
		NiAVObject*   attachLightNode;  // 10
		bool          allAttached;      // 18
		std::uint8_t  pad19;            // 19
		std::uint16_t pad1A;            // 1A
		std::uint32_t pad1C;            // 1C
	};
	static_assert(sizeof(AttachLightHitEffectVisitor) == 0x20);
}


===============================================
File: include/RE/A/AttachTechniqueInput.h
===============================================
#pragma once

#include "RE/M/MagicSystem.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiNode;

	namespace BSAttachTechniques
	{
		struct AttachTechniqueInput
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSAttachTechniques__AttachTechniqueInput;

			virtual ~AttachTechniqueInput();  // 00

			// add
			virtual void Unk_01(void);  // 01

			// members
			NiPointer<NiNode>          current3DRoot;  // 08 - smart ptr
			NiPointer<NiNode>          attachedArt;    // 10 - smart ptr
			MagicSystem::CastingSource castingSource;  // 18
			std::uint32_t              unk1C;          // 1C
		};
		static_assert(sizeof(AttachTechniqueInput) == 0x20);
	}
}


===============================================
File: include/RE/A/AttachedScript.h
===============================================
#pragma once

#include "RE/B/BSTPointerAndFlags.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/O/Object.h"

namespace RE
{
	namespace BSScript
	{
		namespace Internal
		{
			class AttachedScript : public BSTPointerAndFlags<BSTSmartPointer<Object>, 1>
			{
			public:
			};
			static_assert(sizeof(AttachedScript) == 0x8);
		}
	}
}


===============================================
File: include/RE/A/AttackAnimationArrayMap.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/N/NiRefObject.h"
#include "RE/S/SetEventData.h"

namespace RE
{
	class AttackAnimationArrayMap :
		public NiRefObject,                                              // 00
		public BSTHashMap<std::uint32_t, BSTArray<SetEventData> const*>  // 10
	{
	public:
		inline static constexpr auto RTTI = RTTI_AttackAnimationArrayMap;

		// hash key (hiword = right hand | loward = left hand)
		enum HashKey : std::uint32_t
		{
			kHandToHandMelee,
			kOneHandSword,
			kOneHandDagger,
			kOneHandAxe,
			kOneHandMace,
			kTwoHandSword,
			kTwoHandAxe,
			kBow,
			kStaff,
			kCrossbow,
			kSpell,
			kShield
		};

		virtual ~AttackAnimationArrayMap();  // 00
	};
	static_assert(sizeof(AttackAnimationArrayMap) == 0x40);
}


===============================================
File: include/RE/A/AttackBlockHandler.h
===============================================
#pragma once

#include "RE/H/HeldStateHandler.h"

namespace RE
{
	struct AttackBlockHandler : public HeldStateHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_AttackBlockHandler;

		enum class AttackType : std::uint8_t
		{
			kRight = 0,
			kLeft = 1,
			kDual = 2
		};

		~AttackBlockHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04
		void UpdateHeldStateActive(const ButtonEvent* a_event) override;                // 05
		void SetHeldStateActive(bool a_flag) override;                                  // 06

		// members
		std::uint32_t heldTimeMs;                  // 18
		std::uint32_t unk1C;                       // 1C
		BSFixedString controlID;                   // 20
		AttackType    attackType;                  // 28
		std::uint8_t  pad29;                       // 29
		std::uint16_t pad2A;                       // 2A
		std::uint8_t  attackCount;                 // 2C
		float         initialPowerAttackDelay;     // 30
		std::uint32_t pad34;                       // 34
		float         subsequentPowerAttackDelay;  // 38
		bool          ignore;                      // 40
		bool          unk41;                       // 41
		bool          heldLeft;                    // 42
		bool          heldRight;                   // 43
		std::uint32_t unk44;                       // 44
	};
	static_assert(sizeof(AttackBlockHandler) == 0x48);
}


===============================================
File: include/RE/A/AutoMoveHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	struct AutoMoveHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_AutoMoveHandler;

		~AutoMoveHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04
	};
	static_assert(sizeof(AutoMoveHandler) == 0x10);
}


===============================================
File: include/RE/A/AutoRegisterCreator.h
===============================================
#pragma once

#include "RE/A/AutoRegisterFactory.h"
#include "RE/B/BSTDerivedCreator.h"

namespace RE
{
	// 08
	template <class Derived, class Manager>
	struct AutoRegisterCreator : public AutoRegisterFactory<BSTDerivedCreator<Derived, typename Manager::mapped_type>, Manager>
	{
	public:
		virtual ~AutoRegisterCreator();  // 00
	};
}


===============================================
File: include/RE/A/AutoRegisterFactory.h
===============================================
#pragma once

namespace RE
{
	// auto registers the factory with the manager
	template <class Parent, class Manager>
	class AutoRegisterFactory : public Parent
	{
	public:
		static_assert(sizeof(AutoRegisterFactory) == 0x8);
		virtual ~AutoRegisterFactory();  // 00
	};
}


===============================================
File: include/RE/A/ahkpCharacterProxy.h
===============================================
#pragma once

#include "RE/H/hkpCharacterProxy.h"

namespace RE
{
	class ahkpCharacterProxy : public hkpCharacterProxy
	{
	public:
		inline static constexpr auto RTTI = RTTI_ahkpCharacterProxy;

		~ahkpCharacterProxy() override;  // 00

		// members
		std::uint64_t unk0F0;  // 0F0
		std::uint64_t unk0F8;  // 0F8
	};
	static_assert(sizeof(ahkpCharacterProxy) == 0x100);
}


===============================================
File: include/RE/A/ahkpWorld.h
===============================================
#pragma once

#include "RE/H/hkpWorld.h"

namespace RE
{
	class ahkpWorld : public hkpWorld
	{
	public:
		inline static constexpr auto RTTI = RTTI_ahkpWorld;

		~ahkpWorld() override;  // 00

		// members
		std::uint64_t unk430;  // 430
		std::uint64_t unk438;  // 438
	};
	static_assert(sizeof(ahkpWorld) == 0x440);
}


===============================================
File: include/RE/B/BGSAbilityPerkEntry.h
===============================================
#pragma once

#include "RE/B/BGSPerkEntry.h"

namespace RE
{
	class SpellItem;

	class BGSAbilityPerkEntry : public BGSPerkEntry
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAbilityPerkEntry;
		inline static constexpr auto VTABLE = VTABLE_BGSAbilityPerkEntry;

		~BGSAbilityPerkEntry() override;  // 03

		// override (BGSPerkEntry)
		PERK_ENTRY_TYPE GetType() const override;                  // 04 - { return kAbility; }
		void            InitItem(TESFile* a_owner) override;       // 06
		bool            Load(TESFile* a_file) override;            // 07
		void            ApplyPerkEntry(Actor* a_actor) override;   // 0A
		void            RemovePerkEntry(Actor* a_actor) override;  // 0B

		// members
		SpellItem* ability;  // 10
	};
	static_assert(sizeof(BGSAbilityPerkEntry) == 0x18);
}


===============================================
File: include/RE/B/BGSAcousticSpace.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"

namespace RE
{
	class BGSAcousticSpace : public TESBoundObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAcousticSpace;
		inline static constexpr auto VTABLE = VTABLE_BGSAcousticSpace;
		inline static constexpr auto FORMTYPE = FormType::AcousticSpace;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSAcousticSpace() override;  // 00

		// override (TESBoundObject)
		void        InitializeData() override;                 // 04
		bool        Load(TESFile* a_mod) override;             // 06
		void        InitItemImpl() override;                   // 13
		void        UnClone3D(TESObjectREFR* a_ref) override;  // 41
		NiAVObject* Clone3D(TESObjectREFR* a_ref) override;    // 4A - { return 0; }

		// members
		BGSSoundDescriptorForm* loopingSound;  // 30 - SNAM
		TESRegion*              soundRegion;   // 38 - RDAT - interiors only
		BGSReverbParameters*    reverbType;    // 40 - BNAM
	};
	static_assert(sizeof(BGSAcousticSpace) == 0x48);
}


===============================================
File: include/RE/B/BGSAction.h
===============================================
#pragma once

#include "RE/B/BGSKeyword.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSAction : public BGSKeyword
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAction;
		inline static constexpr auto VTABLE = VTABLE_BGSAction;
		inline static constexpr auto FORMTYPE = FormType::Action;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSAction() override;  // 00

		// members
		std::uint32_t index;  // 28
		std::uint32_t pad2C;  // 2C
	};
	static_assert(sizeof(BGSAction) == 0x30);
}


===============================================
File: include/RE/B/BGSActionData.h
===============================================
#pragma once

#include "RE/A/ActionInput.h"
#include "RE/A/ActionOutput.h"

namespace RE
{
	class BGSActionData :
		public ActionInput,  // 00
		public ActionOutput  // 28
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSActionData;
		inline static constexpr auto VTABLE = VTABLE_BGSActionData;

		virtual ~BGSActionData() override;  // 00

		// add
		virtual BGSActionData* Clone() const;  // 04
		virtual bool           Process();      // 05 - { return false; }

		// members
		uint32_t flags;  // 58
	};
	static_assert(sizeof(BGSActionData) == 0x60);
}


===============================================
File: include/RE/B/BGSActorCellEvent.h
===============================================
#pragma once

#include "RE/B/BGSActorEvent.h"

namespace RE
{
	struct BGSActorCellEvent : public BGSActorEvent
	{
		enum class CellFlag
		{
			kEnter = 0,
			kLeave = 1
		};

		FormID                                    cellID;
		stl::enumeration<CellFlag, std::uint32_t> flags;
	};
	static_assert(sizeof(BGSActorCellEvent) == 0xC);
}


===============================================
File: include/RE/B/BGSActorEvent.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"

namespace RE
{
	struct BGSActorEvent
	{
	public:
		// members
		ActorHandle actor;  // 0
	};
	static_assert(sizeof(BGSActorEvent) == 0x4);
}


===============================================
File: include/RE/B/BGSAddToPlayerInventoryEvent.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"

namespace RE
{
	class BGSLocation;
	class TESForm;

	enum class AQUIRE_TYPE
	{
		kNone = 0,
		kSteal = 1,
		kBuy = 2,
		kPickPocket = 3,
		kPickup = 4,
		kContainer = 5,
		kDeadBody = 6
	};

	class BGSAddToPlayerInventoryEvent
	{
	public:
		[[nodiscard]] static std::uint32_t& GetIndex()
		{
			REL::Relocation<std::uint32_t*> index{ RELOCATION_ID(508412, 380074) };
			return *index;
		}

		// members
		ObjectRefHandle                              ownerRef;                           // 0x00
		ObjectRefHandle                              containerRef;                       // 0x04
		BGSLocation*                                 location{ nullptr };                // 0x08
		TESForm*                                     itemBase{ nullptr };                // 0x10
		stl::enumeration<AQUIRE_TYPE, std::uint32_t> acquireType{ AQUIRE_TYPE::kNone };  // 0x18
	};
	static_assert(sizeof(BGSAddToPlayerInventoryEvent) == 0x20);
}


===============================================
File: include/RE/B/BGSAddonNode.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	struct ADDON_DATA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kAlwaysLoaded = 3
		};

		// members
		std::uint16_t                        masterParticleCap;  // 0
		stl::enumeration<Flag, std::uint8_t> flags;              // 2
		std::uint8_t                         pad3;               // 3
	};
	static_assert(sizeof(ADDON_DATA) == 0x4);

	class BGSAddonNode :
		public TESBoundObject,      // 00
		public TESModelTextureSwap  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAddonNode;
		inline static constexpr auto VTABLE = VTABLE_BGSAddonNode;
		inline static constexpr auto FORMTYPE = FormType::AddonNode;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSAddonNode() override;  // 00

		// override (TESBoundObject)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		std::uint32_t           index;  // 68 - DATA
		std::uint32_t           pad6C;  // 6C
		BGSSoundDescriptorForm* sound;  // 70 - SNAM
		ADDON_DATA              data;   // 78 - DNAM
		std::uint32_t           pad7C;  // 7C
	};
	static_assert(sizeof(BGSAddonNode) == 0x80);
}


===============================================
File: include/RE/B/BGSAnimationSequencer.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"

namespace RE
{
	class BGSActionData;

	class BGSAnimationSequencer
	{
	public:
		// members
		std::uint32_t                             numSequences;  // 00
		std::uint32_t                             pad04;         // 04
		BSTHashMap<BSFixedString, BGSActionData*> actions;       // 08
	};
	static_assert(sizeof(BGSAnimationSequencer) == 0x38);
}


===============================================
File: include/RE/B/BGSApparatus.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESObjectMISC.h"
#include "RE/T/TESQualityForm.h"

namespace RE
{
	class BGSApparatus :
		public TESObjectMISC,   // 000
		public TESQualityForm,  // 100
		public TESDescription   // 110
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSApparatus;
		inline static constexpr auto VTABLE = VTABLE_BGSApparatus;
		inline static constexpr auto FORMTYPE = FormType::Apparatus;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSApparatus() override;  // 00

		// override (TESObjectMISC)
		bool Load(TESFile* a_mod) override;  // 06
	};
	static_assert(sizeof(BGSApparatus) == 0x120);
}


===============================================
File: include/RE/B/BGSArtObject.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	class BGSArtObject :
		public TESBoundObject,      // 00
		public TESModelTextureSwap  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSArtObject;
		inline static constexpr auto VTABLE = VTABLE_BGSArtObject;
		inline static constexpr auto FORMTYPE = FormType::ArtObject;

		enum class ArtType
		{
			kMagicCastingArt = 0,
			kMagicHitEffect = 1,
			kMagicEnchantEffect = 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Data  // DNAM
		{
		public:
			// members
			stl::enumeration<ArtType, std::uint32_t> artType;  // 0
		};
		static_assert(sizeof(Data) == 0x4);

		~BGSArtObject() override;  // 00

		// override (TESBoundObject)
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		Data          data;   // 68 - DNAM
		std::uint32_t pad6C;  // 6C
	};
	static_assert(sizeof(BGSArtObject) == 0x70);
}


===============================================
File: include/RE/B/BGSAssociationType.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSAssociationType : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAssociationType;
		inline static constexpr auto VTABLE = VTABLE_BGSAssociationType;
		inline static constexpr auto FORMTYPE = FormType::AssociationType;

		enum class FLAGS  // DATA
		{
			kNone = 0,
			kFamily = 1 << 0
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Members
		{
			enum
			{
				kParent,
				kChild,

				kTotal
			};
		};

		struct Sexes
		{
			enum
			{
				kMale,
				kFemale,

				kTotal
			};
		};

		~BGSAssociationType() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06

		// members
		BSFixedString                          associationLabels[Members::kTotal][Sexes::kTotal];  // 20 - MPRT - FCHT
		stl::enumeration<FLAGS, std::uint32_t> flags;                                              // 40 - DATA
		std::uint32_t                          pad44;                                              // 44
	};
	static_assert(sizeof(BGSAssociationType) == 0x48);
}


===============================================
File: include/RE/B/BGSAttackData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	struct AttackData  // ATKD
	{
	public:
		enum class AttackFlag
		{
			kNone = 0,
			kIgnoreWeapon = 1 << 0,
			kBashAttack = 1 << 1,
			kPowerAttack = 1 << 2,
			kChargeAttack = 1 << 3,
			kRotatingAttack = 1 << 4,
			kContinuousAttack = 1 << 5,
			kOverrideData = 1 << 31
		};

		// members
		float                                       damageMult;     // 00
		float                                       attackChance;   // 04
		SpellItem*                                  attackSpell;    // 08
		stl::enumeration<AttackFlag, std::uint32_t> flags;          // 10
		float                                       attackAngle;    // 14
		float                                       strikeAngle;    // 18
		float                                       staggerOffset;  // 1C
		BGSKeyword*                                 attackType;     // 20
		float                                       knockDown;      // 28
		float                                       recoveryTime;   // 2C
		float                                       staminaMult;    // 30
		std::uint32_t                               pad34;          // 34
	};
	static_assert(sizeof(AttackData) == 0x38);

	NiSmartPointer(BGSAttackData);

	class BGSAttackData : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAttackData;

		~BGSAttackData() override;  // 00

		[[nodiscard]] bool IsLeftAttack() const;

		// members
		BSFixedString event;  // 10 - ATKE
		AttackData    data;   // 18 - ATKD
	};
	static_assert(sizeof(BGSAttackData) == 0x50);
}


===============================================
File: include/RE/B/BGSAttackDataForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSAttackDataMap;

	class BGSAttackDataForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAttackDataForm;

		~BGSAttackDataForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { return; }
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		NiPointer<BGSAttackDataMap> attackDataMap;  // 08
	};
	static_assert(sizeof(BGSAttackDataForm) == 0x10);
}


===============================================
File: include/RE/B/BGSAttackDataMap.h
===============================================
#pragma once

#include "RE/B/BGSAttackData.h"
#include "RE/B/BSTHashMap.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	NiSmartPointer(BGSAttackDataMap);

	class BGSAttackDataMap : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSAttackDataMap;

		~BGSAttackDataMap() override;  // 00

		// members
		BSTHashMap<BSFixedString, NiPointer<BGSAttackData>> attackDataMap;    // 10
		TESRace*                                            defaultDataRace;  // 40 - ATKR
	};
	static_assert(sizeof(BGSAttackDataMap) == 0x48);
}


===============================================
File: include/RE/B/BGSBaseAlias.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	class TESFile;
	class TESForm;
	class TESQuest;

	class BGSBaseAlias
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSBaseAlias;
		inline static auto           VMTYPEID = static_cast<VMTypeID>(139);

		enum class FLAGS
		{
			kNone = 0,
			kReserves = 1 << 0,
			kOptional = 1 << 1,
			kQuestObject = 1 << 2,
			kAllowReuse = 1 << 3,
			kAllowDead = 1 << 4,
			kLoadedOnly = 1 << 5,
			kEssential = 1 << 6,
			kAllowDisabled = 1 << 7,
			kStoreName = 1 << 8,
			kAllowReserved = 1 << 9,
			kProtected = 1 << 10,
			kForcedFromAlias = 1 << 11,
			kAllowDestroyed = 1 << 12,
			kFindPlayerClosest = 1 << 13,
			kUsesNames = 1 << 14,
			kInitiallyDisabled = 1 << 15,
			kAllowCleared = 1 << 16,
			kClearNameOnRemove = 1 << 17,
			kActorsOnly = 1 << 18,
			kTransient = 1 << 19,
			kExternalLink = 1 << 20,
			kNoPickpocket = 1 << 21,
			kDataAlias = 1 << 22,
			kSceneOptional = 1 << 24,
			kCreateIn = 1 << 31  // BGSRefAlias
		};

		enum class FILL_TYPE  // BGSRefAlias
		{
			kConditions = 0,
			kForced = 1,
			kFromAlias = 2,
			kFromEvent = 3,
			kCreated = 4,
			kFromExternal = 5,
			kUniqueActor = 6,
			kNearAlias = 7
		};

		virtual ~BGSBaseAlias();  // 00

		// add
		virtual bool                               Load(TESFile* a_mod) = 0;       // 01
		virtual void                               InitItem(TESForm* a_form) = 0;  // 02
		[[nodiscard]] virtual const BSFixedString& QType() const = 0;              // 03

		[[nodiscard]] const BSFixedString& GetTypeString() const;
		[[nodiscard]] VMTypeID             GetVMTypeID() const;
		[[nodiscard]] bool                 IsEssential() const;
		[[nodiscard]] bool                 IsProtected() const;
		[[nodiscard]] bool                 IsQuestObject() const;
		void                               SetEssential(bool a_set);
		void                               SetProtected(bool a_set);

		// members
		BSFixedString                              aliasName;    // 08 - ALID
		TESQuest*                                  owningQuest;  // 10
		std::uint32_t                              aliasID;      // 18 - ALST/ALLS
		stl::enumeration<FLAGS, std::uint32_t>     flags;        // 1C - FNAM
		stl::enumeration<FILL_TYPE, std::uint16_t> fillType;     // 20
		std::uint16_t                              pad22;        // 22
		std::uint32_t                              pad24;        // 24
	};
	static_assert(sizeof(BGSBaseAlias) == 0x28);
}


===============================================
File: include/RE/B/BGSBehaviorGraphModel.h
===============================================
#pragma once

#include "RE/T/TESModel.h"

namespace RE
{
	class BGSBehaviorGraphModel : public TESModel
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSBehaviorGraphModel;

		~BGSBehaviorGraphModel() override;  // 00

		// override (TESModel)
		void SetModel(const char* a_model) override;  // 05
	};
	static_assert(sizeof(BGSBehaviorGraphModel) == 0x28);
}


===============================================
File: include/RE/B/BGSBipedObjectForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	struct BIPED_MODEL  // BOD2
	{
	public:
		enum class BipedObjectSlot
		{
			kNone = 0,
			kHead = 1 << 0,
			kHair = 1 << 1,
			kBody = 1 << 2,
			kHands = 1 << 3,
			kForearms = 1 << 4,
			kAmulet = 1 << 5,
			kRing = 1 << 6,
			kFeet = 1 << 7,
			kCalves = 1 << 8,
			kShield = 1 << 9,
			kTail = 1 << 10,
			kLongHair = 1 << 11,
			kCirclet = 1 << 12,
			kEars = 1 << 13,
			kModMouth = 1 << 14,
			kModNeck = 1 << 15,
			kModChestPrimary = 1 << 16,
			kModBack = 1 << 17,
			kModMisc1 = 1 << 18,
			kModPelvisPrimary = 1 << 19,
			kDecapitateHead = 1 << 20,
			kDecapitate = 1 << 21,
			kModPelvisSecondary = 1 << 22,
			kModLegRight = 1 << 23,
			kModLegLeft = 1 << 24,
			kModFaceJewelry = 1 << 25,
			kModChestSecondary = 1 << 26,
			kModShoulder = 1 << 27,
			kModArmLeft = 1 << 28,
			kModArmRight = 1 << 29,
			kModMisc2 = 1 << 30,
			kFX01 = 1 << 31
		};

		enum class ArmorType
		{
			kLightArmor,
			kHeavyArmor,
			kClothing
		};

		// members
		stl::enumeration<BipedObjectSlot, std::uint32_t> bipedObjectSlots;  // 0
		stl::enumeration<ArmorType, std::uint32_t>       armorType;         // 4
	};
	static_assert(sizeof(BIPED_MODEL) == 0x8);

	class BGSBipedObjectForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSBipedObjectForm;

		using ArmorType = BIPED_MODEL::ArmorType;
		using BipedObjectSlot = BIPED_MODEL::BipedObjectSlot;
		using FirstPersonFlag = BIPED_MODEL::BipedObjectSlot;

		~BGSBipedObjectForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		BipedObjectSlot               AddSlotToMask(BipedObjectSlot a_slot);
		[[nodiscard]] ArmorType       GetArmorType() const;
		[[nodiscard]] BipedObjectSlot GetSlotMask() const;
		[[nodiscard]] bool            HasPartOf(BipedObjectSlot a_flag) const;
		[[nodiscard]] bool            IsClothing() const;
		[[nodiscard]] bool            IsHeavyArmor() const;
		[[nodiscard]] bool            IsLightArmor() const;
		[[nodiscard]] bool            IsShield() const;
		BipedObjectSlot               RemoveSlotFromMask(BipedObjectSlot a_slot);
		void                          SetSlotMask(BipedObjectSlot a_mask);

		// members
		BIPED_MODEL bipedModelData;  // 08 - BOD2
	};
	static_assert(sizeof(BGSBipedObjectForm) == 0x10);
}


===============================================
File: include/RE/B/BGSBlockBashData.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSBlockBashData : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSBlockBashData;

		~BGSBlockBashData() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { impact = 0; material = 0; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		BGSImpactDataSet* blockBashImpactDataSet;  // 08 - BIDS
		BGSMaterialType*  altBlockMaterialType;    // 10 - BAMT
	};
	static_assert(sizeof(BGSBlockBashData) == 0x18);
}


===============================================
File: include/RE/B/BGSBodyPartData.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BGSBodyPartDefs.h"
#include "RE/B/BGSPreloadable.h"
#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiPoint3.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESModelPSA.h"

namespace RE
{
	struct PART_DATA  // BPND
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kSeverable = 1 << 0,
			kIKData = 1 << 1,
			kIKData_BipedData = 1 << 2,
			kExplodable = 1 << 3,
			kIKData_IsHead = 1 << 4,
			kIKData_HeadTracking = 1 << 5,
			kToHitChance_Absolute = 1 << 6
		};

		// members
		float                                                      damageMult;                   // 00
		stl::enumeration<Flag, std::uint8_t>                       flags;                        // 04
		stl::enumeration<BGSBodyPartDefs::LIMB_ENUM, std::uint8_t> type;                         // 05
		std::int8_t                                                healthPercent;                // 06
		stl::enumeration<ActorValue, std::uint8_t>                 actorValue;                   // 07
		std::int8_t                                                toHitChance;                  // 08
		std::int8_t                                                explosionChance;              // 09
		std::int8_t                                                explosionGenericDebrisCount;  // 0A
		std::uint8_t                                               pad0B;                        // 0B
		std::uint32_t                                              pad0C;                        // 0C
		BGSDebris*                                                 explosionGenericDebris;       // 10
		BGSExplosion*                                              explosion;                    // 18
		float                                                      trackingMaxAngle;             // 20
		float                                                      explosionGenericDebrisScale;  // 24
		std::int8_t                                                dismemberGenericDebrisCount;  // 28
		std::int8_t                                                unk29;                        // 29
		std::uint16_t                                              unk2A;                        // 2A
		std::uint32_t                                              unk2C;                        // 2C
		BGSDebris*                                                 dismemberGenericDebris;       // 30
		BGSExplosion*                                              dismemberExplosion;           // 38
		float                                                      dismemberGenericDebrisScale;  // 40
		NiPoint3                                                   goreTranslate;                // 44
		NiPoint3                                                   goreRotate;                   // 50
		std::uint32_t                                              pad5C;                        // 5C
		BGSImpactDataSet*                                          dismemberImpactDataSet;       // 60
		BGSImpactDataSet*                                          explosionImpactDataSet;       // 68
		std::int8_t                                                dismemberDecalCount;          // 70
		std::int8_t                                                explosionDecalCount;          // 71
		std::uint16_t                                              pad72;                        // 72
		float                                                      explosionSpecialDebrisScale;  // 74
	};
	static_assert(sizeof(PART_DATA) == 0x78);

	class BGSBodyPart
	{
	public:
		// members
		BSFixedString nodeName;                   // 00 - BPNN
		BSFixedString targetName;                 // 08 - BPNT
		BSFixedString hitReactionVariablePrefix;  // 10 - BPNI
		BSFixedString partName;                   // 18 - BPTN
		BSFixedString goreObjectName;             // 20 - NAM4
		TESModel      explosionSpecialDebris;     // 28 - NAM1
		TESModelPSA   poseMatching;               // 50 - PNAM
		PART_DATA     data;                       // 78 - BPND
	};
	static_assert(sizeof(BGSBodyPart) == 0xF0);

	class BGSBodyPartData :
		public TESForm,        // 00
		public TESModel,       // 20
		public BGSPreloadable  // 48
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSBodyPartData;
		inline static constexpr auto VTABLE = VTABLE_BGSBodyPartData;
		inline static constexpr auto FORMTYPE = FormType::BodyPartData;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSBodyPartData() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BGSBodyPart* parts[BGSBodyPartDefs::LIMB_ENUM::kTotal];  // 50
		BGSRagdoll*  ragdoll;                                    // 80
	};
	static_assert(sizeof(BGSBodyPartData) == 0x88);
}


===============================================
File: include/RE/B/BGSBodyPartDefs.h
===============================================
#pragma once

namespace RE
{
	namespace BGSBodyPartDefs
	{
		struct LIMB_ENUMS
		{
			enum LIMB_ENUM
			{
				kNone = static_cast<std::underlying_type_t<LIMB_ENUM>>(-1),
				kTorso = 0,
				kHead,
				kEye,
				kLookAt,
				kFlyGrab,
				kSaddle,

				kTotal
			};
		};
		using LIMB_ENUM = LIMB_ENUMS::LIMB_ENUM;
	}
}


===============================================
File: include/RE/B/BGSCameraPath.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class NiFormArray;

	struct PATH_DATA  // DATA
	{
		enum class PathFlags
		{
			kNone = 0,
			kZoomDisable = 1 << 0,
			kZoomShotList = 1 << 1,
			kDynamicTimes = 1 << 2,
			kRandomPaths = 1 << 6,
			kAllowNoShots = 1 << 7
		};

		stl::enumeration<PathFlags, std::uint8_t> flags;  // 0
	};
	static_assert(sizeof(PATH_DATA) == 0x1);

	class BGSCameraPath : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSCameraPath;
		inline static constexpr auto VTABLE = VTABLE_BGSCameraPath;
		inline static constexpr auto FORMTYPE = FormType::CameraPath;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Relatives
		{
			enum Relative
			{
				kParent,
				kPreviousSibling,

				kTotal
			};
		};

		~BGSCameraPath() override;  // 00

		// override (TESForm)
		void     InitializeData() override;                                          // 04
		void     ClearData() override;                                               // 05
		bool     Load(TESFile* a_mod) override;                                      // 06
		TESForm* CreateDuplicateForm(bool a_createEditorID, void* a_arg2) override;  // 09
		void     InitItemImpl() override;                                            // 13

		// members
		TESCondition                 conditions;  // 20
		BSSimpleList<BGSCameraShot*> shots;       // 28 - SNAM
		PATH_DATA                    data;        // 38 - DATA
		std::uint8_t                 pad39;       // 39
		std::uint16_t                pad3A;       // 3A
		std::uint32_t                pad3C;       // 3C
		NiFormArray*                 childPaths;  // 40
		BGSCameraPath*               parentPath;  // 48 - ANAM~
		BGSCameraPath*               prevPath;    // 48 - ~ANAM
	};
	static_assert(sizeof(BGSCameraPath) == 0x58);
}


===============================================
File: include/RE/B/BGSCameraShot.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESImageSpaceModifiableForm.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class BGSCameraShot :
		public TESForm,                     // 00
		public TESModel,                    // 20
		public TESImageSpaceModifiableForm  // 48
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSCameraShot;
		inline static constexpr auto VTABLE = VTABLE_BGSCameraShot;
		inline static constexpr auto FORMTYPE = FormType::CameraShot;

		enum class CAM_ACTION
		{
			kShoot = 0,
			kFly = 1,
			kHit = 2,
			kZoom = 3
		};

		enum class CAM_OBJECT
		{
			kAttacker = 0,
			kProjectile = 1,
			kTarget = 2,
			kLeadActor = 3
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct CAMERA_SHOT_DATA  // DATA
		{
		public:
			enum class Flag
			{
				kNone = 0,
				kPositionFollowsLocation = 1 << 0,
				kRotationFollowsTarget = 1 << 1,
				kDontFollowBone = 1 << 2,
				kFirstPersonCamera = 1 << 3,
				kNoTracer = 1 << 4,
				kStartAtTimeZero = 1 << 5
			};

			// members
			stl::enumeration<CAM_ACTION, std::uint32_t> cameraAction;                // 00
			stl::enumeration<CAM_OBJECT, std::uint32_t> location;                    // 04
			stl::enumeration<CAM_OBJECT, std::uint32_t> target;                      // 08
			stl::enumeration<Flag, std::uint32_t>       flags;                       // 0C
			float                                       playerTimeMult;              // 10
			float                                       targetTimeMult;              // 14
			float                                       globalTimeMult;              // 18
			float                                       maxTime;                     // 1C
			float                                       minTime;                     // 20
			float                                       targetPercentBetweenActors;  // 24
			float                                       nearTargetDistance;          // 28
		};
		static_assert(sizeof(CAMERA_SHOT_DATA) == 0x2C);

		~BGSCameraShot() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		CAMERA_SHOT_DATA      data;   // 58 - DATA
		std::uint32_t         pad84;  // 84
		void*                 unk88;  // 88 - smart ptr
		void*                 unk90;  // 90 - smart ptr
		RefHandle             unk98;  // 98
		std::uint32_t         unk9C;  // 9C
		void*                 unkA0;  // A0 - smart ptr
		NiPointer<NiAVObject> unkA8;  // A8 - smart ptr
		std::uint8_t          unkB0;  // B0
		bool                  unkB1;  // B1
		std::uint16_t         padB2;  // B2
		std::uint32_t         padB4;  // B4
		void*                 unkB8;  // B8
	};
	static_assert(sizeof(BGSCameraShot) == 0xC0);
}


===============================================
File: include/RE/B/BGSCollisionLayer.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/C/Color.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSCollisionLayer :
		public TESForm,        // 00
		public TESDescription  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSCollisionLayer;
		inline static constexpr auto VTABLE = VTABLE_BGSCollisionLayer;
		inline static constexpr auto FORMTYPE = FormType::CollisionLayer;

		enum class FLAG  // GNAM
		{
			kNone = 0,
			kTriggerVolume = 1 << 0,
			kSensor = 1 << 1,
			kNavmeshObstacle = 1 << 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSCollisionLayer() override;  // 00

		// override (TESForm)
		void ClearData() override;            // 05
		bool Load(TESFile* a_mod) override;   // 06
		void InitItemImpl() override;         // 13
		void SetDelete(bool a_set) override;  // 23 - { TESForm::SetDelete(a_set); }

		// members
		std::uint32_t                         collisionIdx;  // 30 - BNAM
		Color                                 debugColor;    // 34 - FNAM
		stl::enumeration<FLAG, std::uint32_t> flags;         // 38 - GNAM
		std::uint32_t                         pad3C;         // 3C
		BSFixedString                         name;          // 40 - MNAM
		BSTArray<BGSCollisionLayer*>          collidesWith;  // 48 - CNAM
	};
	static_assert(sizeof(BGSCollisionLayer) == 0x60);
}


===============================================
File: include/RE/B/BGSColorForm.h
===============================================
#pragma once

#include "RE/C/Color.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class BGSColorForm :
		public TESForm,     // 00
		public TESFullName  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSColorForm;
		inline static constexpr auto VTABLE = VTABLE_BGSColorForm;
		inline static constexpr auto FORMTYPE = FormType::ColorForm;

		enum class Flag  // FNAM
		{
			kNone = 0,
			kPlayable = 1 << 0
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSColorForm() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06

		[[nodiscard]] bool IsPlayable() const;

		// memebrs
		Color                                 color;  // 30 - CNAM
		stl::enumeration<Flag, std::uint32_t> flags;  // 34 - FNAM
	};
	static_assert(sizeof(BGSColorForm) == 0x38);
}


===============================================
File: include/RE/B/BGSConstructibleObject.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESContainer.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSConstructibleObject : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSConstructibleObject;
		inline static constexpr auto VTABLE = VTABLE_BGSConstructibleObject;
		inline static constexpr auto FORMTYPE = FormType::ConstructibleObject;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct ConstructibleObjectData
		{
			std::uint16_t numConstructed;  // 0 - NAM1
		};
		static_assert(sizeof(ConstructibleObjectData) == 0x2);

		~BGSConstructibleObject() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		TESContainer            requiredItems;  // 20
		TESCondition            conditions;     // 38
		TESForm*                createdItem;    // 40 - CNAM
		BGSKeyword*             benchKeyword;   // 48 - BNAM
		ConstructibleObjectData data;           // 50
		std::uint16_t           pad52;          // 52
		std::uint32_t           unk54;          // 54
	};
	static_assert(sizeof(BGSConstructibleObject) == 0x58);
}


===============================================
File: include/RE/B/BGSCreatedObjectManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"
#include "RE/E/Effect.h"

namespace RE
{
	class MagicItem;
	class EnchantmentItem;

	class BGSCreatedObjectManager : public BSTSingletonSDM<BGSCreatedObjectManager>
	{
	public:
		struct CreatedMagicItemData
		{
			MagicItem*             magicItem;  // 00
			volatile std::uint32_t refCount;   // 08
			std::uint32_t          pad0C;      // 0C
		};
		static_assert(sizeof(CreatedMagicItemData) == 0x10);

		static BGSCreatedObjectManager* GetSingleton();

		EnchantmentItem* AddArmorEnchantment(BSTArray<Effect>& a_effects);
		EnchantmentItem* AddWeaponEnchantment(BSTArray<Effect>& a_effects);

		// members
		std::uint8_t                                    pad01;               // 01
		std::uint16_t                                   pad02;               // 02
		std::uint32_t                                   pad04;               // 03
		BSTArray<CreatedMagicItemData>                  weaponEnchantments;  // 08
		BSTArray<CreatedMagicItemData>                  armorEnchantments;   // 20
		BSTHashMap<std::uint32_t, CreatedMagicItemData> potions;             // 38
		BSTHashMap<std::uint32_t, CreatedMagicItemData> poisons;             // 68
		BSTSet<MagicItem*>                              queuedDeletes;       // 98
		mutable BSSpinLock                              lock;                // C8
	};
	static_assert(sizeof(BGSCreatedObjectManager) == 0xD0);
}


===============================================
File: include/RE/B/BGSDebris.h
===============================================
#pragma once

#include "RE/B/BGSPreloadable.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/I/ID.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct BGSDebrisData
	{
	public:
		BGSDebrisData();
		BGSDebrisData(const char* a_fileName);

		~BGSDebrisData() = default;

		enum class BGSDebrisDataFlags
		{
			kNone = 0,
			kCollisionData = 1 << 0
		};

		// members
		std::int8_t                                        percentage;  // 00 - DATA~
		stl::enumeration<BGSDebrisDataFlags, std::uint8_t> flags;       // 01 - ~DATA
		std::uint16_t                                      pad02;       // 02
		std::uint32_t                                      pad04;       // 04
		const char*                                        fileName;    // 08
		BSTArray<BSResource::ID>                           textureIDs;  // 10 - MODT
		BSTArray<std::uint32_t>                            addons;      // 28
	};
	static_assert(sizeof(BGSDebrisData) == 0x40);

	class BGSDebris :
		public TESForm,        // 00
		public BGSPreloadable  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSDebris;
		inline static constexpr auto VTABLE = VTABLE_BGSDebris;
		inline static constexpr auto FORMTYPE = FormType::Debris;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSDebris() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04 - { return; }
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06

		// members
		BSSimpleList<BGSDebrisData*> data;  // 28
	};
	static_assert(sizeof(BGSDebris) == 0x38);
}


===============================================
File: include/RE/B/BGSDecalEmitter.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSImpactData;
	class BSTempEffectParticle;

	class BGSDecalEmitter
	{
	public:
		// members
		std::int32_t                    unk00;            // 00
		bool                            unk04;            // 04
		bool                            pad05;            // 05
		std::uint16_t                   pad06;            // 06
		BGSImpactData*                  impactData;       // 08
		NiPointer<BSTempEffectParticle> particleEmitter;  // 10
	};
	static_assert(sizeof(BGSDecalEmitter) == 0x18);
}


===============================================
File: include/RE/B/BGSDecalGroup.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSTextureSet;
	class NiAVObject;
	class NiNode;
	class TESObjectCELL;

	struct DECAL_CREATION_DATA
	{
	public:
		// members
		NiPoint3              origin;         // 00
		NiPoint3              direction;      // 0C
		NiPoint3              surfaceNormal;  // 18
		ObjectRefHandle       objRef;         // 24
		NiPointer<NiAVObject> avObj;          // 28
		NiNode*               clone;          // 30
		BGSTextureSet*        texSet;         // 38
		BGSTextureSet*        texSet2;        // 40
		std::uint64_t         unk48;          // 48
		std::uint64_t         unk50;          // 50
		float                 unk58;          // 58
		std::uint32_t         unk5C;          // 5C
		std::uint64_t         unk60;          // 60
		float                 unk68;          // 68
		std::uint32_t         unk6C;          // 6C
		std::uint64_t         unk70;          // 70
		float                 unk78;          // 78
		std::uint32_t         unk7C;          // 7C
		TESObjectCELL*        parentCell;     // 80
		std::uint64_t         unk88;          // 88
		std::uint64_t         unk90;          // 90
		float                 unk98;          // 98
		float                 unk9C;          // 9C
		float                 unkA0;          // A0
		float                 unkA4;          // A4
		std::uint32_t         unkA8;          // A8
		float                 unkAC;          // AC
		std::uint32_t         unkB0;          // B0
		std::uint16_t         unkB4;          // B4
		std::uint8_t          unkB6;          // B6
		std::uint8_t          unkB7;          // B7
		std::uint16_t         unkB8;          // B8
		std::uint8_t          unkBA;          // BA
		std::uint8_t          unkBB;          // BB
		std::uint16_t         unkBC;          // BC
		std::uint8_t          unkBE;          // BE
		std::uint32_t         unkC0;          // C0
		std::uint32_t         padC4;          // C4
	};
	static_assert(sizeof(DECAL_CREATION_DATA) == 0xC8);

	struct BGSDecalGroup
	{
	public:
		// members
		bool                           permanentGroup;  // 00
		bool                           manualSaveLoad;  // 01
		std::uint16_t                  pad02;           // 02
		std::uint32_t                  pad04;           // 04
		BSTArray<std::uint32_t>        decalGroups;     // 08
		BSTArray<DECAL_CREATION_DATA*> pendingDecals;   // 20
	};
	static_assert(sizeof(BGSDecalGroup) == 0x38);
}


===============================================
File: include/RE/B/BGSDecalManager.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSDecalEmitter;
	class BGSDecalNode;
	class BSShaderAccumulator;
	class BSTempEffect;
	class NiCamera;

	class BGSDecalManager
	{
	public:
		static BGSDecalManager* GetSingleton()
		{
			REL::Relocation<BGSDecalManager**> singleton{ RELOCATION_ID(514414, 400561) };
			return *singleton;
		}

		// members
		std::uint32_t                        unk00;                       // 00
		std::uint32_t                        decalCountCurrentFrame;      // 04
		std::uint32_t                        skinDecalCountCurrentFrame;  // 08
		std::uint32_t                        decalCount;                  // 0C
		std::uint32_t                        skinDecalCount;              // 10
		bool                                 unk14;                       // 14
		std::uint8_t                         pad15;                       // 15
		std::uint16_t                        pad16;                       // 16
		BSTArray<NiPointer<BSTempEffect>>    decals;                      // 18
		BSTArray<NiPointer<BGSDecalEmitter>> decalEmitters;               // 30
		BSTArray<NiPointer<BGSDecalNode>>    decalNodes;                  // 48
		BSTArray<NiPointer<BSTempEffect>>    unk60;                       // 60
		NiPointer<NiCamera>                  camera;                      // 78
		NiPointer<BSShaderAccumulator>       shaderAccumulator;           // 80
		std::uint32_t                        unk88;                       // 88
	};
	static_assert(sizeof(BGSDecalManager) == 0x90);
};


===============================================
File: include/RE/B/BGSDecalNode.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiNode.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSTempEffect;

	class BGSDecalNode : public NiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSDecalNode;
		inline static auto           Ni_RTTI = NiRTTI_BGSDecalNode;

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                              \
	BSTArray<NiPointer<BSTempEffect>> decals;    /* 00 */ \
	bool                              isSkinned; /* 18 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x20);

		~BGSDecalNode() override;  // 00

		// override (NiNode)
		const NiRTTI* GetRTTI() const override;                            // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;   // 17
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D
#ifndef SKYRIM_CROSS_VR
		// The following are virtual functions past the point where VR compatibility breaks.
		void OnVisible(NiCullingProcess& a_process) override;  // 34
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL std::uint8_t Unk_3E();                                               // 3E - { return 1; }
		SKYRIM_REL_VR_VIRTUAL void         AttachDecal(BSTempEffect* a_decal, bool a_firstAvail);  // 3F

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BGSDecalNode) == 0x148);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BGSDecalNode) == 0x170);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BGSDefaultObjectManager.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct DEFAULT_OBJECTS
	{
		enum DEFAULT_OBJECT
		{
			kWerewolfSpell = 0,
			kSittingAngleLimit = 1,
			kAllowPlayerShout = 2,
			kGold = 3,
			kLockpick = 4,
			kSkeletonKey = 5,
			kPlayerFaction = 6,
			kGuardFaction = 7,
			kDefaultMusic = 8,
			kBattleMusic = 9,
			kDeathMusic = 10,
			kSuccessMusic = 11,
			kLevelUpMusic = 12,
			kDungeonClearedMusic = 13,
			kPlayerVoiceMale = 14,
			kPlayerVoiceMaleChild = 15,
			kPlayerVoiceFemale = 16,
			kPlayerVoiceFemaleChild = 17,
			kEatPackageDefaultFood = 18,
			kLeftHandEquip = 19,
			kRightHandEquip = 20,
			kEitherHandEquip = 21,
			kVoiceEquip = 22,
			kPotionEquip = 23,
			kEveryActorAbility = 24,
			kCommandedActorAbility = 25,
			kDrugWearsOffImageSpace = 26,
			kFootstepSet = 27,
			kLandscapeMaterial = 28,
			kDragonLandZoneMarker = 29,
			kDragonCrashZoneMarker = 30,
			kCombatStyle = 31,
			kDefaultPackList = 32,
			kWaitForDialoguePackage = 33,
			kLocRefTypeBoss = 34,
			kVirtualLocation = 35,
			kPersistAllLocation = 36,
			kInventoryPlayer = 37,
			kPathingTestNPC = 38,
			kFavorCostSmall = 39,
			kFavorCostMedium = 40,
			kFavorCostLarge = 41,
			kFavorGiftsPerDay = 42,
			kActionSwimStateChange = 43,
			kActionLook = 44,
			kActionLeftAttack = 45,
			kActionLeftReady = 46,
			kActionLeftRelease = 47,
			kActionLeftInterrupt = 48,
			kActionRightAttack = 49,
			kActionRightReady = 50,
			kActionRightRelease = 51,
			kActionRightInterrupt = 52,
			kActionDualAttack = 53,
			kActionDualRelease = 54,
			kActionActivate = 55,
			kActionJump = 56,
			kActionFall = 57,
			kActionLand = 58,
			kActionSneak = 59,
			kActionVoice = 60,
			kActionVoiceReady = 61,
			kActionVoiceRelease = 62,
			kActionVoiceInterrupt = 63,
			kActionIdle = 64,
			kActionSprintStart = 65,
			kActionSprintStop = 66,
			kActionDraw = 67,
			kActionSheath = 68,
			kActionLeftPowerAttack = 69,
			kActionRightPowerAttack = 70,
			kActionDualPowerAttack = 71,
			kActionStaggerStart = 72,
			kActionBlockHit = 73,
			kActionBlockAnticipate = 74,
			kActionRecoil = 75,
			kActionLargeRecoil = 76,
			kActionBleedoutStart = 77,
			kActionBleedoutStop = 78,
			kActionIdleStop = 79,
			kActionWardHit = 80,
			kActionForceEquip = 81,
			kActionShieldChange = 82,
			kActionPathStart = 83,
			kActionPathEnd = 84,
			kActionLargeMovementDelta = 85,
			kActionFlyStart = 86,
			kActionFlyStop = 87,
			kActionHoverStart = 88,
			kActionHoverStop = 89,
			kActionBumpedInto = 90,
			kActionSummonedStart = 91,
			kActionTalkingIdle = 92,
			kActionListenIdle = 93,
			kActionDeath = 94,
			kActionDeathWait = 95,
			kActionIdleWarn = 96,
			kActionMoveStart = 97,
			kActionMoveStop = 98,
			kActionTurnRight = 99,
			kActionTurnLeft = 100,
			kActionTurnStop = 101,
			kActionMoveForward = 102,
			kActionMoveBackward = 103,
			kActionMoveLeft = 104,
			kActionMoveRight = 105,
			kActionResetAnimationGraph = 106,
			kActionKnockdown = 107,
			kActionGetUp = 108,
			kActionIdleStopInstant = 109,
			kActionRagdollInstant = 110,
			kActionWaterwalkStart = 111,
			kActionReload = 112,
			kPickupSoundGeneric = 113,
			kPutdownSoundGeneric = 114,
			kPickupSoundWeapon = 115,
			kPutdownSoundWeapon = 116,
			kPickupSoundArmor = 117,
			kPutdownSoundArmor = 118,
			kPickupSoundBook = 119,
			kPutdownSoundBook = 120,
			kPickupSoundIngredient = 121,
			kPutdownSoundIngredient = 122,
			kHarvestSound = 123,
			kHarvestFailedSound = 124,
			kWardBreakSound = 125,
			kWardAbsorbSound = 126,
			kWardDeflectSound = 127,
			kMagicFailSound = 128,
			kShoutFailSound = 129,
			kHeartbeatSoundFast = 130,
			kHeartbeatSoundSlow = 131,
			kImagespaceLowHealth = 132,
			kSoulCapturedSound = 133,
			kNoActivationSound = 134,
			kMapMenuLoopingSound = 135,
			kDialogueVoiceCategory = 136,
			kNonDialogueVoiceCategory = 137,
			kSFXToFadeInDialogueCategory = 138,
			kPauseDuringMenuCategoryFade = 139,
			kPauseDuringMenuCategoryImmediate = 140,
			kPauseDuringLoadingMenuCategory = 141,
			kMusicSoundCategory = 142,
			kStatsMuteCategory = 143,
			kStatsMusic = 144,
			kMasterSoundCategory = 145,
			kTimeSensitiveSoundCategory = 146,
			kDialogueOutputModel3D = 147,
			kDialogueOutputModel2D = 148,
			kPlayersOutputModel1stPerson = 149,
			kPlayersOutputModel3rdPerson = 150,
			kInterfaceOutputModel = 151,
			kReverbType = 152,
			kUnderwaterLoopSound = 153,
			kUnderwaterReverbType = 154,
			kKeywordHorse = 155,
			kKeywordUndead = 156,
			kKeywordNPC = 157,
			kKeywordBeastRace = 158,
			kKeywordDummyObject = 159,
			kKeywordUseGeometryEmitter = 160,
			kKeywordMustStop = 161,
			kKeywordUpdateDuringArchery = 162,
			kKeywordSkipOutfitItems = 163,
			kMaleFaceTextureSetHead = 164,
			kMaleFaceTextureSetMouth = 165,
			kMaleFaceTextureSetEyes = 166,
			kFemaleFaceTextureSetHead = 167,
			kFemaleFaceTextureSetMouth = 168,
			kFemaleFaceTextureSetEyes = 169,
			kImageSpaceModifierforinventorymenu = 170,
			kPackagetemplate = 171,
			kMainMenuCell = 172,
			kDefaultMovementTypeWalk = 173,
			kDefaultMovementTypeRun = 174,
			kDefaultMovementTypeSwim = 175,
			kDefaultMovementTypeFly = 176,
			kDefaultMovementTypeSneak = 177,
			kDefaultMovementTypeSprint = 178,
			kKeywordSpecialFurniture = 179,
			kKeywordFurnitureForces1stPerson = 180,
			kKeywordFurnitureForces3rdPerson = 181,
			kKeywordActivatorFurnitureNoPlayer = 182,
#ifndef ENABLE_SKYRIM_VR
			kTelekinesisGrabSound = 183,
			kTelekinesisThrowSound = 184,
			kWorldMapWeather = 185,
			kHelpManualPC = 186,
			kHelpManualXBox = 187,
			kKeywordTypeAmmo = 188,
			kKeywordTypeArmor = 189,
			kKeywordTypeBook = 190,
			kKeywordTypeIngredient = 191,
			kKeywordTypeKey = 192,
			kKeywordTypeMisc = 193,
			kKeywordTypeSoulGem = 194,
			kKeywordTypeWeapon = 195,
			kKeywordTypePotion = 196,
			kBaseWeaponEnchantment = 197,
			kBaseArmorEnchantment = 198,
			kBasePotion = 199,
			kBasePoison = 200,
			kKeywordDragon = 201,
			kKeywordMovable = 202,
			kArtObjectAbsorbEffect = 203,
			kWeaponMaterialList = 204,
			kArmorMaterialList = 205,
			kKeywordDisallowEnchanting = 206,
			kFavortravelmarkerlocation = 207,
			kKeywordHoldLocation = 208,
			kKeywordCivilWarOwner = 209,
			kKeywordCivilWarNeutral = 210,
			kLocRefTypeCivilWarSoldier = 211,
			kKeywordClearableLocation = 212,
			kLocRefTypeResourceDestructible = 213,
			kFormListHairColorList = 214,
			kComplexSceneObject = 215,
			kKeywordReusableSoulGem = 216,
			kKeywordAnimal = 217,
			kKeywordDaedra = 218,
			kKeywordRobot = 219,
			kKeywordNirnroot = 220,
			kFightersGuildFaction = 221,
			kMagesGuildFaction = 222,
			kThievesGuildFaction = 223,
			kDarkBrotherhoodFaction = 224,
			kJarlFaction = 225,
			kBunnyFaction = 226,
			kPlayerIsVampireVariable = 227,
			kPlayerIsWerewolfVariable = 228,
			kRoadMarker = 229,
			kKeywordScaleActorTo10 = 230,
			kKeywordVampire = 231,
			kKeywordForge = 232,
			kKeywordCookingPot = 233,
			kKeywordSmelter = 234,
			kKeywordTanningRack = 235,
			kHelpBasicLockpickingPC = 236,
			kHelpBasicLockpickingConsole = 237,
			kHelpBasicForging = 238,
			kHelpBasicCooking = 239,
			kHelpBasicSmelting = 240,
			kHelpBasicTanning = 241,
			kHelpBasicObjectCreation = 242,
			kHelpBasicEnchanting = 243,
			kHelpBasicSmithingWeapon = 244,
			kHelpBasicSmithingArmor = 245,
			kHelpBasicAlchemy = 246,
			kHelpBarter = 247,
			kHelpLevelingup = 248,
			kHelpSkillsMenu = 249,
			kHelpMapMenu = 250,
			kHelpJournal = 251,
			kHelpLowHealth = 252,
			kHelpLowMagicka = 253,
			kHelpLowStamina = 254,
			kHelpJail = 255,
			kHelpTeamateFavor = 256,
			kHelpWeaponCharge = 257,
			kHelpFavorites = 258,
			kKinectHelpFormList = 259,
			kHelpFlyingMount = 260,
			kHelpTargetLock = 261,
			kHelpAttackTarget = 262,
			kImagespaceLoadscreen = 263,
			kKeywordWeaponMaterialDaedric = 264,
			kKeywordWeaponMaterialDraugr = 265,
			kKeywordWeaponMaterialDraugrHoned = 266,
			kKeywordWeaponMaterialDwarven = 267,
			kKeywordWeaponMaterialEbony = 268,
			kKeywordWeaponMaterialElven = 269,
			kKeywordWeaponMaterialFalmer = 270,
			kKeywordWeaponMaterialFalmerHoned = 271,
			kKeywordWeaponMaterialGlass = 272,
			kKeywordWeaponMaterialImperial = 273,
			kKeywordWeaponMaterialIron = 274,
			kKeywordWeaponMaterialOrcish = 275,
			kKeywordWeaponMaterialSteel = 276,
			kKeywordWeaponMaterialWood = 277,
			kKeywordWeaponTypeBoundArrow = 278,
			kKeywordArmorMaterialDaedric = 279,
			kKeywordArmorMaterialDragonplate = 280,
			kKeywordArmorMaterialDragonscale = 281,
			kKeywordArmorMaterialDragonbone = 282,
			kKeywordArmorMaterialDwarven = 283,
			kKeywordArmorMaterialEbony = 284,
			kKeywordArmorMaterialElven = 285,
			kKeywordArmorMaterialElvenSplinted = 286,
			kKeywordArmorMaterialFullLeather = 287,
			kKeywordArmorMaterialGlass = 288,
			kKeywordArmorMaterialHide = 289,
			kKeywordArmorMaterialImperial = 290,
			kKeywordArmorMaterialImperialHeavy = 291,
			kKeywordArmorMaterialImperialReinforced = 292,
			kKeywordArmorMaterialIron = 293,
			kKeywordArmorMaterialIronBanded = 294,
			kKeywordArmorMaterialOrcish = 295,
			kKeywordArmorMaterialScaled = 296,
			kKeywordArmorMaterialSteel = 297,
			kKeywordArmorMaterialSteelPlate = 298,
			kKeywordArmorMaterialStormcloak = 299,
			kKeywordArmorMaterialStudded = 300,
			kKeywordGenericCraftableKeyword01 = 301,
			kKeywordGenericCraftableKeyword02 = 302,
			kKeywordGenericCraftableKeyword03 = 303,
			kKeywordGenericCraftableKeyword04 = 304,
			kKeywordGenericCraftableKeyword05 = 305,
			kKeywordGenericCraftableKeyword06 = 306,
			kKeywordGenericCraftableKeyword07 = 307,
			kKeywordGenericCraftableKeyword08 = 308,
			kKeywordGenericCraftableKeyword09 = 309,
			kKeywordGenericCraftableKeyword10 = 310,
			kKeywordJewelry = 311,
			kKeywordCuirass = 312,
			kLocalMapHidePlane = 313,
			kSnowLODMaterial = 314,
			kSnowLODMaterialHD = 315,
			kAshLODMaterial = 316,
			kAshLODMaterialHD = 317,
			kDialogueFollowerQuest = 318,
			kPotentialFollowerFaction = 319,
			kWerewolfAvailablePerks = 320,
			kVampireAvailablePerks = 321,
			kSurvivalModeToggle = 322,
			kSurvivalModeEnabled = 323,
			kSurvivalModeShowOption = 324,
			kSurvivalTemperature = 325,
			kSurvivalColdPenalty = 326,
			kSurvivalHungerPenalty = 327,
			kSurvivalSleepPenalty = 328,
			kSurvivalKeywordCold = 329,
			kSurvivalKeywordWarm = 330,
			kSurvivalKeywordArmorHands = 331,
			kSurvivalKeywordClothingHands = 332,
			kSurvivalKeywordArmorFeet = 333,
			kSurvivalKeywordClothingFeet = 334,
			kSurvivalKeywordArmorBody = 335,
			kSurvivalKeywordClothingBody = 336,
			kSurvivalKeywordArmorHead = 337,
			kSurvivalKeywordClothingHead = 338,
			kWerewolfRace = 339,
			kVampireRace = 340,
			kVampireSpells = 341,
			kDragonMountNoLandList = 342,
			kPlayerCanMountDragonHereList = 343,
			kFlyingMountAllowedSpells = 344,
			kFlyingMountDisallowedSpells = 345,
			kKeywordMount = 346,
			kVerletCape = 347,
			kFurnitureTestNPC = 348,
			kKeywordConditionalExplosion = 349,
			kVampireFeedNoCrimeFaction = 350,
			kSkyrimWorldspace = 351,
			kKeywordArmorMaterialLightBonemold = 352,
			kKeywordArmorMaterialLightChitin = 353,
			kKeywordArmorMaterialLightNordic = 354,
			kKeywordArmorMaterialLightStalhrim = 355,
			kFlyingMountFlyFastWorldspaces = 356,
			kKeywordArmorMaterialHeavyBonemold = 357,
			kKeywordArmorMaterialHeavyChitin = 358,
			kKeywordArmorMaterialHeavyNordic = 359,
			kKeywordArmorMaterialHeavyStalhrim = 360,
			kKeywordWeaponMaterialNordic = 361,
			kKeywordWeaponMaterialStalhrim = 362,
			kModsHelpFormList = 363,

			kTotal = 364
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
			kisJarlChair = 184,
			kFurnitureAnimatesFast = 185,
			isCartTravelPlayer = 186,
			kTelekinesisGrabSound = 187,
			kTelekinesisThrowSound = 188,
			kWorldMapWeather = 189,
			kHelpManualPC = 190,
			kHelpManualXBox = 191,
			kHelpManualUnknown1 = 192,
			kHelpManualUnknown2 = 193,
			kKeywordTypeAmmo = 194,
			kKeywordTypeArmor = 195,
			kKeywordTypeBook = 196,
			kKeywordTypeIngredient = 197,
			kKeywordTypeKey = 198,
			kKeywordTypeMisc = 199,
			kKeywordTypeSoulGem = 200,
			kKeywordTypeWeapon = 201,
			kKeywordTypePotion = 202,
			kBaseWeaponEnchantment = 203,
			kBaseArmorEnchantment = 204,
			kBasePotion = 205,
			kBasePoison = 206,
			kKeywordDragon = 207,
			kKeywordMovable = 208,
			kArtObjectAbsorbEffect = 209,
			kWeaponMaterialList = 210,
			kArmorMaterialList = 211,
			kKeywordDisallowEnchanting = 212,
			kFavortravelmarkerlocation = 213,
			kKeywordHoldLocation = 214,
			kKeywordCivilWarOwner = 215,
			kKeywordCivilWarNeutral = 216,
			kLocRefTypeCivilWarSoldier = 217,
			kKeywordClearableLocation = 218,
			kLocRefTypeResourceDestructible = 219,
			kFormListHairColorList = 220,
			kComplexSceneObject = 221,
			kKeywordReusableSoulGem = 222,
			kKeywordAnimal = 223,
			kKeywordDaedra = 224,
			kKeywordRobot = 225,
			kKeywordNirnroot = 226,
			kFightersGuildFaction = 227,
			kMagesGuildFaction = 228,
			kThievesGuildFaction = 229,
			kDarkBrotherhoodFaction = 230,
			kJarlFaction = 231,
			kBunnyFaction = 232,
			kPlayerIsVampireVariable = 233,
			kPlayerIsWerewolfVariable = 234,
			kRoadMarker = 235,
			kKeywordScaleActorTo10 = 236,
			kKeywordVampire = 237,
			kKeywordForge = 238,
			kKeywordCookingPot = 239,
			kKeywordSmelter = 240,
			kKeywordTanningRack = 241,
			kHelpBasicLockpickingPC = 242,
			kHelpBasicLockpickingConsole = 243,

			kHelpBasicForging = 245,
			kHelpBasicCooking = 246,
			kHelpBasicSmelting = 247,
			kHelpBasicTanning = 248,
			kHelpBasicObjectCreation = 249,
			kHelpBasicEnchanting = 250,
			kHelpBasicSmithingWeapon = 251,
			kHelpBasicSmithingArmor = 252,
			kHelpBasicAlchemy = 253,
			kHelpBarter = 254,
			kHelpLevelingup = 255,
			kHelpSkillsMenu = 256,
			kHelpMapMenu = 257,
			kHelpJournal = 258,
			kHelpLowHealth = 259,
			kHelpLowMagicka = 260,
			kHelpLowStamina = 261,
			kHelpJail = 262,
			kHelpTeamateFavor = 263,
			kHelpWeaponCharge = 264,
			kHelpFavorites = 265,
			kKinectHelpFormList = 266,
			//kHelpFlyingMount = 260,
			kHelpTargetLock = 267,
			kHelpSwitchTarget = 268,
			kHelpAttackTarget = 269,
			kHelp270 = 270,
			kHelp271 = 271,
			kHelp272 = 271,
			kHelpSwimming = 273,
			kHelpArchery = 274,
			kHelp275 = 275,
			kImagespaceLoadscreen = 280,
			kKeywordWeaponMaterialDaedric = 281,
			kKeywordWeaponMaterialDraugr = 282,
			kKeywordWeaponMaterialDraugrHoned = 283,
			kKeywordWeaponMaterialDwarven = 284,
			kKeywordWeaponMaterialEbony = 285,
			kKeywordWeaponMaterialElven = 286,
			kKeywordWeaponMaterialFalmer = 287,
			kKeywordWeaponMaterialFalmerHoned = 288,
			kKeywordWeaponMaterialGlass = 289,
			kKeywordWeaponMaterialImperial = 290,
			kKeywordWeaponMaterialIron = 291,
			kKeywordWeaponMaterialOrcish = 292,
			kKeywordWeaponMaterialSteel = 293,
			kKeywordWeaponMaterialWood = 294,
			kKeywordWeaponTypeBoundArrow = 295,
			kKeywordArmorMaterialDaedric = 296,
			kKeywordArmorMaterialDragonplate = 297,
			kKeywordArmorMaterialDragonscale = 298,
			kKeywordArmorMaterialDragonbone = 299,
			kKeywordArmorMaterialDwarven = 300,
			kKeywordArmorMaterialEbony = 301,
			kKeywordArmorMaterialElven = 302,
			kKeywordArmorMaterialElvenSplinted = 303,
			kKeywordArmorMaterialFullLeather = 304,
			kKeywordArmorMaterialGlass = 305,
			kKeywordArmorMaterialHide = 306,
			kKeywordArmorMaterialImperial = 307,
			kKeywordArmorMaterialImperialHeavy = 308,
			kKeywordArmorMaterialImperialReinforced = 309,
			kKeywordArmorMaterialIron = 310,
			kKeywordArmorMaterialIronBanded = 311,
			kKeywordArmorMaterialOrcish = 312,
			kKeywordArmorMaterialScaled = 313,
			kKeywordArmorMaterialSteel = 314,
			kKeywordArmorMaterialSteelPlate = 315,
			kKeywordArmorMaterialStormcloak = 316,
			kKeywordArmorMaterialStudded = 317,
			kKeywordGenericCraftableKeyword01 = 318,
			kKeywordGenericCraftableKeyword02 = 319,
			kKeywordGenericCraftableKeyword03 = 320,
			kKeywordGenericCraftableKeyword04 = 321,
			kKeywordGenericCraftableKeyword05 = 322,
			kKeywordGenericCraftableKeyword06 = 323,
			kKeywordGenericCraftableKeyword07 = 324,
			kKeywordGenericCraftableKeyword08 = 325,
			kKeywordGenericCraftableKeyword09 = 326,
			kKeywordGenericCraftableKeyword10 = 327,
			kKeywordJewelry = 328,
			kKeywordCuirass = 329,
			kLocalMapHidePlane = 330,
			kSnowLODMaterial = 331,
			kSnowLODMaterialHD = 332,
			kAshLODMaterial = 333,
			kAshLODMaterialHD = 334,
			kDialogueFollowerQuest = 335,
			kPotentialFollowerFaction = 336,
			kWerewolfAvailablePerks = 337,
			kVampireAvailablePerks = 338,
			kWerewolfRace = 339,
			kVampireRace = 340,
			kVampireSpells = 341,
			kDragonMountNoLandList = 342,
			kPlayerCanMountDragonHereList = 343,
			kFlyingMountAllowedSpells = 344,
			kFlyingMountDisallowedSpells = 345,
			kKeywordMount = 346,
			kVerletCape = 347,
			kFurnitureTestNPC = 348,
			kKeywordConditionalExplosion = 349,
			kVampireFeedNoCrimeFaction = 350,
			kSkyrimWorldspace = 351,
			kKeywordArmorMaterialLightBonemold = 352,
			kKeywordArmorMaterialLightChitin = 353,
			kKeywordArmorMaterialLightNordic = 354,
			kKeywordArmorMaterialLightStalhrim = 355,
			kFlyingMountFlyFastWorldspaces = 356,
			kKeywordArmorMaterialHeavyBonemold = 357,
			kKeywordArmorMaterialHeavyChitin = 358,
			kKeywordArmorMaterialHeavyNordic = 359,
			kKeywordArmorMaterialHeavyStalhrim = 360,
			kKeywordWeaponMaterialNordic = 361,
			kKeywordWeaponMaterialStalhrim = 362,
			kModsHelpFormList = 363,
			kVrPlayerStaggerImod = 364,
			kVRPlayroomQuest = 366,
			kVRPlayroom = 367,
			kVRSettingsWarning = 368,

			kTotal = 369
#else
			kTotal = 183
#endif
		};
	};
	using DEFAULT_OBJECT = DEFAULT_OBJECTS::DEFAULT_OBJECT;

#define MakeDefaultObjectID(se, vr) (se | (vr << 16))
	enum class DefaultObjectID
	{
		kWerewolfSpell = 0,
		kSittingAngleLimit = 1,
		kAllowPlayerShout = 2,
		kGold = 3,
		kLockpick = 4,
		kSkeletonKey = 5,
		kPlayerFaction = 6,
		kGuardFaction = 7,
		kDefaultMusic = 8,
		kBattleMusic = 9,
		kDeathMusic = 10,
		kSuccessMusic = 11,
		kLevelUpMusic = 12,
		kDungeonClearedMusic = 13,
		kPlayerVoiceMale = 14,
		kPlayerVoiceMaleChild = 15,
		kPlayerVoiceFemale = 16,
		kPlayerVoiceFemaleChild = 17,
		kEatPackageDefaultFood = 18,
		kLeftHandEquip = 19,
		kRightHandEquip = 20,
		kEitherHandEquip = 21,
		kVoiceEquip = 22,
		kPotionEquip = 23,
		kEveryActorAbility = 24,
		kCommandedActorAbility = 25,
		kDrugWearsOffImageSpace = 26,
		kFootstepSet = 27,
		kLandscapeMaterial = 28,
		kDragonLandZoneMarker = 29,
		kDragonCrashZoneMarker = 30,
		kCombatStyle = 31,
		kDefaultPackList = 32,
		kWaitForDialoguePackage = 33,
		kLocRefTypeBoss = 34,
		kVirtualLocation = 35,
		kPersistAllLocation = 36,
		kInventoryPlayer = 37,
		kPathingTestNPC = 38,
		kFavorCostSmall = 39,
		kFavorCostMedium = 40,
		kFavorCostLarge = 41,
		kFavorGiftsPerDay = 42,
		kActionSwimStateChange = 43,
		kActionLook = 44,
		kActionLeftAttack = 45,
		kActionLeftReady = 46,
		kActionLeftRelease = 47,
		kActionLeftInterrupt = 48,
		kActionRightAttack = 49,
		kActionRightReady = 50,
		kActionRightRelease = 51,
		kActionRightInterrupt = 52,
		kActionDualAttack = 53,
		kActionDualRelease = 54,
		kActionActivate = 55,
		kActionJump = 56,
		kActionFall = 57,
		kActionLand = 58,
		kActionSneak = 59,
		kActionVoice = 60,
		kActionVoiceReady = 61,
		kActionVoiceRelease = 62,
		kActionVoiceInterrupt = 63,
		kActionIdle = 64,
		kActionSprintStart = 65,
		kActionSprintStop = 66,
		kActionDraw = 67,
		kActionSheath = 68,
		kActionLeftPowerAttack = 69,
		kActionRightPowerAttack = 70,
		kActionDualPowerAttack = 71,
		kActionStaggerStart = 72,
		kActionBlockHit = 73,
		kActionBlockAnticipate = 74,
		kActionRecoil = 75,
		kActionLargeRecoil = 76,
		kActionBleedoutStart = 77,
		kActionBleedoutStop = 78,
		kActionIdleStop = 79,
		kActionWardHit = 80,
		kActionForceEquip = 81,
		kActionShieldChange = 82,
		kActionPathStart = 83,
		kActionPathEnd = 84,
		kActionLargeMovementDelta = 85,
		kActionFlyStart = 86,
		kActionFlyStop = 87,
		kActionHoverStart = 88,
		kActionHoverStop = 89,
		kActionBumpedInto = 90,
		kActionSummonedStart = 91,
		kActionTalkingIdle = 92,
		kActionListenIdle = 93,
		kActionDeath = 94,
		kActionDeathWait = 95,
		kActionIdleWarn = 96,
		kActionMoveStart = 97,
		kActionMoveStop = 98,
		kActionTurnRight = 99,
		kActionTurnLeft = 100,
		kActionTurnStop = 101,
		kActionMoveForward = 102,
		kActionMoveBackward = 103,
		kActionMoveLeft = 104,
		kActionMoveRight = 105,
		kActionResetAnimationGraph = 106,
		kActionKnockdown = 107,
		kActionGetUp = 108,
		kActionIdleStopInstant = 109,
		kActionRagdollInstant = 110,
		kActionWaterwalkStart = 111,
		kActionReload = 112,
		kPickupSoundGeneric = 113,
		kPutdownSoundGeneric = 114,
		kPickupSoundWeapon = 115,
		kPutdownSoundWeapon = 116,
		kPickupSoundArmor = 117,
		kPutdownSoundArmor = 118,
		kPickupSoundBook = 119,
		kPutdownSoundBook = 120,
		kPickupSoundIngredient = 121,
		kPutdownSoundIngredient = 122,
		kHarvestSound = 123,
		kHarvestFailedSound = 124,
		kWardBreakSound = 125,
		kWardAbsorbSound = 126,
		kWardDeflectSound = 127,
		kMagicFailSound = 128,
		kShoutFailSound = 129,
		kHeartbeatSoundFast = 130,
		kHeartbeatSoundSlow = 131,
		kImagespaceLowHealth = 132,
		kSoulCapturedSound = 133,
		kNoActivationSound = 134,
		kMapMenuLoopingSound = 135,
		kDialogueVoiceCategory = 136,
		kNonDialogueVoiceCategory = 137,
		kSFXToFadeInDialogueCategory = 138,
		kPauseDuringMenuCategoryFade = 139,
		kPauseDuringMenuCategoryImmediate = 140,
		kPauseDuringLoadingMenuCategory = 141,
		kMusicSoundCategory = 142,
		kStatsMuteCategory = 143,
		kStatsMusic = 144,
		kMasterSoundCategory = 145,
		kTimeSensitiveSoundCategory = 146,
		kDialogueOutputModel3D = 147,
		kDialogueOutputModel2D = 148,
		kPlayersOutputModel1stPerson = 149,
		kPlayersOutputModel3rdPerson = 150,
		kInterfaceOutputModel = 151,
		kReverbType = 152,
		kUnderwaterLoopSound = 153,
		kUnderwaterReverbType = 154,
		kKeywordHorse = 155,
		kKeywordUndead = 156,
		kKeywordNPC = 157,
		kKeywordBeastRace = 158,
		kKeywordDummyObject = 159,
		kKeywordUseGeometryEmitter = 160,
		kKeywordMustStop = 161,
		kKeywordUpdateDuringArchery = 162,
		kKeywordSkipOutfitItems = 163,
		kMaleFaceTextureSetHead = 164,
		kMaleFaceTextureSetMouth = 165,
		kMaleFaceTextureSetEyes = 166,
		kFemaleFaceTextureSetHead = 167,
		kFemaleFaceTextureSetMouth = 168,
		kFemaleFaceTextureSetEyes = 169,
		kImageSpaceModifierforinventorymenu = 170,
		kPackagetemplate = 171,
		kMainMenuCell = 172,
		kDefaultMovementTypeWalk = 173,
		kDefaultMovementTypeRun = 174,
		kDefaultMovementTypeSwim = 175,
		kDefaultMovementTypeFly = 176,
		kDefaultMovementTypeSneak = 177,
		kDefaultMovementTypeSprint = 178,
		kKeywordSpecialFurniture = 179,
		kKeywordFurnitureForces1stPerson = 180,
		kKeywordFurnitureForces3rdPerson = 181,
		kKeywordActivatorFurnitureNoPlayer = 182,

		kTelekinesisGrabSound = MakeDefaultObjectID(183, 187),
		kTelekinesisThrowSound = MakeDefaultObjectID(184, 188),
		kWorldMapWeather = MakeDefaultObjectID(185, 189),
		kHelpManualPC = MakeDefaultObjectID(186, 190),
		kHelpManualXBox = MakeDefaultObjectID(187, 191),
		kKeywordTypeAmmo = MakeDefaultObjectID(188, 194),
		kKeywordTypeArmor = MakeDefaultObjectID(189, 195),
		kKeywordTypeBook = MakeDefaultObjectID(190, 196),
		kKeywordTypeIngredient = MakeDefaultObjectID(191, 197),
		kKeywordTypeKey = MakeDefaultObjectID(192, 198),
		kKeywordTypeMisc = MakeDefaultObjectID(193, 199),
		kKeywordTypeSoulGem = MakeDefaultObjectID(194, 200),
		kKeywordTypeWeapon = MakeDefaultObjectID(195, 201),
		kKeywordTypePotion = MakeDefaultObjectID(196, 202),
		kBaseWeaponEnchantment = MakeDefaultObjectID(197, 203),
		kBaseArmorEnchantment = MakeDefaultObjectID(198, 204),
		kBasePotion = MakeDefaultObjectID(199, 205),
		kBasePoison = MakeDefaultObjectID(200, 206),
		kKeywordDragon = MakeDefaultObjectID(201, 207),
		kKeywordMovable = MakeDefaultObjectID(202, 208),
		kArtObjectAbsorbEffect = MakeDefaultObjectID(203, 209),
		kWeaponMaterialList = MakeDefaultObjectID(204, 210),
		kArmorMaterialList = MakeDefaultObjectID(205, 211),
		kKeywordDisallowEnchanting = MakeDefaultObjectID(206, 212),
		kFavortravelmarkerlocation = MakeDefaultObjectID(207, 213),
		kKeywordHoldLocation = MakeDefaultObjectID(208, 214),
		kKeywordCivilWarOwner = MakeDefaultObjectID(209, 215),
		kKeywordCivilWarNeutral = MakeDefaultObjectID(210, 216),
		kLocRefTypeCivilWarSoldier = MakeDefaultObjectID(211, 217),
		kKeywordClearableLocation = MakeDefaultObjectID(212, 218),
		kLocRefTypeResourceDestructible = MakeDefaultObjectID(213, 219),
		kFormListHairColorList = MakeDefaultObjectID(214, 220),
		kComplexSceneObject = MakeDefaultObjectID(215, 221),
		kKeywordReusableSoulGem = MakeDefaultObjectID(216, 222),
		kKeywordAnimal = MakeDefaultObjectID(217, 223),
		kKeywordDaedra = MakeDefaultObjectID(218, 224),
		kKeywordRobot = MakeDefaultObjectID(219, 225),
		kKeywordNirnroot = MakeDefaultObjectID(220, 226),
		kFightersGuildFaction = MakeDefaultObjectID(221, 227),
		kMagesGuildFaction = MakeDefaultObjectID(222, 228),
		kThievesGuildFaction = MakeDefaultObjectID(223, 229),
		kDarkBrotherhoodFaction = MakeDefaultObjectID(224, 230),
		kJarlFaction = MakeDefaultObjectID(225, 231),
		kBunnyFaction = MakeDefaultObjectID(226, 232),
		kPlayerIsVampireVariable = MakeDefaultObjectID(227, 233),
		kPlayerIsWerewolfVariable = MakeDefaultObjectID(228, 234),
		kRoadMarker = MakeDefaultObjectID(229, 235),
		kKeywordScaleActorTo10 = MakeDefaultObjectID(230, 236),
		kKeywordVampire = MakeDefaultObjectID(231, 237),
		kKeywordForge = MakeDefaultObjectID(232, 238),
		kKeywordCookingPot = MakeDefaultObjectID(233, 239),
		kKeywordSmelter = MakeDefaultObjectID(234, 240),
		kKeywordTanningRack = MakeDefaultObjectID(235, 241),
		kHelpBasicLockpickingPC = MakeDefaultObjectID(236, 242),
		kHelpBasicLockpickingConsole = MakeDefaultObjectID(237, 243),
		kHelpBasicForging = MakeDefaultObjectID(238, 245),
		kHelpBasicCooking = MakeDefaultObjectID(239, 246),
		kHelpBasicSmelting = MakeDefaultObjectID(240, 247),
		kHelpBasicTanning = MakeDefaultObjectID(241, 248),
		kHelpBasicObjectCreation = MakeDefaultObjectID(242, 249),
		kHelpBasicEnchanting = MakeDefaultObjectID(243, 250),
		kHelpBasicSmithingWeapon = MakeDefaultObjectID(244, 251),
		kHelpBasicSmithingArmor = MakeDefaultObjectID(245, 252),
		kHelpBasicAlchemy = MakeDefaultObjectID(246, 252),
		kHelpBarter = MakeDefaultObjectID(247, 254),
		kHelpLevelingup = MakeDefaultObjectID(248, 255),
		kHelpSkillsMenu = MakeDefaultObjectID(249, 256),
		kHelpMapMenu = MakeDefaultObjectID(250, 257),
		kHelpJournal = MakeDefaultObjectID(251, 258),
		kHelpLowHealth = MakeDefaultObjectID(252, 259),
		kHelpLowMagicka = MakeDefaultObjectID(253, 260),
		kHelpLowStamina = MakeDefaultObjectID(254, 261),
		kHelpJail = MakeDefaultObjectID(255, 262),
		kHelpTeamateFavor = MakeDefaultObjectID(256, 263),
		kHelpWeaponCharge = MakeDefaultObjectID(257, 264),
		kHelpFavorites = MakeDefaultObjectID(258, 265),
		kKinectHelpFormList = MakeDefaultObjectID(259, 266),
		kHelpFlyingMount = MakeDefaultObjectID(260, 0),
		kHelpTargetLock = MakeDefaultObjectID(261, 267),
		kHelpAttackTarget = MakeDefaultObjectID(262, 269),
		kImagespaceLoadscreen = MakeDefaultObjectID(263, 280),
		kKeywordWeaponMaterialDaedric = MakeDefaultObjectID(264, 281),
		kKeywordWeaponMaterialDraugr = MakeDefaultObjectID(265, 282),
		kKeywordWeaponMaterialDraugrHoned = MakeDefaultObjectID(266, 283),
		kKeywordWeaponMaterialDwarven = MakeDefaultObjectID(267, 284),
		kKeywordWeaponMaterialEbony = MakeDefaultObjectID(268, 285),
		kKeywordWeaponMaterialElven = MakeDefaultObjectID(269, 286),
		kKeywordWeaponMaterialFalmer = MakeDefaultObjectID(270, 287),
		kKeywordWeaponMaterialFalmerHoned = MakeDefaultObjectID(271, 288),
		kKeywordWeaponMaterialGlass = MakeDefaultObjectID(272, 289),
		kKeywordWeaponMaterialImperial = MakeDefaultObjectID(273, 290),
		kKeywordWeaponMaterialIron = MakeDefaultObjectID(274, 291),
		kKeywordWeaponMaterialOrcish = MakeDefaultObjectID(275, 292),
		kKeywordWeaponMaterialSteel = MakeDefaultObjectID(276, 293),
		kKeywordWeaponMaterialWood = MakeDefaultObjectID(277, 294),
		kKeywordWeaponTypeBoundArrow = MakeDefaultObjectID(278, 295),
		kKeywordArmorMaterialDaedric = MakeDefaultObjectID(279, 296),
		kKeywordArmorMaterialDragonplate = MakeDefaultObjectID(280, 297),
		kKeywordArmorMaterialDragonscale = MakeDefaultObjectID(281, 298),
		kKeywordArmorMaterialDragonbone = MakeDefaultObjectID(282, 299),
		kKeywordArmorMaterialDwarven = MakeDefaultObjectID(283, 300),
		kKeywordArmorMaterialEbony = MakeDefaultObjectID(284, 301),
		kKeywordArmorMaterialElven = MakeDefaultObjectID(285, 302),
		kKeywordArmorMaterialElvenSplinted = MakeDefaultObjectID(286, 303),
		kKeywordArmorMaterialFullLeather = MakeDefaultObjectID(287, 304),
		kKeywordArmorMaterialGlass = MakeDefaultObjectID(288, 305),
		kKeywordArmorMaterialHide = MakeDefaultObjectID(289, 306),
		kKeywordArmorMaterialImperial = MakeDefaultObjectID(290, 307),
		kKeywordArmorMaterialImperialHeavy = MakeDefaultObjectID(291, 308),
		kKeywordArmorMaterialImperialReinforced = MakeDefaultObjectID(292, 309),
		kKeywordArmorMaterialIron = MakeDefaultObjectID(293, 310),
		kKeywordArmorMaterialIronBanded = MakeDefaultObjectID(294, 311),
		kKeywordArmorMaterialOrcish = MakeDefaultObjectID(295, 312),
		kKeywordArmorMaterialScaled = MakeDefaultObjectID(296, 313),
		kKeywordArmorMaterialSteel = MakeDefaultObjectID(297, 314),
		kKeywordArmorMaterialSteelPlate = MakeDefaultObjectID(298, 315),
		kKeywordArmorMaterialStormcloak = MakeDefaultObjectID(299, 316),
		kKeywordArmorMaterialStudded = MakeDefaultObjectID(300, 317),
		kKeywordGenericCraftableKeyword01 = MakeDefaultObjectID(301, 318),
		kKeywordGenericCraftableKeyword02 = MakeDefaultObjectID(302, 319),
		kKeywordGenericCraftableKeyword03 = MakeDefaultObjectID(303, 320),
		kKeywordGenericCraftableKeyword04 = MakeDefaultObjectID(304, 321),
		kKeywordGenericCraftableKeyword05 = MakeDefaultObjectID(305, 322),
		kKeywordGenericCraftableKeyword06 = MakeDefaultObjectID(306, 323),
		kKeywordGenericCraftableKeyword07 = MakeDefaultObjectID(307, 324),
		kKeywordGenericCraftableKeyword08 = MakeDefaultObjectID(308, 325),
		kKeywordGenericCraftableKeyword09 = MakeDefaultObjectID(309, 326),
		kKeywordGenericCraftableKeyword10 = MakeDefaultObjectID(310, 327),
		kKeywordJewelry = MakeDefaultObjectID(311, 328),
		kKeywordCuirass = MakeDefaultObjectID(312, 329),
		kLocalMapHidePlane = MakeDefaultObjectID(313, 330),
		kSnowLODMaterial = MakeDefaultObjectID(314, 331),
		kSnowLODMaterialHD = MakeDefaultObjectID(315, 332),
		kAshLODMaterial = MakeDefaultObjectID(316, 333),
		kAshLODMaterialHD = MakeDefaultObjectID(317, 334),
		kDialogueFollowerQuest = MakeDefaultObjectID(318, 335),
		kPotentialFollowerFaction = MakeDefaultObjectID(319, 336),
		kWerewolfAvailablePerks = MakeDefaultObjectID(320, 337),
		kVampireAvailablePerks = MakeDefaultObjectID(321, 338),
		kSurvivalModeToggle = 322,
		kSurvivalModeEnabled = 323,
		kSurvivalModeShowOption = 324,
		kSurvivalTemperature = 325,
		kSurvivalColdPenalty = 326,
		kSurvivalHungerPenalty = 327,
		kSurvivalSleepPenalty = 328,
		kSurvivalKeywordCold = 329,
		kSurvivalKeywordWarm = 330,
		kSurvivalKeywordArmorHands = 331,
		kSurvivalKeywordClothingHands = 332,
		kSurvivalKeywordArmorFeet = 333,
		kSurvivalKeywordClothingFeet = 334,
		kSurvivalKeywordArmorBody = 335,
		kSurvivalKeywordClothingBody = 336,
		kSurvivalKeywordArmorHead = 337,
		kSurvivalKeywordClothingHead = 338,
		kWerewolfRace = MakeDefaultObjectID(339, 339),
		kVampireRace = MakeDefaultObjectID(340, 340),
		kVampireSpells = MakeDefaultObjectID(341, 341),
		kDragonMountNoLandList = MakeDefaultObjectID(342, 342),
		kPlayerCanMountDragonHereList = MakeDefaultObjectID(343, 343),
		kFlyingMountAllowedSpells = MakeDefaultObjectID(344, 344),
		kFlyingMountDisallowedSpells = MakeDefaultObjectID(345, 345),
		kKeywordMount = MakeDefaultObjectID(346, 346),
		kVerletCape = MakeDefaultObjectID(347, 347),
		kFurnitureTestNPC = MakeDefaultObjectID(348, 348),
		kKeywordConditionalExplosion = MakeDefaultObjectID(349, 349),
		kVampireFeedNoCrimeFaction = MakeDefaultObjectID(350, 350),
		kSkyrimWorldspace = MakeDefaultObjectID(351, 351),
		kKeywordArmorMaterialLightBonemold = MakeDefaultObjectID(352, 352),
		kKeywordArmorMaterialLightChitin = MakeDefaultObjectID(353, 353),
		kKeywordArmorMaterialLightNordic = MakeDefaultObjectID(354, 354),
		kKeywordArmorMaterialLightStalhrim = MakeDefaultObjectID(355, 355),
		kFlyingMountFlyFastWorldspaces = MakeDefaultObjectID(356, 356),
		kKeywordArmorMaterialHeavyBonemold = MakeDefaultObjectID(357, 357),
		kKeywordArmorMaterialHeavyChitin = MakeDefaultObjectID(358, 358),
		kKeywordArmorMaterialHeavyNordic = MakeDefaultObjectID(359, 359),
		kKeywordArmorMaterialHeavyStalhrim = MakeDefaultObjectID(360, 360),
		kKeywordWeaponMaterialNordic = MakeDefaultObjectID(361, 361),
		kKeywordWeaponMaterialStalhrim = MakeDefaultObjectID(362, 362),
		kModsHelpFormList = MakeDefaultObjectID(363, 363),

		// VR-specific
		kisJarlChair = MakeDefaultObjectID(0, 184),
		kFurnitureAnimatesFast = MakeDefaultObjectID(0, 185),
		isCartTravelPlayer = MakeDefaultObjectID(0, 186),
		kHelpManualUnknown1 = MakeDefaultObjectID(0, 192),
		kHelpManualUnknown2 = MakeDefaultObjectID(0, 193),
		kHelpSwitchTarget = MakeDefaultObjectID(0, 268),
		kHelp270 = MakeDefaultObjectID(0, 270),
		kHelp271 = MakeDefaultObjectID(0, 271),
		kHelp272 = MakeDefaultObjectID(0, 272),
		kHelpSwimming = MakeDefaultObjectID(0, 273),
		kHelpArchery = MakeDefaultObjectID(0, 274),
		kHelp275 = MakeDefaultObjectID(0, 275),
		kVrPlayerStaggerImod = MakeDefaultObjectID(0, 364),
		kVRPlayroomQuest = MakeDefaultObjectID(0, 366),
		kVRPlayroom = MakeDefaultObjectID(0, 367),
		kVRSettingsWarning = MakeDefaultObjectID(0, 368)
	};
#undef MakeDefaultObjectID

	enum class DEFAULT_OBJECT_TYPE
	{
		kMisc = 0,
		kFaceGen = 1,
		kMovement = 2,
		kActions = 3,
		kItems = 4,
		kSounds = 5,
		kKeywords = 6
	};

	struct DEFAULT_OBJECT_DATA
	{
	public:
		// members
		const char*                                          name;         // 00
		stl::enumeration<FormType, std::uint8_t>             type;         // 08
		std::uint8_t                                         pad09;        // 09
		std::uint16_t                                        pad0A;        // 0A
		char                                                 uniqueID[4];  // 0C
		stl::enumeration<DEFAULT_OBJECT_TYPE, std::uint32_t> doType;       // 10
		std::uint32_t                                        pad14;        // 14
	};
	static_assert(sizeof(DEFAULT_OBJECT_DATA) == 0x18);

	class BGSDefaultObjectManager :
		public TESForm,                                       // 000
		public BSTSingletonImplicit<BGSDefaultObjectManager>  // 020
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSDefaultObjectManager;
		inline static constexpr auto VTABLE = VTABLE_BGSDefaultObjectManager;

		using DefaultObject = DEFAULT_OBJECT;
		inline static constexpr auto FORMTYPE = FormType::DefaultObject;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~BGSDefaultObjectManager() override;  // 00

		// override (TESForm)
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		[[nodiscard]] static BGSDefaultObjectManager* GetSingleton()
		{
			using func_t = decltype(&BGSDefaultObjectManager::GetSingleton);
			REL::Relocation<func_t> func{ RELOCATION_ID(10878, 13894) };
			return func();
		}

		[[nodiscard]] TESForm* GetObject(DefaultObject a_object) const noexcept { return GetObject(stl::to_underlying(a_object)); }

		template <class T>
		[[nodiscard]] T* GetObject(DefaultObject a_object) const noexcept
		{
			return GetObject<T>(stl::to_underlying(a_object));
		}

		[[nodiscard]] TESForm* GetObject(std::size_t a_idx) const noexcept
		{
			assert(a_idx < stl::to_underlying(DefaultObject::kTotal));
			return IsObjectInitialized(a_idx) ? objects[a_idx] : nullptr;
		}

		template <class T>
		[[nodiscard]] T* GetObject(std::size_t a_idx) const noexcept
		{
			const auto obj = GetObject(a_idx);
			return obj ? obj->As<T>() : nullptr;
		}

		[[nodiscard]] TESForm** GetObject(DefaultObjectID a_object) noexcept;

		template <class T>
		[[nodiscard]] T** GetObject(DefaultObjectID a_object) noexcept
		{
			auto obj = GetObject(a_object);
			return obj && *obj && (*obj)->As<T>() ? reinterpret_cast<T**>(obj) : nullptr;
		}

		[[nodiscard]] bool IsObjectInitialized(DEFAULT_OBJECT a_object) const noexcept
		{
			return IsObjectInitialized(stl::to_underlying(a_object));
		}

		[[nodiscard]] bool IsObjectInitialized(DefaultObjectID a_object) const noexcept;

		[[nodiscard]] bool IsObjectInitialized(std::size_t a_idx) const noexcept
		{
			return REL::RelocateMember<bool*>(this, 0xB80, 0xBA8)[a_idx];
		}

		[[nodiscard]] static bool SupportsVR(DefaultObjectID a_object) noexcept;

		[[nodiscard]] static bool SupportsSE(DefaultObjectID a_object) noexcept;

		[[nodiscard]] static inline bool SupportsAE(DefaultObjectID a_object) noexcept
		{
			return SupportsSE(a_object);
		}

		[[nodiscard]] static bool SupportsCurrentRuntime(DefaultObjectID a_object) noexcept;

		// members
		TESForm* objects[DEFAULT_OBJECTS::kTotal];  // 020 - DNAM
#ifndef SKYRIM_CROSS_VR
		bool          objectInit[DEFAULT_OBJECTS::kTotal];  // B80
		std::uint32_t padCEC;                               // CEC
#else
		std::uint8_t unk5D8[0x718];  // 5D8
#endif
	};
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BGSDefaultObjectManager) == 0xD20);
#else
	static_assert(sizeof(BGSDefaultObjectManager) == 0xCF0);
#endif
}


===============================================
File: include/RE/B/BGSDestructibleObjectForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class QueuedFile;
	class TESModelTextureSwap;

	struct DestructibleObjectStage
	{
	public:
		enum class DESTRUCTIBLE_OBJECT_STAGE_FLAGS
		{
			kNone = 0,
			kCapDamage = 1 << 0,
			kDisableObject = 1 << 1,
			kDestroyObject = 1 << 2,
			kIgnoreExternalDamage = 1 << 3,
			kBecomesDynamic = 1 << 4
		};

		// members
		std::int8_t                                                     modelDamageStage;     // 00 - DSTD~
		std::int8_t                                                     healthPercentage;     // 01
		stl::enumeration<DESTRUCTIBLE_OBJECT_STAGE_FLAGS, std::uint8_t> flags;                // 02
		std::uint8_t                                                    pad03;                // 03
		std::uint32_t                                                   selfDamagePerSecond;  // 04
		BGSExplosion*                                                   explosion;            // 08
		BGSDebris*                                                      debris;               // 10
		std::uint32_t                                                   debrisCount;          // 18 - ~DSTD
		std::uint32_t                                                   pad1C;                // 1C
		TESModelTextureSwap*                                            replacementModel;     // 20 - DMD*
	};
	static_assert(sizeof(DestructibleObjectStage) == 0x28);

	struct DestructibleObjectData
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kVatsTargetable = 1 << 0
		};

		// members
		std::uint32_t                        health;                      // 00 - DEST~
		std::int8_t                          numStages;                   // 04
		stl::enumeration<Flag, std::uint8_t> flags;                       // 05 - ~DEST
		std::uint16_t                        pad06;                       // 06
		DestructibleObjectStage**            stages;                      // 08
		volatile std::int32_t                replacementModelRefCount;    // 10
		std::uint32_t                        pad14;                       // 14
		NiPointer<QueuedFile>                preloadedReplacementModels;  // 18
	};
	static_assert(sizeof(DestructibleObjectData) == 0x20);

	class BGSDestructibleObjectForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSDestructibleObjectForm;

		~BGSDestructibleObjectForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		DestructibleObjectData* data;  // 08
	};
	static_assert(sizeof(BGSDestructibleObjectForm) == 0x10);
}


===============================================
File: include/RE/B/BGSDialogueBranch.h
===============================================
#pragma once

#include "RE/D/DialogueTypes.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSDialogueBranch : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSDialogueBranch;
		inline static constexpr auto VTABLE = VTABLE_BGSDialogueBranch;
		inline static constexpr auto FORMTYPE = FormType::DialogueBranch;

		enum class Flag
		{
			kNone = 0,
			kTopLevel = 1 << 0,
			kBlocking = 1 << 1,
			kExclusive = 1 << 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSDialogueBranch() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		stl::enumeration<Flag, std::uint32_t> flags;          // 20 - DNAM
		std::uint32_t                         pad24;          // 24
		TESQuest*                             quest;          // 28 - QNAM
		TESTopic*                             startingTopic;  // 30 - SNAM
		DIALOGUE_TYPE                         type;           // 38 - TNAM
		std::uint32_t                         pad3C;          // 3C
	};
	static_assert(sizeof(BGSDialogueBranch) == 0x40);
}


===============================================
File: include/RE/B/BGSDirectionalAmbientLightingColors.h
===============================================
#pragma once

#include "RE/C/Color.h"

namespace RE
{
	class BGSDirectionalAmbientLightingColors
	{
	public:
		struct Directional
		{
		public:
			template <class T>
			struct MaxMin
			{
			public:
				// members
				T max;  // 0
				T min;  // ?
			};
			static_assert(sizeof(MaxMin<Color>) == 0x8);

			// members
			MaxMin<Color> x;  // 00
			MaxMin<Color> y;  // 08
			MaxMin<Color> z;  // 10
		};
		static_assert(sizeof(Directional) == 0x18);

		// members
		Directional directional;   // 00
		Color       specular;      // 18
		float       fresnelPower;  // 1C
	};
	static_assert(sizeof(BGSDirectionalAmbientLightingColors) == 0x20);
}


===============================================
File: include/RE/B/BGSDistantTreeBlock.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSTerrainNode;
	class BSMultiStreamInstanceTriShape;

	class BGSDistantTreeBlock
	{
	public:
		struct InstanceData
		{
		public:
			// members
			FormID        id;      // 00 - Only the lower 24 bits used
			std::uint16_t x;       // 04
			std::uint16_t y;       // 06
			std::uint16_t z;       // 08
			std::uint16_t rotZ;    // 0A
			std::uint16_t scale;   // 0C
			std::uint16_t alpha;   // 0E - This is Float2Word(fAlpha)
			bool          hidden;  // 10 - alpha <= 0.0f or set by object flags
			std::uint8_t  pad11;   // 11
			std::uint16_t pad12;   // 12
		};
		static_assert(sizeof(InstanceData) == 0x14);

		struct TreeGroup
		{
		public:
			// members
			NiPointer<BSMultiStreamInstanceTriShape> geometry;                // 00
			BSTArray<InstanceData>                   instances;               // 08
			std::uint32_t                            num;                     // 20
			bool                                     shaderPropertyUpToDate;  // 24
			std::int8_t                              treeType;                // 25
			std::uint16_t                            pad26;                   // 26
		};
		static_assert(sizeof(TreeGroup) == 0x28);

		// members
		BSTArray<TreeGroup*>                     treeGroups;   // 00
		BSTHashMap<std::uint32_t, InstanceData*> instanceMap;  // 18
		BSTHashMap<std::uint32_t, TreeGroup*>    nextGroup;    // 48
		BGSTerrainNode*                          node;         // 78
		bool                                     doneLoading;  // 80
		bool                                     attached;     // 81
		bool                                     allVisible;   // 82
		std::uint8_t                             pad83;        // 83
		std::uint32_t                            pad84;        // 84
	};
	static_assert(sizeof(BGSDistantTreeBlock) == 0x88);
}


===============================================
File: include/RE/B/BGSDualCastData.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"

namespace RE
{
	struct BGSDualCastDataDEF  // DATA
	{
	public:
		enum class Flags
		{
			kNone = 0,
			kHitEffectInheritScale = 1 << 0,
			kProjectileInheritScale = 1 << 1,
			kExplosionInheritScale = 1 << 2
		};

		// members
		BGSProjectile*                         pProjectile;     // 00
		BGSExplosion*                          pExplosion;      // 08
		TESEffectShader*                       pEffectShader;   // 10
		BGSArtObject*                          pHitEffectArt;   // 18
		BGSImpactDataSet*                      pImpactDataSet;  // 20
		stl::enumeration<Flags, std::uint32_t> flags;           // 28
		std::uint32_t                          pad30;           // 30
	};
	static_assert(sizeof(BGSDualCastDataDEF) == 0x30);

	class BGSDualCastData : public TESBoundObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSDualCastData;
		inline static constexpr auto VTABLE = VTABLE_BGSDualCastData;
		inline static constexpr auto FORMTYPE = FormType::DualCastData;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSDualCastData() override;  // 00

		// override (TESBoundObject)
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BGSDualCastDataDEF data;  // 30 - DATA
	};
	static_assert(sizeof(BGSDualCastData) == 0x60);
}


===============================================
File: include/RE/B/BGSEncounterZone.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct ENCOUNTER_ZONE_DATA  // DATA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kNeverResets = 1 << 0,
			kMatchPCBelowMinimumLevel = 1 << 1,
			kDisableCombatBoundary = 1 << 2
		};

		// members
		TESFaction*                          zoneOwner;  // 00
		BGSLocation*                         location;   // 08
		std::int8_t                          ownerRank;  // 10
		std::int8_t                          minLevel;   // 11
		stl::enumeration<Flag, std::uint8_t> flags;      // 12
		std::int8_t                          maxLevel;   // 13
		std::uint32_t                        pad14;      // 14
	};
	static_assert(sizeof(ENCOUNTER_ZONE_DATA) == 0x18);

	struct ENCOUNTER_ZONE_GAME_DATA
	{
	public:
		// members
		std::uint32_t detachTime;  // 00
		std::uint32_t attachTime;  // 04
		std::uint32_t resetTime;   // 08
		std::uint16_t zoneLevel;   // 0C
		std::uint16_t pad0D;       // 0D
	};
	static_assert(sizeof(ENCOUNTER_ZONE_GAME_DATA) == 0x10);

	class BGSEncounterZone : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEncounterZone;
		inline static constexpr auto VTABLE = VTABLE_BGSEncounterZone;
		inline static constexpr auto FORMTYPE = FormType::EncounterZone;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kZoneFlags = 1 << 1,
				kGameData = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSEncounterZone() override;  // 00

		// override (TESForm)
		void InitializeData() override;                    // 04
		bool Load(TESFile* a_mod) override;                // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void InitItemImpl() override;                      // 13

		// members
		ENCOUNTER_ZONE_DATA      data;      // 20 - DATA
		ENCOUNTER_ZONE_GAME_DATA gameData;  // 38
	};
	static_assert(sizeof(BGSEncounterZone) == 0x48);
}


===============================================
File: include/RE/B/BGSEntryPoint.h
===============================================
#pragma once

namespace RE
{
	class Actor;

	struct BGSEntryPoint
	{
		struct ENTRY_POINTS
		{
			enum ENTRY_POINT : std::uint32_t
			{
				kCalculateWeaponDamage = 0,
				kCalculateMyCriticalHitChance = 1,
				kCalculateMyCriticalHitDamage = 2,
				kCalculateMineExplodeChance = 3,
				kAdjustLimbDamage = 4,
				kAdjustBookSkillPoints = 5,
				kModRecoveredHealth = 6,
				kGetShouldAttack = 7,
				kModBuyPrices = 8,
				kAddLeveledListOnDeath = 9,
				kGetMaxCarryWeight = 10,
				kModAddictionChance = 11,
				kModAddictionDuration = 12,
				kModPositiveChemDuration = 13,
				kActivate = 14,
				kIgnoreRunningDuringDetection = 15,
				kIgnoreBrokenLock = 16,
				kModEnemyCriticalHitChance = 17,
				kModSneakAttackMult = 18,
				kModMaxPlaceableMines = 19,
				kModBowZoom = 20,
				kModRecoverArrowChance = 21,
				kModSkillUse = 22,
				kModTelekinesisDistance = 23,
				kModTelekinesisDamageMult = 24,
				kModTelekinesisDamage = 25,
				kModBashingDamage = 26,
				kModPowerAttackStamina = 27,
				kModPowerAttackDamage = 28,
				kModSpellMagnitude = 29,
				kModSpellDuration = 30,
				kModSecondaryValueWeight = 31,
				kModArmorWeight = 32,
				kModIncomingStagger = 33,
				kModTargetStagger = 34,
				kModAttackDamage = 35,
				kModIncomingDamage = 36,
				kModTargetDamageResistance = 37,
				kModSpellCost = 38,
				kModPercentBlocked = 39,
				kModShieldDeflectArrowChance = 40,
				kModIncomingSpellMagnitude = 41,
				kModIncomingSpellDuration = 42,
				kModPlayerIntimidation = 43,
				kModPlayerReputation = 44,
				kModFavorPoints = 45,
				kModBribeAmount = 46,
				kModDetectionLight = 47,
				kModDetectionMovement = 48,
				kModSoulGemRecharge = 49,
				kSetSweepAttack = 50,
				kApplyCombatHitSpell = 51,
				kApplyBashingSpell = 52,
				kApplyReanimateSpell = 53,
				kSetBooleanGraphVariable = 54,
				kModSpellCastingSoundEvent = 55,
				kModPickpocketChance = 56,
				kModDetectionSneakSkill = 57,
				kModFallingDamage = 58,
				kModLockpickSweetSpot = 59,
				kModSellPrices = 60,
				kCanPickpocketEquippedItem = 61,
				kModLockpickLevelAllowed = 62,
				kSetLockpickStartingArc = 63,
				kSetProgressionPicking = 64,
				kMakeLockpicksUnbreakable = 65,
				kModAlchemyEffectiveness = 66,
				kApplyWeaponSwingSpell = 67,
				kModCommandedActorLimit = 68,
				kApplySneakingSpell = 69,
				kModPlayerMagicSlowdown = 70,
				kModWardMagickaAbsorptionPct = 71,
				kModInitialIngredientEffectsLearned = 72,
				kPurifyAlchemyIngredients = 73,
				kFilterActivation = 74,
				kCanDualCastSpell = 75,
				kModTemperingHealth = 76,
				kModEnchantmentPower = 77,
				kModSoulPctCapturedToWeapon = 78,
				kModSoulGemEnchanting = 79,
				kModNumberAppliedEnchantmentsAllowed = 80,
				kSetActivateLabel = 81,
				kModShoutOK = 82,
				kModPoisonDoseCount = 83,
				kShouldApplyPlacedItem = 84,
				kModArmorRating = 85,
				kModLockpickingCrimeChance = 86,
				kModIngredientsHarvested = 87,
				kModSpellRange_TargetLoc = 88,
				kModPotionsCreated = 89,
				kModLockpickingKeyRewardChance = 90,
				kAllowMountActor = 91,

				kTotal
			};
		};
		using ENTRY_POINT = ENTRY_POINTS::ENTRY_POINT;

		template <class... Args>
		static void HandleEntryPoint(ENTRY_POINT a_entryPoint, Actor* a_perkOwner, Args... a_args)
		{
			using func_t = decltype(&BGSEntryPoint::HandleEntryPoint<Args...>);
			REL::Relocation<func_t> func{ RELOCATION_ID(23073, 23526) };
			return func(a_entryPoint, a_perkOwner, a_args...);
		}
	};
}


===============================================
File: include/RE/B/BGSEntryPointFunctionData.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"

namespace RE
{
	class TESFile;

	class BGSEntryPointFunctionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEntryPointFunctionData;

		enum class FunctionType
		{
			kInvalid = 0,
			kOneValue = 1,
			kTwoValue = 2,
			kLeveledList = 3,
			kActivateChoice = 4,
			kSpellItem = 5,
			kBooleanGraphVariable = 6,
			kText = 7
		};

		virtual ~BGSEntryPointFunctionData();  // 00

		[[nodiscard]] virtual FunctionType GetType() const = 0;                   // 01
		virtual bool                       LoadFunctionData(TESFile* a_mod) = 0;  // 02
		virtual void                       ResolveForms(TESFile* a_mod);          // 03 - { return; }
		virtual void                       Unk_04(void);                          // 04 - { return; }
		virtual void                       Unk_05(void);                          // 05 - { return 0xFFFF; }
		virtual void                       SetPerk(BGSPerk* a_perk);              // 06 - { return; }
		virtual BGSPerk*                   GetPerk();                             // 07 - { return 0; }
	};
	static_assert(sizeof(BGSEntryPointFunctionData) == 0x8);
}


===============================================
File: include/RE/B/BGSEntryPointFunctionDataActivateChoice.h
===============================================
#pragma once

#include "RE/B/BGSEntryPointFunctionData.h"
#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSEntryPointFunctionDataActivateChoice : public BGSEntryPointFunctionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEntryPointFunctionDataActivateChoice;

		enum class Flag1
		{
			kNone = 0,
			kRunImmediately = 1,
			kReplaceDefault = 2
		};

		~BGSEntryPointFunctionDataActivateChoice() override;  // 00

		// override (BGSEntryPointFunctionData)
		FunctionType GetType() const override;                   // 01 - { return kDataActivateChoice; }
		bool         LoadFunctionData(TESFile* a_mod) override;  // 02
		void         ResolveForms(TESFile* a_mod) override;      // 03
		void         Unk_05(void) override;                      // 05
		void         SetPerk(BGSPerk* a_perk) override;          // 06 - { perk = a_perk; }
		BGSPerk*     GetPerk() override;                         // 07 - { return perk; }

		[[nodiscard]] bool ReplacesDefault() const;
		[[nodiscard]] bool RunsImmediately() const;

		// members
		BSFixedString                          label;         // 08
		BGSPerk*                               perk;          // 10
		SpellItem*                             appliedSpell;  // 18
		stl::enumeration<Flag1, std::uint16_t> flags1;        // 20
		std::uint16_t                          flags2;        // 22
		std::uint32_t                          pad24;         // 24
	};
	static_assert(sizeof(BGSEntryPointFunctionDataActivateChoice) == 0x28);
}


===============================================
File: include/RE/B/BGSEntryPointFunctionDataOneValue.h
===============================================
#pragma once

#include "RE/B/BGSEntryPointFunctionData.h"

namespace RE
{
	class BGSEntryPointFunctionDataOneValue : public BGSEntryPointFunctionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEntryPointFunctionDataOneValue;

		~BGSEntryPointFunctionDataOneValue() override;  // 00

		// override (BGSEntryPointFunctionData)
		FunctionType GetType() const override;                   // 01 - { return kOneValue; }
		bool         LoadFunctionData(TESFile* a_mod) override;  // 02

		// members
		float         data;   // 08 - DATA
		std::uint32_t pad0C;  // 0C
	};
	static_assert(sizeof(BGSEntryPointFunctionDataOneValue) == 0x10);
}


===============================================
File: include/RE/B/BGSEntryPointFunctionDataText.h
===============================================
#pragma once

#include "RE/B/BGSEntryPointFunctionData.h"
#include "RE/B/BSFixedString.h"

namespace RE
{
	class BGSEntryPointFunctionDataText : public BGSEntryPointFunctionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEntryPointFunctionDataText;

		~BGSEntryPointFunctionDataText() override;  // 00

		// override (BGSEntryPointFunctionData)
		FunctionType GetType() const override;                   // 01 - { return kText; }
		bool         LoadFunctionData(TESFile* a_mod) override;  // 02

		// members
		BSFixedString text;  // 08
	};
	static_assert(sizeof(BGSEntryPointFunctionDataText) == 0x10);
}


===============================================
File: include/RE/B/BGSEntryPointPerkEntry.h
===============================================
#pragma once

#include "RE/B/BGSPerkEntry.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class BGSEntryPointFunctionData;
	class TESCondition;

	class BGSEntryPointPerkEntry : public BGSPerkEntry
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEntryPointPerkEntry;

		struct EntryData  // DATA
		{
		public:
			enum class Function
			{
				kSetValue = 1,
				kAddValue = 2,
				kMultiplyValue = 3,
				kAddRangeToValue = 4,
				kAddActorValueMult = 5,
				kAbsoluteValue = 6,
				kNegativeAbsoluteValue = 7,
				kAddLeveledList = 8,
				kAddActivateChoice = 9,
				kSelectSpell = 10,
				kSelectText = 11,
				kSetToActorValueMult = 12,
				kMultiplyActorValueMult = 13,
				kMultiply1PlusActorValueMult = 14,
				kSetText = 15
			};

			// members
			stl::enumeration<EntryPoint, std::uint8_t> entryPoint;  // 0
			stl::enumeration<Function, std::uint8_t>   function;    // 1
			std::uint8_t                               numArgs;     // 2
			std::uint8_t                               unk3;        // 3
			std::uint32_t                              unk4;        // 4
		};
		static_assert(sizeof(EntryData) == 0x8);

		// override (BGSPerkEntry)
		bool       CheckConditionFilters(std::uint32_t a_numArgs, void* a_args) override;  // 00
		EntryPoint GetFunction() override;                                                 // 01 - { return function; }
		void*      GetFunctionData() const override;                                       // 02 - { return functionData; }

		~BGSEntryPointPerkEntry() override;  // 03

		PERK_ENTRY_TYPE GetType() const override;                  // 04 - { return kEntryPoint; }
		void            ClearData() override;                      // 05
		void            InitItem(TESFile* a_owner) override;       // 06
		bool            Load(TESFile* a_file) override;            // 07
		void            SetParent(BGSPerk* a_parent) override;     // 08
		std::uint16_t   GetID() const override;                    // 09
		void            ApplyPerkEntry(Actor* a_actor) override;   // 0A
		void            RemovePerkEntry(Actor* a_actor) override;  // 0B

		[[nodiscard]] bool IsEntryPoint(EntryPoint a_entryPoint) const;

		// members
		EntryData                  entryData;     // 10 - DATA
		BGSEntryPointFunctionData* functionData;  // 18
		SimpleArray<TESCondition>  conditions;    // 20
		BGSPerk*                   perk;          // 28
	};
	static_assert(sizeof(BGSEntryPointPerkEntry) == 0x30);
}


===============================================
File: include/RE/B/BGSEquipSlot.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSEquipSlot : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEquipSlot;
		inline static constexpr auto VTABLE = VTABLE_BGSEquipSlot;
		inline static constexpr auto FORMTYPE = FormType::EquipSlot;

		enum class Flag  // DATA
		{
			kNone = 0,
			kUseAllParents = 1 << 0,
			kParentsOptional = 1 << 1,
			kItemSlot = 1 << 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSEquipSlot() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BSTArray<BGSEquipSlot*>               parentSlots;  // 20 - PNAM
		stl::enumeration<Flag, std::uint32_t> flags;        // 38 - DATA
		std::uint32_t                         pad3C;        // 3C
	};
	static_assert(sizeof(BGSEquipSlot) == 0x40);
}


===============================================
File: include/RE/B/BGSEquipType.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSEquipType : public BaseFormComponent  // EQUP
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSEquipType;

		enum class EQUIPPED_ITEM_TYPE
		{
			kSpell = 24,
			kShield = 25,
			kTorch = 26,

			kTotal
		};

		~BGSEquipType() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { equipSlot = 0; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual BGSEquipSlot* GetEquipSlot() const;                // 04 - { return equipSlot; }
		virtual void                        SetEquipSlot(BGSEquipSlot* a_slot);  // 05 - { equipSlot = a_slot; }

		// members
		BGSEquipSlot* equipSlot;  // 08 - ETYP
	};
	static_assert(sizeof(BGSEquipType) == 0x10);
}


===============================================
File: include/RE/B/BGSExplosion.h
===============================================
#pragma once

#include "RE/B/BGSPreloadable.h"
#include "RE/F/FormTypes.h"
#include "RE/S/SoundLevels.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESEnchantableForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESImageSpaceModifiableForm.h"
#include "RE/T/TESModel.h"

namespace RE
{
	struct BGSExplosionData  // DATA
	{
		enum class Flag
		{
			kNone = 0,
			kAlwaysUsesWorldOrientation = 1 << 1,
			kKnockDown_Always = 1 << 2,
			kKnockDown_ByFormula = 1 << 3,
			kIgnoreLOSCheck = 1 << 4,
			kPushExplosionSourceRefOnly = 1 << 5,
			kIgnoreImageSpaceSwap = 1 << 6,
			kChain = 1 << 7,
			kNoControllerVibration = 1 << 8
		};

		TESObjectLIGH*                               light;               // 00
		BGSSoundDescriptorForm*                      sound1;              // 08
		BGSSoundDescriptorForm*                      sound2;              // 10
		BGSImpactDataSet*                            impactDataSet;       // 18
		TESObjectREFR*                               impactPlacedObject;  // 20
		BGSProjectile*                               spawnProjectile;     // 28
		float                                        force;               // 30
		float                                        damage;              // 34
		float                                        radius;              // 38
		float                                        imageSpaceRadius;    // 3C
		float                                        verticalOffsetMult;  // 40
		stl::enumeration<Flag, std::uint32_t>        flags;               // 44
		stl::enumeration<SOUND_LEVEL, std::uint32_t> eSoundLevel;         // 48
		std::uint32_t                                pad4C;               // 4C
	};
	static_assert(sizeof(BGSExplosionData) == 0x50);

	class BGSExplosion :
		public TESBoundObject,              // 00
		public TESFullName,                 // 30
		public TESModel,                    // 40
		public TESEnchantableForm,          // 68
		public BGSPreloadable,              // 80
		public TESImageSpaceModifiableForm  // 88
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSExplosion;
		inline static constexpr auto VTABLE = VTABLE_BGSExplosion;
		inline static constexpr auto FORMTYPE = FormType::Explosion;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSExplosion() override;  // 00

		// override (TESBoundObject)
		void        InitializeData() override;                            // 04
		bool        Load(TESFile* a_mod) override;                        // 06
		void        InitItemImpl() override;                              // 13
		NiAVObject* Clone3D(TESObjectREFR* a_ref, bool a_arg3) override;  // 40
		void        UnClone3D(TESObjectREFR* a_ref) override;             // 41

		// members
		BGSExplosionData data;  // 98 - DATA
	};
	static_assert(sizeof(BGSExplosion) == 0xE8);
}


===============================================
File: include/RE/B/BGSFootstep.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSFootstep : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSFootstep;
		inline static constexpr auto VTABLE = VTABLE_BGSFootstep;
		inline static constexpr auto FORMTYPE = FormType::Footstep;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSFootstep() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BSFixedString     tag;        // 20 - ANAM
		BGSImpactDataSet* impactSet;  // 28 - DATA
	};
	static_assert(sizeof(BGSFootstep) == 0x30);
}


===============================================
File: include/RE/B/BGSFootstepEvent.h
===============================================
#pragma once

#include "RE/B/BGSActorEvent.h"
#include "RE/B/BSFixedString.h"

namespace RE
{
	struct BGSFootstepEvent : public BGSActorEvent
	{
	public:
		// members
		std::uint32_t pad04;  // 04
		BSFixedString tag;    // 08
	};
	static_assert(sizeof(BGSFootstepEvent) == 0x10);
}


===============================================
File: include/RE/B/BGSFootstepManager.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	struct BGSFootstepEvent;

	class BGSFootstepManager :
		public BSTEventSource<BGSFootstepEvent>,    // 00
		public BSTSingletonSDM<BGSFootstepManager>  // 58
	{
	public:
		static BGSFootstepManager* GetSingleton();

		// members
		std::uint8_t            pad59;  // 59
		std::uint16_t           pad5A;  // 5A
		std::uint32_t           pad5C;  // 5C
		BSTArray<BSFixedString> unk60;  // 60
		std::uint64_t           unk78;  // 78
	};
	static_assert(sizeof(BGSFootstepManager) == 0x80);
}


===============================================
File: include/RE/B/BGSFootstepSet.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct ACTOR_MOVEMENT_TYPES
	{
		enum ACTOR_MOVEMENT_TYPE : std::uint32_t
		{
			kWalk = 0,
			kRun = 1,
			kSneak = 2,
			kBleedout = 3,
			kSwim = 4,

			kTotal = 5
		};
	};
	using ACTOR_MOVEMENT_TYPE = ACTOR_MOVEMENT_TYPES::ACTOR_MOVEMENT_TYPE;

	class BGSFootstepSet : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSFootstepSet;
		inline static constexpr auto VTABLE = VTABLE_BGSFootstepSet;
		inline static constexpr auto FORMTYPE = FormType::FootstepSet;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSFootstepSet() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BSTArray<BGSFootstep*> entries[ACTOR_MOVEMENT_TYPES::kTotal];  // 20
	};
	static_assert(sizeof(BGSFootstepSet) == 0x98);
}


===============================================
File: include/RE/B/BGSGrassManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiNode;

	class BGSGrassManager : public BSTSingletonSDM<BGSGrassManager>
	{
	public:
		static BGSGrassManager* GetSingleton()
		{
			REL::Relocation<BGSGrassManager**> singleton{ RELOCATION_ID(514292, 400452) };
			return *singleton;
		}

		// members
		bool                    generateGrassDataFiles;  // 01
		std::uint8_t            unk02;                   // 02
		std::uint16_t           unk04;                   // 04
		std::uint32_t           unk08;                   // 08
		std::uint32_t           unk0C;                   // 0C
		std::uint64_t           unk10;                   // 10 - BSTHashMap<std::uint64_t, GrassType*> ?
		std::uint64_t           unk18;                   // 18
		std::uint64_t           unk20;                   // 20
		std::uint64_t           unk28;                   // 28
		std::uint64_t           unk30;                   // 30
		mutable BSReadWriteLock lock;                    // 38
		std::uint32_t           unk40;                   // 40
		std::uint32_t           pad44;                   // 44
		BSTArray<void*>         unk48;                   // 48
		float                   unk60;                   // 60
		std::uint32_t           pad64;                   // 64
		NiPointer<NiNode>       grassNode;               // 68
		std::uint32_t           grassEvalSize;           // 70
		std::uint32_t           grassEvalSizeSquared;    // 74
		std::uint32_t           unk78;                   // 78
		std::uint32_t           unk7C;                   // 7C
		std::uint64_t           unk80;                   // 80
		bool                    enableGrass;             // 88
	};
	static_assert(sizeof(BGSGrassManager) == 0x90);
}


===============================================
File: include/RE/B/BGSHazard.h
===============================================
#pragma once

#include "RE/B/BGSPreloadable.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESImageSpaceModifiableForm.h"
#include "RE/T/TESModel.h"

namespace RE
{
	struct BGSHazardData  // DATA
	{
	public:
		enum class BGSHazardFlags
		{
			kNone = 0,
			kPCOnly = 1 << 0,
			kInheritDuration = 1 << 1,
			kAlignToNormal = 1 << 2,
			kInheritRadius = 1 << 3,
			kDropToGround = 1 << 4
		};

		std::uint32_t                                   limit;             // 00
		float                                           radius;            // 04
		float                                           lifetime;          // 08
		float                                           imageSpaceRadius;  // 0C
		float                                           targetInterval;    // 10
		stl::enumeration<BGSHazardFlags, std::uint32_t> flags;             // 14
		SpellItem*                                      spell;             // 18
		TESObjectLIGH*                                  light;             // 20
		BGSImpactDataSet*                               impactDataSet;     // 28
		BGSSoundDescriptorForm*                         sound;             // 30
	};
	static_assert(sizeof(BGSHazardData) == 0x38);

	class BGSHazard :
		public TESBoundObject,              // 00
		public TESFullName,                 // 30
		public TESModel,                    // 40
		public BGSPreloadable,              // 68
		public TESImageSpaceModifiableForm  // 70
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSHazard;
		inline static constexpr auto VTABLE = VTABLE_BGSHazard;
		inline static constexpr auto FORMTYPE = FormType::Hazard;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSHazard() override;  // 00

		// override (TESBoundObject)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BGSHazardData data;  // 80 - DATA
	};
	static_assert(sizeof(BGSHazard) == 0xB8);
}


===============================================
File: include/RE/B/BGSHeadPart.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESModelTri.h"

namespace RE
{
	class BGSHeadPart :
		public TESForm,             // 000
		public TESFullName,         // 020
		public TESModelTextureSwap  // 030
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSHeadPart;
		inline static constexpr auto VTABLE = VTABLE_BGSHeadPart;
		inline static constexpr auto FORMTYPE = FormType::HeadPart;

		enum class Flag  // DATA
		{
			kNone = 0,
			kPlayable = 1 << 0,
			kMale = 1 << 1,
			kFemale = 1 << 2,
			kIsExtraPart = 1 << 3,
			kUseSolidTint = 1 << 4
		};

		enum class HeadPartType  // PNAM
		{
			kMisc = 0x0,
			kFace = 0x1,
			kEyes = 0x2,
			kHair = 0x3,
			kFacialHair = 0x4,
			kScar = 0x5,
			kEyebrows = 0x6,

			kTotal
		};

		struct MorphIndices
		{
			enum MorphIndex : std::uint32_t
			{
				kRaceMorph = 0,
				kDefaultMorph,
				kChargenMorph,

				kTotal
			};
		};
		using MorphIndex = MorphIndices::MorphIndex;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSHeadPart() override;  // 00

		// override (TESForm)
		void        InitializeData() override;                    // 04
		void        ClearData() override;                         // 05
		bool        Load(TESFile* a_mod) override;                // 06
		void        InitItemImpl() override;                      // 13
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { formEditorID = a_str; return true; }

		bool IsExtraPart();

		// members
		stl::enumeration<Flag, std::uint8_t>          flags;                         // 068 - DATA
		std::uint8_t                                  pad069;                        // 069
		std::uint16_t                                 pad06A;                        // 06A
		stl::enumeration<HeadPartType, std::uint32_t> type;                          // 06C - PNAM
		BSTArray<BGSHeadPart*>                        extraParts;                    // 070
		BGSTextureSet*                                textureSet;                    // 088 - TNAM
		TESModelTri                                   morphs[MorphIndices::kTotal];  // 090
		BGSColorForm*                                 color;                         // 108 - CNAM
		BGSListForm*                                  validRaces;                    // 110 - RNAM
		BSFixedString                                 formEditorID;                  // 118 - EDID
	};
	static_assert(sizeof(BGSHeadPart) == 0x120);
}


===============================================
File: include/RE/B/BGSIdleCollection.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESIdleForm;

	class BGSIdleCollection : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSIdleCollection;

		enum class IdleFlags
		{
			kNone = 0,
			kPickSequence = 1 << 0,
			kOldPickConditions = 1 << 1,
			kDoOnce = 1 << 2,
			kLooseOnly = 1 << 3,
			kNoSandbox = 1 << 4
		};

		~BGSIdleCollection() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		bool                         AddIdle(TESIdleForm* a_idle);
		static BGSIdleCollection*    Create();
		std::optional<std::uint32_t> GetIndex(TESIdleForm* a_idle) const;
		bool                         RemoveIdle(TESIdleForm* a_idle);

		// members
		stl::enumeration<IdleFlags, std::int8_t> idleFlags;          // 08 - IDLF
		std::int8_t                              idleCount;          // 09 - IDLC
		std::uint16_t                            pad0A;              // 0A
		std::uint32_t                            pad0C;              // 0C
		TESIdleForm**                            idles;              // 10 - IDLA
		float                                    timerCheckForIdle;  // 18 - IDLT
		std::uint32_t                            pad1C;              // 1C

	private:
		BGSIdleCollection* Ctor()
		{
			using func_t = decltype(&BGSIdleCollection::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(14127, 14227) };
			return func(this);
		}
		void CopyIdles(const std::vector<TESIdleForm*>& a_copiedData);
	};
	static_assert(sizeof(BGSIdleCollection) == 0x20);
}


===============================================
File: include/RE/B/BGSIdleMarker.h
===============================================
#pragma once

#include "RE/B/BGSIdleCollection.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class BGSIdleMarker :
		public TESBoundObject,    // 00
		public TESModel,          // 30
		public BGSIdleCollection  // 58
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSIdleMarker;
		inline static constexpr auto VTABLE = VTABLE_BGSIdleMarker;
		inline static constexpr auto FORMTYPE = FormType::IdleMarker;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kChildCanUse = 1 << 29
			};
		};

		~BGSIdleMarker() override;  // 00

		// override (TESBoundObject)
		bool        Load(TESFile* a_mod) override;             // 06
		void        InitItemImpl() override;                   // 13
		bool        GetIgnoredBySandbox() const override;      // 22 - { return (BGSIdleCollection::flags >> 4) & 1; }
		void        UnClone3D(TESObjectREFR* a_ref) override;  // 41
		NiAVObject* Clone3D(TESObjectREFR* a_ref) override;    // 4A
	};
	static_assert(sizeof(BGSIdleMarker) == 0x78);
}


===============================================
File: include/RE/B/BGSImpactData.h
===============================================
#pragma once

#include "RE/C/Color.h"
#include "RE/D/DecalData.h"
#include "RE/F/FormTypes.h"
#include "RE/I/ImpactResults.h"
#include "RE/S/SoundLevels.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class BGSImpactData :
		public TESForm,  // 00
		public TESModel  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSImpactData;
		inline static constexpr auto VTABLE = VTABLE_BGSImpactData;
		inline static constexpr auto FORMTYPE = FormType::Impact;

		enum class ORIENTATION
		{
			kSurfaceNormal = 0,
			kProjVector = 1,
			kProjReflect = 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct IMPACT_DATA_DATA  // DATA
		{
			enum class Flag
			{
				kNone = 0,
				kNoDecalData = 1 << 0
			};

			float                                        effectDuration;   // 00
			stl::enumeration<ORIENTATION, std::uint32_t> orient;           // 04
			float                                        angleThreshold;   // 08
			float                                        placementRadius;  // 0C
			SOUND_LEVEL                                  soundLevel;       // 10
			stl::enumeration<Flag, std::uint8_t>         flags;            // 14
			stl::enumeration<ImpactResult, std::uint8_t> resultOverride;   // 15
			std::uint16_t                                unk16;            // 16
		};
		static_assert(sizeof(IMPACT_DATA_DATA) == 0x18);

		~BGSImpactData() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		IMPACT_DATA_DATA        data;              // 48 - DATA
		BGSTextureSet*          decalTextureSet;   // 60 - DNAM
		BGSTextureSet*          decalTextureSet2;  // 68 - ENAM
		BGSSoundDescriptorForm* sound1;            // 70 - SNAM
		BGSSoundDescriptorForm* sound2;            // 78 - NAM1
		BGSHazard*              hazard;            // 80 - NAM2
		DecalData               dData;             // 88 - DODT
		std::uint32_t           padAC;             // AC
	};
	static_assert(sizeof(BGSImpactData) == 0xB0);
}


===============================================
File: include/RE/B/BGSImpactDataSet.h
===============================================
#pragma once

#include "RE/B/BGSPreloadable.h"
#include "RE/B/BSTHashMap.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSImpactDataSet :
		public TESForm,        // 00
		public BGSPreloadable  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSImpactDataSet;
		inline static constexpr auto VTABLE = VTABLE_BGSImpactDataSet;
		inline static constexpr auto FORMTYPE = FormType::ImpactDataSet;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSImpactDataSet() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BSTHashMap<const BGSMaterialType*, BGSImpactData*> impactMap;  // 28 - PNAM
	};
	static_assert(sizeof(BGSImpactDataSet) == 0x58);
}


===============================================
File: include/RE/B/BGSImpactManager.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class TESObjectREFR;
	class BGSImpactDataSet;
	struct BGSFootstepEvent;
	struct BGSCombatImpactEvent;
	struct BGSCollisionSoundEvent;
	struct BSSoundHandle;

	class BGSImpactManager :
		public BSTEventSink<BGSFootstepEvent>,        // 00
		public BSTEventSink<BGSCombatImpactEvent>,    // 08
		public BSTEventSink<BGSCollisionSoundEvent>,  // 10
		public BSTSingletonSDM<BGSImpactManager>      // 18
	{
	public:
		struct ImpactSoundData
		{
		public:
			// members
			BGSImpactData* impactData;      // 00
			NiPoint3*      position;        // 08
			NiAVObject*    objectToFollow;  // 10
			BSSoundHandle* sound1;          // 18
			BSSoundHandle* sound2;          // 20
			bool           playSound1;      // 28
			bool           playSound2;      // 29
			bool           unk2A;           // 2A
			void*          unk30;           // 30
		};
		static_assert(sizeof(ImpactSoundData) == 0x38);

		// override (BSTEventSink<BGSFootstepEvent>)
		BSEventNotifyControl ProcessEvent(const BGSFootstepEvent* a_event, BSTEventSource<BGSFootstepEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BGSCombatImpactEvent>)
		BSEventNotifyControl ProcessEvent(const BGSCombatImpactEvent* a_event, BSTEventSource<BGSCombatImpactEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BGSCollisionSoundEvent>)
		BSEventNotifyControl ProcessEvent(const BGSCollisionSoundEvent* a_event, BSTEventSource<BGSCollisionSoundEvent>* a_eventSource) override;  // 01

		static BGSImpactManager* GetSingleton()
		{
			REL::Relocation<BGSImpactManager**> singleton{ RELOCATION_ID(515123, 401262) };
			return *singleton;
		}

		bool PlayImpactEffect(TESObjectREFR* a_ref, BGSImpactDataSet* a_impactEffect, const BSFixedString& a_nodeName, NiPoint3& a_pickDirection, float a_pickLength, bool a_applyNodeRotation, bool a_useNodeLocalRotation)
		{
			using func_t = decltype(&BGSImpactManager::PlayImpactEffect);
			REL::Relocation<func_t> func{ RELOCATION_ID(35320, 36215) };
			return func(this, a_ref, a_impactEffect, a_nodeName, a_pickDirection, a_pickLength, a_applyNodeRotation, a_useNodeLocalRotation);
		}
		bool PlayImpactDataSounds(ImpactSoundData& a_impactSoundData)
		{
			using func_t = decltype(&BGSImpactManager::PlayImpactDataSounds);
			REL::Relocation<func_t> func{ RELOCATION_ID(35317, 36212) };
			return func(this, a_impactSoundData);
		}
	};
}


===============================================
File: include/RE/B/BGSInstancedQuestObjective.h
===============================================
#pragma once

#include "RE/Q/QuestObjectiveStates.h"

namespace RE
{
	class BGSQuestObjective;

	class BGSInstancedQuestObjective
	{
	public:
		// members
		BGSQuestObjective*    Objective;      // 00
		std::uint32_t         instanceID;     // 08
		QUEST_OBJECTIVE_STATE InstanceState;  // 0C
	};
	static_assert(sizeof(BGSInstancedQuestObjective) == 0x10);
}


===============================================
File: include/RE/B/BGSKeyword.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSKeyword : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSKeyword;
		inline static constexpr auto VTABLE = VTABLE_BGSKeyword;
		inline static constexpr auto FORMTYPE = FormType::Keyword;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSKeyword() override;  // 00

		// override (TESForm)
		bool        Load(TESFile* a_mod) override;                // 06
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { formEditorID = a_str; }

		// members
		BSFixedString formEditorID;  // 20
	};
	static_assert(sizeof(BGSKeyword) == 0x28);
}


===============================================
File: include/RE/B/BGSKeywordForm.h
===============================================
#pragma once

#include "RE/B/BGSKeyword.h"
#include "RE/B/BSContainer.h"
#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class BGSKeyword;

	class BGSKeywordForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSKeywordForm;

		~BGSKeywordForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { return; }
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual bool        HasKeyword(const BGSKeyword* a_keyword) const;  // 04
		[[nodiscard]] virtual BGSKeyword* GetDefaultKeyword() const;                      // 05 - { return 0; }

		bool                                       AddKeyword(BGSKeyword* a_keyword);
		bool                                       AddKeywords(const std::vector<BGSKeyword*>& a_keywords);
		[[nodiscard]] bool                         ContainsKeywordString(std::string_view a_editorID) const;
		void                                       ForEachKeyword(std::function<BSContainer::ForEachResult(BGSKeyword&)> a_callback) const;
		[[nodiscard]] std::optional<BGSKeyword*>   GetKeywordAt(std::uint32_t a_idx) const;
		[[nodiscard]] std::optional<std::uint32_t> GetKeywordIndex(BGSKeyword* a_keyword) const;
		[[nodiscard]] std::uint32_t                GetNumKeywords() const;
		[[nodiscard]] bool                         HasKeywordID(FormID a_formID) const;
		[[nodiscard]] bool                         HasKeywordString(std::string_view a_editorID) const;
		bool                                       RemoveKeyword(std::uint32_t a_index);
		bool                                       RemoveKeyword(BGSKeyword* a_keyword);
		bool                                       RemoveKeywords(const std::vector<RE::BGSKeyword*>& a_keywords);

		[[nodiscard]] std::span<BGSKeyword*> GetKeywords()
		{
			return { keywords, numKeywords };
		}

		[[nodiscard]] std::span<BGSKeyword* const> GetKeywords() const
		{
			return { keywords, numKeywords };
		}

		// members
		BGSKeyword**  keywords;     // 08 - KWDA
		std::uint32_t numKeywords;  // 10 - KSIZ
		std::uint32_t pad14;        // 14

	private:
		void CopyKeywords(const std::vector<RE::BGSKeyword*>& a_copiedData);
	};
	static_assert(sizeof(BGSKeywordForm) == 0x18);
}


===============================================
File: include/RE/B/BGSLensFlare.h
===============================================
#pragma once

#include "RE/B/BSLensFlareRenderData.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSLensFlare :
		public TESForm,               // 00
		public BSLensFlareRenderData  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLensFlare;
		inline static constexpr auto VTABLE = VTABLE_BGSLensFlare;
		inline static constexpr auto FORMTYPE = FormType::LensFlare;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~BGSLensFlare() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13
	};
	static_assert(sizeof(BGSLensFlare) == 0x40);
}


===============================================
File: include/RE/B/BGSLightingTemplate.h
===============================================
#pragma once

#include "RE/B/BGSDirectionalAmbientLightingColors.h"
#include "RE/F/FormTypes.h"
#include "RE/I/InteriorData.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSLightingTemplate : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLightingTemplate;
		inline static constexpr auto VTABLE = VTABLE_BGSLightingTemplate;
		inline static constexpr auto FORMTYPE = FormType::LightingMaster;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSLightingTemplate() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		INTERIOR_DATA                       data;                              // 20 - DATA
		BGSDirectionalAmbientLightingColors directionalAmbientLightingColors;  // 80 - DALC
	};
	static_assert(sizeof(BGSLightingTemplate) == 0xA0);
}


===============================================
File: include/RE/B/BGSListForm.h
===============================================
#pragma once

#include "RE/B/BSContainer.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSListForm : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSListForm;
		inline static constexpr auto VTABLE = VTABLE_BGSListForm;
		inline static constexpr auto FORMTYPE = FormType::FormList;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kAddedForm = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSListForm() override;  // 00

		// override (TESForm)
		void ClearData() override;                         // 05
		bool Load(TESFile* a_mod) override;                // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void InitItemImpl() override;                      // 13

		void               AddForm(TESForm* a_form);
		[[nodiscard]] bool ContainsOnlyType(FormType a_formType) const;
		void               ForEachForm(std::function<BSContainer::ForEachResult(TESForm&)> a_callback) const;
		[[nodiscard]] bool HasForm(const TESForm* a_form) const;
		[[nodiscard]] bool HasForm(FormID a_formID) const;

		// members
		BSTArray<TESForm*> forms;                 // 20 - LNAM
		BSTArray<FormID>*  scriptAddedTempForms;  // 38
		std::uint32_t      scriptAddedFormCount;  // 40
		std::uint32_t      pad44;                 // 44
	};
	static_assert(sizeof(BGSListForm) == 0x48);
}


===============================================
File: include/RE/B/BGSLoadFormBuffer.h
===============================================
#pragma once

#include "RE/B/BGSLoadFormData.h"
#include "RE/B/BGSLoadGameBuffer.h"

namespace RE
{
	class BGSLoadFormBuffer :
		public BGSLoadGameBuffer,  // 00
		public BGSLoadFormData     // 28
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLoadFormBuffer;
		inline static constexpr auto VTABLE = VTABLE_BGSLoadFormBuffer;

		~BGSLoadFormBuffer() override;

		// override (BGSLoadGameBuffer)
		std::uint8_t GetVersion(void) override;  // 01 - { return version; }
	};
	static_assert(sizeof(BGSLoadFormBuffer) == 0x50);
}


===============================================
File: include/RE/B/BGSLoadFormData.h
===============================================
#pragma once

namespace RE
{
	class TESForm;

	class BGSLoadFormData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLoadFormData;

		enum class Flags
		{
			kSkipForm = 1 << 0,
			kFormPending = 1 << 1,
			kRevertOnly = 1 << 2,
			kConstructedForm = 1 << 3,
			kCellChanged = 1 << 4,
			kLoadingPackageFromExtraData = 1 << 5
		};

		// members
		FormID                                 formID;            // 00
		std::uint32_t                          size;              // 04
		std::uint32_t                          uncompressedSize;  // 08
		std::uint32_t                          pad0C;             // 0C
		TESForm*                               form;              // 10
		std::uint32_t                          changeFlags;       // 18
		std::uint32_t                          oldChangeFlags;    // 1C
		stl::enumeration<Flags, std::uint32_t> flags;             // 20
		std::uint8_t                           pad22;             // 22
		std::uint8_t                           version;           // 23
	};
	static_assert(sizeof(BGSLoadFormData) == 0x28);
}


===============================================
File: include/RE/B/BGSLoadGameBuffer.h
===============================================
#pragma once

namespace RE
{
	class BGSLoadGameBuffer
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLoadGameBuffer;
		inline static constexpr auto VTABLE = VTABLE_BGSLoadGameBuffer;

		virtual ~BGSLoadGameBuffer();

		// add
		virtual std::uint8_t GetVersion(void);  // 01

		// members
		void*         buffer;          // 08
		std::uint64_t unk10;           // 10
		std::uint32_t unk18;           // 18
		std::uint32_t unk1C;           // 1C
		std::uint32_t unk20;           // 20
		std::uint32_t bufferPosition;  // 24
	};
	static_assert(sizeof(BGSLoadGameBuffer) == 0x28);
}


===============================================
File: include/RE/B/BGSLoadGameSubBuffer.h
===============================================
#pragma once

namespace RE
{
	struct BGSSaveLoadBuffer
	{
	public:
		// members
		char* buffer;  // 00
	};
	static_assert(sizeof(BGSSaveLoadBuffer) == 0x8);

	struct BGSLoadGameSubBuffer
	{
	public:
		// members
		BGSSaveLoadBuffer buffer;  // 00
	};
	static_assert(sizeof(BGSLoadGameSubBuffer) == 0x8);
}


===============================================
File: include/RE/B/BGSLocAlias.h
===============================================
#pragma once

#include "RE/B/BGSBaseAlias.h"

namespace RE
{
	class TESCondition;

	class BGSLocAlias : public BGSBaseAlias
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLocAlias;
		inline static auto           VMTYPEID = static_cast<VMTypeID>(141);

		~BGSLocAlias() override;  // 00

		// members
		std::uint64_t unk28;       // 28
		std::uint64_t unk30;       // 30
		std::uint64_t unk38;       // 38
		std::uint64_t unk40;       // 40
		std::uint64_t unk48;       // 48
		std::uint64_t unk50;       // 50
		TESCondition* conditions;  // 58
	};
	static_assert(sizeof(BGSLocAlias) == 0x60);
}


===============================================
File: include/RE/B/BGSLocalizedStringDL.h
===============================================
#pragma once

namespace RE
{
	class BGSLocalizedStringDL
	{
	public:
		// members
		std::uint32_t id;  // 0
	};
	static_assert(sizeof(BGSLocalizedStringDL) == 0x4);
}


===============================================
File: include/RE/B/BGSLocation.h
===============================================
#pragma once

#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTTuple.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class QueuedPromoteLocationReferencesTask;

	struct UnloadedRefData
	{
	public:
		union CellKey
		{
			BSTTuple<std::int16_t, std::int16_t> xy;
			std::uint32_t                        raw;
		};
		static_assert(sizeof(CellKey) == 0x4);

		// members
		FormID  refID;          // 0
		FormID  parentSpaceID;  // 4
		CellKey cellKey;        // 8
	};
	static_assert(sizeof(UnloadedRefData) == 0xC);

	struct SpecialRefData  // LCSR
	{
	public:
		// members
		BGSLocationRefType* type;     // 00
		UnloadedRefData     refData;  // 08
		std::uint32_t       pad14;    // 14
	};
	static_assert(sizeof(SpecialRefData) == 0x18);

	struct UniqueNPCData  // LCUN
	{
	public:
		// members
		Actor*        actor;      // 00
		FormID        refID;      // 08
		std::uint32_t pad0C;      // 0C
		BGSLocation*  editorLoc;  // 10
	};
	static_assert(sizeof(UniqueNPCData) == 0x18);

	struct OverrideData
	{
	public:
		// members
		BSTArray<UnloadedRefData> addedData;    // 00 - ACPR
		BSTSet<FormID>            removedData;  // 18 - RCPR
	};
	static_assert(sizeof(OverrideData) == 0x48);

	class BGSLocation :
		public TESForm,        // 00
		public TESFullName,    // 20
		public BGSKeywordForm  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLocation;
		inline static constexpr auto VTABLE = VTABLE_BGSLocation;
		inline static constexpr auto FORMTYPE = FormType::Location;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kKeywordData = 1 << 30,
				kCleared = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kCleared = (std::uint32_t)1 << 31
			};
		};

		struct KEYWORD_DATA
		{
		public:
			// members
			BGSKeyword*   keyword;  // 00
			float         data;     // 08
			std::uint32_t pad0C;    // 0C
		};
		static_assert(sizeof(KEYWORD_DATA) == 0x10);

		~BGSLocation() override;  // 00

		// override (TESForm)
		void InitializeData() override;                    // 04
		bool Load(TESFile* a_mod) override;                // 06
		bool FindInFileFast(TESFile* a_mod) override;      // 0C
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void InitItemImpl() override;                      // 13

		[[nodiscard]] bool IsCleared() const;
		[[nodiscard]] bool IsChild(const BGSLocation* a_possibleChild) const;
		[[nodiscard]] bool IsParent(const BGSLocation* a_possibleParent) const;
		[[nodiscard]] bool IsLoaded() const;

		// members
		BGSLocation*                                   parentLoc;               // 48 - PNAM
		TESFaction*                                    unreportedCrimeFaction;  // 50 - FNAM
		BGSMusicType*                                  musicType;               // 58 - NAM1
		ObjectRefHandle                                worldLocMarker;          // 60 - MNAM
		float                                          worldLocRadius;          // 64 - RNAM
		ObjectRefHandle                                horseLocMarker;          // 68 - NAM0
		std::uint32_t                                  pad6C;                   // 6C
		BSTArray<SpecialRefData>                       specialRefs;             // 70 - LCSR
		BSTArray<UniqueNPCData>                        uniqueNPCs;              // 88 - LCUN
		OverrideData*                                  overrideData;            // A0
		NiPointer<QueuedPromoteLocationReferencesTask> promoteRefsTask;         // A8
		BSTArray<ObjectRefHandle>                      promotedRefs;            // B0
		volatile std::int32_t                          loadedCount;             // C8
		std::uint32_t                                  fileOffset;              // CC
		BSTArray<KEYWORD_DATA>                         keywordData;             // D0
		std::uint32_t                                  lastChecked;             // E8
		bool                                           cleared;                 // EC
		bool                                           everCleared;             // ED
		std::uint16_t                                  padEE;                   // EE
	};
	static_assert(sizeof(BGSLocation) == 0xF0);
}


===============================================
File: include/RE/B/BGSLocationRefType.h
===============================================
#pragma once

#include "RE/B/BGSKeyword.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSLocationRefType : public BGSKeyword
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSLocationRefType;
		inline static constexpr auto VTABLE = VTABLE_BGSLocationRefType;
		inline static constexpr auto FORMTYPE = FormType::LocationRefType;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSLocationRefType() override;  // 00

		// override (BGSKeyword)
		void InitItemImpl() override;  // 13
	};
	static_assert(sizeof(BGSLocationRefType) == 0x28);
}


===============================================
File: include/RE/B/BGSMaterialObject.h
===============================================
#pragma once

#include "RE/B/BSMaterialObject.h"
#include "RE/B/BSString.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class BGSMaterialObject :
		public TESForm,          // 00
		public TESModel,         // 20
		public BSMaterialObject  // 48
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMaterialObject;
		inline static constexpr auto VTABLE = VTABLE_BGSMaterialObject;
		inline static constexpr auto FORMTYPE = FormType::MaterialObject;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct FILE_DATA
		{
			char*         buffer;      // 00
			std::uint32_t bufferSize;  // 08
			std::uint32_t pad0C;       // 0C
		};
		static_assert(sizeof(FILE_DATA) == 0x10);

		~BGSMaterialObject() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06

		// override (BSMaterialObject)
		void EnsureLoaded() override;  // 01

		// members
		BSTArray<FILE_DATA> fileData;  // A0 - DNAM
	};
	static_assert(sizeof(BGSMaterialObject) == 0xB8);
}


===============================================
File: include/RE/B/BGSMaterialType.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MaterialIDs.h"
#include "RE/N/NiColor.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSMaterialType : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMaterialType;
		inline static constexpr auto VTABLE = VTABLE_BGSMaterialType;
		inline static constexpr auto FORMTYPE = FormType::MaterialType;

		enum class FLAG
		{
			kNone = 0,
			kStairs = 1 << 0,
			kArrowsStick = 1 << 1
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSMaterialType() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		static BGSMaterialType* GetMaterialType(MATERIAL_ID a_materialID)
		{
			using func_t = decltype(&BGSMaterialType::GetMaterialType);
			REL::Relocation<func_t> func{ RELOCATION_ID(20529, 20968) };
			return func(a_materialID);
		}

		// members
		BGSMaterialType*                      parentType;          // 20 - PNAM
		BSFixedString                         materialName;        // 28 - MNAM
		MATERIAL_ID                           materialID;          // 30
		NiColor                               materialColor;       // 34 - CNAM
		float                                 buoyancy;            // 40 - BNAM
		stl::enumeration<FLAG, std::uint32_t> flags;               // 44 - FNAM
		BGSImpactDataSet*                     havokImpactDataSet;  // 48 - HNAM
	};
	static_assert(sizeof(BGSMaterialType) == 0x50);
}


===============================================
File: include/RE/B/BGSMenuDisplayObject.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESBoundObject;

	class BGSMenuDisplayObject : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMenuDisplayObject;

		~BGSMenuDisplayObject() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual TESBoundObject* GetMenuDisplayObject() const;  // 04 - { return menuDispObject; }

		// members
		TESBoundObject* menuDispObject;  // 08 - MDOB
	};
	static_assert(sizeof(BGSMenuDisplayObject) == 0x10);
}


===============================================
File: include/RE/B/BGSMenuIcon.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESIcon.h"

namespace RE
{
	class BGSMenuIcon :
		public TESForm,  // 00
		public TESIcon   // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMenuIcon;
		inline static constexpr auto VTABLE = VTABLE_BGSMenuIcon;
		inline static constexpr auto FORMTYPE = FormType::MenuIcon;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~BGSMenuIcon() override;  // 00

		// override (TESForm)
		bool Load(TESFile* a_mod) override;  // 06 - { return true; }
	};
	static_assert(sizeof(BGSMenuIcon) == 0x30);
}


===============================================
File: include/RE/B/BGSMessage.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class BGSMessage :
		public TESForm,        // 00
		public TESFullName,    // 20
		public TESDescription  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMessage;
		inline static constexpr auto VTABLE = VTABLE_BGSMessage;
		inline static constexpr auto FORMTYPE = FormType::Message;

		enum class MessageFlag
		{
			kNone = 0,
			kMessageBox = 1 << 0,
			kInitialDelay = 1 << 1
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct MESSAGEBOX_BUTTON
		{
		public:
			// members
			BSFixedString text;        // 00 - ITXT
			TESCondition  conditions;  // 08
		};
		static_assert(sizeof(MESSAGEBOX_BUTTON) == 0x10);

		~BGSMessage() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BGSMenuIcon*                                 icon;         // 40 - INAM
		TESQuest*                                    ownerQuest;   // 48 - QNAM
		BSSimpleList<MESSAGEBOX_BUTTON*>             menuButtons;  // 50
		stl::enumeration<MessageFlag, std::uint32_t> flags;        // 60 - DNAM
		std::uint32_t                                displayTime;  // 64 - TNAM
	};
	static_assert(sizeof(BGSMessage) == 0x68);
}


===============================================
File: include/RE/B/BGSMessageIcon.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/T/TESIcon.h"

namespace RE
{
	class BGSMessageIcon : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMessageIcon;

		~BGSMessageIcon() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02 - { icon.ReleaseRefs(); }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		TESIcon icon;  // 08
	};
	static_assert(sizeof(BGSMessageIcon) == 0x18);
}


===============================================
File: include/RE/B/BGSMovableStatic.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESObjectSTAT.h"

namespace RE
{
	struct MOVABLE_STATIC_DATA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kOnLocalMap = 1 << 0
		};

		// members
		stl::enumeration<Flag, std::uint8_t> flags;  // 0
	};
	static_assert(sizeof(MOVABLE_STATIC_DATA) == 0x1);

	class BGSMovableStatic :
		public TESFullName,                // 00
		public BGSDestructibleObjectForm,  // 10
		public TESObjectSTAT               // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMovableStatic;
		inline static constexpr auto VTABLE = VTABLE_BGSMovableStatic;
		inline static constexpr auto FORMTYPE = FormType::MovableStatic;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kMustUpdateAnims = 1 << 8,
				kHiddenFromLocalMap = 1 << 9,
				kIgnored = 1 << 12,
				kHasDistantLOD = 1 << 15,
				kRandomAnimStart = 1 << 16,
				kHasCurrents = 1 << 19,
				kObstacle = 1 << 25,
				kNavMeshGeneration_Filter = 1 << 26,
				kNavMeshGeneration_BoundingBox = 1 << 27,
				kNavMeshGeneration_Ground = 1 << 30
			};
		};

		~BGSMovableStatic() override;  // 00

		// override (TESObjectSTAT)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BGSSoundDescriptorForm* soundLoop;  // A0 - SNAM
		MOVABLE_STATIC_DATA     data;       // A8
		std::uint8_t            padA9;      // A9
		std::uint16_t           padAA;      // AA
		std::uint32_t           padAC;      // AC
	};
	static_assert(sizeof(BGSMovableStatic) == 0xB0);
}


===============================================
File: include/RE/B/BGSMovementType.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/M/Movement.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSMovementType : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMovementType;
		inline static constexpr auto VTABLE = VTABLE_BGSMovementType;
		inline static constexpr auto FORMTYPE = FormType::MovementType;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSMovementType() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		Movement::TypeData movementTypeData;  // 20
	};
	static_assert(sizeof(BGSMovementType) == 0x60);
}


===============================================
File: include/RE/B/BGSMoviePlayer.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/M/MoviePlayer.h"

namespace RE
{
	class InputEvent;
	struct BSMusicEvent;

	class BGSMoviePlayer :
		public MoviePlayer,                  // 00
		public BSTEventSink<InputEvent*>,    // 58
		public BSTEventSource<BSMusicEvent>  // 60
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMoviePlayer;

		~BGSMoviePlayer() override;  // 00

		// override (MoviePlayer)
		void Unk_01(void) override;  // 01
		void Unk_02(void) override;  // 02
		void Unk_03(void) override;  // 03
		void Unk_04(void) override;  // 04
		void Unk_05(void) override;  // 05 - { return; }
		void Unk_06(void) override;  // 06 - { return; }
		void Unk_07(void) override;  // 07
		void Unk_08(void) override;  // 08
		void Unk_09(void) override;  // 09
		void Unk_0A(void) override;  // 0A
		void Unk_0B(void) override;  // 0B
		void Unk_0C(void) override;  // 0C
		void Unk_0D(void) override;  // 0D

		// members
		std::uint64_t unkB8;  // B8
	};
	static_assert(sizeof(BGSMoviePlayer) == 0xC0);
}


===============================================
File: include/RE/B/BGSMusicPaletteTrack.h
===============================================
#pragma once

#include "RE/B/BGSMusicTrack.h"
#include "RE/B/BSTArray.h"

namespace RE
{
	class BGSMusicPaletteTrack : public BGSMusicTrack
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMusicPaletteTrack;

		~BGSMusicPaletteTrack() override;  // 00

		// override (BGSMusicTrack)
		void      DoUpdate() override;                           // 01
		void      DoPlay() override;                             // 02
		void      DoPause() override;                            // 03
		void      DoFinish(bool a_arg1, float a_arg2) override;  // 04
		float     GetDurationImpl() const override;              // 05 - { return duration; }
		TrackType GetType() const override;                      // 06 - "BGSMusicPaletteTrack"
		void      InitItem(TESForm* a_form) override;            // 0B
		void      Load(TESFile* a_mod) override;                 // 0C

		// members
		BSTArray<BSIMusicTrack*> layers[3];          // 20 - SNAM - tracks are split based on null entries on the record
		std::int32_t             playingIndexes[3];  // 68
		float                    duration;           // 74 - FLTV
		float                    fadeOutTime;        // 78 - DNAM
		std::uint32_t            pad7C;              // 7C
		std::uint64_t            playTime;           // 80
		std::uint64_t            pauseTime;          // 88
	};
	static_assert(sizeof(BGSMusicPaletteTrack) == 0x90);
}


===============================================
File: include/RE/B/BGSMusicSilenceTrack.h
===============================================
#pragma once

#include "RE/B/BGSMusicTrack.h"

namespace RE
{
	class BGSMusicSilenceTrack : public BGSMusicTrack
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMusicSilenceTrack;

		~BGSMusicSilenceTrack() override;  // 00

		// override (BGSMusicTrack)
		void      DoUpdate(void) override;                       // 01
		void      DoPlay() override;                             // 02
		void      DoPause() override;                            // 03
		void      DoFinish(bool a_arg1, float a_arg2) override;  // 04
		float     GetDurationImpl() const override;              // 05 - { return duration; }
		TrackType GetType() const override;                      // 06 - "BGSMusicSilenceTrack"
		void      Load(TESFile* a_mod) override;                 // 0C

		// members
		float         duration;   // 20 - FLTV
		std::uint32_t pad24;      // 24
		std::uint64_t playTime;   // 28
		std::uint64_t pauseTime;  // 30
	};
	static_assert(sizeof(BGSMusicSilenceTrack) == 0x38);
}


===============================================
File: include/RE/B/BGSMusicSingleTrack.h
===============================================
#pragma once

#include "RE/B/BGSMusicTrack.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/I/ID.h"

namespace RE
{
	class BGSMusicSingleTrack : public BGSMusicTrack
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMusicSingleTrack;

		struct LoopData  // LNAM
		{
			float         loopBegin;  // 0
			float         loopEnd;    // 4
			std::uint32_t loopCount;  // 8
		};
		static_assert(sizeof(LoopData) == 0xC);

		~BGSMusicSingleTrack() override;  // 00

		// override (BGSMusicTrack)
		void      DoUpdate() override;                                    // 01
		void      DoPlay() override;                                      // 02
		void      DoPause() override;                                     // 03
		void      DoFinish(bool a_arg1, float a_arg2) override;           // 04
		float     GetDurationImpl() const override;                       // 05
		TrackType GetType() const override;                               // 06 - "BGSMusicSingleTrack"
		void      DoSetDuckingAttenuation(std::uint16_t a_val) override;  // 09
		void      DoClearDucking() override;                              // 0A
		void      Load(TESFile* a_mod) override;                          // 0C

		// members
		BSResource::ID  trackID;                    // 20 - ANAM
		BSResource::ID  finaleID;                   // 2C - BNAM
		BSTArray<float> cuePoints;                  // 38 - FNAM
		std::uint32_t   nextCuePoint;               // 50
		std::uint32_t   loopsRemaining;             // 54
		std::uint32_t   lastKnownPlaybackPosition;  // 58
		std::uint32_t   pad5C;                      // 5C
		LoopData*       loopData;                   // 60 - LNAM
		BSSoundHandle   trackHandle;                // 68
		BSSoundHandle   finaleHandle;               // 78
	};
	static_assert(sizeof(BGSMusicSingleTrack) == 0x80);
}


===============================================
File: include/RE/B/BGSMusicTrack.h
===============================================
#pragma once

#include "RE/B/BSIMusicTrack.h"
#include "RE/T/TESCondition.h"

namespace RE
{
	class TESFile;
	class TESForm;

	class BGSMusicTrack : public BSIMusicTrack
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMusicTrack;

		~BGSMusicTrack() override;  // 00

		// override (BSIMusicTrack)
		[[nodiscard]] bool TestCanPlay() const override;  // 07 - { return conditions ? conditions->Run(g_thePlayer, g_thePlayer) : true; }

		// add
		virtual void InitItem(TESForm* a_form);  // 0B
		virtual void Load(TESFile* a_mod) = 0;   // 0C

		// members
		TESCondition  conditions;  // 10
		std::uint64_t unk18;       // 18
	};
	static_assert(sizeof(BGSMusicTrack) == 0x20);
}


===============================================
File: include/RE/B/BGSMusicTrackFormWrapper.h
===============================================
#pragma once

#include "RE/B/BSIMusicTrack.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSMusicTrack;

	class BGSMusicTrackFormWrapper :
		public TESForm,       // 00
		public BSIMusicTrack  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMusicTrackFormWrapper;
		inline static constexpr auto VTABLE = VTABLE_BGSMusicTrackFormWrapper;
		inline static constexpr auto FORMTYPE = FormType::MusicTrack;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSMusicTrackFormWrapper() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// override (BSIMusicTrack)
		void         DoUpdate() override;                                    // 01
		void         DoPlay() override;                                      // 02
		void         DoPause() override;                                     // 03
		void         DoFinish(bool a_arg1, float a_arg2) override;           // 04
		float        GetDurationImpl() const override;                       // 05
		TrackType    GetType() const override;                               // 06
		bool         TestCanPlay() const override;                           // 07
		MUSIC_STATUS GetMusicStatus() const override;                        // 08
		void         DoSetDuckingAttenuation(std::uint16_t a_val) override;  // 09
		void         DoClearDucking() override;                              // 0A

		// members
		BGSMusicTrack* track;  // 30
	};
	static_assert(sizeof(BGSMusicTrackFormWrapper) == 0x38);
}


===============================================
File: include/RE/B/BGSMusicType.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIMusicType.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSMusicType :
		public TESForm,      // 00
		public BSIMusicType  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSMusicType;
		inline static constexpr auto VTABLE = VTABLE_BGSMusicType;
		inline static constexpr auto FORMTYPE = FormType::MusicType;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSMusicType() override;  // 00

		// override (TESForm)
		void        ClearData() override;                         // 05
		bool        Load(TESFile* a_mod) override;                // 06
		void        InitItemImpl() override;                      // 13
		const char* GetFormEditorID() const override;             // 32 - { return editorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { editorID = a_str; return true; }

		// override (BSIMusicType)
		void DoUpdate() override;                                       // 00
		void DoPlay() override;                                         // 01
		void DoPause() override;                                        // 02
		void DoFinish(bool a_arg1) override;                            // 03
		void DoApplyDuckingAttenuation(std::uint16_t a_arg1) override;  // 04
		void DoClearDucking() override;                                 // 05
		void DoPrepare() override;                                      // 06

		// members
		BSFixedString formEditorID;  // 70 - EDID
	};
	static_assert(sizeof(BGSMusicType) == 0x78);
}


===============================================
File: include/RE/B/BGSNamedPackageData.h
===============================================
#pragma once

#include "RE/I/IPackageData.h"

namespace RE
{
	template <class Parent>
	class BGSNamedPackageData : public Parent
	{
	public:
		static_assert(std::is_base_of<IPackageData, Parent>::value);

		union Data
		{
			bool          b;
			std::uint32_t i;
			float         f;
			void*         p;
		};
		static_assert(sizeof(Data) == 0x8);

		// override (IPackageData)
		void InitPackage() override;                            // 01 - { return; }
		void LoadPackage(TESFile* a_mod) override;              // 02
		void Assign(IPackageData* a_other) override;            // 03 - { return; }
		bool IsNotEqual(IPackageData* a_other) const override;  // 04

		// members
		Data data;  // ??
	};
}


===============================================
File: include/RE/B/BGSNote.h
===============================================
#pragma once

#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class BGSNote :
		public TESBoundObject,         // 00
		public TESModel,               // 30
		public TESFullName,            // 58
		public TESIcon,                // 68
		public BGSPickupPutdownSounds  // 78
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSNote;
		inline static constexpr auto VTABLE = VTABLE_BGSNote;
		inline static constexpr auto FORMTYPE = FormType::Note;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kNoteRead = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~BGSNote() override;  // 00

		// override (TESBoundObject)
		void InitializeData() override;                                                                                                                                // 04
		void ClearData() override;                                                                                                                                     // 05
		bool Load(TESFile* a_mod) override;                                                                                                                            // 06
		void LoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                              // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;                                                                                                                // 12
		void InitItemImpl() override;                                                                                                                                  // 13
		bool Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37

		// members
		TESTopic*               unk90;  // 90
		TESActorBase*           unk98;  // 98
		BSSimpleList<TESQuest*> unkA0;  // A0
		std::uint64_t           unkB0;  // B0
	};
	static_assert(sizeof(BGSNote) == 0xB8);
}


===============================================
File: include/RE/B/BGSOpenCloseForm.h
===============================================
#pragma once

namespace RE
{
	class Actor;
	class TESObjectREFR;

	class BGSOpenCloseForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSOpenCloseForm;

		enum class OPEN_STATE
		{
			kNone = 0,
			kOpen = 1,
			kOpening = 2,
			kClosed = 3,
			kClosing = 4
		};

		virtual ~BGSOpenCloseForm();  // 00

		// add
		virtual void HandleOpen(TESObjectREFR* a_target, TESObjectREFR* a_activator);   // 01 - { return; }
		virtual void HandleClose(TESObjectREFR* a_target, TESObjectREFR* a_activator);  // 02 - { return; }
		virtual void Unk_03(void);                                                      // 03 - { return 0; }

		[[nodiscard]] static OPEN_STATE GetOpenState(const TESObjectREFR* a_ref);
		static void                     SetOpenState(TESObjectREFR* a_ref, bool a_open, bool a_snap);
	};
	static_assert(sizeof(BGSOpenCloseForm) == 0x8);
}


===============================================
File: include/RE/B/BGSOutfit.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSOutfit : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSOutfit;
		inline static constexpr auto VTABLE = VTABLE_BGSOutfit;
		inline static constexpr auto FORMTYPE = FormType::Outfit;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSOutfit() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		void ForEachItem(std::function<BSContainer::ForEachResult(TESForm&)> a_callback) const
		{
			for (auto& item : outfitItems) {
				if (item && a_callback(*item) == BSContainer::ForEachResult::kStop) {
					return;
				}
			}
		}

		// members
		BSTArray<TESForm*> outfitItems;  // 20 - INAM
	};
	static_assert(sizeof(BGSOutfit) == 0x38);
}


===============================================
File: include/RE/B/BGSOverridePackCollection.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class BGSListForm;

	class BGSOverridePackCollection : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSOverridePackCollection;

		~BGSOverridePackCollection() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		BGSListForm* spectatorOverRidePackList;      // 08 - SPOR
		BGSListForm* observeCorpseOverRidePackList;  // 10 - OCOR
		BGSListForm* guardWarnOverRidePackList;      // 18 - GWOR
		BGSListForm* enterCombatOverRidePackList;    // 20 - ECOR
	};
	static_assert(sizeof(BGSOverridePackCollection) == 0x28);
}


===============================================
File: include/RE/B/BGSPackageDataBool.h
===============================================
#pragma once

#include "RE/B/BGSNamedPackageData.h"
#include "RE/I/IPackageData.h"

namespace RE
{
	class BGSPackageDataBool : public BGSNamedPackageData<IPackageData>
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSPackageDataBool;

		~BGSPackageDataBool() override;  // 00

		// override (BGSNamedPackageData<IPackageData>)
		void                               LoadPackage(TESFile* a_mod) override;              // 02
		void                               Assign(IPackageData* a_other) override;            // 03
		bool                               IsNotEqual(IPackageData* a_other) const override;  // 04
		void                               Unk_05(void) override;                             // 05 - { return 1; }
		void                               Unk_07(void) override;                             // 07
		void                               LoadBuffer(BGSLoadFormBuffer* a_buf) override;     // 08
		void                               Unk_09(void) override;                             // 09 - { return; }
		bool                               GetDataAsString(BSString* a_dst) const override;   // 0A - { return *a_dst->set_cstr(((data >> 1) & 1) ? "True" : "False"); }
		[[nodiscard]] const BSFixedString& GetTypeName() const override;                      // 0B - { return "Bool"; }
	};
	static_assert(offsetof(BGSPackageDataBool, data) == 0x08);
	static_assert(sizeof(BGSPackageDataBool) == 0x10);
}


===============================================
File: include/RE/B/BGSPackageDataLocation.h
===============================================
#pragma once

#include "RE/B/BGSPackageDataPointerTemplate.h"
#include "RE/I/IPackageDataAIWorldLocationHandle.h"

namespace RE
{
	class PackageLocation;

	//const BSFixedString kPackageDataLocationTypeName("Location");

	class BGSPackageDataLocation : public BGSPackageDataPointerTemplate<IPackageDataAIWorldLocationHandle, PackageLocation /*, kPackageDataLocationTypeName*/>
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSPackageDataLocation;

		~BGSPackageDataLocation() override;  // 00

		// override (BGSPackageDataPointerTemplate<IPackageDataAIWorldLocationHandle, PackageLocation, kPackageDataLocationTypeName>)
		void Unk_06(void) override;                            // 06
		void Unk_07(void) override;                            // 07
		void LoadBuffer(BGSLoadFormBuffer* a_buf) override;    // 08
		void Unk_09(void) override;                            // 09 - { return; }
		bool GetDataAsString(BSString* a_dst) const override;  // 0A
		void Unk_0C(void) override;                            // 0C - { return pointer->type == PackageLocation::Type::kNearPackageStartLocation; }
	};
	static_assert(sizeof(BGSPackageDataLocation) == 0x20);
}


===============================================
File: include/RE/B/BGSPackageDataPointerTemplate.h
===============================================
#pragma once

#include "RE/B/BGSNamedPackageData.h"
#include "RE/B/BSFixedString.h"

namespace RE
{
	class TESFile;

	template <class Parent, class Pointer /*, const BSFixedString& TYPE_NAME*/>
	class BGSPackageDataPointerTemplate : public BGSNamedPackageData<Parent>
	{
	public:
		virtual ~BGSPackageDataPointerTemplate();  // 00

		// override (BGSNamedPackageData<Parent>)
		void                               Unk_05(void) override;         // 05 - { return 1; }
		[[nodiscard]] const BSFixedString& GetTypeName() const override;  // 0B - { return TYPE_NAME; }

		// add
		virtual void LoadPointer(TESFile* a_mod) = 0;  // ??

		// members
		Pointer* pointer;  // ??
	};
}


===============================================
File: include/RE/B/BGSPerk.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/P/PerkRankVisitor.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"

namespace RE
{
	class BGSPerkEntry;

	struct PerkData  // DATA
	{
		bool        trait;     // 0
		std::int8_t level;     // 1
		std::int8_t numRanks;  // 2
		bool        playable;  // 3
		bool        hidden;    // 4
	};
	static_assert(sizeof(PerkData) == 0x5);

	class BGSPerk :
		public TESForm,         // 00
		public TESFullName,     // 20
		public TESDescription,  // 30
		public TESIcon          // 40
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSPerk;
		inline static constexpr auto VTABLE = VTABLE_BGSPerk;
		inline static constexpr auto FORMTYPE = FormType::Perk;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		class FindPerkInRanksVisitor : public PerkRankVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_BGSPerk__FindPerkInRanksVisitor;

			// override (PerkRankVisitor)
			bool operator()(const PerkRankData* a_entry) override;  // 00
		};
		static_assert(sizeof(FindPerkInRanksVisitor) == 0x8);

		class ApplyPerksVisitor : public PerkRankVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_BGSPerk__ApplyPerksVisitor;

			// override (PerkRankVisitor)
			bool operator()(const PerkRankData* a_entry) override;  // 00
		};
		static_assert(sizeof(ApplyPerksVisitor) == 0x8);

		class AddPerkVisitor : public PerkRankVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_BGSPerk__AddPerkVisitor;

			// override (PerkRankVisitor)
			bool operator()(const PerkRankData* a_entry) override;  // 00
		};
		static_assert(sizeof(AddPerkVisitor) == 0x8);

		~BGSPerk() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		PerkData                data;            // 50 - DATA
		std::uint8_t            pad55;           // 55
		std::uint16_t           pad56;           // 56
		TESCondition            perkConditions;  // 58
		BSTArray<BGSPerkEntry*> perkEntries;     // 60
		BGSPerk*                nextPerk;        // 78 - NNAM
	};
	static_assert(sizeof(BGSPerk) == 0x80);
}


===============================================
File: include/RE/B/BGSPerkEntry.h
===============================================
#pragma once

#include "RE/B/BGSEntryPoint.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class Actor;
	class BGSEntryPointFunctionData;
	class TESFile;

	enum class PERK_ENTRY_TYPE
	{
		kQuest = 0,
		kAbility = 1,
		kEntryPoint = 2
	};

	class BGSPerkEntry
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSPerkEntry;

		using EntryPoint = BGSEntryPoint::ENTRY_POINT;

		struct Header  // PRKE
		{
		public:
			// members
			std::uint8_t  rank;      // 0
			std::uint8_t  priority;  // 1
			std::uint16_t unk2;      // 2
			std::uint32_t unk4;      // 4
		};
		static_assert(sizeof(Header) == 0x8);

		virtual bool                CheckConditionFilters(std::uint32_t a_numArgs, void* a_args);  // 00 - { return false; }
		virtual EntryPoint          GetFunction();                                                 // 01 - { return 0; }
		[[nodiscard]] virtual void* GetFunctionData() const;                                       // 02 - { return 0; }

		virtual ~BGSPerkEntry();  // 03

		[[nodiscard]] virtual PERK_ENTRY_TYPE GetType() const = 0;                  // 04
		virtual void                          ClearData();                          // 05 - { return; }
		virtual void                          InitItem(TESFile* a_owner);           // 06 - { return; }
		virtual bool                          Load(TESFile* a_file);                // 07 - { return true; }
		virtual void                          SetParent(BGSPerk* a_parent);         // 08 - { return; }
		[[nodiscard]] virtual std::uint16_t   GetID() const;                        // 09 - { return 0xFFFF; }
		virtual void                          ApplyPerkEntry(Actor* a_actor) = 0;   // 0A
		virtual void                          RemovePerkEntry(Actor* a_actor) = 0;  // 0B

		[[nodiscard]] std::uint8_t GetRank() const;
		[[nodiscard]] std::uint8_t GetPriority() const;

		// members
		Header header;  // 08 - PRKE
	};
	static_assert(sizeof(BGSPerkEntry) == 0x10);
}


===============================================
File: include/RE/B/BGSPerkRankArray.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class BGSPerk;

	struct PerkRankData  // PRKR
	{
		PerkRankData();
		PerkRankData(BGSPerk* a_perk, std::int8_t a_rank);

		~PerkRankData() = default;

		TES_HEAP_REDEFINE_NEW();

		BGSPerk*      perk;         // 00
		std::int8_t   currentRank;  // 08
		std::uint8_t  pad09;        // 09
		std::uint16_t pad0A;        // 0A
		std::uint32_t pad0C;        // 0C
	};
	static_assert(sizeof(PerkRankData) == 0x10);

	class BGSPerkRankArray : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSPerkRankArray;

		~BGSPerkRankArray() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;              // 01 - { return; }
		void ClearDataComponent() override;                   // 02
		void CopyComponent(BaseFormComponent* rhs) override;  // 03

		// members
		PerkRankData* perks;      // 08 - PRKR
		std::uint32_t perkCount;  // 10 - PRKZ
		std::uint32_t pad14;      // 14
	};
	static_assert(sizeof(BGSPerkRankArray) == 0x18);
}


===============================================
File: include/RE/B/BGSPickupPutdownSounds.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class BGSSoundDescriptorForm;

	class BGSPickupPutdownSounds : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSPickupPutdownSounds;

		~BGSPickupPutdownSounds() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		BGSSoundDescriptorForm* pickupSound;   // 08 - YNAM
		BGSSoundDescriptorForm* putdownSound;  // 10 - ZNAM
	};
	static_assert(sizeof(BGSPickupPutdownSounds) == 0x18);
}


===============================================
File: include/RE/B/BGSPreloadable.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class BGSPreloadable : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSPreloadable;

		~BGSPreloadable() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { return; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03 - { return; }

		// add
		virtual void Unk_04(void) = 0;  // 04
	};
	static_assert(sizeof(BGSPreloadable) == 0x8);
}


===============================================
File: include/RE/B/BGSProcedureTreeBranch.h
===============================================
#pragma once

#include "RE/B/BGSProcedureTreeConditionalItem.h"
#include "RE/B/BSTArray.h"

namespace RE
{
	class BGSProcedureTreeBranch : public BGSProcedureTreeConditionalItem
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSProcedureTreeBranch;

		~BGSProcedureTreeBranch() override;  // 00

		// override (BGSProcedureTreeConditionalItem)
		void Unk_01(void) override;          // 01
		void Unk_02(void) override;          // 02
		void Load(TESFile* a_mod) override;  // 03
		void Unk_05(void) override;          // 05
		void Unk_0A(void) override;          // 0A - { return 1; }
		void Unk_0B(void) override;          // 0B
		void Unk_0C(void) override;          // 0C
		void Unk_0D(void) override;          // 0D - { return 0; }
		void Unk_0E(void) override;          // 0E - { return; }
		void Unk_0F(void) override;          // 0F - { return 0; }
		void Unk_10(void) override;          // 10

		// add
		virtual void Unk_11(void);  // 11

		// members
		BSTArray<BGSProcedureTreeConditionalItem*> conditions;  // 10
		std::uint64_t                              unk28;       // 28
	};
	static_assert(sizeof(BGSProcedureTreeBranch) == 0x30);
}


===============================================
File: include/RE/B/BGSProcedureTreeConditionalItem.h
===============================================
#pragma once

#include "RE/I/IProcedureTreeItem.h"
#include "RE/T/TESCondition.h"

namespace RE
{
	class BGSProcedureTreeConditionalItem : public IProcedureTreeItem
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSProcedureTreeConditionalItem;

		~BGSProcedureTreeConditionalItem() override;  // 00

		// override (IProcedureTreeItem)
		void Unk_01(void) override;          // 01
		void Unk_02(void) override;          // 02
		void Load(TESFile* a_mod) override;  // 03
		void Unk_07(void) override;          // 07

		// members
		TESCondition conditions;  // 08
	};
	static_assert(sizeof(BGSProcedureTreeConditionalItem) == 0x10);
}


===============================================
File: include/RE/B/BGSProcedureTreeProcedure.h
===============================================
#pragma once

#include "RE/B/BGSProcedureTreeConditionalItem.h"
#include "RE/B/BGSTypedItem.h"

namespace RE
{
	class BGSProcedureBase;

	class BGSProcedureTreeProcedure : public BGSTypedItem<BGSProcedureTreeProcedure, BGSProcedureTreeConditionalItem>
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSProcedureTreeProcedure;

		~BGSProcedureTreeProcedure() override;  // 00

		// override (BGSProcedureTreeConditionalItem)
		void Unk_01(void) override;          // 01
		void Unk_02(void) override;          // 02
		void Load(TESFile* a_mod) override;  // 03
		void Unk_04(void) override;          // 04
		void Unk_05(void) override;          // 05
		void Unk_06(void) override;          // 06
		void Unk_07(void) override;          // 07
		void Unk_08(void) override;          // 08
		void Unk_09(void) override;          // 09
		void Unk_0A(void) override;          // 0A
		void Unk_0B(void) override;          // 0B
		void Unk_0C(void) override;          // 0C
		void Unk_0D(void) override;          // 0D
		void Unk_0E(void) override;          // 0E
		void Unk_0F(void) override;          // 0F - { return 1; }
		void Unk_10(void) override;          // 10

		// members
		BGSProcedureBase* procedure;  // 10
	};
	static_assert(sizeof(BGSProcedureTreeProcedure) == 0x18);
}


===============================================
File: include/RE/B/BGSProcedureTreeSequence.h
===============================================
#pragma once

#include "RE/B/BGSProcedureTreeBranch.h"
#include "RE/B/BGSTypedItem.h"

namespace RE
{
	class BGSProcedureTreeSequence : public BGSTypedItem<BGSProcedureTreeSequence, BGSProcedureTreeBranch>
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSProcedureTreeSequence;

		~BGSProcedureTreeSequence() override;  // 00

		// override (BGSProcedureTreeBranch)
		void Unk_04(void) override;  // 04
		void Unk_06(void) override;  // 06
	};
	static_assert(sizeof(BGSProcedureTreeSequence) == 0x30);
}


===============================================
File: include/RE/B/BGSProjectile.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSPreloadable.h"
#include "RE/F/FormTypes.h"
#include "RE/S/SoundLevels.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESModel.h"

namespace RE
{
	struct BGSProjectileData  // DATA
	{
	public:
		enum class BGSProjectileFlags
		{
			kNone = 0,
			kHitScan = 1 << 0,
			kExplosion = 1 << 1,
			kExplosionAltTrigger = 1 << 2,
			kMuzzleFlash = 1 << 3,
			kCanTurnOff = 1 << 5,
			kCanPickUp = 1 << 6,
			kSupersonic = 1 << 7,
			kPinsLimbs = 1 << 8,
			kPassSMTransparent = 1 << 9,
			kDisableCombatAimCorrection = 1 << 10,
			kContinuousUpdate = 1 << 11
		};

		enum class Type
		{
			kMissile = 1 << 0,
			kGrenade = 1 << 1,
			kBeam = 1 << 2,
			kFlamethrower = 1 << 3,
			kCone = 1 << 4,
			kBarrier = 1 << 5,
			kArrow = 1 << 6
		};

		// members
		stl::enumeration<BGSProjectileFlags, std::uint16_t> flags;                // 00
		stl::enumeration<Type, std::uint16_t>               types;                // 02
		float                                               gravity;              // 04
		float                                               speed;                // 08
		float                                               range;                // 0C
		TESObjectLIGH*                                      light;                // 10
		TESObjectLIGH*                                      muzzleFlashLight;     // 18
		float                                               tracerChance;         // 20
		float                                               explosionProximity;   // 24
		float                                               explosionTimer;       // 28
		std::uint32_t                                       pad2C;                // 2C
		BGSExplosion*                                       explosionType;        // 30
		BGSSoundDescriptorForm*                             activeSoundLoop;      // 38
		float                                               muzzleFlashDuration;  // 40
		float                                               fadeOutTime;          // 44
		float                                               force;                // 48
		std::uint32_t                                       pad4C;                // 4C
		BGSSoundDescriptorForm*                             countdownSound;       // 50
		BGSSoundDescriptorForm*                             deactivateSound;      // 58
		TESObjectWEAP*                                      defaultWeaponSource;  // 60
		float                                               coneSpread;           // 68
		float                                               collisionRadius;      // 6C
		float                                               lifetime;             // 70
		float                                               relaunchInterval;     // 74
		BGSTextureSet*                                      decalData;            // 78
		BGSCollisionLayer*                                  collisionLayer;       // 80
	};
	static_assert(sizeof(BGSProjectileData) == 0x88);

	class BGSProjectile :
		public TESBoundObject,            // 000
		public TESFullName,               // 030
		public TESModel,                  // 040
		public BGSPreloadable,            // 068
		public BGSDestructibleObjectForm  // 070
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSProjectile;
		inline static constexpr auto VTABLE = VTABLE_BGSProjectile;
		inline static constexpr auto FORMTYPE = FormType::Projectile;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSProjectile() override;  // 00

		// override (TESBoundObject)
		void        InitializeData() override;                                                                                                                                // 04
		void        ClearData() override;                                                                                                                                     // 05
		bool        Load(TESFile* a_mod) override;                                                                                                                            // 06
		void        InitItemImpl() override;                                                                                                                                  // 13
		bool        Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		NiAVObject* Clone3D(TESObjectREFR* a_ref, bool a_arg3) override;                                                                                                      // 40
		void        UnClone3D(TESObjectREFR* a_ref) override;                                                                                                                 // 41
		bool        GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C

		[[nodiscard]] constexpr bool IsMissile() const noexcept { return data.types.all(BGSProjectileData::Type::kMissile); }
		[[nodiscard]] constexpr bool IsGrenade() const noexcept { return data.types.all(BGSProjectileData::Type::kGrenade); }
		[[nodiscard]] constexpr bool IsBeam() const noexcept { return data.types.all(BGSProjectileData::Type::kBeam); }
		[[nodiscard]] constexpr bool IsFlamethrower() const noexcept { return data.types.all(BGSProjectileData::Type::kFlamethrower); }
		[[nodiscard]] constexpr bool IsCone() const noexcept { return data.types.all(BGSProjectileData::Type::kCone); }
		[[nodiscard]] constexpr bool IsBarrier() const noexcept { return data.types.all(BGSProjectileData::Type::kBarrier); }
		[[nodiscard]] constexpr bool IsArrow() const noexcept { return data.types.all(BGSProjectileData::Type::kArrow); }

		// members
		BGSProjectileData data;              // 080 - DATA
		TESModel          muzzleFlashModel;  // 108
		SOUND_LEVEL       soundLevel;        // 130 - VNAM
		std::uint32_t     pad134;            // 134
	};
	static_assert(sizeof(BGSProjectile) == 0x138);
}


===============================================
File: include/RE/B/BGSRagdoll.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class TESActorBase;

	class BGSRagdoll :
		public TESForm,  // 000
		public TESModel  // 020
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSRagdoll;
		inline static constexpr auto VTABLE = VTABLE_BGSRagdoll;
		inline static constexpr auto FORMTYPE = FormType::Ragdoll;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~BGSRagdoll() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		std::uint64_t    unk048;  // 048
		std::uint64_t    unk050;  // 050
		std::uint64_t    unk058;  // 058
		std::uint64_t    unk060;  // 060
		std::uint64_t    unk068;  // 068
		std::uint64_t    unk070;  // 070
		std::uint64_t    unk078;  // 078
		std::uint64_t    unk080;  // 080
		std::uint64_t    unk088;  // 088
		std::uint64_t    unk090;  // 090
		BSTArray<void*>  unk098;  // 098
		std::uint64_t    unk0B0;  // 0B0
		std::uint64_t    unk0B8;  // 0B8
		std::uint64_t    unk0C0;  // 0C0
		std::uint64_t    unk0C8;  // 0C8
		BSTArray<void*>  unk0D0;  // 0D0
		BSTArray<void*>  unk0E8;  // 0E8
		std::uint64_t    unk100;  // 100
		BSTArray<void*>  unk108;  // 108
		BSTArray<void*>  unk120;  // 120
		std::uint64_t    unk138;  // 138
		BSTArray<void*>  unk140;  // 140
		BSTArray<void*>  unk158;  // 158
		std::uint64_t    unk170;  // 170
		std::uint64_t    unk178;  // 178
		std::uint64_t    unk180;  // 180
		std::uint64_t    unk188;  // 188
		std::uint64_t    unk190;  // 190
		std::uint64_t    unk198;  // 198
		std::uint64_t    unk1A0;  // 1A0
		BGSBodyPartData* unk1A8;  // 1A8
		TESActorBase*    unk1B0;  // 1B0
	};
	static_assert(sizeof(BGSRagdoll) == 0x1B8);
}


===============================================
File: include/RE/B/BGSRefAlias.h
===============================================
#pragma once

#include "RE/B/BGSBaseAlias.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/F/FormTypes.h"
#include "RE/Q/QuestEvents.h"

namespace RE
{
	class BGSLocationRefType;
	class TESBoundObject;
	class TESCondition;

	class BGSRefAlias : public BGSBaseAlias
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSRefAlias;
		inline static auto           VMTYPEID = static_cast<VMTypeID>(140);

		struct ForcedFillData  // kForced
		{
		public:
			// members
			ObjectRefHandle forcedRef;  // 0 - ALFR
		};
		static_assert(sizeof(ForcedFillData) == 0x4);

		struct FromAliasFillData  // kFromAlias
		{
		public:
			// members
			std::uint32_t       forcedFromAlias;  // 00 - ALFA
			std::uint32_t       pad04;            // 04
			BGSLocationRefType* forcedRefType;    // 08 - ALRT
		};
		static_assert(sizeof(FromAliasFillData) == 0x10);

		struct FromEventFillData  // kFromEvent
		{
		public:
			// members
			QuestEvent    forcedFromEvent;  // ALFE
			std::uint32_t forcedEventData;  // ALFD
		};
		static_assert(sizeof(FromEventFillData) == 0x8);

		struct CreatedFillData  // kCreated
		{
		public:
			enum class Level  // ALCL
			{
				kEasy = 0,
				kMedium = 1,
				kHard = 2,
				kVeryHard = 3,
				kNone = 4
			};

			struct Alias  // ALCA
			{
			public:
				enum class Create
				{
					kAt = 0x0000,
					kIn = 0x8000
				};

				// members
				std::uint16_t                           alias;   // 0
				stl::enumeration<Create, std::uint16_t> create;  // 2
			};
			static_assert(sizeof(Alias) == 0x4);

			// members
			TESBoundObject*                        object;  // 00 - ALCO
			Alias                                  alias;   // 08 - ALCA
			stl::enumeration<Level, std::uint16_t> level;   // 0C - ALCL
			std::uint16_t                          pad0E;   // 0E
		};
		static_assert(sizeof(CreatedFillData) == 0x10);

		struct FromExternalFillData  // kFromExternal
		{
		public:
			// members
			TESQuest*     externalQuest;  // 00 - ALEQ
			std::uint32_t externalAlias;  // 08 - ALEA
			std::uint32_t pad0C;          // 0C
		};
		static_assert(sizeof(FromExternalFillData) == 0x10);

		struct UniqueActorFillData  // kUniqueActor
		{
		public:
			// members
			TESNPC* uniqueActor;  // 0 - ALUA
		};
		static_assert(sizeof(UniqueActorFillData) == 0x8);

		struct NearAliasFillData  // kNearAlias
		{
		public:
			enum class NEARFILLTYPE
			{
				kLinkedChildren = 0,
				kLinkedParents = 1
			};

			// members
			std::uint32_t                                 nearAlias;     // 0 - ALNA
			stl::enumeration<NEARFILLTYPE, std::uint32_t> nearFillType;  // 4 - ALNT
		};
		static_assert(sizeof(NearAliasFillData) == 0x8);

		union GenericFillData
		{
		public:
			struct Padding
			{
			public:
				// members
				std::uint64_t pad1;  // 00
				std::uint64_t pad2;  // 08
				std::uint64_t pad3;  // 10
			};
			static_assert(sizeof(Padding) == 0x18);

			~GenericFillData() {}

			// members
			Padding              padding;
			ForcedFillData       forced;
			FromAliasFillData    fromAlias;
			FromEventFillData    fromEvent;
			CreatedFillData      created;
			FromExternalFillData fromExternal;
			UniqueActorFillData  uniqueActor;
			NearAliasFillData    nearAlias;
		};
		static_assert(sizeof(GenericFillData) == 0x18);

		~BGSRefAlias() override;  // 00

		// override (BGSBaseAlias)
		bool                               Load(TESFile* a_mod) override;       // 01
		void                               InitItem(TESForm* a_form) override;  // 02
		[[nodiscard]] const BSFixedString& QType() const override;              // 03 - { return "Ref"; }

		TESObjectREFR* GetReference() const;
		Actor*         GetActorReference() const;

		// members
		GenericFillData fillData;    // 28
		TESCondition*   conditions;  // 40
	};
	static_assert(sizeof(BGSRefAlias) == 0x48);
}


===============================================
File: include/RE/B/BGSReferenceEffect.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSReferenceEffect : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSReferenceEffect;
		inline static constexpr auto VTABLE = VTABLE_BGSReferenceEffect;
		inline static constexpr auto FORMTYPE = FormType::ReferenceEffect;

		enum class Flag
		{
			kNone = 0,
			kFaceTarget = 1 << 0,
			kAttachToCamera = 1 << 1,
			kInheritRotation = 1 << 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Data  // DATA
		{
		public:
			// members
			BGSArtObject*                         artObject;     // 00
			TESEffectShader*                      effectShader;  // 08
			stl::enumeration<Flag, std::uint32_t> flags;         // 10
			std::uint32_t                         pad14;         // 14
		};
		static_assert(sizeof(Data) == 0x18);

		~BGSReferenceEffect() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		Data data;  // 20 - DATA
	};
	static_assert(sizeof(BGSReferenceEffect) == 0x38);
}


===============================================
File: include/RE/B/BGSRelationship.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSRelationship : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSRelationship;
		inline static constexpr auto VTABLE = VTABLE_BGSRelationship;
		inline static constexpr auto FORMTYPE = FormType::Relationship;

		enum class RELATIONSHIP_LEVEL
		{
			kLover = 0,
			kAlly = 1,
			kConfidant = 2,
			kFriend = 3,
			kAcquaintance = 4,
			kRival = 5,
			kFoe = 6,
			kEnemy = 7,
			kArchnemesis = 8
		};

		enum class Flag
		{
			kNone = 0,
			kSecret = 1 << 7
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kRelationshipData = 1 << 1
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kSecret = 1 << 6,
				kIgnored = 1 << 12
			};
		};

		~BGSRelationship() override;  // 00

		// override (TESForm)
		void InitializeData() override;                        // 04
		bool Load(TESFile* a_mod) override;                    // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;      // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;      // 0F
		void InitLoadGame(BGSLoadFormBuffer* a_buf) override;  // 10
		void InitItemImpl() override;                          // 13

		static BGSRelationship* GetRelationship(TESNPC* a_npc1, TESNPC* a_npc2)
		{
			using func_t = decltype(&BGSRelationship::GetRelationship);
			REL::Relocation<func_t> func{ RELOCATION_ID(23632, 24084) };
			return func(a_npc1, a_npc2);
		}

		// members
		TESNPC*                                            npc1;       // 20 - DATA~
		TESNPC*                                            npc2;       // 28
		BGSAssociationType*                                assocType;  // 30
		stl::enumeration<RELATIONSHIP_LEVEL, std::uint8_t> level;      // 38
		std::uint8_t                                       unk39;      // 39
		std::uint8_t                                       unk3A;      // 3A
		stl::enumeration<Flag, std::uint8_t>               flags;      // 3B
		std::uint32_t                                      pad3C;      // 3C - ~DATA
	};
	static_assert(sizeof(BGSRelationship) == 0x40);
}


===============================================
File: include/RE/B/BGSReverbParameters.h
===============================================
#pragma once

#include "RE/B/BSIReverbType.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSReverbParameters :
		public TESForm,       // 00
		public BSIReverbType  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSReverbParameters;
		inline static constexpr auto VTABLE = VTABLE_BGSReverbParameters;
		inline static constexpr auto FORMTYPE = FormType::ReverbParam;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct ReverbParams  // DATA
		{
			std::uint16_t decayTime;        // 00 - in ms
			std::uint16_t hfReference;      // 02 - in Hz
			std::int8_t   roomFilter;       // 04
			std::int8_t   roomHFFilter;     // 05
			std::int8_t   reflections;      // 06
			std::int8_t   reverb;           // 07
			std::int8_t   decayHFRatio;     // 08
			std::int8_t   reflectionDelay;  // 09 - in ms
			std::int8_t   reverbDelay;      // 0A - in ms
			std::int8_t   diffusionPct;     // 0B
			std::int8_t   densityPct;       // 0C
			std::uint8_t  pad0D;            // 0D
		};
		static_assert(sizeof(ReverbParams) == 0xE);

		~BGSReverbParameters() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06

		// override (BSIReverbType)
		std::int32_t        DoGetRoomLevel() const override;        // 00 - { return data.roomFilter * 100; }
		std::int32_t        DoGetRoomHFLevel() const override;      // 01 - { return data.roomHFFilter * 100; }
		float               DoGetDecayTime() const override;        // 02 - { return data.decayTime * 0.001; }
		float               DoGetDecayHFRatio() const override;     // 03 - { return data.decayHFRatio * 0.0099999998; }
		std::int32_t        DoGetReflectionLevel() const override;  // 04 - { return data.reflections * 100; }
		float               DoGetReflectionDelay() const override;  // 05 - { return data.reflectDelay * 0.0012000001; }
		std::int32_t        DoGetReverbLevel() const override;      // 06 - { return data.reverb * 100; }
		float               DoGetReverbDelay() const override;      // 07 - { return data.reverbDelay * 0.001; }
		float               DoGetDiffusion() const override;        // 08 - { return data.diffusionPct; }
		float               DoGetDensity() const override;          // 09 - { return data.densityPct; }
		[[nodiscard]] float DoGetHFReference() const override;      // 0A - { return data.hfReference; }

		// members
		ReverbParams  data;   // 28 - DATA
		std::uint16_t pad36;  // 36
	};
	static_assert(sizeof(BGSReverbParameters) == 0x38);
}


===============================================
File: include/RE/B/BGSSaveLoadManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTMessageQueue.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BSThread.h"
#include "RE/R/RaceSexMenuEvent.h"
#include "RE/R/Request.h"

namespace RE
{
	class BSSaveDataEvent;
	class BSSystemEvent;
	struct BGSSaveLoadManagerEvent;

	class BGSSaveLoadFileEntry
	{
	public:
		// members
		BSFixedString fileName;     // 00
		BSFixedString playerName;   // 08
		BSFixedString playerTitle;  // 10
		BSFixedString location;     // 18
		BSFixedString playTime;     // 20
		BSFixedString raceName;     // 28
		std::uint32_t unk30;        // 30
		std::uint32_t unk34;        // 34
		std::uint32_t unk38;        // 38
		std::uint32_t unk3C;        // 3C
		std::uint32_t unk40;        // 40
		std::uint32_t unk44;        // 44
		std::uint64_t unk48;        // 48
		std::uint64_t unk50;        // 50
		std::uint64_t unk58;        // 58
		std::uint64_t unk60;        // 60
		std::uint64_t unk68;        // 68
		std::uint64_t unk70;        // 70
	};
	static_assert(sizeof(BGSSaveLoadFileEntry) == 0x78);

	class BGSSaveLoadManager :
		public BSTEventSink<BSSaveDataEvent>,                     // 000
		public BSTEventSink<RaceSexMenuEvent::NameChangedEvent>,  // 008
		public BSTEventSource<BGSSaveLoadManagerEvent>,           // 018
		public BSTEventSink<BSSystemEvent>                        // 010
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSaveLoadManager;

		class Thread : public BSThread
		{
		public:
			inline static constexpr auto RTTI = RTTI_BGSSaveLoadManager__Thread;

			~Thread() override;  // 00

			void Unk_01(void) override;  // 01
			void Unk_02(void) override;  // 02

			// members
			bool                                                                    isRunnning;                   // 50
			bool                                                                    isBusy;                       // 51
			std::uint16_t                                                           pad52;                        // 52
			std::uint32_t                                                           pad54;                        // 54
			BSEventFlag                                                             haveTask;                     // 58
			BSTCommonStaticMessageQueue<BSTSmartPointer<bgs::saveload::Request>, 8> asyncSaveLoadOperationQueue;  // 60
		};
		static_assert(sizeof(Thread) == 0xC0);

		~BGSSaveLoadManager() override;  // 00

		// override (BSTEventSink<BSSaveDataEvent>)
		BSEventNotifyControl ProcessEvent(const BSSaveDataEvent* a_event, BSTEventSource<BSSaveDataEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<RaceSexMenuEvent::NameChangedEvent>)
		BSEventNotifyControl ProcessEvent(const RaceSexMenuEvent::NameChangedEvent* a_event, BSTEventSource<RaceSexMenuEvent::NameChangedEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BSSystemEvent>)
		BSEventNotifyControl ProcessEvent(const BSSystemEvent* a_event, BSTEventSource<BSSystemEvent>* a_eventSource) override;  // 01

		static BGSSaveLoadManager* GetSingleton();

		void Save(const char* a_fileName);
		void Load(const char* a_fileName);
		void Load(const char* a_fileName, bool a_checkForMods);

		bool LoadMostRecentSaveGame();

		// members
		BSTHashMap<std::uint64_t, BSFixedString> playerIDNameMap;  // 078
		std::uint64_t                            unk0A0;           // 0A0
		std::uint32_t                            unk0A8;           // 0A8
		std::uint32_t                            unk0AC;           // 0AC
		std::uint32_t                            unk0B0;           // 0B0
		std::uint32_t                            unk0B4;           // 0B4
		std::uint64_t                            unk0B8;           // 0B8
		std::uint64_t                            unk0C0;           // 0C0
		std::uint64_t                            unk0C8;           // 0C8
		std::uint64_t                            currentPlayerID;  // 0D0
		std::uint32_t                            unk0D8;           // 0D8
		std::uint32_t                            unk0DC;           // 0DC
		std::uint32_t                            unk0E0;           // 0E0
		std::uint32_t                            unk0E4;           // 0E4
		BSTArray<void*>                          unk0E8;           // 0E8

		BSTArray<BGSSaveLoadFileEntry*> saveGameList;  // 100
		std::uint8_t                    unk118;        // 118
		std::uint8_t                    unk119;        // 119
		std::uint16_t                   unk11A;        // 11A
		std::uint32_t                   unk11C;        // 11C
		std::uint16_t                   unk120;        // 120
		std::uint16_t                   unk122;        // 122
		std::uint32_t                   unk124;        // 124
		std::uint32_t                   tickCount;     // 128
		std::uint32_t                   unk12C;        // 12C
		std::uint8_t                    unk130;        // 130
		std::uint8_t                    unk131;        // 131
		std::uint16_t                   unk132;        // 132
		std::uint32_t                   unk134;        // 134
		std::uint64_t                   unk138;        // 138
		std::uint64_t                   unk140;        // 140
		std::uint64_t                   unk148;        // 148
		std::uint64_t                   unk150;        // 150
		std::uint64_t                   unk158;        // 158
		std::uint64_t                   unk160;        // 160
		std::uint64_t                   unk168;        // 168
		std::uint64_t                   unk170;        // 170
		std::uint64_t                   unk178;        // 178
		std::uint64_t                   unk180;        // 180
		std::uint64_t                   unk188;        // 188
		std::uint64_t                   unk190;        // 190
		std::uint64_t                   unk198;        // 198
		std::uint64_t                   unk1A0;        // 1A0
		std::uint64_t                   unk1A8;        // 1A8
		std::uint64_t                   unk1B0;        // 1B0
		std::uint64_t                   unk1B8;        // 1B8
		std::uint64_t                   unk1C0;        // 1C0
		std::uint64_t                   unk1C8;        // 1C8
		std::uint64_t                   unk1D0;        // 1D0
		std::uint64_t                   unk1D8;        // 1D8
		std::uint64_t                   unk1E0;        // 1E0
		std::uint64_t                   unk1E8;        // 1E8
		std::uint64_t                   unk1F0;        // 1F0
		std::uint64_t                   unk1F8;        // 1F8

		std::uint64_t unk200;  // 200
		std::uint64_t unk208;  // 208
		std::uint64_t unk210;  // 210
		std::uint64_t unk218;  // 218
		std::uint64_t unk220;  // 220
		std::uint64_t unk228;  // 228
		std::uint64_t unk230;  // 230
		std::uint64_t unk238;  // 238
		std::uint64_t unk240;  // 240
		std::uint64_t unk248;  // 248
		std::uint32_t unk250;  // 250
		std::uint32_t unk254;  // 254
		std::uint64_t unk258;  // 258
		std::uint16_t unk260;  // 260
		std::uint16_t unk262;  // 262
		std::uint32_t unk264;  // 264
		std::uint64_t unk268;  // 268
		std::uint32_t unk270;  // 270
		std::uint32_t unk274;  // 274
		std::uint64_t unk278;  // 278
		std::uint64_t unk280;  // 280
		std::uint32_t unk288;  // 288
		std::uint32_t unk28C;  // 28C
		std::uint64_t unk290;  // 290
		std::uint64_t unk298;  // 298
		std::uint32_t unk2A0;  // 2A0
		std::uint32_t unk2A4;  // 2A4
		std::uint64_t unk2A8;  // 2A8
		Thread        unk2B0;  // 2B0

		BSTCommonStaticMessageQueue<BSTSmartPointer<bgs::saveload::Request>, 8> unk370;  // 370

	protected:
		bool Save_Impl(std::int32_t a_deviceID, std::uint32_t a_outputStats, const char* a_fileName);
		bool Load_Impl(const char* a_fileName, std::int32_t a_deviceID, std::uint32_t a_outputStats, bool a_checkForMods);
	};
	static_assert(sizeof(BGSSaveLoadManager) == 0x3D0);
}


===============================================
File: include/RE/B/BGSScene.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSSceneAction;

	enum class SCENE_ACTOR_FLAG  // LNAM
	{
		kNone = 0,
		kNoPlayerActivation = 1 << 0,
		kOptional = 1 << 1,
		kRunOnlyScenePackages = 1 << 2,
		kNoCommandState = 1 << 3
	};

	class BGSScenePhase
	{
	public:
		// members
		TESCondition              startConditions;       // 00
		TESCondition              completionConditions;  // 08
		BGSStoryManagerQuestNode* questNode;             // 10
	};
	static_assert(sizeof(BGSScenePhase) == 0x18);

	class BGSScene : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSScene;
		inline static constexpr auto VTABLE = VTABLE_BGSScene;
		inline static constexpr auto FORMTYPE = FormType::Scene;

		enum class Flag
		{
			kNone = 0,
			kBeginOnQuestStart = 1 << 0,
			kStopOnQuestEnd = 1 << 1,
			kRepeatConditionsWhileTrue = 1 << 3,
			kInterruptible = 1 << 4
		};

		enum class BehaviourFlag  // DNAM
		{
			kNone = 0,
			kDeathPause = 1 << 0,  // unused
			kDeathEnd = 1 << 1,
			kCombatPause = 1 << 2,
			kCombatEnd = 1 << 3,
			kDialoguePause = 1 << 4,
			kDialogueEnd = 1 << 5,
			kOBS_COMPause = 1 << 6,
			kOBS_COMEnd = 1 << 7
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kActive = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSScene() override;  // 00

		// override (TESForm)
		void InitializeData() override;                        // 05
		bool Load(TESFile* a_mod) override;                    // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;      // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;      // 0F
		void InitLoadGame(BGSLoadFormBuffer* a_buf) override;  // 10
		void Revert(BGSLoadFormBuffer* a_buf) override;        // 12
		void InitItemImpl() override;                          // 13

		// members
		BSTArray<BGSScenePhase*>                                    phases;                 // 20
		BSTArray<FormID>                                            actors;                 // 00 - ALID
		BSTArray<stl::enumeration<SCENE_ACTOR_FLAG, std::uint32_t>> actorFlags;             // 18 - LNAM
		BSTArray<stl::enumeration<BehaviourFlag, std::uint32_t>>    actorProgressionFlags;  // 30 - DNAM
		BSTArray<BGSSceneAction*>                                   actions;                // 80
		TESQuest*                                                   parentQuest;            // 98 - PNAM
		stl::enumeration<Flag, std::uint32_t>                       flags;                  // A0 - FNAM
		std::uint32_t                                               padA4;                  // A4
		TESCondition                                                conditions;             // A8 - CTDA
		std::uint32_t                                               unkB0;                  // B0
		std::uint32_t                                               unkB4;                  // B4
		std::uint32_t                                               unkB8;                  // B8
		std::uint32_t                                               unkBC;                  // BC
		std::uint32_t                                               unkC0;                  // C0
		std::uint32_t                                               padC4;                  // C4
	};
	static_assert(sizeof(BGSScene) == 0xC8);
}


===============================================
File: include/RE/B/BGSSceneAction.h
===============================================
#pragma once

#include "RE/E/EmotionTypes.h"

namespace RE
{
	class BGSLoadGameBuffer;
	class TESFile;

	class BGSSceneAction
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSceneAction;

		enum class Type
		{
			kDialogue = 0,
			kPackage = 1,
			kTimer = 2
		};

		enum class Flag
		{
			kNone = 0,
			kFaceTarget = 1 << 15,
			kLooping = 1 << 16,
			kHeadTrackPlayer = 1 << 17
		};

		virtual ~BGSSceneAction();  // 00

		// add
		virtual bool                        LoadSceneAction(TESFile* a_mod);                     // 01
		virtual void                        Unk_02(void);                                        // 02
		virtual void                        Unk_03(void);                                        // 03 - { return; }
		virtual void                        ClearFlags();                                        // 04 - { flags = kNone; }
		[[nodiscard]] virtual bool          Loops() const;                                       // 05 - { return false; }
		[[nodiscard]] virtual bool          FacesTarget() const;                                 // 06 - { return true; }
		[[nodiscard]] virtual Type          GetType() const = 0;                                 // 07
		virtual void                        Unk_08(void);                                        // 08 - { return 0; }
		virtual void                        LoadBuffer(void* a_arg1, BGSLoadGameBuffer* a_buf);  // 09
		virtual void                        Unk_0A(void);                                        // 0A
		virtual void                        Unk_0B(void);                                        // 0B - { unk14 &= 0xFC; }
		virtual void                        Unk_0C(void);                                        // 0C - { return; }
		virtual void                        Unk_0D(void);                                        // 0D
		[[nodiscard]] virtual EmotionType   GetEmotionType() const;                              // 0E - { return kNeutral; }
		[[nodiscard]] virtual std::uint32_t GetEmotionValue() const;                             // 0F - { return 0; }
		virtual void                        Unk_10(void);                                        // 10 - { unk14 |= 1; }
		virtual void                        Unk_11(void);                                        // 11
		virtual void                        Unk_12(void);                                        // 12 - { return; }
		virtual void                        Unk_13(void);                                        // 13 - { return; }

		// members
		std::uint32_t                         actorID;     // 08 - ALID
		std::uint16_t                         startPhase;  // 0C - SNAM
		std::uint16_t                         endPhase;    // 0E - ENAM
		stl::enumeration<Flag, std::uint32_t> flags;       // 10
		std::uint8_t                          unk14;       // 14
		std::uint8_t                          unk15;       // 15
		std::uint16_t                         unk16;       // 16
		std::uint32_t                         index;       // 18 - INAM
		std::uint32_t                         unk1C;       // 1C
	};
	static_assert(sizeof(BGSSceneAction) == 0x20);
}


===============================================
File: include/RE/B/BGSSceneActionDialogue.h
===============================================
#pragma once

#include "RE/B/BGSSceneAction.h"

namespace RE
{
	class TESTopic;

	class BGSSceneActionDialogue : public BGSSceneAction
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSceneActionDialogue;
		inline static constexpr auto TYPE = Type::kDialogue;

		~BGSSceneActionDialogue() override;  // 00

		// override (BGSSceneAction)
		bool          LoadSceneAction(TESFile* a_mod) override;                     // 01
		void          Unk_02(void) override;                                        // 02
		void          Unk_03(void) override;                                        // 03
		bool          Loops() const override;                                       // 05 - { return (flags >> 16) & 1; }
		bool          FacesTarget() const override;                                 // 06 - { return (flags >> 15) & 1; }
		Type          GetType() const override;                                     // 07 - { return kDialogue; }
		void          LoadBuffer(void* a_arg1, BGSLoadGameBuffer* a_buf) override;  // 09
		void          Unk_0A(void) override;                                        // 0A
		void          Unk_0B(void) override;                                        // 0B
		void          Unk_0C(void) override;                                        // 0C
		EmotionType   GetEmotionType() const override;                              // 0E - { return emotionType; }
		std::uint32_t GetEmotionValue() const override;                             // 0F - { return emotionValue; }
		void          Unk_10(void) override;                                        // 10
		void          Unk_11(void) override;                                        // 11
		void          Unk_13(void) override;                                        // 13

		// members
		TESTopic*     topic;             // 20 - DATA
		std::int32_t  headtrackActorID;  // 28 - HTID
		float         loopingMax;        // 2C - DMAX
		float         loopingMin;        // 30 - DMIN
		std::uint32_t unk34;             // 34
		EmotionType   emotionType;       // 38 - DEMO
		std::uint32_t emotionValue;      // 3C - DEMA
	};
	static_assert(sizeof(BGSSceneActionDialogue) == 0x40);
}


===============================================
File: include/RE/B/BGSSceneActionPackage.h
===============================================
#pragma once

#include "RE/B/BGSSceneAction.h"
#include "RE/B/BSTArray.h"

namespace RE
{
	class TESPackage;

	class BGSSceneActionPackage : public BGSSceneAction
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSceneActionPackage;
		inline static constexpr auto TYPE = Type::kPackage;

		~BGSSceneActionPackage() override;  // 00

		// override (BGSSceneAction)
		bool LoadSceneAction(TESFile* a_mod) override;                     // 01
		void Unk_02(void) override;                                        // 02
		Type GetType() const override;                                     // 07 - { return kPackage; }
		void Unk_08(void) override;                                        // 08
		void LoadBuffer(void* a_arg1, BGSLoadGameBuffer* a_buf) override;  // 09
		void Unk_0A(void) override;                                        // 0A
		void Unk_0B(void) override;                                        // 0B
		void Unk_10(void) override;                                        // 10
		void Unk_11(void) override;                                        // 11
		void Unk_12(void) override;                                        // 12
		void Unk_13(void) override;                                        // 13

		// members
		std::uint64_t         unk20;     // 20
		BSTArray<TESPackage*> packages;  // 28 - PNAM
	};
	static_assert(sizeof(BGSSceneActionPackage) == 0x40);
}


===============================================
File: include/RE/B/BGSSceneActionTimer.h
===============================================
#pragma once

#include "RE/B/BGSSceneAction.h"

namespace RE
{
	class BGSSceneActionTimer : public BGSSceneAction
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSceneActionTimer;
		inline static constexpr auto TYPE = Type::kTimer;

		~BGSSceneActionTimer() override;  // 00

		// override (BGSSceneAction)
		bool LoadSceneAction(TESFile* a_mod) override;                     // 01
		void ClearFlags() override;                                        // 04 - { BGSSceneAction::ClearFlags(); }
		Type GetType() const override;                                     // 07 - { return kTimer; }
		void LoadBuffer(void* a_arg1, BGSLoadGameBuffer* a_buf) override;  // 09
		void Unk_0A(void) override;                                        // 0A
		void Unk_0B(void) override;                                        // 0B
		void Unk_0D(void) override;                                        // 0D
		void Unk_11(void) override;                                        // 11
		void Unk_13(void) override;                                        // 13

		// members
		float         timerSeconds;  // 20 - SNAM
		std::uint32_t unk24;         // 24
		std::uint64_t unk28;         // 28
	};
	static_assert(sizeof(BGSSceneActionTimer) == 0x30);
}


===============================================
File: include/RE/B/BGSShaderParticleGeometryData.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	union SETTING_VALUE
	{
		float         f;
		std::uint32_t i;
	};
	static_assert(sizeof(SETTING_VALUE) == 0x4);

	class BGSShaderParticleGeometryData : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSShaderParticleGeometryData;
		inline static constexpr auto VTABLE = VTABLE_BGSShaderParticleGeometryData;
		inline static constexpr auto FORMTYPE = FormType::ShaderParticleGeometryData;

		enum class DataID
		{
			kGravityVelocity = 0,
			kRotationVelocity,
			kParticleSizeX,
			kParticleSizeY,
			kCenterOffsetMin,
			kCenterOffsetMax,
			kStartRotationRange,
			kNumSubtexturesX,
			kNumSubtexturesY,
			kParticleType,
			kBoxSize,
			kParticleDensity,

			kTotal
		};

		enum class ParticleType
		{
			kRain = 0,
			kSnow = 1
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSShaderParticleGeometryData() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		BSTArray<SETTING_VALUE> data;             // 20 - DATA - size == DataID::kTotal
		TESTexture              particleTexture;  // 38 - ICON
	};
	static_assert(sizeof(BGSShaderParticleGeometryData) == 0x48);
}


===============================================
File: include/RE/B/BGSSkillPerkTreeNode.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"

namespace RE
{
	class ActorValueInfo;
	class BGSPerk;

	class BGSSkillPerkTreeNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSkillPerkTreeNode;

		BGSSkillPerkTreeNode(std::int32_t a_index, ActorValueInfo* a_avInfo);

		virtual ~BGSSkillPerkTreeNode() = default;  // 00

		TES_HEAP_REDEFINE_NEW();

		// members
		std::uint32_t                   index;               // 08 - INAM
		std::uint32_t                   unk0C;               // 0C
		BSTArray<BGSSkillPerkTreeNode*> children;            // 10 - CNAM
		BSTArray<BGSSkillPerkTreeNode*> parents;             // 28
		BGSPerk*                        perk;                // 40 - PNAM
		std::uint32_t                   unk48;               // 48 - FNAM
		std::uint32_t                   perkGridX;           // 4C - XNAM
		std::uint32_t                   perkGridY;           // 50 - YNAM
		std::uint32_t                   unk54;               // 54
		ActorValueInfo*                 associatedSkill;     // 58 - SNAM
		float                           horizontalPosition;  // 60 - HNAM
		float                           verticalPosition;    // 64 - VNAM
	};
	static_assert(sizeof(BGSSkillPerkTreeNode) == 0x68);
}


===============================================
File: include/RE/B/BGSSkinForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESObjectARMO;

	class BGSSkinForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSkinForm;

		~BGSSkinForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		TESObjectARMO* skin;  // 08 - WNAM
	};
	static_assert(sizeof(BGSSkinForm) == 0x10);
}


===============================================
File: include/RE/B/BGSSoundCategory.h
===============================================
#pragma once

#include "RE/B/BSISoundCategory.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class BGSSoundCategory :
		public TESForm,          // 00
		public TESFullName,      // 20
		public BSISoundCategory  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSoundCategory;
		inline static constexpr auto VTABLE = VTABLE_BGSSoundCategory;
		inline static constexpr auto FORMTYPE = FormType::SoundCategory;

		enum class Flag  // FNAM
		{
			kNone = 0,
			kMuteWhenSubmerged = 1 << 0,
			kShouldAppearOnMenu = 1 << 1
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSSoundCategory() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// override (BGSSoundCategory)
		bool          Matches(const BSISoundCategory* a_category) const override;  // 01
		float         GetCategoryVolume() const override;                          // 02
		void          SetCategoryVolume(float a_value) override;                   // 03
		float         GetCategoryFrequency() const override;                       // 04
		void          SetCategoryFrequency(float a_value) override;                // 05
		std::uint16_t GetCategoryAttenuation() const override;                     // 06
		void          SetCategoryAttenuation(std::uint16_t a_value) override;      // 07

		[[nodiscard]] float GetDefaultMenuValue() const;
		[[nodiscard]] float GetStaticVolumeMultiplier() const;
		[[nodiscard]] bool  IsMenuCategory() const;
		void                SetDefaultMenuValue(float a_val);
		void                SetStaticVolumeMultiplier(float a_val);

		// members
		stl::enumeration<Flag, std::uint32_t> flags;             // 38 - FNAM
		std::uint32_t                         unk3C;             // 3C
		BGSSoundCategory*                     parentCategory;    // 40 - SNCT
		std::uint16_t                         unk48;             // 48
		std::uint16_t                         attenuation;       // 4A
		std::uint16_t                         staticMult;        // 4C - VNAM
		std::uint16_t                         defaultMenuValue;  // 4E - UNAM
		float                                 volumeMult;        // 50
		float                                 frequencyMult;     // 54
	};
	static_assert(sizeof(BGSSoundCategory) == 0x58);
}


===============================================
File: include/RE/B/BGSSoundDescriptor.h
===============================================
#pragma once

#include "RE/B/BSISoundDescriptor.h"

namespace RE
{
	class BGSSoundCategory;
	class TESFile;
	class TESForm;

	class BGSSoundDescriptor : public BSISoundDescriptor
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSoundDescriptor;
		inline static constexpr auto VTABLE = VTABLE_BGSSoundDescriptor;

		~BGSSoundDescriptor() override;  // 00

		// add
		virtual void                        InitSound(TESForm* a_src);  // 03
		virtual bool                        LoadSound(TESFile* a_mod);  // 04
		[[nodiscard]] virtual std::uint32_t GetType() const = 0;        // 05 - CRC hash of class name
		virtual void                        Unk_06(void) = 0;           // 06

		// members
		BGSSoundCategory* category;              // 08 - GNAM
		FormID            alternateSoundFormID;  // 10 - SNAM
		std::uint32_t     pad14;                 // 14
	};
	static_assert(sizeof(BGSSoundDescriptor) == 0x18);
}


===============================================
File: include/RE/B/BGSSoundDescriptorForm.h
===============================================
#pragma once

#include "RE/B/BSISoundDescriptor.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSSoundDescriptor;

	class BGSSoundDescriptorForm :
		public TESForm,            // 00
		public BSISoundDescriptor  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSoundDescriptorForm;
		inline static constexpr auto VTABLE = VTABLE_BGSSoundDescriptorForm;
		inline static constexpr auto FORMTYPE = FormType::SoundRecord;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSSoundDescriptorForm() override;  // 00

		// override (TESForm)
		void ClearData() override;                         // 05
		bool Load(TESFile* a_mod) override;                // 06
		void InitItemImpl() override;                      // 13
		bool SetFormEditorID(const char* a_str) override;  // 33

		// add
		virtual std::uint32_t GetDescriptorType();  // 3B - { return soundDescriptor->GetType(); }

		// members
		BGSSoundDescriptor* soundDescriptor;  // 28
	};
	static_assert(sizeof(BGSSoundDescriptorForm) == 0x30);
}


===============================================
File: include/RE/B/BGSSoundOutput.h
===============================================
#pragma once

#include "RE/B/BSISoundOutputModel.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSSoundOutput :
		public TESForm,             // 00
		public BSISoundOutputModel  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSSoundOutput;
		inline static constexpr auto VTABLE = VTABLE_BGSSoundOutput;
		inline static constexpr auto FORMTYPE = FormType::SoundOutputModel;

		enum class Type  // MNAM
		{
			kUsesHRTF = 0,
			kDefinedSpeakerOutput = 1
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Data  // NAM1
		{
		public:
			enum class Flag
			{
				kNone = 0,
				kAttenuatesWithDistance = 1 << 0,
				kAllowsRumble = 1 << 1
			};

			// members
			stl::enumeration<Flag, std::uint8_t> flags;          // 0
			std::uint8_t                         unk1;           // 1
			std::uint8_t                         unk2;           // 2
			std::uint8_t                         reverbSendPct;  // 3
		};
		static_assert(sizeof(Data) == 0x4);

		struct DynamicAttenuationCharacteristics : public BSIAttenuationCharacteristics
		{
		public:
			struct DataType
			{
			public:
				// members
				float         minDistance;  // 00
				float         maxDistance;  // 04
				std::uint8_t  curve[5];     // 08
				std::uint8_t  pad15;        // 0D
				std::uint16_t pad16;        // 0E
			};
			static_assert(sizeof(DataType) == 0x10);

			~DynamicAttenuationCharacteristics() override;  // 00

			// override (BSIAttenuationCharacteristics)
			float        GetMaxDistance() const override;                    // 01 - { return data.maxDistance; }
			float        GetMinDistance() const override;                    // 02 - { return data.minDistance; }
			std::uint8_t GetCurveValue(std::uint32_t a_idx) const override;  // 03 - { return a_idx >= 5 ? 0 : data.curve[a_idx]; }

			// members
			DataType data;  // 00
		};
		static_assert(sizeof(DynamicAttenuationCharacteristics) == 0x18);

		struct SpeakerArrays  // ONAM
		{
		public:
			struct Channel
			{
			public:
				// members
				std::uint8_t l;    // 0
				std::uint8_t r;    // 1
				std::uint8_t c;    // 2
				std::uint8_t lfe;  // 3
				std::uint8_t rl;   // 4
				std::uint8_t rr;   // 5
				std::uint8_t bl;   // 6
				std::uint8_t br;   // 7
			};
			static_assert(sizeof(Channel) == 0x8);

			// members
			Channel channels[3];
		};
		static_assert(sizeof(SpeakerArrays) == 0x18);

		~BGSSoundOutput() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// override (BSISoundOutputModel)
		bool                                 DoGetUsesHRTF() const override;                                                                   // 01 - { return type == kUsesHRTF; }
		bool                                 DoGetHasSpeakerBias() const override;                                                             // 02 - { return type == kDefinedSpeakerOutput; }
		bool                                 DoGetSpeakerBias(std::uint32_t a_arg1, std::uint32_t a_arg2, float (&a_arg3)[8]) const override;  // 03
		bool                                 DoGetAttenuatesWithDistance() const override;                                                     // 04 - { return data.flags & 1; }
		bool                                 DoGetAudibility(float a_distance) const override;                                                 // 05 - { float maxDistance = attenuationValues ? attenuationValues->GetMaxDistance() : 3.4028235e38; return a_distance > maxDistance; }
		std::uint32_t                        DoGetSupportedInputChannels() const override;                                                     // 06 - { return 2; }
		const BSIAttenuationCharacteristics* DoGetAttenuation() const override;                                                                // 07 - { return attenuationValues; }
		float                                DoGetReverbSendLevel() const override;                                                            // 08 - { return data.reverbSendPct * 0.0099999998; }
		[[nodiscard]] bool                   DoGetSupportsMonitor(std::uint32_t a_arg1) const override;                                        // 09

		// members
		Data                                  data;            // 28 - NAM1
		stl::enumeration<Type, std::uint32_t> type;            // 2C - MNAM
		DynamicAttenuationCharacteristics*    attenuation;     // 30 - ANAM
		SpeakerArrays*                        speakerOutputs;  // 38 - ONAM
	};
	static_assert(sizeof(BGSSoundOutput) == 0x40);
}


===============================================
File: include/RE/B/BGSStandardSoundDef.h
===============================================
#pragma once

#include "RE/B/BGSSoundDescriptor.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/I/ID.h"

namespace RE
{
	class TESCondition;

	class BGSStandardSoundDef : public BGSSoundDescriptor
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStandardSoundDef;

		struct SoundPlaybackCharacteristics : public BSISoundDescriptor::BSIPlaybackCharacteristics  // BNAM
		{
		public:
			inline static constexpr auto RTTI = RTTI_BGSStandardSoundDef__SoundPlaybackCharacteristics;

			// override (BSIPlaybackCharacteristics)
			std::uint8_t  GetFrequencyShift() override;     // 01 - { return frequencyShift; }
			std::uint8_t  GetFrequencyVariance() override;  // 02 - { return frequencyVariance; }
			std::uint8_t  GetPriority() override;           // 03 - { return priority; }
			std::uint16_t GetStaticAttenuation() override;  // 04 - { return staticAttenuation; }
			std::uint8_t  GetDBVariance() override;         // 05 - { return dbVariance; }

			// members
			std::uint8_t  frequencyShift;     // 08
			std::uint8_t  frequencyVariance;  // 09
			std::uint8_t  priority;           // 0A
			std::uint8_t  dbVariance;         // 0B
			std::uint16_t staticAttenuation;  // 0C - CK Value * 100
			std::uint16_t pad0E;              // 0E
		};
		static_assert(sizeof(SoundPlaybackCharacteristics) == 0x10);

		struct LengthCharacteristics  // LNAM
		{
			enum class Looping
			{
				kNone = 0,
				kLoop = 1 << 3,
				kEnvelopeFast = 1 << 4,
				kEnvelopeSlow = 1 << 5
			};

			std::uint8_t                            unk0;             // 0
			stl::enumeration<Looping, std::uint8_t> looping;          // 1
			std::uint8_t                            unk2;             // 2
			std::uint8_t                            rumbleSendValue;  // 3
		};
		static_assert(sizeof(LengthCharacteristics) == 0x4);

		~BGSStandardSoundDef() override;  // 00

		// override (BGSSoundDescriptor)
		void          Unk_01(void) override;               // 01
		void          Unk_02(void) override;               // 02
		void          InitSound(TESForm* a_src) override;  // 03
		bool          LoadSound(TESFile* a_mod) override;  // 04
		std::uint32_t GetType() const override;            // 05 - "BGSStandardSoundDef"
		void          Unk_06(void) override;               // 06

		// members
		BSTArray<BSResource::ID>     soundFiles;             // 18 - ANAM
		SoundPlaybackCharacteristics soundCharacteristics;   // 30 - BNAM
		TESCondition*                conditions;             // 40 - CTDA
		BGSSoundOutput*              outputModel;            // 48 - ONAM
		LengthCharacteristics        lengthCharacteristics;  // 50 - LNAM
		std::int32_t                 unk54;                  // 54
	};
	static_assert(sizeof(BGSStandardSoundDef) == 0x58);
}


===============================================
File: include/RE/B/BGSStaticCollection.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	class BGSStaticCollection :
		public TESBoundObject,      // 00
		public TESModelTextureSwap  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStaticCollection;
		inline static constexpr auto VTABLE = VTABLE_BGSStaticCollection;
		inline static constexpr auto FORMTYPE = FormType::StaticCollection;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~BGSStaticCollection() override;  // 00

		// override (TESBoundObject)
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13
	};
	static_assert(sizeof(BGSStaticCollection) == 0x68);
}


===============================================
File: include/RE/B/BGSStoryEventManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	struct BGSRegisteredStoryEvent;
	class BGSStoryEvent;

	class BGSStoryEventManager :
		public BSTSingletonImplicit<BGSStoryEventManager>  // 00
	{
	public:
		[[nodiscard]] static BGSStoryEventManager* GetSingleton()
		{
			using func_t = decltype(&BGSStoryEventManager::GetSingleton);
			REL::Relocation<func_t> func{ RELOCATION_ID(22317, 22790) };
			return func();
		}

		template <class T>
		std::uint32_t AddEvent(const T& a_event)
		{
			return AddEvent_Impl(T::GetIndex(), &a_event);
		}

		// members
		BSTArray<BGSRegisteredStoryEvent>        registeredEvents;    // 00
		BSTHashMap<std::uint32_t, std::uint32_t> registeredEventIDs;  // 18
		BSTArray<BGSStoryEvent>                  events;              // 48
		mutable BSSpinLock                       eventArrayLock;      // 60

	private:
		std::uint32_t AddEvent_Impl(std::uint32_t a_index, const void* a_event)
		{
			using func_t = decltype(&BGSStoryEventManager::AddEvent_Impl);
			REL::Relocation<func_t> func{ RELOCATION_ID(31576, 32359) };
			return func(this, a_index, a_event);
		}
	};
	static_assert(sizeof(BGSStoryEventManager) == 0x68);
}


===============================================
File: include/RE/B/BGSStoryManagerBranchNode.h
===============================================
#pragma once

#include "RE/B/BGSStoryManagerNodeBase.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSStoryManagerBranchNode : public BGSStoryManagerNodeBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStoryManagerBranchNode;
		inline static constexpr auto VTABLE = VTABLE_BGSStoryManagerBranchNode;
		inline static constexpr auto FORMTYPE = FormType::StoryManagerBranchNode;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSStoryManagerBranchNode() override;  // 00

		// override (BGSStoryManagerNodeBase)
		void                                     ClearData() override;                                           // 05 - { BGSStoryManagerNodeBase::ClearData(); }
		void                                     InitItemImpl() override;                                        // 13
		std::uint32_t                            QChildCount() const override;                                   // 3B - { return nodeChildren.size(); }
		BGSStoryManagerTreeForm*                 GetChild(std::uint32_t a_idx) const override;                   // 3C - { return children[a_idx]; }
		BGSStoryManagerTreeVisitor::VisitControl AcceptVisitor(BGSStoryManagerTreeVisitor& a_visitor) override;  // 3E - { return a_visitor->VisitBranchNode(this); }

		// members
		BSTArray<BGSStoryManagerNodeBase*> children;  // 48
	};
	static_assert(sizeof(BGSStoryManagerBranchNode) == 0x60);
}


===============================================
File: include/RE/B/BGSStoryManagerEventNode.h
===============================================
#pragma once

#include "RE/B/BGSStoryManagerBranchNode.h"
#include "RE/B/BSString.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	struct BGSStoryEventMember
	{
		enum class DATA_TYPE
		{
		};

		stl::enumeration<DATA_TYPE, std::uint32_t> type;      // 00
		std::uint32_t                              uniqueID;  // 04
		BSString                                   name;      // 08
	};
	static_assert(sizeof(BGSStoryEventMember) == 0x18);

	struct BGSRegisteredStoryEvent  // ENAM
	{
		char                           uniqueID[4];  // 00
		std::uint32_t                  pad04;        // 04
		BSTArray<BGSStoryEventMember>* members;      // 08
		BSString                       name;         // 10
		bool                           immediate;    // 20
		std::uint8_t                   pad21;        // 21
		std::uint16_t                  pad22;        // 22
		std::uint32_t                  pad24;        // 24
	};
	static_assert(sizeof(BGSRegisteredStoryEvent) == 0x28);

	class BGSStoryManagerEventNode : public BGSStoryManagerBranchNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStoryManagerEventNode;
		inline static constexpr auto FORMTYPE = FormType::StoryManagerEventNode;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSStoryManagerEventNode() override;  // 00

		// override (BGSStoryManagerBranchNode)
		void                      InitializeData() override;         // 04
		void                      ClearData() override;              // 05 - { BGSStoryManagerNodeBase::ClearData(); }
		bool                      Load(TESFile* a_mod) override;     // 06
		void                      InitItemImpl() override;           // 13
		[[nodiscard]] const char* GetFormEditorID() const override;  // 32 - { if (!((flags >> 3) & 1)) return "(Uninitialized event node)"; return event ? event->name.c_str() : "(No event)"; }

		// members
		const BGSRegisteredStoryEvent* event;  // 60 - ENAM
	};
	static_assert(sizeof(BGSStoryManagerEventNode) == 0x68);
}


===============================================
File: include/RE/B/BGSStoryManagerNodeBase.h
===============================================
#pragma once

#include "RE/B/BGSStoryManagerTreeForm.h"
#include "RE/T/TESCondition.h"

namespace RE
{
	class BGSStoryManagerNodeBase : public BGSStoryManagerTreeForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStoryManagerNodeBase;

		struct Flags  // DNAM
		{
		public:
			enum class NodeFlag
			{
				kNone = 0,
				kRandom = 1 << 0,
				kWarnIfNoChildQuestStarted = 1 << 1
			};

			enum class QuestFlag
			{
				kNone = 0,
				kDoAllBeforeRepeating = 1 << 0,
				kSharesEvent = 1 << 1,
				kNumQuestsToRun = 1 << 2
			};

			// members
			stl::enumeration<NodeFlag, std::uint16_t>  nodeFlags;  // 0
			stl::enumeration<QuestFlag, std::uint16_t> questFags;  // 2
		};
		static_assert(sizeof(Flags) == 0x4);

		~BGSStoryManagerNodeBase() override;  // 00

		// override (BGSStoryManagerTreeForm)
		void          InitializeData() override;      // 04
		void          ClearData() override;           // 05
		bool          Load(TESFile* a_mod) override;  // 06
		void          InitItemImpl() override;        // 13
		TESCondition* QConditions() override;         // 3D - { return &conditions; }

		// members
		BGSStoryManagerBranchNode* parent;           // 28 - PNAM
		BGSStoryManagerNodeBase*   previousSibling;  // 30 - SNAM
		std::uint32_t              maxQuests;        // 38 - XNAM
		Flags                      flags;            // 3C - DNAM
		TESCondition               conditions;       // 40 - CITC
	};
	static_assert(sizeof(BGSStoryManagerNodeBase) == 0x48);
}


===============================================
File: include/RE/B/BGSStoryManagerQuestNode.h
===============================================
#pragma once

#include "RE/B/BGSStoryManagerNodeBase.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BGSStoryManagerQuestNode : public BGSStoryManagerNodeBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStoryManagerQuestNode;
		inline static constexpr auto VTABLE = VTABLE_BGSStoryManagerQuestNode;
		inline static constexpr auto FORMTYPE = FormType::StoryManagerQuestNode;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kTimeLastRun = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSStoryManagerQuestNode() override;  // 00

		// override (BGSStoryManagerNodeBase)
		void                                     ClearData() override;                                           // 05
		bool                                     Load(TESFile* a_mod) override;                                  // 06
		void                                     SaveGame(BGSSaveFormBuffer* a_buf) override;                    // 0E
		void                                     LoadGame(BGSLoadFormBuffer* a_buf) override;                    // 0F
		void                                     Revert(BGSLoadFormBuffer* a_buf) override;                      // 12
		void                                     InitItemImpl() override;                                        // 13
		std::uint32_t                            QChildCount() const override;                                   // 3B - { return quests.size(); }
		BGSStoryManagerTreeForm*                 GetChild(std::uint32_t a_idx) const override;                   // 3C - { return quests[a_idx]; }
		BGSStoryManagerTreeVisitor::VisitControl AcceptVisitor(BGSStoryManagerTreeVisitor& a_visitor) override;  // 3E - { return a_visitor->VisitQuestNode(this); }

		// members
		BSTArray<TESQuest*>                  quests;                   // 48 - NNAM
		BSTHashMap<TESQuest*, std::uint32_t> perQuestFlags;            // 60 - maps NNAM to FNAM
		BSTHashMap<TESQuest*, float>         perQuestHoursUntilReset;  // 90 - maps NNAM to RNAM
		std::uint32_t                        numQuestsToStart;         // C0 - MNAM
		std::uint32_t                        padC4;                    // C4
		BSTArray<float>                      childrenLastRun;          // C8
	};
	static_assert(sizeof(BGSStoryManagerQuestNode) == 0xE0);
}


===============================================
File: include/RE/B/BGSStoryManagerTreeForm.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSStoryManagerBranchNode;
	class BGSStoryManagerQuestNode;
	class BGSStoryManagerTreeForm;
	class PeriodicUpdateTimer;
	class TESCondition;

	class BGSStoryManagerTreeVisitor
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStoryManagerTreeVisitor;

		enum class VisitControl
		{
		};

		virtual ~BGSStoryManagerTreeVisitor();  // 00

		// add
		virtual VisitControl VisitBranchNode(BGSStoryManagerBranchNode& a_node);             // 01
		virtual VisitControl VisitQuestNode(BGSStoryManagerQuestNode& a_node, bool a_arg2);  // 02
		virtual VisitControl VisitQuest(TESQuest& a_quest);                                  // 03
		virtual void         Revert();                                                       // 04

		// members
		PeriodicUpdateTimer*               timer;               // 08
		std::int32_t                       currentCursorDepth;  // 10
		std::uint32_t                      pad14;               // 14
		BGSStoryManagerQuestNode*          lastQuestParent;     // 18
		BSTArray<BGSStoryManagerTreeForm*> cursorAncestry;      // 20
		std::uint32_t                      queryID;             // 38
		std::uint32_t                      pad3C;               // 3C
	};
	static_assert(sizeof(BGSStoryManagerTreeVisitor) == 0x40);

	class BGSStoryManagerTreeForm : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStoryManagerTreeForm;

		~BGSStoryManagerTreeForm() override;  // 00

		// add
		[[nodiscard]] virtual std::uint32_t              QChildCount() const;                                       // 3B - { return 0; }
		[[nodiscard]] virtual BGSStoryManagerTreeForm*   GetChild(std::uint32_t a_idx) const;                       // 3C - { return 0; }
		virtual TESCondition*                            QConditions() = 0;                                         // 3D
		virtual BGSStoryManagerTreeVisitor::VisitControl AcceptVisitor(BGSStoryManagerTreeVisitor& a_visitor) = 0;  // 3E

		// members
		std::uint32_t lastVisitorID;  // 20
		std::uint32_t pad24;          // 24
	};
	static_assert(sizeof(BGSStoryManagerTreeForm) == 0x28);
}


===============================================
File: include/RE/B/BGSStoryTeller.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTTuple.h"

namespace RE
{
	class TESQuest;
	struct TESQuestStageItemDoneEvent;

	class BGSStoryTeller :
		public BSTSingletonSDM<BGSStoryTeller>,          // 08
		public BSTEventSink<TESQuestStageItemDoneEvent>  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSStoryTeller;

		~BGSStoryTeller() override;  // 00

		// override (BSTEventSink<TESQuestStageItemDoneEvent>)
		BSEventNotifyControl ProcessEvent(const TESQuestStageItemDoneEvent* a_event, BSTEventSource<TESQuestStageItemDoneEvent>* a_eventSource) override;  // 01

		static BGSStoryTeller* GetSingleton();

		void BeginShutDownQuest(TESQuest* a_quest);
		void BeginStartUpQuest(TESQuest* a_quest);

		// members
		std::uint8_t                                                                 pad09;                     // 09
		std::uint16_t                                                                pad0A;                     // 0A
		std::uint32_t                                                                pad0C;                     // 0C
		BSTArray<TESQuest*>                                                          queuedStartQuests;         // 10
		BSTArray<TESQuest*>                                                          runningQuests;             // 28
		BSTArray<TESQuest*>                                                          queuedStopQuests;          // 40
		BSTArray<TESQuest*>                                                          infoClearQuests;           // 58
		BSTArray<TESQuest*>                                                          helloTopicQuests;          // 70
		BSTArray<TESQuest*>                                                          greetingTopicQuests;       // 88
		bool                                                                         startUpQuestsInitialized;  // A0
		std::uint8_t                                                                 padA1;                     // A1
		std::uint16_t                                                                padA2;                     // A2
		std::uint32_t                                                                padA4;                     // A4
		BSTHashMap<std::uint32_t, BSTArray<BSTTuple<std::uint32_t, std::uint32_t>>*> questStageWaitMap;         // A8
	};
	static_assert(sizeof(BGSStoryTeller) == 0xD8);
}


===============================================
File: include/RE/B/BGSTalkingActivator.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESObjectACTI.h"

namespace RE
{
	class BGSTalkingActivator : public TESObjectACTI
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSTalkingActivator;
		inline static constexpr auto VTABLE = VTABLE_BGSTalkingActivator;
		inline static constexpr auto FORMTYPE = FormType::TalkingActivator;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kSpeaker = 1 << 23
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kHiddenFromLocalMap = 1 << 9,
				kIgnored = 1 << 12,
				kRandomAnimStart = 1 << 16,
				kRadioStation = 1 << 17
			};
		};

		~BGSTalkingActivator() override;  // 00

		// override (TESObjectACTI)
		void                        InitializeData() override;                                                                                                                              // 04
		bool                        Load(TESFile* a_mod) override;                                                                                                                          // 06
		void                        SaveGame(BGSSaveFormBuffer* a_buf) override;                                                                                                            // 0E
		void                        LoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                            // 0F
		void                        Revert(BGSLoadFormBuffer* a_buf) override;                                                                                                              // 12
		void                        InitItemImpl() override;                                                                                                                                // 13
		bool                        GetDangerous() const override;                                                                                                                          // 1B - { return 0; }
		bool                        Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_arg4, std::int32_t a_targetCount) override;  // 37
		void                        SetObjectVoiceType(BGSVoiceType* a_voiceType) override;                                                                                                 // 48 - { voiceType = a_voiceType; }
		[[nodiscard]] BGSVoiceType* GetObjectVoiceType() const override;                                                                                                                    // 49 - { return voiceType; }

		// add
		virtual bool GetReflectedByAutoWater();  // 53 - { return false; }

		// members
		TESObjectREFR* tempRef;    // C8
		BGSVoiceType*  voiceType;  // D0 - VNAM
	};
	static_assert(sizeof(BGSTalkingActivator) == 0xD8);
}


===============================================
File: include/RE/B/BGSTextureModel.h
===============================================
#pragma once

#include "RE/T/TESModel.h"

namespace RE
{
	class BGSTextureModel : public TESModel
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSTextureModel;

		~BGSTextureModel() override;  // 00

		// override (TESModel)
		void SetModel(const char* a_model) override;  // 05
	};
	static_assert(sizeof(BGSTextureModel) == 0x28);
}


===============================================
File: include/RE/B/BGSTextureSet.h
===============================================
#pragma once

#include "RE/B/BSTextureSet.h"
#include "RE/C/Color.h"
#include "RE/D/DecalData.h"
#include "RE/F/FormTypes.h"
#include "RE/I/ID.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	class BGSTextureSet :
		public TESBoundObject,  // 00
		public BSTextureSet     // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSTextureSet;
		inline static constexpr auto VTABLE = VTABLE_BGSTextureSet;
		inline static constexpr auto FORMTYPE = FormType::TextureSet;

		enum class Flag
		{
			kNone = 0,
			kNoSpecularMap = 1 << 0,
			kFacegenTextures = 1 << 1,
			kHasModelSpaceNormalMap = 1 << 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSTextureSet() override;  // 00

		// override (TESBoundObject)
		void        InitializeData() override;                            // 04
		void        ClearData() override;                                 // 05
		bool        Load(TESFile* a_mod) override;                        // 06
		NiAVObject* Clone3D(TESObjectREFR* a_ref, bool a_arg3) override;  // 40
		void        UnClone3D(TESObjectREFR* a_ref) override;             // 41

		// members
		TESTexture                            textures[Textures::kUsedTotal];        // 040 - TX00 - TX07
		DecalData*                            decalData;                             // 0C0 - DODT
		stl::enumeration<Flag, std::uint16_t> flags;                                 // 0C8 - DNAM
		std::uint16_t                         pad0CA;                                // 0CA
		BSResource::ID                        textureFileIDs[Textures::kUsedTotal];  // 0CC
		std::uint32_t                         pad12C;                                // 12C
	};
	static_assert(sizeof(BGSTextureSet) == 0x130);
}


===============================================
File: include/RE/B/BGSTypedItem.h
===============================================
#pragma once

namespace RE
{
	template <class Child, class Parent>
	class BGSTypedItem : public Parent
	{
	public:
	};
}


===============================================
File: include/RE/B/BGSVoiceType.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct VOICE_TYPE_DATA  // DNAM
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kAllowDefaultDialogue = 1 << 0,
			kFemale = 1 << 1
		};

		// members
		stl::enumeration<Flag, std::uint8_t> flags;  // 0
	};
	static_assert(sizeof(VOICE_TYPE_DATA) == 0x1);

	class BGSVoiceType : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSVoiceType;
		inline static constexpr auto VTABLE = VTABLE_BGSVoiceType;
		inline static constexpr auto FORMTYPE = FormType::VoiceType;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSVoiceType() override;  // 00

		// override (TESForm)
		bool        Load(TESFile* a_mod) override;                // 06
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { formEditorID = a_str; return true; }

		// members
		VOICE_TYPE_DATA data;          // 20 - DNAM
		std::uint8_t    pad21;         // 21
		std::uint16_t   pad22;         // 22
		std::uint16_t   pad24;         // 24
		BSString        formEditorID;  // 28 - EDID
	};
	static_assert(sizeof(BGSVoiceType) == 0x38);
}


===============================================
File: include/RE/B/BGSVolumetricLighting.h
===============================================
#pragma once

#include "RE/B/BSVolumetricLightingRenderData.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSVolumetricLighting :
		public TESForm,                        // 00
		public BSVolumetricLightingRenderData  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_BGSVolumetricLighting;
		inline static constexpr auto FORMTYPE = FormType::VolumetricLighting;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~BGSVolumetricLighting() override;  // 00

		// override (TESForm)
		void ClearData() override;           // 05 - { return; }
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13
	};
	static_assert(sizeof(BGSVolumetricLighting) == 0x50);
}


===============================================
File: include/RE/B/BGSWorldLocation.h
===============================================
#pragma once

#include "RE/N/NiPoint3.h"

namespace RE
{
	class TESForm;

	struct BGSWorldLocation
	{
		// members
		NiPoint3 pos;               // 00
		TESForm* cellOrWorldSpace;  // 0C
	};
	static_assert(sizeof(BGSWorldLocation) == 0x18);
}


===============================================
File: include/RE/B/BSAnimNote.h
===============================================
#pragma once

#include "RE/N/NiObject.h"

namespace RE
{
	class BSAnimNote : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSAnimNote;
		inline static auto           Ni_RTTI = NiRTTI_BSAnimNote;

		enum class AnimNoteType
		{
			kInvalid = 0,
			kGrabIK = 1,
			kLookIK = 2
		};

		~BSAnimNote() override = 0;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17 - { return this; }
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiObject::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiObject::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		// add
		virtual void Unk_25(void);  // 25
	};
	//static_assert(sizeof(BSAnimNote) == 0x);
}


===============================================
File: include/RE/B/BSAnimNoteListener.h
===============================================
#pragma once

#include "RE/B/BSAnimNote.h"
#include "RE/N/NiTArray.h"

namespace RE
{
	class IBSAnimNoteReceiver;

	class BSAnimNoteListener
	{
	public:
		struct BSAnimReceiverType
		{
		public:
			// members
			stl::enumeration<BSAnimNote::AnimNoteType, std::uint32_t> noteType;  // 00
			std::uint32_t                                             pad04;     // 04
			IBSAnimNoteReceiver*                                      receiver;  // 08
		};
		static_assert(sizeof(BSAnimReceiverType) == 0x10);

		// members
		NiTPrimitiveArray<BSAnimReceiverType*> receivers;  // 00
	};
	static_assert(sizeof(BSAnimNoteListener) == 0x18);
}


===============================================
File: include/RE/B/BSAnimationGraphChannel.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"

namespace RE
{
	class BSAnimationGraphChannel : public BSIntrusiveRefCounted
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSAnimationGraphChannel;

		virtual ~BSAnimationGraphChannel();  // 00

		// add
		virtual void PollChannelUpdateImpl(bool a_arg1) = 0;  // 01
		virtual void ResetImpl() = 0;                         // 02

		// members
		std::uint32_t       pad0C;        // 0C
		const BSFixedString channelName;  // 10
		std::uint32_t       value;        // 18
		std::uint32_t       pad1C;        // 1C
	};
	static_assert(sizeof(BSAnimationGraphChannel) == 0x20);
}


===============================================
File: include/RE/B/BSAnimationGraphEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	class TESObjectREFR;

	struct BSAnimationGraphEvent
	{
	public:
		// members
		const BSFixedString  tag;      // 00
		const TESObjectREFR* holder;   // 08
		const BSFixedString  payload;  // 10
	};
	static_assert(sizeof(BSAnimationGraphEvent) == 0x18);
}


===============================================
File: include/RE/B/BSAnimationGraphManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSmartPointer.h"
#include "SKSE/Version.h"

namespace RE
{
	class BSAnimationGraphChannel;
	class BShkbAnimationGraph;
	struct BSAnimationGraphEvent;

	union hkbVariableValue
	{
		bool         b;
		std::int32_t i;
		float        f;
	};
	static_assert(sizeof(hkbVariableValue) == 0x4);

	struct AnimVariableCacheInfo
	{
	public:
		// members
		BSFixedString     variableName;  // 00
		hkbVariableValue* variable;      // 08
	};
	static_assert(sizeof(AnimVariableCacheInfo) == 0x10);

	struct BSAnimationGraphVariableCache
	{
	public:
		[[nodiscard]] BSSpinLock* GetGraphLock() const noexcept {
			if SKYRIM_REL_CONSTEXPR (REL::Module::IsAE()) {
				if (REL::Module::get().version() >= SKSE::RUNTIME_SSE_1_6_629) {
					return &REL::RelocateMember<BSSpinLock>(this, 0x20);
				}
			}
			return nullptr;
		}

		[[nodiscard]] BSTSmartPointer<BShkbAnimationGraph>& GetAnimationGraph() noexcept {
			return REL::RelocateMemberIfNewer<BSTSmartPointer<BShkbAnimationGraph>>(SKSE::RUNTIME_SSE_1_6_629, this, 0x20, 0x28);
		}

		[[nodiscard]] const BSTSmartPointer<BShkbAnimationGraph>& GetAnimationGraph() const noexcept {
			return REL::RelocateMemberIfNewer<BSTSmartPointer<BShkbAnimationGraph>>(SKSE::RUNTIME_SSE_1_6_629, this, 0x20, 0x28);
		}

		// members
		BSTArray<AnimVariableCacheInfo>      variableCache;   // 00
		mutable BSSpinLock                   updateLock;      // 18
#if !defined(ENABLE_SKYRIM_AE)
		BSTSmartPointer<BShkbAnimationGraph> animationGraph;  // 20, 28 - smart ptr
#endif
	};
#if !defined(ENABLE_SKYRIM_AE)
	static_assert(sizeof(BSAnimationGraphVariableCache) == 0x28);
#endif

	BSSmartPointer(BSAnimationGraphManager);

	class BSAnimationGraphManager :
		public BSTEventSink<BSAnimationGraphEvent>,  // 00
		public BSIntrusiveRefCounted                 // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSAnimationGraphManager;

		struct AnimationVariable
		{
		public:
			union Value
			{
				bool         b;
				std::int32_t i;
				float        f;
			};
			static_assert(sizeof(Value) == 0x4);

			// members
			BSFixedString name;   // 00
			Value*        value;  // 08
		};
		static_assert(sizeof(AnimationVariable) == 0x10);

		~BSAnimationGraphManager() override;  // 00

		// override (BSTEventSink<BSAnimationGraphEvent>)
		BSEventNotifyControl ProcessEvent(const BSAnimationGraphEvent* a_event, BSTEventSource<BSAnimationGraphEvent>* a_eventSource) override;  // 01

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                \
	mutable BSSpinLock                   updateLock;           /* 98, A0 */ \
	mutable BSSpinLock                   dependentManagerLock; /* A0 */     \
	std::uint32_t                        activeGraph;          /* A8 */     \
	std::uint32_t                        generateDepth;        /* A8 */

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x98, 0xA0);
		}

		// members
		std::uint32_t                                       pad0C;                 // 0C
		BSTArray<BSTSmartPointer<BSAnimationGraphChannel>>  boundChannels;         // 10
		BSTArray<BSTSmartPointer<BSAnimationGraphChannel>>  bumpedChannels;        // 28
		BSTSmallArray<BSTSmartPointer<BShkbAnimationGraph>> graphs;                // 40
		BSTArray<BSAnimationGraphManagerPtr> subManagers;                          // 58
		BSAnimationGraphVariableCache        variableCache;                        // 70

#ifndef ENABLE_SKYRIM_AE
		RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(BSAnimationGraphManager) == 0xB0);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSAnimationUpdateData.h
===============================================
#pragma once

namespace RE
{
	class IPostAnimationChannelUpdateFunctor;
	class NiPoint3;
	class TESObjectREFR;

	struct BSAnimationUpdateData
	{
	public:
		// members
		float                               deltaTime{ 0.0f };               // 00
		uint32_t                            pad04;                           // 04
		void*                               unkFunctionPtr{ nullptr };       // 08
		TESObjectREFR*                      refr{ nullptr };                 // 10
		NiPoint3*                           optionalEyePosition{ nullptr };  // 18
		IPostAnimationChannelUpdateFunctor* updateFunctor{ nullptr };        // 20
		uint16_t                            flags;                           // 28
		bool                                unk2A;                           // 2A
		bool                                unk2B;                           // 2B
		bool                                unk2C;                           // 2C
		bool                                unk2D;                           // 2D
		bool                                unk2E;                           // 2E
		bool                                unk2F;                           // 2F
	};
	static_assert(sizeof(BSAnimationUpdateData) == 0x30);
}


===============================================
File: include/RE/B/BSArchive.h
===============================================
#pragma once

#include "RE/B/BSArchiveHeader.h"

namespace RE
{
	struct BSDirectoryEntry;

	class BSArchive : public BSArchiveHeader
	{
	public:
		// members
		std::uint32_t     pad24;        // 24
		BSDirectoryEntry* directories;  // 28
	};
	static_assert(sizeof(BSArchive) == 0x30);
}


===============================================
File: include/RE/B/BSArchiveHeader.h
===============================================
#pragma once

namespace RE
{
	class BSArchiveHeader
	{
	public:
		struct ArchiveFlag
		{
		public:
			// members
			std::uint32_t flag;  // 0
		};
		static_assert(sizeof(ArchiveFlag) == 0x4);

		// members
		std::uint32_t tag;                   // 00
		std::uint32_t version;               // 04
		std::uint32_t headerSize;            // 08
		ArchiveFlag   flags;                 // 0C
		std::uint32_t directories;           // 10
		std::uint32_t files;                 // 14
		std::uint32_t directoryNamesLength;  // 18
		std::uint32_t fileNamesLength;       // 1C
		std::uint16_t archiveType;           // 20
		std::uint16_t pad22;                 // 22
	};
	static_assert(sizeof(BSArchiveHeader) == 0x24);
}


===============================================
File: include/RE/B/BSAtomic.h
===============================================
#pragma once

namespace RE
{
	class BSCriticalSection
	{
	public:
		// members
		WinAPI::CRITICAL_SECTION criticalSection;  // 00
	};
	static_assert(sizeof(BSCriticalSection) == 0x28);

	class BSEventFlag
	{
	public:
		// members
		void* event;  // 0
	};
	static_assert(sizeof(BSEventFlag) == 0x8);

	class BSNonReentrantSpinLock
	{
	public:
		// members
		volatile std::uint32_t lock;  // 0
	};
	static_assert(sizeof(BSNonReentrantSpinLock) == 0x4);

	class BSSemaphoreBase
	{
	public:
		BSSemaphoreBase();
		~BSSemaphoreBase();

		// members
		void* semaphore;  // 0
	};
	static_assert(sizeof(BSSemaphoreBase) == 0x8);

	class BSSemaphore : public BSSemaphoreBase
	{
	public:
		BSSemaphore() = default;
		~BSSemaphore() = default;
	};
	static_assert(sizeof(BSSemaphore) == 0x8);

	class BSSpinLock
	{
	public:
		enum
		{
			kFastSpinThreshold = 10000,
		};

		BSSpinLock();

		void Lock(std::uint32_t a_pauseAttempts = 0);
		void Unlock();

	private:
		// members
		volatile std::uint32_t _owningThread;  // 0
		volatile std::uint32_t _lockCount;     // 4
	};
	static_assert(sizeof(BSSpinLock) == 0x8);

	class BSReadWriteLock
	{
	public:
		enum
		{
			kLockWrite = 0x80000000,
			kLockCountMask = 0xFFFFFFF
		};

		BSReadWriteLock();

		void LockForRead();
		void UnlockForRead();
		void LockForWrite();
		void UnlockForWrite();

	private:
		// members
		[[maybe_unused]] volatile std::uint32_t _writerThread;  // 0
		[[maybe_unused]] volatile std::uint32_t _lock;          // 4
	};
	static_assert(sizeof(BSReadWriteLock) == 0x8);

	class BSSpinLockGuard
	{
	public:
		BSSpinLockGuard() = delete;
		BSSpinLockGuard(const BSSpinLockGuard&) = delete;
		BSSpinLockGuard(BSSpinLockGuard&&) = delete;
		[[nodiscard]] explicit BSSpinLockGuard(BSSpinLock& a_lock);
		~BSSpinLockGuard();

		BSSpinLockGuard& operator=(const BSSpinLockGuard&) = delete;
		BSSpinLockGuard& operator=(BSSpinLockGuard&&) = delete;

	private:
		BSSpinLock& _lock;  // 0
	};
	static_assert(sizeof(BSSpinLockGuard) == 0x8);

	class BSReadLockGuard
	{
	public:
		BSReadLockGuard() = delete;
		BSReadLockGuard(const BSReadLockGuard&) = delete;
		BSReadLockGuard(BSReadLockGuard&&) = delete;
		[[nodiscard]] explicit BSReadLockGuard(BSReadWriteLock& a_lock);
		~BSReadLockGuard();

		BSReadLockGuard& operator=(const BSReadLockGuard&) = delete;
		BSReadLockGuard& operator=(BSReadLockGuard&&) = delete;

	private:
		BSReadWriteLock& _lock;  // 0
	};
	static_assert(sizeof(BSReadLockGuard) == 0x8);

	class BSWriteLockGuard
	{
	public:
		BSWriteLockGuard() = delete;
		BSWriteLockGuard(const BSWriteLockGuard&) = delete;
		BSWriteLockGuard(BSWriteLockGuard&&) = delete;
		[[nodiscard]] explicit BSWriteLockGuard(BSReadWriteLock& a_lock);
		~BSWriteLockGuard();

		BSWriteLockGuard& operator=(const BSWriteLockGuard&) = delete;
		BSWriteLockGuard& operator=(BSWriteLockGuard&&) = delete;

	private:
		BSReadWriteLock& _lock;  // 0
	};
	static_assert(sizeof(BSWriteLockGuard) == 0x8);
}


===============================================
File: include/RE/B/BSAudioManager.h
===============================================
#pragma once

#include "RE/B/BSAudioManagerThread.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"

namespace RE
{
	class BSISoundDescriptor;
	class BSXAudio2GameSound;
	struct BSSoundHandle;

	class BSAudioManager
	{
	public:
		static BSAudioManager* GetSingleton();

		bool Play(FormID a_soundFormID);
		bool Play(BSISoundDescriptor* a_descriptor);
		bool BuildSoundDataFromDescriptor(BSSoundHandle& a_soundHandle, BSISoundDescriptor* a_descriptor, std::uint32_t a_flags = 0x1A);
		void BuildSoundDataFromEditorID(BSSoundHandle& a_soundHandle, const char* a_editorID, std::uint32_t a_flags);

		// members
		std::uint64_t                                  unk000;  // 000
		void*                                          unk008;  // 008
		void*                                          unk010;  // 010
		void*                                          unk018;  // 018
		void*                                          unk020;  // 020
		std::uint64_t                                  unk028;  // 028
		BSTHashMap<std::uint32_t, BSXAudio2GameSound*> unk030;  // 030
		BSTHashMap<UnkKey, UnkValue>                   unk060;  // 060
		BSTHashMap<UnkKey, UnkValue>                   unk090;  // 090
		BSTHashMap<UnkKey, UnkValue>                   unk0C0;  // 0C0
		std::uint64_t                                  unk0F0;  // 0F0
		BSAudioManagerThread*                          unk0F8;  // 0F8
		std::uint64_t                                  unk100;  // 100
		BSFixedString                                  unk108;  // 108
		std::uint64_t                                  unk110;  // 110
		std::uint64_t                                  unk118;  // 118
		std::uint64_t                                  unk120;  // 120
		std::uint64_t                                  unk128;  // 128
		std::uint64_t                                  unk130;  // 130
		std::uint64_t                                  unk138;  // 138
		std::uint64_t                                  unk140;  // 140
		std::uint64_t                                  unk148;  // 148
		std::uint64_t                                  unk150;  // 150
		std::uint64_t                                  unk158;  // 158
		std::uint64_t                                  unk160;  // 160
		std::uint64_t                                  unk168;  // 168
		std::uint64_t                                  unk170;  // 170
		std::uint64_t                                  unk178;  // 178
		std::uint64_t                                  unk180;  // 180
		std::uint64_t                                  unk188;  // 188
	};
	static_assert(sizeof(BSAudioManager) == 0x190);
}


===============================================
File: include/RE/B/BSAudioManagerThread.h
===============================================
#pragma once

#include "RE/B/BSThread.h"

namespace RE
{
	class BSAudioManagerThread : public BSThread
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSAudioManagerThread;

		~BSAudioManagerThread() override;  // 00

		// override (BSThread)
		void Unk_01(void) override;  // 01

		// members
		std::uint64_t unk50;  // 50
		std::uint64_t unk58;  // 58
		std::uint64_t unk60;  // 60
	};
	static_assert(sizeof(BSAudioManagerThread) == 0x68);
}


===============================================
File: include/RE/B/BSBatchRenderer.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"

namespace RE
{
	class BSBatchRenderer
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSBatchRenderer;

		virtual ~BSBatchRenderer();  // 00

		// add
		virtual void Unk_01(void);  // 01
		virtual void Unk_02(void);  // 02
		virtual void Unk_03(void);  // 03

		// members
		BSTArray<void*>              unk008;      // 008
		BSTHashMap<UnkKey, UnkValue> unk020;      // 020
		std::uint64_t                unk050;      // 050
		std::uint64_t                unk058;      // 058
		std::uint64_t                unk060;      // 060
		std::uint64_t                unk068;      // 068
		void*                        unk070[16];  // 070
		std::uint64_t                unk0F0;      // 0F0
		std::uint64_t                unk0F8;      // 0F8
		std::uint64_t                unk100;      // 100
	};
	static_assert(sizeof(BSBatchRenderer) == 0x108);
}


===============================================
File: include/RE/B/BSBitField.h
===============================================
#pragma once

namespace RE
{
	class BSBitFieldHeapAllocator
	{
	public:
		// members
		std::uint32_t* data;  // 0
	};
	static_assert(sizeof(BSBitFieldHeapAllocator) == 0x8);

	template <class Allocator = BSBitFieldHeapAllocator>
	class BSBitField : public Allocator
	{
	public:
		union Buffer
		{
			std::uint32_t  local;
			std::uint32_t* heap;
		};

		// members
		Buffer        buffer;
		std::uint32_t size;
	};
	static_assert(sizeof(BSBitField<>) == 0x18);
}


===============================================
File: include/RE/B/BSBloodSplatterShaderProperty.h
===============================================
#pragma once

#include "RE/B/BSShaderProperty.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiSourceTexture;

	class BSBloodSplatterShaderProperty : public BSShaderProperty
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSBloodSplatterShaderProperty;
		inline static auto           Ni_RTTI = NiRTTI_BSBloodSplatterShaderProperty;

		enum : std::uint32_t
		{
			kBloodColor = 0,
			kBloodAlpha,
			kFlareColor,

			kTotal
		};

		~BSBloodSplatterShaderProperty() override;  // 00

		// override (BSShaderProperty)
		const NiRTTI*    GetRTTI() const override;                                                                                    // 02
		NiObject*        CreateClone(NiCloningProcess& a_cloning) override;                                                           // 17
		RenderPassArray* GetRenderPasses(BSGeometry* a_geometry, std::uint32_t a_arg2, BSShaderAccumulator* a_accumulator) override;  // 2A
		std::int32_t     ForEachTexture(ForEachVisitor& a_visitor) override;                                                          // 33
		std::int32_t     QShader() override;                                                                                          // 35 - { return 12 }
		NiSourceTexture* GetBaseTexture() override;                                                                                   // 37 - { return bloodColorTexture; }

		// members
		NiPointer<NiSourceTexture> bloodTextures[kTotal];  // 088
		std::int32_t               textureClampMode;       // 0A0
		float*                     alphaSource;            // 0A8
	};
	static_assert(sizeof(BSBloodSplatterShaderProperty) == 0xB0);
}


===============================================
File: include/RE/B/BSBound.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class BSBound : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSBound;
		inline static auto           Ni_RTTI = NiRTTI_BSBound;

		~BSBound() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17 - { return this; }
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream) == false; }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		// members
		NiPoint3 center;   // 18
		NiPoint3 extents;  // 24
	};
	static_assert(sizeof(BSBound) == 0x30);
}


===============================================
File: include/RE/B/BSContainer.h
===============================================
#pragma once

namespace RE::BSContainer
{
	enum class ForEachResult
	{
		kStop = 0,
		kContinue = 1
	};
}


===============================================
File: include/RE/B/BSCoreTypes.h
===============================================
#pragma once

namespace RE
{
	using FormID = std::uint32_t;
	using RefHandle = std::uint32_t;
	using VMHandle = std::uint64_t;
	using VMStackID = std::uint32_t;
	using VMTypeID = std::uint32_t;
}


===============================================
File: include/RE/B/BSCullingProcess.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTLocklessQueue.h"
#include "RE/N/NiCullingProcess.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSCompoundFrustum;
	class BSMultiBound;
	class BSOcclusionPlane;
	class NiAVObject;
	class NiBound;

	class BSCullingProcess : public NiCullingProcess
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSCullingProcess;
		inline static auto           Ni_RTTI = NiRTTI_BSCullingProcess;

		enum class BSCPCullingType
		{
			kNormal = 0,
			kAllPass = 1,
			kAllFail = 2,
			kIgnoreMultiBounds = 3,
			kForceMultiBoundsNoUpdate = 4
		};

		struct Data
		{
		public:
			// members
			std::uint8_t unk00[0x10];  // 00
		};
		static_assert(sizeof(Data) == 0x10);

		// override (NiCullingProcess)
		const NiRTTI* GetRTTI() const override;  // 00

		~BSCullingProcess() override;  // 15

		void Process1(NiAVObject* a_object, std::uint32_t a_arg2) override;                                   // 16
		void Process2(const NiCamera* a_camera, NiAVObject* a_scene, NiVisibleArray* a_visibleSet) override;  // 17
		void AppendVirtual(BSGeometry& a_visible, std::uint32_t a_arg2) override;                             // 18

		// add
		virtual void               AppendNonAccum(NiAVObject& a_object);               // 19
		virtual bool               TestBaseVisibility1(BSMultiBound& a_bound);         // 1A
		virtual bool               TestBaseVisibility2(BSOcclusionPlane& a_bound);     // 1B
		[[nodiscard]] virtual bool TestBaseVisibility3(const NiBound& a_bound) const;  // 1C

		BSTArray<NiPointer<NiAVObject>>                   unk00128;           // 00128
		BSTLocklessQueue::ObjMultiProdCons<Data, 4096, 0> cullQueue;          // 00140
		std::uint64_t                                     unk30160;           // 30160
		std::uint64_t                                     unk30168;           // 30168
		std::uint64_t                                     unk30170;           // 30170
		std::uint64_t                                     unk30178;           // 30178
		std::uint64_t                                     unk30180;           // 30180
		std::uint64_t                                     unk30188;           // 30188
		void*                                             unk30190;           // 30190
		std::int32_t                                      cullMode;           // 30198
		BSCompoundFrustum*                                compoundFrustum;    // 301A0
		std::uint64_t                                     unk301A8;           // 301A8
		std::uint64_t                                     unk301B0;           // 301B0
		std::uint64_t                                     unk301B8;           // 301B8
		std::uint64_t                                     unk301C0;           // 301C0
		std::uint64_t                                     unk301C8;           // 301C8
		std::uint32_t                                     unk301D0;           // 301D0
		bool                                              recurseToGeometry;  // 301D4
		std::uint8_t                                      unk301D5;           // 301D5
		std::uint16_t                                     unk301D6;           // 301D6
		BSTArray<void*>                                   unk301D8;           // 301D8
		std::uint64_t                                     unk301F0;           // 301F0
	};
	static_assert(sizeof(BSCullingProcess) == 0x301F8);
}


===============================================
File: include/RE/B/BSDirectInputManager.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"

namespace RE
{
	class BSDirectInputManager : public BSTSingletonSDM<BSDirectInputManager>
	{
	public:
		static BSDirectInputManager* GetSingleton();

		DirectInput8::IDirectInputDevice8A* CreateDeviceWithGUID(WinAPI::GUID* a_guid);
		void                                GetDeviceState(DirectInput8::IDirectInputDevice8A* a_device, std::uint32_t a_size, void* a_outData);
		void                                GetDeviceData(DirectInput8::IDirectInputDevice8A* a_device, std::uint32_t* a_dataSize, DirectInput8::DIDEVICEOBJECTDATA** a_outData);
		void                                ReleaseDevice(DirectInput8::IDirectInputDevice8A* a_device);

		// members
		std::uint32_t                 pad00;        // 00
		DirectInput8::IDirectInput8A* diInterface;  // 08
	};
	static_assert(sizeof(BSDirectInputManager) == 0x10);
}


===============================================
File: include/RE/B/BSDismemberSkinInstance.h
===============================================
#pragma once

#include "RE/N/NiSkinInstance.h"

namespace RE
{
	class BSDismemberSkinInstance : public NiSkinInstance
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSDismemberSkinInstance;
		inline static auto           Ni_RTTI = NiRTTI_BSDismemberSkinInstance;

		struct Data
		{
		public:
			// members
			bool          editorVisible;    // 0
			bool          startNetBoneSet;  // 1
			std::uint16_t slot;             // 2 - https://wiki.nexusmods.com/index.php/Skyrim_bodyparts_number
		};
		static_assert(sizeof(Data) == 0x4);

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT              \
	std::int32_t  numPartitions; /* 00 */ \
	std::uint32_t pad8C;         /* 04 */ \
	Data*         partitions;    /* 08 */ \
	bool          unk98;         /* 10 */ \
	std::uint8_t  pad99;         /* 11 */ \
	std::uint16_t pad9A;         /* 12 */ \
	std::uint32_t pad9C;         /* 14 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x18);

		~BSDismemberSkinInstance() override;  // 00

		// override (NiSkinInstance)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiSkinInstance::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiSkinInstance::RegisterStreamables(a_stream) != false; }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
		void          Unk_25(void) override;                              // 25

		void UpdateDismemberPartion(std::uint16_t a_slot, bool a_enable)
		{
			using func_t = decltype(&BSDismemberSkinInstance::UpdateDismemberPartion);
			REL::Relocation<func_t> func{ RELOCATION_ID(15576, 15753) };
			return func(this, a_slot, a_enable);
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x88, 0x68);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x88, 0x68);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 88, 68
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSDismemberSkinInstance) == 0xA0);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSDismemberSkinInstance) == 0x80);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSDynamicTriShape.h
===============================================
#pragma once

#include "RE/B/BSTriShape.h"

namespace RE
{
	class BSDynamicTriShape : public BSTriShape
	{
	public:
		struct DYNAMIC_TRISHAPE_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT             \
	void*         dynamicData;  /* 00 */ \
	BSSpinLock    lock;         /* 08 */ \
	std::uint32_t dataSize;     /* 10 */ \
	std::uint32_t frameCount;   /* 14 */ \
	std::uint32_t unk178;       /* 18 */ \
	std::uint32_t unk17C;       /* 1C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(DYNAMIC_TRISHAPE_RUNTIME_DATA) == 0x20);

		// override (BSTriShape)
		const NiRTTI*      GetRTTI() const override;                           // 02
		BSDynamicTriShape* AsDynamicTriShape() override;                       // 0C
		NiObject*          CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void               LoadBinary(NiStream& a_stream) override;            // 18
		void               LinkObject(NiStream& a_stream) override;            // 19 - { BSTriShape::LinkObject(a_stream); }
		bool               RegisterStreamables(NiStream& a_stream) override;   // 1A - { return BSTriShape::RegisterStreamables(a_stream); }
		void               SaveBinary(NiStream& a_stream) override;            // 1B
		bool               IsEqual(NiObject* a_object) override;               // 1C

		[[nodiscard]] inline DYNAMIC_TRISHAPE_RUNTIME_DATA& GetDynamicTrishapeRuntimeData() noexcept
		{
			return REL::RelocateMember<DYNAMIC_TRISHAPE_RUNTIME_DATA>(this, 0x160, 0x1A8);
		}

		[[nodiscard]] inline const DYNAMIC_TRISHAPE_RUNTIME_DATA& GetDynamicTrishapeRuntimeData() const noexcept
		{
			return REL::RelocateMember<DYNAMIC_TRISHAPE_RUNTIME_DATA>(this, 0x160, 0x1A8);
		}

		BSDynamicTriShape* ctor()
		{
			using func_t = decltype(&BSDynamicTriShape::ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(69564, 70948) };
			return func(this);
		}

#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT;  // 160, 1A8
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSDynamicTriShape) == 0x180);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSDynamicTriShape) == 0x1C8);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSEffectShaderData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/D/DepthStencilDepthModes.h"
#include "RE/N/NiAlphaProperty.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TextureAddressModes.h"

namespace RE
{
	class NiTexture;

	class BSEffectShaderData : public BSIntrusiveRefCounted
	{
	public:
		using NodeFilterFunction_t = bool(const BSFixedString*);

		BSEffectShaderData();
		~BSEffectShaderData();

		// members
		std::uint32_t                     pad04;                    // 04
		NodeFilterFunction_t*             nodeFilterFunction;       // 08
		NiPointer<NiTexture>              baseTexture;              // 10
		NiPointer<NiTexture>              paletteTexture;           // 18
		NiPointer<NiTexture>              blockOutTexture;          // 20
		BSGraphics::TextureAddressMode    textureClampMode;         // 28
		NiColorA                          fillColor;                // 2C
		NiColorA                          rimColor;                 // 3C
		float                             baseFillScale;            // 4C
		float                             baseFillAlpha;            // 50
		float                             baseRimAlpha;             // 54
		float                             uOffset;                  // 58
		float                             vOffset;                  // 5C
		float                             uScale;                   // 60
		float                             vScale;                   // 64
		float                             edgeExponent;             // 68
		float                             boundDiameter;            // 6C
		NiAlphaProperty::AlphaFunction    srcBlend;                 // 70
		NiAlphaProperty::AlphaFunction    destBlend;                // 74
		BSGraphics::DepthStencilDepthMode zTestFunc;                // 78
		std::int8_t                       alphaTestRef;             // 7C
		bool                              grayscaleToColor;         // 7D
		bool                              grayscaleToAlpha;         // 7E
		bool                              ignoreTextureAlpha;       // 7F
		bool                              baseTextureProjectedUVs;  // 80
		bool                              ignoreBaseGeomTexAlpha;   // 81
		bool                              lighting;                 // 82
		bool                              alpha;                    // 83
		std::uint32_t                     pad84;                    // 84
	};
	static_assert(sizeof(BSEffectShaderData) == 0x88);
}


===============================================
File: include/RE/B/BSEffectShaderMaterial.h
===============================================
#pragma once

#include "RE/B/BSShaderMaterial.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TextureAddressModes.h"

namespace RE
{
	class NiSourceTexture;

	class BSEffectShaderMaterial : public BSShaderMaterial
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSEffectShaderMaterial;

		~BSEffectShaderMaterial() override;  // 00

		// override (BSShaderMaterial)
		BSShaderMaterial* Create() override;                                // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;  // 02
		bool              DoIsCopy(BSShaderMaterial* a_other) override;     // 03
		std::uint32_t     ComputeCRC32(void) override;                      // 04
		BSShaderMaterial* GetDefault() override;                            // 05
		Type              GetType() const override;                         // 07 - { return Type::kEffect; }

		// members
		float                                                          falloffStartAngle;     // 38
		float                                                          falloffStopAngle;      // 3C
		float                                                          falloffStartOpacity;   // 40
		float                                                          falloffStopOpacity;    // 44
		NiColorA                                                       baseColor;             // 48
		NiPointer<NiSourceTexture>                                     sourceTexture;         // 58
		NiPointer<NiSourceTexture>                                     greyscaleTexture;      // 60
		float                                                          softFalloffDepth;      // 68
		float                                                          baseColorScale;        // 6C
		BSFixedString                                                  sourceTexturePath;     // 70
		BSFixedString                                                  greyscaleTexturePath;  // 78
		stl::enumeration<BSGraphics::TextureAddressMode, std::uint8_t> effectClampMode;       // 80
		std::uint8_t                                                   unk81;                 // 81
	};
	static_assert(sizeof(BSEffectShaderMaterial) == 0x88);
}


===============================================
File: include/RE/B/BSEffectShaderProperty.h
===============================================
#pragma once

#include "RE/B/BSShaderProperty.h"

namespace RE
{
	class NiColor;

	class BSEffectShaderProperty : public BSShaderProperty
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSEffectShaderProperty;
		inline static auto           Ni_RTTI = NiRTTI_BSEffectShaderProperty;

		~BSEffectShaderProperty() override;  // 00

		// override (BSShaderProperty)
		const NiRTTI*          GetRTTI() const override;                                                                                    // 02
		NiObject*              CreateClone(NiCloningProcess& a_cloning) override;                                                           // 17 - { return 0; }
		void                   LoadBinary(NiStream& a_stream) override;                                                                     // 18
		void                   LinkObject(NiStream& a_stream) override;                                                                     // 19 - { NiShadeProperty::LinkObject(a_stream); }
		void                   SaveBinary(NiStream& a_stream) override;                                                                     // 1B
		void                   PostLinkObject(NiStream& a_stream) override;                                                                 // 1E - { NiObjectNET::PostLinkObject(a_stream); }
		bool                   SetupGeometry(BSGeometry* a_geometry) override;                                                              // 27
		RenderPassArray*       GetRenderPasses(BSGeometry* a_geometry, std::uint32_t a_arg2, BSShaderAccumulator* a_accumulator) override;  // 2A
		void                   Unk_2B(void) override;                                                                                       // 2B - { return 0; }
		void                   SetMaterialAlpha(float a_alpha) override;                                                                    // 31 - { baseColor->alpha = a_alpha }
		float                  QMaterialAlpha() override;                                                                                   // 32 - { baseColor->alpha }
		std::int32_t           ForEachTexture(ForEachVisitor& a_visitor) override;                                                          // 33
		std::int32_t           QShader() override;                                                                                          // 35 - { return 1; }
		NiSourceTexture*       GetBaseTexture() override;                                                                                   // 37 - { return material->sourceTexture }
		void                   Unk_3B(void) override;                                                                                       // 3B - { return; }
		void                   Unk_3C(void) override;                                                                                       // 3C - { return 1; }
		BSShaderMaterial::Type GetMaterialType() override;                                                                                  // 3E - { return 1; }

		// members
		NiColor*      unk88;  // 88
		std::uint64_t unk90;  // 90
		std::uint64_t unk98;  // 98
	};
	static_assert(sizeof(BSEffectShaderProperty) == 0xA0);
}


===============================================
File: include/RE/B/BSExtraData.h
===============================================
#pragma once

#include "RE/E/ExtraDataTypes.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSExtraData;
		inline static constexpr auto VTABLE = VTABLE_BSExtraData;
		inline static auto           EXTRADATATYPE = ExtraDataType::kNone;

		BSExtraData();
		virtual ~BSExtraData() = default;  // 00

		// add
		[[nodiscard]] virtual ExtraDataType GetType() const = 0;                         // 01
		virtual bool                        IsNotEqual(const BSExtraData* a_rhs) const;  // 02 - { return false; }

		static BSExtraData* Create(std::size_t a_size, std::uintptr_t a_vtbl);
		template <class T>
		static T* Create();

		bool operator==(const BSExtraData& a_rhs) const;
		bool operator!=(const BSExtraData& a_rhs) const;

		TES_HEAP_REDEFINE_NEW();

		// members
		BSExtraData* next;  // 08
	};
	static_assert(sizeof(BSExtraData) == 0x10);

	template <class T>
	T* BSExtraData::Create()
	{
		return static_cast<T*>(Create(sizeof(T), T::VTABLE[0].address()));
	}
}


===============================================
File: include/RE/B/BSFaceGenAnimationData.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSFaceGenKeyframeMultiple.h"
#include "RE/N/NiExtraData.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class BSFaceGenAnimationData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFaceGenAnimationData;
		inline static auto           Ni_RTTI = NiRTTI_BSFaceGenAnimationData;

		~BSFaceGenAnimationData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;  // 02

		void ClearExpressionOverride() noexcept { exprOverride = false; }

		void Reset(float a_timer, bool a_resetExpression, bool a_resetModifierAndPhoneme, bool a_resetCustom, bool a_closeEyes)
		{
			using func_t = decltype(&BSFaceGenAnimationData::Reset);
			REL::Relocation<func_t> func{ RELOCATION_ID(25977, 26586) };
			return func(this, a_timer, a_resetExpression, a_resetModifierAndPhoneme, a_resetCustom, a_closeEyes);
		}

		void SetExpressionOverride(std::int32_t a_idx, float a_value)
		{
			using func_t = decltype(&BSFaceGenAnimationData::SetExpressionOverride);
			REL::Relocation<func_t> func{ RELOCATION_ID(25980, 26594) };
			return func(this, a_idx, a_value);
		}

		// members
		BSFaceGenKeyframeMultiple* transitionTargetKeyFrame;  // 018
		BSFaceGenKeyframeMultiple  expressionKeyFrame;        // 020
		BSFaceGenKeyframeMultiple  unk040;                    // 040
		BSFaceGenKeyframeMultiple  modifierKeyFrame;          // 060
		BSFaceGenKeyframeMultiple  phenomeKeyFrame;           // 080
		BSFaceGenKeyframeMultiple  customKeyFrame;            // 0A0
		BSFaceGenKeyframeMultiple  unk0C0;                    // 0C0
		BSFaceGenKeyframeMultiple  unk0E0;                    // 0E0
		BSFaceGenKeyframeMultiple  unk100;                    // 100
		BSFaceGenKeyframeMultiple  unk120;                    // 120
		BSFaceGenKeyframeMultiple  unk140;                    // 140
		BSFaceGenKeyframeMultiple  unk160;                    // 160
		BSFaceGenKeyframeMultiple  unk180;                    // 180
		NiPoint3                   unk1A0;                    // 1A0
		std::uint32_t              unk1AC;                    // 1AC
		std::uint64_t              unk1B0;                    // 1B0
		std::uint64_t              unk1B8;                    // 1B8
		std::uint64_t              unk1C0;                    // 1C0
		std::uint64_t              unk1C8;                    // 1C8
		std::uint8_t               unk1D0;                    // 1D0
		std::uint8_t               unk1D1;                    // 1D1
		std::uint16_t              unk1D2;                    // 1D2
		std::uint32_t              unk1D4;                    // 1D4
		std::uint64_t              unk1D8;                    // 1D8
		std::uint64_t              unk1E0;                    // 1E0
		std::uint64_t              unk1E8;                    // 1E8
		std::uint32_t              unk1F0;                    // 1F0
		std::uint32_t              unk1F4;                    // 1F4
		std::uint64_t              unk1F8;                    // 1F8
		std::uint32_t              unk200;                    // 200
		float                      blinkDelay;                // 204
		std::uint32_t              unk208;                    // 208
		std::uint32_t              unk20C;                    // 20C
		std::uint32_t              unk210;                    // 210
		std::uint16_t              unk214;                    // 214
		std::uint8_t               unk216;                    // 216
		std::uint8_t               unk217;                    // 217
		std::uint8_t               unk218;                    // 218
		std::uint8_t               unk219;                    // 219
		std::uint8_t               unk21A;                    // 21A
		std::uint8_t               unk21B;                    // 21B
		std::uint8_t               unk21C;                    // 21C
		std::uint8_t               unk21D;                    // 21D
		bool                       exprOverride;              // 21E
		std::uint8_t               unk21F;                    // 21F
		mutable BSSpinLock         lock;                      // 220
		std::uint64_t              unk228;                    // 228
	};
	static_assert(sizeof(BSFaceGenAnimationData) == 0x230);
}


===============================================
File: include/RE/B/BSFaceGenKeyframe.h
===============================================
#pragma once

namespace RE
{
	class BSFaceGenKeyframe
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFaceGenKeyframe;

		virtual ~BSFaceGenKeyframe();  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void) = 0;  // 05
		virtual void Unk_06(void) = 0;  // 06
		virtual void Unk_07(void) = 0;  // 07
		virtual void Unk_08(void) = 0;  // 08
		virtual void Unk_09(void) = 0;  // 09
		virtual void Unk_0A(void) = 0;  // 0A
		virtual void Unk_0B(void) = 0;  // 0B
		virtual void Unk_0C(void);      // 0C - { return 0; }
		virtual void Unk_0D(void);      // 0D - { return 0; }

		// members
		std::uint32_t type;   // 08
		float         unk0C;  // 0C
	};
	static_assert(sizeof(BSFaceGenKeyframe) == 0x10);
}


===============================================
File: include/RE/B/BSFaceGenKeyframeMultiple.h
===============================================
#pragma once

#include "RE/B/BSFaceGenKeyframe.h"

namespace RE
{
	class BSFaceGenKeyframeMultiple : public BSFaceGenKeyframe
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFaceGenKeyframeMultiple;

		~BSFaceGenKeyframeMultiple() override;  // 00

		// override (BSFaceGenKeyframe)
		void Unk_01(void) override;  // 01
		void Unk_02(void) override;  // 02
		void Unk_03(void) override;  // 03
		void Unk_04(void) override;  // 04
		void Unk_05(void) override;  // 05
		void Unk_06(void) override;  // 06
		void Unk_07(void) override;  // 07
		void Unk_08(void) override;  // 08
		void Unk_09(void) override;  // 09
		void Unk_0A(void) override;  // 0A
		void Unk_0B(void) override;  // 0B
		void Unk_0C(void) override;  // 0C - { return 1; }

		// add
		virtual void Unk_0E(void);  // 0E
		virtual void Unk_0F(void);  // 0F

		void SetValue(std::uint32_t a_idx, float a_value) noexcept
		{
			assert(a_idx < count);
			assert(values != nullptr);
			values[a_idx] = a_value;
			isUpdated = false;
		}

		// members
		float*        values;     // 10
		std::uint32_t count;      // 18
		bool          isUpdated;  // 1C
		std::uint8_t  pad1D;      // 1D
		std::uint16_t pad1E;      // 1E
	};
	static_assert(sizeof(BSFaceGenKeyframeMultiple) == 0x20);
}


===============================================
File: include/RE/B/BSFaceGenManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSHeadPart;
	class BSFaceGenModel;
	class BSFaceGenNiNode;
	class TESNPC;

	struct BSFaceGenModelMap
	{
	public:
		class Entry : public NiRefObject
		{
		public:
			// members
			NiPointer<BSFaceGenModel> model;  // 10
			std::uint64_t             time;   // 18
		};
		static_assert(sizeof(Entry) == 0x20);

		// members
		BSTHashMap<BSFixedString, NiPointer<Entry>> map;             // 00
		BSReadWriteLock                             lock;            // 30
		bool                                        hasFaceGenData;  // 38
	};
	static_assert(sizeof(BSFaceGenModelMap) == 0x40);

	class BSFaceGenManager : public BSTSingletonSDM<BSFaceGenManager>
	{
	public:
		[[nodiscard]] static BSFaceGenManager* GetSingleton()
		{
			REL::Relocation<BSFaceGenManager**> singleton{ RELOCATION_ID(514182, 400331) };
			return *singleton;
		}

		void PrepareHeadPartForShaders(BSFaceGenNiNode* a_node, BGSHeadPart* a_headPart, TESNPC* a_npc)
		{
			using func_t = decltype(&BSFaceGenManager::PrepareHeadPartForShaders);
			REL::Relocation<func_t> func{ RELOCATION_ID(26259, 26838) };
			return func(this, a_node, a_headPart, a_npc);
		}

		// members
		std::uint32_t     numActorsToMorph;  // 04
		bool              emotions;          // 08
		std::uint8_t      pad09[7];          // 09
		std::uint64_t     unk10;             // 10
		BSFaceGenModelMap modelMap;          // 18
		std::uint8_t      isReset;           // 58
		std::uint8_t      pad59[3];          // 59
		std::uint32_t     unk5C;             // 5C
		std::uint8_t      unk60;             // 60
		std::uint8_t      pad61[7];          // 61
	};
	static_assert(sizeof(BSFaceGenManager) == 0x68);
};


===============================================
File: include/RE/B/BSFaceGenModel.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSFaceGenMorphData;
	class BSFaceGenNiNode;
	class BSTriShape;

	class BSFaceGenModelMeshData
	{
	public:
		// members
		std::uint32_t                 unk00;      // 00
		std::uint32_t                 pad04;      // 04
		NiPointer<BSFaceGenNiNode>    faceNode;   // 08
		NiPointer<BSTriShape>         faceShape;  // 10
		void*                         triData;    // 18
		NiPointer<BSFaceGenMorphData> morphData;  // 20
	};
	static_assert(sizeof(BSFaceGenModelMeshData) == 0x28);

	class BSFaceGenModel : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFaceGenModel;
		inline static constexpr auto VTABLE = VTABLE_BSFaceGenModel;

		~BSFaceGenModel() override;  // 00

		// members
		BSTSmartPointer<BSFaceGenModelMeshData> modelMeshData;  // 10
		std::uint32_t                           unk18;          // 18
		std::uint32_t                           pad1C;          // 1C
	};
	static_assert(sizeof(BSFaceGenModel) == 0x20);
}


===============================================
File: include/RE/B/BSFaceGenModelExtraData.h
===============================================
#pragma once

#include "RE/B/BSFaceGenManager.h"
#include "RE/B/BSFixedString.h"

namespace RE
{
	class BSFaceGenModelExtraData : public NiExtraData
	{
	public:
		BSFaceGenModel* m_model;   // 18
		BSFixedString   bones[8];  // 20
	};
	static_assert(sizeof(BSFaceGenModelExtraData) == 0x60);
}


===============================================
File: include/RE/B/BSFaceGenNiNode.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiNode.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSFaceGenAnimationData;
	class NiNode;

	class BSFaceGenNiNode : public NiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFaceGenNiNode;
		inline static auto           Ni_RTTI = NiRTTI_BSFaceGenNiNode;

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                  \
	NiMatrix3                         baseRotation;  /* 00 */ \
	std::uint32_t                     pad14C;        /* 24 */ \
	NiPointer<BSFaceGenAnimationData> animationData; /* 28 */ \
	float                             lastTime;      /* 30 */ \
	ActorHandle                       unk15C;        /* 34 */ \
	std::uint16_t                     flags;         /* 38 */ \
	std::uint16_t                     pad162;        /* 3A */ \
	std::uint32_t                     pad164;        /* 3C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x40);

		~BSFaceGenNiNode() override;  // 00

		// override (NiNode)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
#ifndef SKYRIM_CROSS_VR
		// The following are virtual functions past the point where VR compatibility breaks.
		void UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;  // 2C
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void FixSkinInstances(NiNode* a_skeleton, bool a_arg2);  // 3E

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSFaceGenNiNode) == 0x168);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSFaceGenNiNode) == 0x190);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSFadeNode.h
===============================================
#pragma once

#include "RE/N/NiNode.h"

namespace RE
{
	class BSLeafAnimNode;
	class BSTreeNode;

	class BSFadeNode : public NiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFadeNode;
		inline static auto           Ni_RTTI = NiRTTI_BSFadeNode;

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT            \
	float         unk128;      /* 00 */ \
	float         unk12C;      /* 04 */ \
	float         currentFade; /* 08 */ \
	std::uint32_t unk134;      /* 0C */ \
	std::uint32_t unk138;      /* 10 */ \
	std::uint32_t unk13C;      /* 14 */ \
	float         unk140;      /* 18 */ \
	std::uint32_t unk144;      /* 1C */ \
	std::uint32_t unk148;      /* 20 */ \
	float         unk14C;      /* 24 */ \
	std::uint16_t unk150;      /* 28 */ \
	std::uint8_t  unk152;      /* 2A */ \
	std::uint8_t  unk153;      /* 2B */ \
	std::uint8_t  unk154;      /* 2C */ \
	std::uint8_t  unk155;      /* 2D */ \
	std::uint16_t unk156;      /* 2E */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x30);

		~BSFadeNode() override;  // 00

		// override (NiNode)
		const NiRTTI* GetRTTI() const override;                           // 02
		BSFadeNode*   AsFadeNode() override;                              // 05 - { return this; }
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
#ifndef SKYRIM_CROSS_VR
		// The following are virtual functions past the point where VR compatibility breaks.
		void UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;  // 2D
		void OnVisible(NiCullingProcess& a_process) override;                                  // 34
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL BSTreeNode* AsTreeNode();          // 3E - { return 0; }
		SKYRIM_REL_VR_VIRTUAL BSLeafAnimNode* AsLeafAnimNode();  // 3F - { return 0; }

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSFadeNode) == 0x158);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSFadeNode) == 0x180);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSFile.h
===============================================
#pragma once

#include "RE/N/NiFile.h"

namespace RE
{
	class BSFile : public NiFile
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFile;

		~BSFile() override;  // 00

		// override (NiFile)
		void          seek(std::int32_t a_numBytes) override;                     // 02
		void          set_endian_swap(bool a_doSwap) override;                    // 05
		void          seek(std::int32_t a_offset, std::int32_t a_from) override;  // 06
		std::uint32_t size() const override;                                      // 07

		// add
		virtual void Unk_08(void);  // 08
		virtual void Unk_09(void);  // 09
		virtual void Unk_0A(void);  // 0A
		virtual void Unk_0B(void);  // 0B
		virtual void Unk_0C(void);  // 0C
		virtual void Unk_0D(void);  // 0D
		virtual void Unk_0E(void);  // 0E
		virtual void Unk_0F(void);  // 0F
		virtual void Unk_10(void);  // 10
		virtual void Unk_11(void);  // 11
		virtual void Unk_12(void);  // 12

		// members
		bool          useAuxBuffer;        // 048
		std::uint8_t  pad049;              // 049
		std::uint16_t pad04A;              // 04A
		std::uint32_t pad04C;              // 04C
		char*         auxBuffer;           // 050
		std::int32_t  auxTrueFilePos;      // 058
		std::uint32_t auxBufferMinIndex;   // 05C
		std::uint32_t auxBufferMaxIndex;   // 060
		char          fileName[MAX_PATH];  // 064
		std::uint32_t result;              // 168
		std::uint32_t ioSize;              // 16C
		std::uint32_t trueFilePos;         // 170
		std::uint32_t fileSize;            // 174
		bool          virtualAlloc;        // 178
		std::uint8_t  unk179;              // 179
		std::uint16_t unk17A;              // 17A
	};
	static_assert(sizeof(BSFile) == 0x180);
}


===============================================
File: include/RE/B/BSFixedString.h
===============================================
#pragma once

#include "RE/B/BSStringPool.h"
#include "RE/C/CRC.h"

namespace RE
{
	namespace detail
	{
		template <class CharT>
		class BSFixedString
		{
		public:
			using size_type = std::uint32_t;
			using value_type = CharT;
			using pointer = value_type*;
			using const_pointer = const value_type*;
			using reference = value_type&;
			using const_reference = const value_type&;

			constexpr BSFixedString() noexcept = default;

			inline BSFixedString(const BSFixedString& a_rhs) :
				_data(a_rhs._data)
			{
				try_acquire();
			}

			inline BSFixedString(BSFixedString&& a_rhs) :
				_data(a_rhs._data)
			{
				a_rhs._data = nullptr;
			}

			inline BSFixedString(const_pointer a_string)
			{
				if (a_string) {
					ctor(a_string);
				}
			}

			template <
				class T,
				std::enable_if_t<
					std::conjunction_v<
						std::is_convertible<const T&, std::basic_string_view<value_type>>,
						std::negation<
							std::is_convertible<const T&, const_pointer>>>,
					int> = 0>
			inline BSFixedString(const T& a_string)
			{
				const auto view = static_cast<std::basic_string_view<value_type>>(a_string);
				if (!view.empty()) {
					ctor(view.data());
				}
			}

			inline ~BSFixedString() { try_release(); }

			inline BSFixedString& operator=(const BSFixedString& a_rhs)
			{
				if (this != std::addressof(a_rhs)) {
					try_release();
					_data = a_rhs._data;
					try_acquire();
				}
				return *this;
			}

			inline BSFixedString& operator=(BSFixedString&& a_rhs)
			{
				if (this != std::addressof(a_rhs)) {
					try_release();
					_data = a_rhs._data;
					a_rhs._data = nullptr;
				}
				return *this;
			}

			inline BSFixedString& operator=(const_pointer a_string)
			{
				try_release();
				if (a_string) {
					ctor(a_string);
				}
				return *this;
			}

			template <
				class T,
				std::enable_if_t<
					std::conjunction_v<
						std::is_convertible<const T&, std::basic_string_view<value_type>>,
						std::negation<
							std::is_convertible<const T&, const_pointer>>>,
					int> = 0>
			inline BSFixedString& operator=(const T& a_string)
			{
				const auto view = static_cast<std::basic_string_view<value_type>>(a_string);
				try_release();
				if (!view.empty()) {
					ctor(view.data());
				}
				return *this;
			}

			[[nodiscard]] inline const_reference operator[](size_type a_pos) const noexcept
			{
				assert(a_pos < size());
				return _data[a_pos];
			}

			[[nodiscard]] inline const_reference front() const noexcept { return _data[0]; }
			[[nodiscard]] inline const_reference back() const noexcept { return _data[size() - 1]; }

			[[nodiscard]] inline const_pointer data() const noexcept
			{
				const auto proxy = get_proxy();
				const auto cstr = proxy ? proxy->template data<value_type>() : nullptr;
				return cstr ? cstr : EMPTY;
			}

			[[nodiscard]] inline const_pointer c_str() const noexcept { return data(); }

			[[nodiscard]] constexpr operator std::basic_string_view<value_type>() const { return { c_str(), length() }; }

			[[nodiscard]] constexpr bool empty() const noexcept { return size() == 0; }

			[[nodiscard]] constexpr size_type size() const noexcept
			{
				const auto proxy = get_proxy();
				return proxy ? proxy->size() : 0;
			}

			[[nodiscard]] constexpr size_type length() const noexcept { return size(); }

			[[nodiscard]] inline friend bool operator==(const BSFixedString& a_lhs, const BSFixedString& a_rhs) noexcept
			{
				return a_lhs._data == a_rhs._data || (a_lhs.empty() && a_rhs.empty());
			}

			[[nodiscard]] inline friend bool operator!=(const BSFixedString& a_lhs, const BSFixedString& a_rhs) noexcept { return !(a_lhs == a_rhs); }

			[[nodiscard]] inline friend bool operator==(const BSFixedString& a_lhs, std::basic_string_view<value_type> a_rhs)
			{
				if (a_lhs.empty() && a_rhs.empty()) {
					return true;
				} else if (const auto length = a_lhs.length(); length != a_rhs.length()) {
					return false;
				} else {
					return strncmp(a_lhs.c_str(), a_rhs.data(), length) == 0;
				}
			}

			[[nodiscard]] inline friend bool operator!=(const BSFixedString& a_lhs, std::basic_string_view<value_type> a_rhs) { return !(a_lhs == a_rhs); }
			[[nodiscard]] inline friend bool operator==(std::basic_string_view<value_type> a_lhs, const BSFixedString& a_rhs) { return a_rhs == a_lhs; }
			[[nodiscard]] inline friend bool operator!=(std::basic_string_view<value_type> a_lhs, const BSFixedString& a_rhs) { return !(a_lhs == a_rhs); }

			[[nodiscard]] inline friend bool operator==(const BSFixedString& a_lhs, const_pointer a_rhs) { return a_lhs == std::basic_string_view<value_type>(a_rhs ? a_rhs : EMPTY); }
			[[nodiscard]] inline friend bool operator!=(const BSFixedString& a_lhs, const_pointer a_rhs) { return !(a_lhs == a_rhs); }
			[[nodiscard]] inline friend bool operator==(const_pointer a_lhs, const BSFixedString& a_rhs) { return a_rhs == a_lhs; }
			[[nodiscard]] inline friend bool operator!=(const_pointer a_lhs, const BSFixedString& a_rhs) { return !(a_lhs == a_rhs); }

			[[nodiscard]] inline bool contains(std::basic_string_view<value_type> a_rhs) const
			{
				if (a_rhs.length() > length()) {
					return false;
				}
				for (size_type i = 0; i < length(); ++i) {
					if (strncmp(&c_str()[i], a_rhs.data(), a_rhs.length()) == 0) {
						return true;
					}
				}
				return false;
			}

		private:
			[[nodiscard]] static inline int strncmp(const char* a_lhs, const char* a_rhs, std::size_t a_length)
			{
				return _strnicmp(a_lhs, a_rhs, a_length);
			}

			[[nodiscard]] static inline int strncmp(const wchar_t* a_lhs, const wchar_t* a_rhs, std::size_t a_length)
			{
				return _wcsnicmp(a_lhs, a_rhs, a_length);
			}

			inline BSFixedString* ctor(const char* a_data) { return ctor8(a_data); }
			inline BSFixedString* ctor(const wchar_t* a_data) { return ctor16(a_data); }

			inline BSFixedString* ctor8(const char* a_data)
			{
				using func_t = decltype(&BSFixedString::ctor8);
				REL::Relocation<func_t> func{ RELOCATION_ID(67819, 69161) };
				return func(this, a_data);
			}

			inline BSFixedString* ctor16(const wchar_t* a_data)
			{
				using func_t = decltype(&BSFixedString::ctor16);
				REL::Relocation<func_t> func{ RELOCATION_ID(67834, 69176) };
				return func(this, a_data);
			}

			[[nodiscard]] inline BSStringPool::Entry* get_proxy() noexcept
			{
				return _data ?
                           reinterpret_cast<BSStringPool::Entry*>(const_cast<pointer>(_data)) - 1 :
                           nullptr;
			}

			[[nodiscard]] inline const BSStringPool::Entry* get_proxy() const noexcept
			{
				return _data ?
                           reinterpret_cast<const BSStringPool::Entry*>(_data) - 1 :
                           nullptr;
			}

			inline void try_acquire()
			{
				const auto proxy = get_proxy();
				if (proxy) {
					proxy->acquire();
				}
			}

			inline void try_release() { BSStringPool::Entry::release(_data); }

			static constexpr const value_type EMPTY[]{ 0 };

			// members
			const_pointer _data{ nullptr };  // 0
		};

		extern template class BSFixedString<char>;
		extern template class BSFixedString<wchar_t>;
	}

	using BSFixedString = detail::BSFixedString<char>;
	using BSFixedStringCI = BSFixedString;
	using BSFixedStringW = detail::BSFixedString<wchar_t>;

	template <class CharT>
	struct BSCRC32_<detail::BSFixedString<CharT>>
	{
	public:
		[[nodiscard]] inline std::uint32_t operator()(const detail::BSFixedString<CharT>& a_key) const noexcept
		{
			return BSCRC32_<const void*>()(a_key.data());
		}
	};
}


===============================================
File: include/RE/B/BSFurnitureMarkerNode.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiExtraData.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class BSFurnitureMarker
	{
	public:
		enum class AnimationType
		{
			kSit = 1 << 0,
			kSleep = 1 << 1,
			kLean = 1 << 2
		};

		enum class EntryProperties
		{
			kFront = 1 << 0,
			kBehind = 1 << 1,
			kRight = 1 << 2,
			kLeft = 1 << 3,
			kUp = 1 << 4
		};

		NiPoint3                                         offset;           // 00
		float                                            heading;          // 0C
		stl::enumeration<AnimationType, std::uint16_t>   animationType;    // 10
		stl::enumeration<EntryProperties, std::uint16_t> entryProperties;  // 12
	};

	class BSFurnitureMarkerNode : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSFurnitureMarkerNode;
		inline static auto           NiRTTI = NiRTTI_BSFurnitureMarkerNode;

		BSTArray<BSFurnitureMarker> markers;  // 18
	};
}


===============================================
File: include/RE/B/BSGameSound.h
===============================================
#pragma once

namespace RE
{
	class BSGameSound
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSGameSound;

		// add
		virtual void Unk_00(void);  // 00 - { return; }

		virtual ~BSGameSound();  // 01

		virtual void Unk_02(void);      // 02 - { return (unk5C >> 4) & 1; }
		virtual void Unk_03(void);      // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void);      // 05
		virtual void Unk_06(void) = 0;  // 06
		virtual void Unk_07(void) = 0;  // 07
		virtual void Unk_08(void) = 0;  // 08
		virtual void Unk_09(void) = 0;  // 09
		virtual void Unk_0A(void) = 0;  // 0A
		virtual void Unk_0B(void);      // 0B - { unk5C |= 0x800; }
		virtual void Unk_0C(void);      // 0C
		virtual void Unk_0D(void) = 0;  // 0D
		virtual void Unk_0E(void);      // 0E
		virtual void Unk_0F(void) = 0;  // 0F
		virtual void Unk_10(void) = 0;  // 10
		virtual void Unk_11(void) = 0;  // 11
		virtual void Unk_12(void) = 0;  // 12
		virtual void Unk_13(void);      // 13 - { return; }
		virtual void Unk_14(void) = 0;  // 14
		virtual void Unk_15(void) = 0;  // 15
		virtual void Unk_16(void) = 0;  // 16
		virtual void Unk_17(void) = 0;  // 17
		virtual void Unk_18(void) = 0;  // 18

		// members
		std::uint64_t unk08;  // 08
		std::uint64_t unk10;  // 10
		std::uint64_t unk18;  // 18
		std::uint64_t unk20;  // 20
		std::uint64_t unk28;  // 28
		std::uint64_t unk30;  // 30
		std::uint64_t unk38;  // 38
		std::uint64_t unk40;  // 40
		std::uint64_t unk48;  // 48
		std::uint64_t unk50;  // 50
		std::uint64_t unk58;  // 58
		std::uint64_t unk60;  // 60
		std::uint64_t unk68;  // 68
		std::uint64_t unk70;  // 70
		std::uint64_t unk78;  // 78
		std::uint64_t unk80;  // 80
		std::uint64_t unk88;  // 88
		std::uint64_t unk90;  // 90
		std::uint64_t unk98;  // 98
		std::uint64_t unkA0;  // A0
		std::uint64_t unkA8;  // A8
		std::uint64_t unkB0;  // B0
		std::uint64_t unkB8;  // B8
		std::uint64_t unkC0;  // C0
	};
	static_assert(sizeof(BSGameSound) == 0xC8);
}


===============================================
File: include/RE/B/BSGamepadDevice.h
===============================================
#pragma once

#include "RE/B/BSInputDevice.h"
#include "RE/B/BSTEvent.h"

namespace RE
{
	struct BSGamepadEvent;

	class BSGamepadDevice :
		public BSInputDevice,                  // 00
		public BSTEventSource<BSGamepadEvent>  // 70
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSGamepadDevice;
		inline static constexpr auto VTABLE = VTABLE_BSGamepadDevice;

		struct ColorParam
		{
			std::uint32_t r;
			std::uint32_t g;
			std::uint32_t b;
		};

		~BSGamepadDevice() override;  // 00

		// override (BSInputDevice)
		bool IsEnabled() const override;  // 07 - { return connected && userIndex != -1; }

		// add
		virtual void SetRumble(float a_lValue, float a_rValue) = 0;                                  // 09
		virtual void SetLEDColor(ColorParam* a_colorParam);                                          // 0A - { return; }
		virtual void ResetLEDColor();                                                                // 0B - { return; }
		virtual void Unk_0C(void);                                                                   // 0C - { return 0; }
		virtual void ProcessRawInput(int32_t a_rawX, int32_t a_rawY, float& a_outX, float& a_outY);  // 0D
		virtual void Unk_0E(void);                                                                   // 0E - { return; }

		// members
		std::int32_t  userIndex;          // C8
		bool          connected;          // CC
		bool          listeningForInput;  // CD
		std::uint16_t padCE;              // CE

	protected:
		BSGamepadDevice();
	};
	static_assert(sizeof(BSGamepadDevice) == 0xD0);
}


===============================================
File: include/RE/B/BSGeometry.h
===============================================
#pragma once

#include "RE/N/NiAVObject.h"
#include "RE/N/NiSkinPartition.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSMultiIndexTriShape;
	class BSSkinnedDecalTriShape;
	class NiProperty;
	class NiSkinInstance;

	class BSGeometry : public NiAVObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSGeometry;
		inline static auto           Ni_RTTI = NiRTTI_BSGeometry;

		enum class Type
		{
			kGeometry = 0,
			kParticles = 1,
			kStripParticles = 2,
			kTriShape = 3,
			kDynamicTriShape = 4,
			kMeshLODTriShape = 5,
			kLODMultiIndexTriShape = 6,
			kMultiIndexTriShape = 7,
			kSubIndexTriShape = 8,
			kSubIndexLandTriShape = 9,
			kMultiStreamInstanceTriShape = 10,
			kParticleShaderDynamicTriShape = 11,
			kLines = 12,
			kDynamicLines = 13,
			kInstanceGroup = 14
		};

		struct States
		{
			enum State
			{
				kProperty,
				kEffect,
				kTotal
			};
		};

		struct MODEL_DATA
		{
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
#	define MODEL_DATA_CONTENT        \
		NiBound  modelBound; /* 0 */  \
		NiPoint3 unk148;     /* 10 */ \
		NiPoint3 unk154;     /* 2C */
#else
#	define MODEL_DATA_CONTENT NiBound modelBound; /* 0 */
#endif
			MODEL_DATA_CONTENT
		};
#ifndef ENABLE_SKYRIM_VR
		static_assert(sizeof(MODEL_DATA) == 0x10);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		static_assert(sizeof(MODEL_DATA) == 0x28);
#endif

		struct GEOMETRY_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                   \
	NiPointer<NiProperty>     properties[States::kTotal]; /* 00 */             \
	NiPointer<NiSkinInstance> skinInstance;               /* 10 */             \
	BSGraphics::TriShape*     rendererData;               /* 18 */             \
	void*                     unk20;                      /* 20 - smart ptr */ \
	BSGraphics::VertexDesc    vertexDesc;                 /* 28 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(GEOMETRY_RUNTIME_DATA) == 0x30);

		~BSGeometry() override;  // 00

		// override (NiAVObject)
		const NiRTTI* GetRTTI() const override;                            // 02
		BSGeometry*   AsGeometry() override;                               // 07 - { return this; }
		void          LoadBinary(NiStream& a_stream) override;             // 18
		void          LinkObject(NiStream& a_stream) override;             // 19
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A
		void          SaveBinary(NiStream& a_stream) override;             // 1B
		bool          IsEqual(NiObject* a_object) override;                // 1C - { return false; }
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D
		void          PostLinkObject(NiStream& a_stream) override;         // 1E
#ifndef SKYRIM_CROSS_VR
		// The following are virtual functions past the point where VR compatibility breaks.
		void AttachProperty(NiAlphaProperty* a_property) override;                                                        // 27
		void SetSelectiveUpdateFlags(bool& a_selectiveUpdate, bool a_selectiveUpdateTransforms, bool& a_rigid) override;  // 2B
		void UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                                     // 2C
		void UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                             // 2D
		void UpdateRigidDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                                // 2E
		void UpdateWorldBound() override;                                                                                 // 2F
		void OnVisible(NiCullingProcess& a_process) override;                                                             // 34
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL BSMultiIndexTriShape* AsMultiIndexTriShape();      // 35 - { return 0; }
		SKYRIM_REL_VR_VIRTUAL BSSkinnedDecalTriShape* AsSkinnedDecalTriShape();  // 36 - { return 0; }
		SKYRIM_REL_VR_VIRTUAL void                    Unk_37(void);              // 37 - { return 0; }

		[[nodiscard]] inline MODEL_DATA& GetModelData() noexcept
		{
			return REL::RelocateMember<MODEL_DATA>(this, 0x110, 0x138);
		}

		[[nodiscard]] inline const MODEL_DATA& GetModelData() const noexcept
		{
			return REL::RelocateMember<MODEL_DATA>(this, 0x110, 0x138);
		}

		[[nodiscard]] inline GEOMETRY_RUNTIME_DATA& GetGeometryRuntimeData() noexcept
		{
			return REL::RelocateMember<GEOMETRY_RUNTIME_DATA>(this, 0x120, 0x160);
		}

		[[nodiscard]] inline const GEOMETRY_RUNTIME_DATA& GetGeometryRuntimeData() const noexcept
		{
			return REL::RelocateMember<GEOMETRY_RUNTIME_DATA>(this, 0x120, 0x160);
		}

		[[nodiscard]] inline stl::enumeration<Type, std::uint8_t>& GetType() noexcept
		{
			return REL::RelocateMember<stl::enumeration<Type, std::uint8_t>>(this, 0x150, 0x190);
		}

		[[nodiscard]] inline const stl::enumeration<Type, std::uint8_t>& GetType() const noexcept
		{
			return REL::RelocateMember<stl::enumeration<Type, std::uint8_t>>(this, 0x150, 0x190);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		MODEL_DATA_CONTENT;    // 110, 138
		RUNTIME_DATA_CONTENT;  // 120, 160
#	ifndef ENABLE_SKYRIM_VR
		stl::enumeration<Type, std::uint8_t> type;   // 150
		std::uint8_t                         pad31;  // 151
		std::uint16_t                        pad32;  // 152
		std::uint32_t                        pad34;  // 154
#	elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		stl::enumeration<Type, std::uint32_t> type;   // 190
		std::uint8_t                          pad31;  // 194
		std::uint16_t                         pad32;  // 195
		std::uint32_t                         pad34;  // 197
#	endif
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSGeometry) == 0x158);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSGeometry) == 0x1A0);
#endif
}
#undef MODEL_DATA_CONTENT
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSHandleRefObject.h
===============================================
#pragma once

#include "RE/N/NiRefObject.h"

namespace RE
{
	class BSHandleRefObject : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSHandleRefObject;

		enum
		{
			kRefCountMask = 0x3FF,
			kHandleValid = 1 << 10
		};

		~BSHandleRefObject() override;  // 00

		void                        DecRefCount();
		void                        IncRefCount();
		[[nodiscard]] bool          IsHandleValid() const;
		[[nodiscard]] std::uint32_t QRefCount() const;
	};
	static_assert(sizeof(BSHandleRefObject) == 0x10);
}


===============================================
File: include/RE/B/BSIInputDevice.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class BSIInputDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSIInputDevice;
		inline static constexpr auto VTABLE = VTABLE_BSIInputDevice;

		virtual ~BSIInputDevice() = default;  // 00

		// add
		virtual void               Initialize() = 0;                                                      // 01
		virtual void               Process(float a_arg1) = 0;                                             // 02
		virtual void               Release() = 0;                                                         // 03
		virtual bool               GetKeyMapping(std::uint32_t a_key, BSFixedString& a_mapping) = 0;      // 04
		virtual std::uint32_t      GetMappingKey(BSFixedString a_mapping) = 0;                            // 05
		virtual bool               GetMappedKeycode(std::uint32_t a_key, std::uint32_t& outKeyCode) = 0;  // 06
		[[nodiscard]] virtual bool IsEnabled() const = 0;                                                 // 07
		virtual void               Reset() = 0;                                                           // 08

	protected:
		friend class BSInputDeviceFactory;
		TES_HEAP_REDEFINE_NEW();
		BSIInputDevice() = default;
	};
	static_assert(sizeof(BSIInputDevice) == 0x8);
}


===============================================
File: include/RE/B/BSIMusicTrack.h
===============================================
#pragma once

namespace RE
{
	class BSIMusicTrack
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSIMusicTrack;

		enum class TrackType : std::uint32_t
		{
			kSilentTrack = 0xA1A9C4D5,
			kSingleTrack = 0x6ED7E048,
			kPalette = 0x23F678C3
		};

		enum class MUSIC_STATUS
		{
			kInactive = 0,
			kPlaying = 1,
			kPaused = 2,
			kFinishing = 3,
			kFinished = 4
		};

		virtual ~BSIMusicTrack();  // 00

		// add
		virtual void                       DoUpdate() = 0;                                    // 01
		virtual void                       DoPlay() = 0;                                      // 02
		virtual void                       DoPause() = 0;                                     // 03
		virtual void                       DoFinish(bool a_immediate, float a_fadeTime) = 0;  // 04
		[[nodiscard]] virtual float        GetDurationImpl() const = 0;                       // 05
		[[nodiscard]] virtual TrackType    GetType() const = 0;                               // 06 - CRC32 hash of class name
		[[nodiscard]] virtual bool         TestCanPlay() const;                               // 07 - { return true; }
		[[nodiscard]] virtual MUSIC_STATUS GetMusicStatus() const;                            // 08 - { return trackStatus; }
		virtual void                       DoSetDuckingAttenuation(std::uint16_t a_ducking);  // 09 - { return; }
		virtual void                       DoClearDucking();                                  // 0A - { return; }

		// members
		stl::enumeration<MUSIC_STATUS, std::uint32_t> trackStatus;  // 08
		std::uint32_t                                 pad0C;        // 0C
	};
	static_assert(sizeof(BSIMusicTrack) == 0x10);
}


===============================================
File: include/RE/B/BSIMusicType.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	class BSIMusicTrack;

	class BSIMusicType
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSIMusicType;

		enum class MST  // FNAM
		{
			kNone = 0,
			kPlaysOnce = 1 << 0,
			kAbruptTransition = 1 << 1,
			kCycleTracks = 1 << 2,
			kUseTrackOrder = 1 << 3,
			kRemovalQueued = 1 << 4,
			kPlaysOver = 1 << 5,
			kDoesntQueue = 1 << 6
		};

		enum class MUSIC_STATUS
		{
			kInactive = 0,
			kPlaying = 1,
			kPaused = 2,
			kFinishing = 3,
			kFinished = 4
		};

		// add
		virtual void DoUpdate() = 0;                                      // 00
		virtual void DoPlay() = 0;                                        // 01
		virtual void DoPause() = 0;                                       // 02
		virtual void DoFinish(bool a_arg1) = 0;                           // 03
		virtual void DoApplyDuckingAttenuation(std::uint16_t a_ducking);  // 04 - { return; }
		virtual void DoClearDucking();                                    // 05 - { return; }
		virtual void DoPrepare();                                         // 06 - { return; }

		virtual ~BSIMusicType();  // 07

		// members
		stl::enumeration<MST, std::uint32_t>          flags;              // 08 - FNAM
		std::uint8_t                                  priority;           // 0C
		std::uint8_t                                  padding;            // 0D
		std::uint16_t                                 ducksOtherMusicBy;  // 0E - ck value * 100 as a std::uint16_t
		float                                         fadeTime;           // 10 - WNAM
		std::uint32_t                                 currentTrackIndex;  // 14
		BSTArray<std::uint32_t>                       trackHistory;       // 18
		BSTArray<BSIMusicTrack*>                      tracks;             // 30 - TNAM
		stl::enumeration<MUSIC_STATUS, std::uint32_t> typeStatus;         // 48
		std::uint32_t                                 pad4C;              // 4C
	};
	static_assert(sizeof(BSIMusicType) == 0x50);
}


===============================================
File: include/RE/B/BSIRagdollDriver.h
===============================================
#pragma once

#include "RE/H/hkpMotion.h"

namespace RE
{
	class bhkWorld;

	class BSIRagdollDriver
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSIRagdollDriver;

		virtual ~BSIRagdollDriver();  // 00

		virtual bool HasRagdoll() = 0;                                       // 01
		virtual bool AddRagdollToWorld() = 0;                                // 02
		virtual bool RemoveRagdollFromWorld() = 0;                           // 03
		virtual void SetWorld(bhkWorld* a_world) = 0;                        // 04 - { world = a_world; }
		virtual void ResetRagdoll(void) = 0;                                 // 05
		virtual void Unk_06(void) = 0;                                       // 06
		virtual void SetRagdollConstraintsFromBhkConstraints() = 0;          // 07
		virtual void SetMotionType(hkpMotion::MotionType a_motionType) = 0;  // 08
		virtual void Unk_09(void) = 0;                                       // 09
		virtual void ToggleSyncOnUpdate(bool a_disable) = 0;                 // 0A
		virtual void Unk_0B(void) = 0;                                       // 0B
		virtual void ToggleConstraints(bool a_disable) = 0;                  // 0C
		virtual void Unk_0D(void) = 0;                                       // 0D
	};
	static_assert(sizeof(BSIRagdollDriver) == 0x8);
}


===============================================
File: include/RE/B/BSIReverbType.h
===============================================
#pragma once

namespace RE
{
	class BSIReverbType
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSIReverbType;

		// add
		[[nodiscard]] virtual std::int32_t DoGetRoomLevel() const = 0;        // 00
		[[nodiscard]] virtual std::int32_t DoGetRoomHFLevel() const = 0;      // 01
		[[nodiscard]] virtual float        DoGetDecayTime() const = 0;        // 02 - in seconds
		[[nodiscard]] virtual float        DoGetDecayHFRatio() const = 0;     // 03
		[[nodiscard]] virtual std::int32_t DoGetReflectionLevel() const = 0;  // 04
		[[nodiscard]] virtual float        DoGetReflectionDelay() const = 0;  // 05 - in seconds
		[[nodiscard]] virtual std::int32_t DoGetReverbLevel() const = 0;      // 06
		[[nodiscard]] virtual float        DoGetReverbDelay() const = 0;      // 07 - in seconds
		[[nodiscard]] virtual float        DoGetDiffusion() const = 0;        // 08
		[[nodiscard]] virtual float        DoGetDensity() const = 0;          // 09
		[[nodiscard]] virtual float        DoGetHFReference() const = 0;      // 0A
	};
	static_assert(sizeof(BSIReverbType) == 0x8);
}


===============================================
File: include/RE/B/BSISoundCategory.h
===============================================
#pragma once

namespace RE
{
	class BSISoundCategory
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSISoundCategory;

		virtual ~BSISoundCategory();  // 00

		// add
		virtual bool                        Matches(const BSISoundCategory* a_category) const = 0;  // 01
		[[nodiscard]] virtual float         GetCategoryVolume() const = 0;                          // 02
		virtual void                        SetCategoryVolume(float a_value) = 0;                   // 03
		[[nodiscard]] virtual float         GetCategoryFrequency() const = 0;                       // 04
		virtual void                        SetCategoryFrequency(float a_value) = 0;                // 05
		[[nodiscard]] virtual std::uint16_t GetCategoryAttenuation() const = 0;                     // 06
		virtual void                        SetCategoryAttenuation(std::uint16_t a_value) = 0;      // 07
		virtual void                        Unk_08(void) = 0;                                       // 08
		virtual void                        Unk_09(void) = 0;                                       // 09
		virtual void                        Unk_0A(void) = 0;                                       // 0A
		virtual void                        Unk_0B(void) = 0;                                       // 0B
	};
	static_assert(sizeof(BSISoundCategory) == 0x8);
}


===============================================
File: include/RE/B/BSISoundDescriptor.h
===============================================
#pragma once

namespace RE
{
	class BSISoundDescriptor
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSISoundDescriptor;

		class BSIPlaybackCharacteristics
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSISoundDescriptor__BSIPlaybackCharacteristics;

			virtual ~BSIPlaybackCharacteristics();  // 00

			// add
			virtual std::uint8_t  GetFrequencyShift() = 0;     // 01
			virtual std::uint8_t  GetFrequencyVariance() = 0;  // 02
			virtual std::uint8_t  GetPriority() = 0;           // 03
			virtual std::uint16_t GetStaticAttenuation() = 0;  // 04
			virtual std::uint8_t  GetDBVariance() = 0;         // 05
		};
		static_assert(sizeof(BSIPlaybackCharacteristics) == 0x8);

		virtual ~BSISoundDescriptor();  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
	};
	static_assert(sizeof(BSISoundDescriptor) == 0x8);
}


===============================================
File: include/RE/B/BSISoundOutputModel.h
===============================================
#pragma once

namespace RE
{
	class BSISoundOutputModel
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSISoundOutputModel;

		struct BSIAttenuationCharacteristics
		{
			inline static constexpr auto RTTI = RTTI_BSISoundOutputModel__BSIAttenuationCharacteristics;

			virtual ~BSIAttenuationCharacteristics();  // 00

			// add
			[[nodiscard]] virtual float        GetMaxDistance() const = 0;                    // 01
			[[nodiscard]] virtual float        GetMinDistance() const = 0;                    // 02
			[[nodiscard]] virtual std::uint8_t GetCurveValue(std::uint32_t a_idx) const = 0;  // 03
		};
		static_assert(sizeof(BSIAttenuationCharacteristics) == 0x8);

		virtual ~BSISoundOutputModel();  // 00

		// add
		[[nodiscard]] virtual bool                                 DoGetUsesHRTF() const = 0;                                                                   // 01
		[[nodiscard]] virtual bool                                 DoGetHasSpeakerBias() const = 0;                                                             // 02
		virtual bool                                               DoGetSpeakerBias(std::uint32_t a_arg1, std::uint32_t a_arg2, float (&a_arg3)[8]) const = 0;  // 03
		[[nodiscard]] virtual bool                                 DoGetAttenuatesWithDistance() const = 0;                                                     // 04
		[[nodiscard]] virtual bool                                 DoGetAudibility(float a_distance) const = 0;                                                 // 05
		[[nodiscard]] virtual std::uint32_t                        DoGetSupportedInputChannels() const = 0;                                                     // 06
		[[nodiscard]] virtual const BSIAttenuationCharacteristics* DoGetAttenuation() const = 0;                                                                // 07
		[[nodiscard]] virtual float                                DoGetReverbSendLevel() const = 0;                                                            // 08
		[[nodiscard]] virtual bool                                 DoGetSupportsMonitor(std::uint32_t a_arg1) const = 0;                                        // 09
	};
	static_assert(sizeof(BSISoundOutputModel) == 0x8);
}


===============================================
File: include/RE/B/BSImagespaceShader.h
===============================================
#pragma once

#include "RE/B/BSShader.h"
#include "RE/I/ImageSpaceEffect.h"

namespace RE
{
	class BSImagespaceShader :
		public BSShader,         // 000
		public ImageSpaceEffect  // 090
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSImagespaceShader;

		~BSImagespaceShader() override;  // 00

		// override (BSShader)
		void Setup(ImageSpaceManager* a_manager, ImageSpaceEffectParam* a_param) override;  // 02
		void ShutDown() override;                                                           // 03
		bool IsActive() override;                                                           // 06
		bool UpdateParams(ImageSpaceEffectParam* a_param) override;                         // 07
		bool RestoreRenderStates(ImageSpaceEffectParam* a_param) override;                  // 09

		// add
		virtual void Unk_0A(void);  // 0A - { return; }
		virtual void Unk_0B(void);  // 0B - { return; }
		virtual void Unk_0C(void);  // 0C
		virtual void Unk_0D(void);  // 0D
		virtual void Unk_0E(void);  // 0E

		// members
		std::uint64_t unk120;  // 120
		std::uint64_t unk128;  // 128
		std::uint64_t unk130;  // 130
		std::uint64_t unk138;  // 138
		std::uint64_t unk140;  // 140
		std::uint64_t unk148;  // 148
		std::uint64_t unk150;  // 150
		std::uint64_t unk158;  // 158
		std::uint64_t unk160;  // 160
		std::uint64_t unk168;  // 168
		std::uint64_t unk170;  // 170
		std::uint64_t unk178;  // 178
		std::uint64_t unk180;  // 180
		std::uint64_t unk188;  // 188
		std::uint64_t unk190;  // 190
		std::uint64_t unk198;  // 198
		std::uint64_t unk1A0;  // 1A0
	};
	static_assert(sizeof(BSImagespaceShader) == 0x1A8);
}


===============================================
File: include/RE/B/BSImagespaceShaderBlur3.h
===============================================
#pragma once

#include "RE/B/BSImagespaceShader.h"

namespace RE
{
	class BSImagespaceShaderBlur3 : public BSImagespaceShader
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSImagespaceShaderBlur3;

		~BSImagespaceShaderBlur3() override;  // 00

		// override (BSImagespaceShader)
		void Unk_0D(void) override;  // 0D
	};
	static_assert(sizeof(BSImagespaceShaderBlur3) == 0x1A8);
}


===============================================
File: include/RE/B/BSInputDevice.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIInputDevice.h"
#include "RE/B/BSTHashMap.h"
#include "RE/I/InputDevices.h"

namespace RE
{
	class BSInputDevice : public BSIInputDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSInputDevice;
		inline static constexpr auto VTABLE = VTABLE_BSInputDevice;

		struct InputButton
		{
			BSFixedString name;          // 00
			float         heldDownSecs;  // 08
			std::uint32_t keycode;       // 0C
		};
		static_assert(sizeof(InputButton) == 0x10);

		~BSInputDevice() override;  // 00

		// override (BSIInputDevice)
		bool               GetKeyMapping(std::uint32_t a_key, BSFixedString& a_mapping) override;      // 04
		std::uint32_t      GetMappingKey(BSFixedString a_mapping) override;                            // 05
		bool               GetMappedKeycode(std::uint32_t a_key, std::uint32_t& outKeyCode) override;  // 06
		[[nodiscard]] bool IsEnabled() const override;                                                 // 07 - { return true; }

		[[nodiscard]] bool IsKeyboard() const;
		[[nodiscard]] bool IsMouse() const;
		[[nodiscard]] bool IsGamepad() const;
		[[nodiscard]] bool IsPressed(std::uint32_t a_keyCode) const;

		bool LoadControlsDefinitionFile(const char* a_fileName);                                                                    // loads the controls definition file from <FILENAME>.txt (usually located in 'interface\controls' folder)
		void ResetButtonMaps();                                                                                                     // resets the button maps
		void SetButtonState(std::uint32_t a_buttonId, float a_timeSinceLastPoll, bool a_buttonWasPressed, bool a_buttonIsPressed);  // sets the button state for a given key code and emits a button event if necessary

		// members
		INPUT_DEVICE                             device;           // 08
		std::uint32_t                            pad0C;            // 0C
		BSTHashMap<std::uint32_t, InputButton*>  deviceButtons;    // 10
		BSTHashMap<BSFixedString, std::uint32_t> buttonNameIDMap;  // 40

	protected:
		BSInputDevice();
	};
	static_assert(sizeof(BSInputDevice) == 0x70);
}


===============================================
File: include/RE/B/BSInputDeviceFactory.h
===============================================
#pragma once

#include "RE/B/BSIInputDevice.h"
#include "RE/I/InputDevices.h"

namespace RE
{
	class BSInputDeviceFactory
	{
	public:
		static BSIInputDevice* CreateInputDevice(INPUT_DEVICE a_deviceType);
		static void            DestroyInputDevice(BSIInputDevice* a_device);
	};
}

===============================================
File: include/RE/B/BSInputDeviceManager.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"
#include "RE/I/InputDevices.h"

namespace RE
{
	class BSIInputDevice;
	class BSInputDevice;
	class BSPCGamepadDeviceDelegate;
	class BSPCGamepadDeviceHandler;
	class BSTrackedControllerDevice;
	class BSWin32KeyboardDevice;
	class BSWin32MouseDevice;
	class BSWin32VirtualKeyboardDevice;
	class InputEvent;
	struct BSRemoteGamepadEvent;

	class BSInputDeviceManager :
		public BSTEventSource<InputEvent*>,           // 00
		public BSTSingletonSDM<BSInputDeviceManager>  // 58
	{
	public:
		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                         \
	bool                                 queuedGamepadEnableValue{ false }; /* 00 */ \
	bool                                 valueQueued{ false };              /* 01 */ \
	bool                                 pollingEnabled{ false };           /* 02 */ \
	std::uint8_t                         pad03;                             /* 03 */ \
	std::uint32_t                        pad04;                             /* 04 */ \
	BSTEventSource<BSRemoteGamepadEvent> remoteGamepadEventSource;          /* 08 */ \
	std::uint8_t                         unk60;                             /* 60 */ \
	std::uint8_t                         unk61;                             /* 61 */ \
	std::uint16_t                        unk62;                             /* 62 */ \
	std::uint32_t                        unk64;                             /* 64 */ \
	std::uint64_t                        unk68;                             /* 68 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x70);

		static BSInputDeviceManager* GetSingleton();

		BSPCGamepadDeviceDelegate*    GetGamepad();
		BSPCGamepadDeviceHandler*     GetGamepadHandler();
		BSWin32KeyboardDevice*        GetKeyboard();
		BSWin32MouseDevice*           GetMouse();
		BSTrackedControllerDevice*    GetVRControllerRight();
		BSTrackedControllerDevice*    GetVRControllerLeft();
		BSWin32VirtualKeyboardDevice* GetVirtualKeyboard();
		[[nodiscard]] bool            IsGamepadConnected();
		[[nodiscard]] bool            IsGamepadEnabled();
		[[nodiscard]] bool            IsMouseBackground();
		bool                          GetDeviceKeyMapping(INPUT_DEVICE a_device, std::uint32_t a_key, BSFixedString& a_mapping);
		bool                          GetDeviceMappedKeycode(INPUT_DEVICE a_device, std::uint32_t a_key, std::uint32_t& a_outKeyCode);
		void                          ProcessGamepadEnabledChange();
		void                          ReinitializeMouse();
		void                          CreateInputDevices();
		void                          ResetInputDevices();
		void                          DestroyInputDevices();
		void                          PollInputDevices(float a_secsSinceLastFrame);

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x80, 0x98);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x80, 0x98);
		}

		// members
		std::uint8_t    pad59;       // 59
		std::uint16_t   pad5A;       // 5A
		std::uint32_t   pad5C;       // 5C
		BSIInputDevice* devices[4];  // 60
#ifndef SKYRIM_CROSS_VR
#	if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		BSTrackedControllerDevice* unkDevice;     // 80
		BSTrackedControllerDevice* vrDevices[2];  // 88
		RUNTIME_DATA_CONTENT                      // 98
#	elif !defined(ENABLE_SKYRIM_VR)
		RUNTIME_DATA_CONTENT  // 80
#	endif
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSInputDeviceManager) == 0xF0);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSInputDeviceManager) == 0x108);
#else
	static_assert(sizeof(BSInputDeviceManager) == 0x80);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSInputEventQueue.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"
#include "RE/B/ButtonEvent.h"
#include "RE/C/CharEvent.h"
#include "RE/D/DeviceConnectEvent.h"
#include "RE/K/KinectEvent.h"
#include "RE/M/MouseMoveEvent.h"
#include "RE/T/ThumbstickEvent.h"

namespace RE
{
	class BSInputEventQueue : public BSTSingletonSDM<BSInputEventQueue>
	{
	public:
		inline static constexpr std::uint8_t MAX_BUTTON_EVENTS = 10;
		inline static constexpr std::uint8_t MAX_CHAR_EVENTS = 5;
		inline static constexpr std::uint8_t MAX_MOUSE_EVENTS = 1;
		inline static constexpr std::uint8_t MAX_THUMBSTICK_EVENTS = 2;
		inline static constexpr std::uint8_t MAX_CONNECT_EVENTS = 1;
		inline static constexpr std::uint8_t MAX_KINECT_EVENTS = 1;

		static BSInputEventQueue* GetSingleton();

		void AddButtonEvent(INPUT_DEVICE a_device, std::int32_t a_id, float a_value, float a_duration);
		void AddCharEvent(std::uint32_t a_keyCode);
		void AddMouseMoveEvent(std::int32_t a_mouseInputX, std::int32_t a_mouseInputY);
		void AddThumbstickEvent(ThumbstickEvent::InputType a_id, float a_xValue, float a_yValue);
		void AddConnectEvent(INPUT_DEVICE a_device, bool a_connected);
		void AddKinectEvent(const BSFixedString& a_userEvent, const BSFixedString& a_heard);
		void PushOntoInputQueue(InputEvent* a_event);
		void ClearInputQueue();

		// members
		std::uint8_t       pad001;                                   // 001
		std::uint16_t      pad002;                                   // 002
		std::uint32_t      buttonEventCount;                         // 004
		std::uint32_t      charEventCount;                           // 008
		std::uint32_t      mouseEventCount;                          // 00C
		std::uint32_t      thumbstickEventCount;                     // 010
		std::uint32_t      connectEventCount;                        // 014
		std::uint32_t      kinectEventCount;                         // 018
		std::uint32_t      pad01C;                                   // 01C
		ButtonEvent        buttonEvents[MAX_BUTTON_EVENTS];          // 020
		CharEvent          charEvents[MAX_CHAR_EVENTS];              // 200
		MouseMoveEvent     mouseEvents[MAX_MOUSE_EVENTS];            // 2A0
		ThumbstickEvent    thumbstickEvents[MAX_THUMBSTICK_EVENTS];  // 2D0
		DeviceConnectEvent connectEvents[MAX_CONNECT_EVENTS];        // 330
		KinectEvent        kinectEvents[MAX_KINECT_EVENTS];          // 350
		InputEvent*        queueHead;                                // 380
		InputEvent*        queueTail;                                // 388
	};
	static_assert(sizeof(BSInputEventQueue) == 0x390);
}


===============================================
File: include/RE/B/BSInstanceTriShape.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTriShape.h"

namespace RE
{
	class BSInstanceTriShape : public BSTriShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSInstanceTriShape;
		inline static auto           Ni_RTTI = NiRTTI_BSInstanceTriShape;

		~BSInstanceTriShape() override;  // 00

		// override (BSTriShape)
		const NiRTTI* GetRTTI() const override;  // 02

		// add
		SKYRIM_REL_VR_VIRTUAL void BeginAddingInstances(std::uint32_t a_numFloatsPerInstance);                                                          // 38
		SKYRIM_REL_VR_VIRTUAL void AddInstances(std::uint32_t a_numInstances, std::uint16_t& a_instanceData);                                           // 39
		SKYRIM_REL_VR_VIRTUAL void DoneAddingInstances(BSTArray<std::uint32_t>& a_instances);                                                           // 3A
		SKYRIM_REL_VR_VIRTUAL bool GetIsAddingInstances();                                                                                              // 3B
		SKYRIM_REL_VR_VIRTUAL std::uint32_t AddGroup(std::uint32_t a_numInstances, std::uint16_t& a_instanceData, std::uint32_t a_arg3, float a_arg4);  // 3C
		SKYRIM_REL_VR_VIRTUAL void          RemoveGroup(std::uint32_t a_numInstance);                                                                   // 3D
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSInstanceTriShape) == 0x160);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSInstanceTriShape) == 0x1A8);
#endif
}


===============================================
File: include/RE/B/BSIntrusiveRefCounted.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	struct BSIntrusiveRefCounted
	{
	public:
		template <class>
		friend struct BSTSmartPointerIntrusiveRefCount;

		std::uint32_t IncRef() const
		{
			stl::atomic_ref myRefCount{ _refCount };
			return ++myRefCount;
		}

		std::uint32_t DecRef() const
		{
			stl::atomic_ref myRefCount{ _refCount };
			return --myRefCount;
		}

		TES_HEAP_REDEFINE_NEW();

	protected:
		// members
		mutable volatile std::uint32_t _refCount{ 0 };  // 0
	};
	static_assert(sizeof(BSIntrusiveRefCounted) == 0x4);
}


===============================================
File: include/RE/B/BSKeyboardDevice.h
===============================================
#pragma once

#include "RE/B/BSInputDevice.h"

namespace RE
{
	class BSKeyboardDevice : public BSInputDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSKeyboardDevice;
		inline static constexpr auto VTABLE = VTABLE_BSKeyboardDevice;

		struct Keys
		{
			enum Key : std::uint32_t
			{
				kNone = 0x00,

				kEscape = 0x01,
				kNum1 = 0x02,
				kNum2 = 0x03,
				kNum3 = 0x04,
				kNum4 = 0x05,
				kNum5 = 0x06,
				kNum6 = 0x07,
				kNum7 = 0x08,
				kNum8 = 0x09,
				kNum9 = 0x0A,
				kNum0 = 0x0B,
				kMinus = 0x0C,
				kEquals = 0x0D,
				kBackspace = 0x0E,
				kTab = 0x0F,
				kQ = 0x10,
				kW = 0x11,
				kE = 0x12,
				kR = 0x13,
				kT = 0x14,
				kY = 0x15,
				kU = 0x16,
				kI = 0x17,
				kO = 0x18,
				kP = 0x19,
				kBracketLeft = 0x1A,
				kBracketRight = 0x1B,
				kEnter = 0x1C,
				kLeftControl = 0x1D,
				kA = 0x1E,
				kS = 0x1F,
				kD = 0x20,
				kF = 0x21,
				kG = 0x22,
				kH = 0x23,
				kJ = 0x24,
				kK = 0x25,
				kL = 0x26,
				kSemicolon = 0x27,
				kApostrophe = 0x28,
				kTilde = 0x29,
				kLeftShift = 0x2A,
				kBackslash = 0x2B,
				kZ = 0x2C,
				kX = 0x2D,
				kC = 0x2E,
				kV = 0x2F,
				kB = 0x30,
				kN = 0x31,
				kM = 0x32,
				kComma = 0x33,
				kPeriod = 0x34,
				kSlash = 0x35,
				kRightShift = 0x36,
				kKP_Multiply = 0x37,
				kLeftAlt = 0x38,
				kSpacebar = 0x39,
				kCapsLock = 0x3A,
				kF1 = 0x3B,
				kF2 = 0x3C,
				kF3 = 0x3D,
				kF4 = 0x3E,
				kF5 = 0x3F,
				kF6 = 0x40,
				kF7 = 0x41,
				kF8 = 0x42,
				kF9 = 0x43,
				kF10 = 0x44,
				kNumLock = 0x45,
				kScrollLock = 0x46,
				kKP_7 = 0x47,
				kKP_8 = 0x48,
				kKP_9 = 0x49,
				kKP_Subtract = 0x4A,
				kKP_4 = 0x4B,
				kKP_5 = 0x4C,
				kKP_6 = 0x4D,
				kKP_Plus = 0x4E,
				kKP_1 = 0x4F,
				kKP_2 = 0x50,
				kKP_3 = 0x51,
				kKP_0 = 0x52,
				kKP_Decimal = 0x53,

				kF11 = 0x57,
				kF12 = 0x58,

				kKP_Enter = 0x9C,
				kRightControl = 0x9D,

				kKP_Divide = 0xB5,

				kPrintScreen = 0xB7,
				kRightAlt = 0xB8,

				kPause = 0xC5,

				kHome = 0xC7,
				kUp = 0xC8,
				kPageUp = 0xC9,

				kLeft = 0xCB,

				kRight = 0xCD,

				kEnd = 0xCF,
				kDown = 0xD0,
				kPageDown = 0xD1,
				kInsert = 0xD2,
				kDelete = 0xD3,

				kLeftWin = 0xDB,
				kRightWin = 0xDC
			};
		};
		using Key = Keys::Key;

		~BSKeyboardDevice() override;  // 00

		// add
		virtual void Unk_09(void) = 0;  // 09
		virtual void Unk_0A(void) = 0;  // 0A
	protected:
		BSKeyboardDevice();
	};
	static_assert(sizeof(BSKeyboardDevice) == 0x70);
}


===============================================
File: include/RE/B/BSLensFlareRenderData.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSLensFlareSpriteRenderData;

	class BSLensFlareRenderData
	{
	public:
		// members
		float                                            fadeDistRadiusScale;  // 00
		float                                            colorInfluence;       // 04
		BSTArray<NiPointer<BSLensFlareSpriteRenderData>> sprites;              // 08
	};
	static_assert(sizeof(BSLensFlareRenderData) == 0x20);
}


===============================================
File: include/RE/B/BSLight.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSPortalGraph;
	class BSTriShape;
	class NiAVObject;
	class BSLensFlareRenderData;
	class NiLight;

	class BSLight : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLight;

		struct ShapeData
		{
			std::uint64_t         unk00;       // 00
			std::uint64_t         unk08;       // 08
			NiPointer<BSTriShape> fenceShape;  // 10
		};
		static_assert(sizeof(ShapeData) == 0x18);

		struct Data
		{
			std::uint64_t unk00;  // 00
			std::uint64_t unk08;  // 08
			std::uint32_t unk10;  // 10
			ShapeData*    data;   // 18
		};
		static_assert(sizeof(Data) == 0x20);

		~BSLight() override;  // 00

		// add
		virtual bool Unk_02(NiLight* a_light);  // 02
		virtual bool Unk_03();                  // 03

		// members
		std::uint32_t          unk010;          // 010
		float                  lodDimmer;       // 014
		Data                   unk018;          // 018
		std::uint64_t          unk038;          // 038
		std::uint32_t          unk040;          // 040
		bool                   pointLight;      // 044
		bool                   ambientLight;    // 045
		bool                   unk046;          // 046
		bool                   portalStrict;    // 047
		NiPointer<NiLight>     light;           // 048
		NiPoint3               worldTranslate;  // 050
		std::uint32_t          unk05C;          // 05C
		std::uint8_t           unk060;          // 060
		bool                   affectLand;      // 061
		std::uint8_t           unk062;          // 062
		bool                   neverFades;      // 063
		std::uint32_t          unk064;          // 064
		std::uint64_t          unk068;          // 068
		std::uint8_t           unk070[96];      // 070
		std::uint8_t           unk0D0;          // 0D0
		std::uint8_t           pad0D1;          // 0D1
		std::uint16_t          pad0D2;          // 0D2
		std::uint32_t          pad0D4;          // 0D4
		BSTArray<void*>        unk0D8;          // 0D8
		BSTArray<void*>        unk0F0;          // 0F0
		BSTArray<void*>        unk108;          // 108
		BSPortalGraph*         portalGraph;     // 120
		std::uint64_t          unk128;          // 128
		NiPointer<NiAVObject>  objectNode;      // 130
		BSLensFlareRenderData* lensFlareData;   // 138
	};
	static_assert(sizeof(BSLight) == 0x140);
}


===============================================
File: include/RE/B/BSLightingShaderMaterial.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"

namespace RE
{
	class BSLightingShaderMaterial : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterial;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterial;
		inline static auto           FEATURE = Feature::kDefault;

		~BSLightingShaderMaterial() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;            // 01
		Feature           GetFeature() const override;  // 06 - { return Feature::kDefault; }

	protected:
		BSLightingShaderMaterial* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterial::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100004, 106711) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterial) == 0xA0);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialBase.h
===============================================
#pragma once

#include "RE/B/BSShaderMaterial.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSTextureSet;
	class NiSourceTexture;
	class NiStream;

	class BSLightingShaderMaterialBase : public BSShaderMaterial
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialBase;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialBase;

		~BSLightingShaderMaterialBase() override;  // 00

		// override (BSShaderMaterial)
		BSShaderMaterial* Create() override = 0;                            // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;  // 02
		bool              DoIsCopy(BSShaderMaterial* a_other) override;     // 03
		std::uint32_t     ComputeCRC32(void) override;                      // 04
		BSShaderMaterial* GetDefault() override;                            // 05
		Feature           GetFeature() const override;                      // 06 - { return Feature::kDefault; }
		Type              GetType() const override;                         // 07 - { return Type::kLighting; }

		// add
		virtual void OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet);                                                       // 08
		virtual void ClearTextures();                                                                                                          // 09
		virtual void ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN);  // 0A
		virtual void GetTextures(void);                                                                                                        // 0B
		virtual void SaveBinary(NiStream& a_stream);                                                                                           // 0C
		virtual void LoadBinary(NiStream& a_stream);                                                                                           // 0D

		static BSLightingShaderMaterialBase* CreateMaterial(Feature a_feature);
		template <class T>
		static T* CreateMaterial();

		void                    CopyBaseMembers(BSLightingShaderMaterialBase* a_other);
		NiPointer<BSTextureSet> GetTextureSet() const;
		void                    SetTextureSet(NiPointer<BSTextureSet> a_textureSet);

		// members
		NiColor                    specularColor;                   // 38
		std::uint32_t              pad44;                           // 44
		NiPointer<NiSourceTexture> diffuseTexture;                  // 48
		std::int32_t               diffuseRenderTargetSourceIndex;  // 50
		std::uint32_t              pad54;                           // 54
		NiPointer<NiSourceTexture> normalTexture;                   // 58
		NiPointer<NiSourceTexture> rimSoftLightingTexture;          // 60
		NiPointer<NiSourceTexture> specularBackLightingTexture;     // 68
		std::int32_t               textureClampMode;                // 70
		std::int32_t               pad74;                           // 70
		NiPointer<BSTextureSet>    textureSet;                      // 78
		float                      materialAlpha;                   // 80
		float                      refractionPower;                 // 84
		float                      specularPower;                   // 88
		float                      specularColorScale;              // 8C
		float                      subSurfaceLightRolloff;          // 90
		float                      rimLightPower;                   // 94
		std::uint64_t              unk98;                           // 98
	};
	static_assert(sizeof(BSLightingShaderMaterialBase) == 0xA0);

	template <class T>
	T* BSLightingShaderMaterialBase::CreateMaterial()
	{
		return static_cast<T*>(CreateMaterial(T::FEATURE));
	}
}


===============================================
File: include/RE/B/BSLightingShaderMaterialEnvmap.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialEnvmap : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialEnvmap;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialEnvmap;
		inline static auto           FEATURE = Feature::kEnvironmentMap;

		~BSLightingShaderMaterialEnvmap() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;                                                                                   // 02
		std::uint32_t     ComputeCRC32(void) override;                                                                                                       // 04
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kEnvironmentMap; }
		void              OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet) override;                                                       // 08
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B
		void              SaveBinary(NiStream& a_stream) override;                                                                                           // 0C
		void              LoadBinary(NiStream& a_stream) override;                                                                                           // 0D

		// members
		NiPointer<NiSourceTexture> envTexture;      // A0
		NiPointer<NiSourceTexture> envMaskTexture;  // A8
		float                      envMapScale;     // B0
		std::uint32_t              padB4;           // B4

	protected:
		BSLightingShaderMaterialEnvmap* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialEnvmap::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100021, 106728) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialEnvmap) == 0xB8);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialEye.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialEye : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialEye;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialEye;
		inline static auto           FEATURE = Feature::kEye;

		~BSLightingShaderMaterialEye() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;                                                                                   // 02
		std::uint32_t     ComputeCRC32(void) override;                                                                                                       // 04
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kEye; }
		void              OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet) override;                                                       // 08
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B
		void              SaveBinary(NiStream& a_stream) override;                                                                                           // 0C
		void              LoadBinary(NiStream& a_stream) override;                                                                                           // 0D

		// members
		NiPointer<NiSourceTexture> envTexture;      // A0
		NiPointer<NiSourceTexture> envMaskTexture;  // A8
		float                      envMapScale;     // B0
		NiPoint3                   eyeCenter[2];    // B4
		std::uint32_t              padC8;           // CC

	protected:
		BSLightingShaderMaterialEye* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialEye::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100033, 106740) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialEye) == 0xD0);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialFacegen.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialFacegen : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialFacegen;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialFacegen;
		inline static auto           FEATURE = Feature::kFaceGen;

		~BSLightingShaderMaterialFacegen() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;                                                                                   // 02
		std::uint32_t     ComputeCRC32(void) override;                                                                                                       // 04
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kFaceGen; }
		void              OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet) override;                                                       // 08
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B

		// members
		NiPointer<NiSourceTexture> tintTexture;        // A0
		NiPointer<NiSourceTexture> detailTexture;      // A8
		NiPointer<NiSourceTexture> subsurfaceTexture;  // B0

	protected:
		BSLightingShaderMaterialFacegen* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialFacegen::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100077, 106784) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialFacegen) == 0xB8);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialFacegenTint.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiColor.h"

namespace RE
{
	class BSLightingShaderMaterialFacegenTint : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialFacegenTint;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialFacegenTint;
		inline static auto           FEATURE = Feature::kFaceGenRGBTint;

		~BSLightingShaderMaterialFacegenTint() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;  // 02
		std::uint32_t     ComputeCRC32(void) override;                      // 04
		Feature           GetFeature() const override;                      // 06 - { return Feature::kFaceGenRGBTint; }
		void              SaveBinary(NiStream& a_stream) override;          // 0C
		void              LoadBinary(NiStream& a_stream) override;          // 0D

		// members
		NiColor       tintColor;  // A0
		std::uint32_t padAC;      // AC

	protected:
		BSLightingShaderMaterialFacegenTint* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialFacegenTint::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100087, 106794) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialFacegenTint) == 0xB0);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialGlowmap.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialGlowmap : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialGlowmap;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialGlowmap;
		inline static auto           FEATURE = Feature::kGlowMap;

		~BSLightingShaderMaterialGlowmap() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;                                                                                   // 02
		std::uint32_t     ComputeCRC32(void) override;                                                                                                       // 04
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kGlowMap; }
		void              OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet) override;                                                       // 08
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B

		// members
		NiPointer<NiSourceTexture> glowTexture;  // A0

	protected:
		BSLightingShaderMaterialGlowmap* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialGlowmap::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100045, 106752) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialGlowmap) == 0xA8);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialHairTint.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiColor.h"

namespace RE
{
	class BSLightingShaderMaterialHairTint : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialHairTint;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialHairTint;
		inline static auto           FEATURE = Feature::kHairTint;

		~BSLightingShaderMaterialHairTint() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                // 01
		void              CopyMembers(BSShaderMaterial* a_other) override;  // 02
		std::uint32_t     ComputeCRC32(void) override;                      // 04
		Feature           GetFeature() const override;                      // 06 - { return Feature::kHairTint; }
		void              SaveBinary(NiStream& a_stream) override;          // 0C
		void              LoadBinary(NiStream& a_stream) override;          // 0D

		// members
		NiColor       tintColor;  // A0
		std::uint32_t padAC;      // AC

	protected:
		BSLightingShaderMaterialHairTint* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialHairTint::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100095, 106802) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialHairTint) == 0xB0);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialLODLandscape.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialLODLandscape : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialLODLandscape;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialLODLandscape;
		inline static auto           FEATURE = Feature::kLODLandNoise;

		~BSLightingShaderMaterialLODLandscape() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_src) override;                                                                                     // 02
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kLODLandNoise; }
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B

		// members
		NiPointer<NiSourceTexture> parentDiffuseTexture;   // A0
		NiPointer<NiSourceTexture> parentNormalTexture;    // A8
		NiPointer<NiSourceTexture> landscapeNoiseTexture;  // B0
		float                      terrainTexOffsetX;      // B4
		float                      terrainTexOffsetY;      // B8
		float                      terrainTexFade;         // BC

	protected:
		BSLightingShaderMaterialLODLandscape* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialLODLandscape::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100110, 106817) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialLODLandscape) == 0xC8);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialLandscape.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialLandscape : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialLandscape;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialLandscape;
		inline static auto           FEATURE = Feature::kMultiTexLandLODBlend;

		~BSLightingShaderMaterialLandscape() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_src) override;                                                                                     // 02
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kMultiTexLandLODBlend; }
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B

		// members
		std::uint32_t              numLandscapeTextures;        // 0A0
		std::uint32_t              pad0A4;                      // 0A4
		NiPointer<NiSourceTexture> landscapeDiffuseTexture[5];  // 0A8
		NiPointer<NiSourceTexture> landscapeNormalTexture[5];   // 0D0
		NiPointer<NiSourceTexture> terrainOverlayTexture;       // 0F8
		NiPointer<NiSourceTexture> terrainNoiseTexture;         // 100
		NiColorA                   landBlendParams;             // 108
		float                      textureIsSnow[6];            // 118
		float                      textureIsSpecPower[6];       // 130
		float                      terrainTexOffsetX;           // 148
		float                      terrainTexOffsetY;           // 14C
		float                      terrainTexFade;              // 150
		std::uint32_t              pad154;                      // 154

	protected:
		BSLightingShaderMaterialLandscape* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialLandscape::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100102, 106809) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialLandscape) == 0x158);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialMultiLayerParallax.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialMultiLayerParallax : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialMultiLayerParallax;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialMultiLayerParallax;
		inline static auto           FEATURE = Feature::kMultilayerParallax;

		~BSLightingShaderMaterialMultiLayerParallax() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_src) override;                                                                                     // 02
		std::uint32_t     ComputeCRC32(void) override;                                                                                                       // 04
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kMultilayerParallax; }
		void              OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet) override;                                                       // 08
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B
		void              SaveBinary(NiStream& a_stream) override;                                                                                           // 0C
		void              LoadBinary(NiStream& a_stream) override;                                                                                           // 0D

		// members
		NiPointer<NiSourceTexture> layerTexture;              // A0
		NiPointer<NiSourceTexture> envTexture;                // A8
		NiPointer<NiSourceTexture> envMaskTexture;            // B0
		float                      parallaxLayerThickness;    // B8
		float                      parallaxRefractionScale;   // BC
		float                      parallaxInnerLayerUScale;  // C0
		float                      parallaxInnerLayerVScale;  // C4
		float                      envmapScale;               // C8
		std::uint32_t              padCC;                     // CC

	protected:
		BSLightingShaderMaterialMultiLayerParallax* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialMultiLayerParallax::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100125, 106832) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialMultiLayerParallax) == 0xD0);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialParallax.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialParallax : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialParallax;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialParallax;
		inline static auto           FEATURE = Feature::kParallax;

		~BSLightingShaderMaterialParallax() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_src) override;                                                                                     // 02
		std::uint32_t     ComputeCRC32(void) override;                                                                                                       // 04
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Type::kParallax; }
		void              OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet) override;                                                       // 08
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B

		// members
		NiPointer<NiSourceTexture> heightTexture;  // A0

	protected:
		BSLightingShaderMaterialParallax* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialParallax::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100055, 106762) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialParallax) == 0xA8);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialParallaxOcc.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiSourceTexture;

	class BSLightingShaderMaterialParallaxOcc : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialParallaxOcc;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialParallaxOcc;
		inline static auto           FEATURE = Feature::kParallaxOcc;

		~BSLightingShaderMaterialParallaxOcc() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                                                                                                                 // 01
		void              CopyMembers(BSShaderMaterial* a_src) override;                                                                                     // 02
		std::uint32_t     ComputeCRC32(void) override;                                                                                                       // 04
		Feature           GetFeature() const override;                                                                                                       // 06 - { return Feature::kParallaxOcc; }
		void              OnLoadTextureSet(std::uint64_t a_arg1, BSTextureSet* a_textureSet) override;                                                       // 08
		void              ClearTextures() override;                                                                                                          // 09
		void              ReceiveValuesFromRootMaterial(bool a_skinned, bool a_rimLighting, bool a_softLighting, bool a_backLighting, bool a_MSN) override;  // 0A
		void              GetTextures(void) override;                                                                                                        // 0B
		void              SaveBinary(NiStream& a_stream) override;                                                                                           // 0C
		void              LoadBinary(NiStream& a_stream) override;                                                                                           // 0D

		// members
		NiPointer<NiSourceTexture> heightTexture;         // A0
		float                      parallaxOccMaxPasses;  // A8
		float                      parallaxOccScale;      // AC

	protected:
		BSLightingShaderMaterialParallaxOcc* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialParallaxOcc::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100065, 106772) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialParallaxOcc) == 0xB0);
}


===============================================
File: include/RE/B/BSLightingShaderMaterialSnow.h
===============================================
#pragma once

#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/N/NiColor.h"

namespace RE
{
	class BSLightingShaderMaterialSnow : public BSLightingShaderMaterialBase
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderMaterialSnow;
		inline static constexpr auto VTABLE = VTABLE_BSLightingShaderMaterialSnow;
		inline static auto           FEATURE = Feature::kMultiIndexTriShapeSnow;

		~BSLightingShaderMaterialSnow() override;  // 00

		// override (BSLightingShaderMaterialBase)
		BSShaderMaterial* Create() override;                              // 01
		void              CopyMembers(BSShaderMaterial* a_src) override;  // 02
		std::uint32_t     ComputeCRC32(void) override;                    // 04
		Feature           GetFeature() const override;                    // 06 - { return Feature::kMultiIndexTriShapeSnow; }
		void              SaveBinary(NiStream& a_stream) override;        // 0C
		void              LoadBinary(NiStream& a_stream) override;        // 0D

		// members
		NiColorA sparkleParams;  // A0

	protected:
		BSLightingShaderMaterialSnow* Ctor()
		{
			using func_t = decltype(&BSLightingShaderMaterialSnow::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(100118, 106825) };
			return func(this);
		}
		friend class BSLightingShaderMaterialBase;
	};
	static_assert(sizeof(BSLightingShaderMaterialSnow) == 0xB0);
}


===============================================
File: include/RE/B/BSLightingShaderProperty.h
===============================================
#pragma once

#include "RE/B/BSShaderProperty.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiColor.h"

namespace RE
{
	class BSLightingShaderProperty : public BSShaderProperty
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSLightingShaderProperty;
		inline static auto           Ni_RTTI = NiRTTI_BSLightingShaderProperty;

		struct Data
		{
			std::uint64_t unk00;  // 00
			std::uint64_t unk08;  // 08
		};
		static_assert(sizeof(Data) == 0x10);

		~BSLightingShaderProperty() override;  // 00

		// override (BSShaderProperty)
		const NiRTTI*          GetRTTI() const override;                                                                                    // 02
		NiObject*              CreateClone(NiCloningProcess& a_cloning) override;                                                           // 17
		void                   LoadBinary(NiStream& a_stream) override;                                                                     // 18
		void                   LinkObject(NiStream& a_stream) override;                                                                     // 19
		bool                   RegisterStreamables(NiStream& a_stream) override;                                                            // 1A
		void                   SaveBinary(NiStream& a_stream) override;                                                                     // 1B
		bool                   IsEqual(NiObject* a_object) override;                                                                        // 1C - { return false; }
		void                   PostLinkObject(NiStream& a_stream) override;                                                                 // 1E
		bool                   SetupGeometry(BSGeometry* a_geometry) override;                                                              // 27
		bool                   FinishSetupGeometry(BSGeometry* a_geometry) override;                                                        // 28
		RenderPassArray*       GetRenderPasses(BSGeometry* a_geometry, std::uint32_t a_arg2, BSShaderAccumulator* a_accumulator) override;  // 2A
		void                   Unk_2B(void) override;                                                                                       // 2B
		void                   Unk_2C(void) override;                                                                                       // 2C
		void                   Unk_2D(void) override;                                                                                       // 2D
		void                   Unk_2F(void) override;                                                                                       // 2F
		bool                   CanMerge(const BSShaderProperty* a_other) override;                                                          // 30
		void                   SetMaterialAlpha(float a_alpha) override;                                                                    // 31
		float                  QMaterialAlpha() override;                                                                                   // 32
		std::int32_t           ForEachTexture(ForEachVisitor& a_visitor) override;                                                          // 33
		void                   DoClearRenderPasses() override;                                                                              // 34
		std::int32_t           QShader() override;                                                                                          // 35 - { return 11; }
		NiSourceTexture*       GetBaseTexture() override;                                                                                   // 37 - { return diffuseTexture }
		bool                   AcceptsEffectData() const override;                                                                          // 39 - { return !(flags & kRefraction) && !(flags & kTempRefraction); }
		void                   Unk_3B(void) override;                                                                                       // 3B
		std::uint32_t          DetermineUtilityShaderDecl() override;                                                                       // 3D
		BSShaderMaterial::Type GetMaterialType() override;                                                                                  // 3E - { return 2; }

		void CopyMembers(BSLightingShaderProperty* a_other);

		// members
		Data            unk088[3];          // 088
		Data            unk0B8;             // 0B8
		Data            unk0C8;             // 0C8
		Data            unk0D8;             // 0D8
		BSRenderPass*   unk0E8;             // 0E8
		NiColor*        emissiveColor;      // 0F0
		float           emissiveMult;       // 0F8
		float           forcedDarkness;     // 0FC - unused
		float           specularLODFade;    // 100
		float           envmapLODFade;      // 104
		std::uint32_t   unk108;             // 108
		NiColorA        projectedUVParams;  // 10C
		NiColorA        projectedUVColor;   // 11C
		std::int32_t    unk12C;             // 12C
		std::uint32_t   unk130;             // 130
		std::uint32_t   unk134;             // 134
		BSTArray<void*> unk138;             // 138
		std::uint64_t   unk150;             // 150
		std::uint8_t    unk158;             // 158
		std::uint8_t    pad159;             // 159
		std::uint16_t   pad15A;             // 15A
		std::uint32_t   pad15C;             // 15C
	};
	static_assert(sizeof(BSLightingShaderProperty) == 0x160);
}


===============================================
File: include/RE/B/BSMasterParticleSystem.h
===============================================
#pragma once

#include "RE/N/NiNode.h"

namespace RE
{
	class NiParticles;

	class BSMasterParticleSystem : public NiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMasterParticleSystem;
		inline static constexpr auto Ni_RTTI = NiRTTI_BSMasterParticleSystem;

		~BSMasterParticleSystem() override;  // 00

		// override (NiNode)
		const NiRTTI* GetRTTI() const override;                                                         // 02
		void          LoadBinary(NiStream& a_stream) override;                                          // 18
		void          LinkObject(NiStream& a_stream) override;                                          // 19
		bool          RegisterStreamables(NiStream& a_stream) override;                                 // 1A
		void          SaveBinary(NiStream& a_stream) override;                                          // 1B
		void          PostLinkObject(NiStream& a_stream) override;                                      // 1E
		bool          IsEqual(NiObject* a_object) override;                                             // 1C
#ifndef SKYRIM_CROSS_VR
		void          UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;          // 2C
		void          UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;  // 2D
		void          UpdateRigidDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;     // 2E
#endif

		struct MASTER_PARTICLE_SYSTEM_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT         \
	BSTArray<NiPointer<NiAVObject>> emitterObjs;           /* 128 */ \
			BSTArray<NiParticles*>          particles;             /* 140 */ \
			std::int32_t                    index;                 /* 158 */ \
			std::uint32_t                   unk15C;                /* 15C */ \
			std::uint16_t                   unk160;                /* 160 */ \
			std::uint16_t                   maxEmitterObj;         /* 162 */ \
			std::uint16_t                   maxParticlesPerFrame;  /* 164 */ \
			bool                            destroyWhenNotInUse;   /* 166 */ \
			std::uint8_t                    pad167;                /* 167 */

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline MASTER_PARTICLE_SYSTEM_RUNTIME_DATA& GetMasterParticleSystemRuntimeData() noexcept
		{
			return REL::RelocateMember<MASTER_PARTICLE_SYSTEM_RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const MASTER_PARTICLE_SYSTEM_RUNTIME_DATA& GetMasterParticleSystemRuntimeData() const noexcept
		{
			return REL::RelocateMember<MASTER_PARTICLE_SYSTEM_RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSMaterialObject.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiProperty;

	class BSMaterialObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMaterialObject;

		struct DIRECTIONAL_DATA  // DATA
		{
		public:
			enum class Flag
			{
				kNone = 0,
				kSnow = 1 << 0
			};

			// members
			float                                 falloffScale;     // 00
			float                                 falloffBias;      // 04
			float                                 noiseUVScale;     // 08
			float                                 materialUVScale;  // 0C
			NiPoint3                              ProjectionDir;    // 10
			float                                 normalDampener;   // 1C
			NiColor                               singlePassColor;  // 20
			std::int32_t                          singlePass;       // 2C
			stl::enumeration<Flag, std::uint32_t> flags;            // 30
			std::uint32_t                         unk2C;            // 34
		};
		static_assert(sizeof(DIRECTIONAL_DATA) == 0x38);

		virtual ~BSMaterialObject();  // 00

		// add
		virtual void EnsureLoaded();  // 01 - { return; }

		// members
		DIRECTIONAL_DATA                directionalData;  // 08 - DATA
		BSTArray<NiPointer<NiProperty>> properties;       // 40
	};
	static_assert(sizeof(BSMaterialObject) == 0x58);
}


===============================================
File: include/RE/B/BSMemStorage.h
===============================================
#pragma once

#include "RE/B/BSStorage.h"

namespace RE
{
	class Win32FileType;

	class BSMemStorage : public BSStorage
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMemStorage;
		inline static constexpr auto VTABLE = VTABLE_BSMemStorage;

		~BSMemStorage() override;  // 00

		// override BSStorage
		std::size_t              GetSize() const override;                                                       // 01
		std::size_t              GetPosition() const override;                                                   // 02
		BSStorageDefs::ErrorCode Seek(std::size_t a_offset, BSStorageDefs::SeekMode a_seekMode) const override;  // 03
		BSStorageDefs::ErrorCode Read(std::size_t a_numBytes, std::byte* a_bytes) const override;                // 04
		BSStorageDefs::ErrorCode Write(std::size_t a_numBytes, const std::byte* a_bytes) override;               // 05

		// members
		Win32FileType* file;   // 20
		std::uint64_t  unk28;  // 28
	};
	static_assert(sizeof(BSMemStorage) == 0x30);
}


===============================================
File: include/RE/B/BSModelDB.h
===============================================
#pragma once

#include "RE/D/DBTraits.h"
#include "RE/E/ErrorCodes.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiNode;

	namespace BSModelDB
	{
		BSResource::ErrorCode Demand(const char* a_modelPath, NiPointer<NiNode>& a_modelOut, const DBTraits::ArgsType& a_args);
	}
}


===============================================
File: include/RE/B/BSMouseDevice.h
===============================================
#pragma once

#include "RE/B/BSInputDevice.h"

namespace RE
{
	class BSMouseDevice : public BSInputDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMouseDevice;
		inline static constexpr auto VTABLE = VTABLE_BSMouseDevice;

		~BSMouseDevice() override;  // 00

		// add
		virtual void Reinitialize(void);  // 09 - { return; }

		// members
		bool backgroundMouse;  // 70

	protected:
		friend class BSInputDeviceFactory;
		BSMouseDevice();
	};

	static_assert(sizeof(BSMouseDevice) == 0x78);
}


===============================================
File: include/RE/B/BSMultiBound.h
===============================================
#pragma once

#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSMultiBoundShape;
	class NiPoint3;

	class BSMultiBound : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMultiBound;
		inline static auto           Ni_RTTI = NiRTTI_BSMultiBound;

		virtual ~BSMultiBound();  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		// add
		virtual bool QWithinPoint(const NiPoint3& a_pos);  // 25
		virtual void Unk_26();                             // 26

		// members
		std::uint32_t                unk10;  // 10
		std::uint32_t                pad14;  // 14
		NiPointer<BSMultiBoundShape> data;   // 18
	};
	static_assert(sizeof(BSMultiBound) == 0x20);
}


===============================================
File: include/RE/B/BSMultiBoundAABB.h
===============================================
#pragma once

#include "RE/B/BSMultiBoundShape.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class BSMultiBoundAABB : public BSMultiBoundShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMultiBoundAABB;
		inline static auto           Ni_RTTI = NiRTTI_BSMultiBoundAABB;

		~BSMultiBoundAABB() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
		std::uint32_t GetType() override;                                 // 25 - { return 1; }
		float         GetLength() override;                               // 26
		bool          Unk_27() override;                                  // 27
		void          Unk_28() override;                                  // 28
		bool          Unk_29() override;                                  // 29
		void          Unk_2A() override;                                  // 2A
		void          Unk_2B() override;                                  // 2B
		bool          GetWithinPoint(const NiPoint3& a_pos) override;     // 2C
		void          SetCenter(const NiPoint3& a_center) override;       // 2D
		void          Unk_2E() override;                                  // 2E

		// members
		std::uint32_t pad18;   // 18
		NiPoint3      center;  // 1C - world coordinates
		std::uint32_t pad28;   // 28
		NiPoint3      size;    // 2C
		std::uint32_t pad38;   // 38
		std::uint32_t pad3C;   // 3C
	};
	static_assert(sizeof(BSMultiBoundAABB) == 0x40);
}


===============================================
File: include/RE/B/BSMultiBoundNode.h
===============================================
#pragma once

#include "RE/B/BSCullingProcess.h"
#include "RE/B/BSNiNode.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSMultiBound;
	class BSMultiBoundRoom;
	class NiPoint3;

	class BSMultiBoundNode : public BSNiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMultiBoundNode;
		inline static auto           Ni_RTTI = NiRTTI_BSMultiBoundNode;

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                  \
	NiPointer<BSMultiBound>           multiBound;    /* 00 */ \
	BSCullingProcess::BSCPCullingType cullingMode;   /* 08 */ \
	float                             lastAccumTime; /* 0C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x10);

		~BSMultiBoundNode() override;  // 00

		// override (BSNiNode)
		const NiRTTI*     GetRTTI() const override;                           // 02
		BSMultiBoundNode* AsMultiBoundNode() override;                        // 06 - { return this; }
		NiObject*         CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void              LoadBinary(NiStream& a_stream) override;            // 18
		void              LinkObject(NiStream& a_stream) override;            // 19
		bool              RegisterStreamables(NiStream& a_stream) override;   // 1A
		void              SaveBinary(NiStream& a_stream) override;            // 1B
		bool              IsEqual(NiObject* a_object) override;               // 1C
#if !defined(ENABLE_SKYRIM_VR) || (!defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_VR))
		// The following are virtual functions past the point where VR compatibility breaks.
		void UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;  // 2C
		void UpdateWorldBound() override;                                              // 2F
		void OnVisible(NiCullingProcess& a_process) override;                          // 34
		void UpdateUpwardPass(NiUpdateData& a_data) override;                          // 3D
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL BSMultiBoundRoom* GetMultiBoundRoom();                    // 3E - { return 0; }
		SKYRIM_REL_VR_VIRTUAL bool              QPointWithin(const NiPoint3& a_point);  // 3F
		SKYRIM_REL_VR_VIRTUAL void              Unk_40(void);                           // 40
		SKYRIM_REL_VR_VIRTUAL void              Unk_41(void);                           // 41

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSMultiBoundNode) == 0x138);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSMultiBoundNode) == 0x160);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSMultiBoundOBB.h
===============================================
#pragma once

#include "RE/B/BSMultiBoundAABB.h"
#include "RE/N/NiMatrix3.h"

namespace RE
{
	class BSMultiBoundOBB : public BSMultiBoundAABB
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMultiBoundOBB;
		inline static auto           Ni_RTTI = NiRTTI_BSMultiBoundOBB;

		~BSMultiBoundOBB() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
		std::uint32_t GetType() override;                                 // 25 - { return 2; }
		bool          Unk_27() override;                                  // 27
		void          Unk_28() override;                                  // 28
		bool          Unk_29() override;                                  // 29
		void          Unk_2A() override;                                  // 2A
		void          Unk_2B() override;                                  // 2B
		bool          GetWithinPoint(const NiPoint3& a_pos) override;     // 2C
		void          Unk_2E() override;                                  // 2E

		// members
		NiMatrix3     rotation;  // 40
		bool          unk64;     // 64
		std::uint8_t  pad65;     // 65
		std::uint16_t pad66;     // 66
	};
	static_assert(sizeof(BSMultiBoundOBB) == 0x68);
}


===============================================
File: include/RE/B/BSMultiBoundShape.h
===============================================
#pragma once

#include "RE/N/NiObject.h"

namespace RE
{
	class BSMultiBoundShape : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMultiBoundShape;
		inline static auto           Ni_RTTI = NiRTTI_BSMultiBoundShape;

		~BSMultiBoundShape() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		// add
		virtual std::uint32_t GetType() = 0;                          // 25
		virtual float         GetLength() = 0;                        // 26
		virtual bool          Unk_27() = 0;                           // 27
		virtual void          Unk_28() = 0;                           // 28
		virtual bool          Unk_29() = 0;                           // 29
		virtual void          Unk_2A() = 0;                           // 2A
		virtual void          Unk_2B() = 0;                           // 2B
		virtual bool          GetWithinPoint(const NiPoint3& a_pos);  // 2C
		virtual void          SetCenter(const NiPoint3& a_center);    // 2D
		virtual void          Unk_2E();                               // 2E

		// members
		std::uint32_t unk10;  // 10
		std::uint32_t pad14;  // 14
	};
	static_assert(sizeof(BSMultiBoundShape) == 0x18);
}


===============================================
File: include/RE/B/BSMultiIndexTriShape.h
===============================================
#pragma once

#include "RE/B/BSTriShape.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	namespace BSGraphics
	{
		class IndexBuffer;
	}

	class BSShaderProperty;

	class BSMultiIndexTriShape : public BSTriShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMultiIndexTriShape;
		inline static auto           Ni_RTTI = NiRTTI_BSMultiIndexTriShape;

		struct MULTI_INDEX_TRISHAPE_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                       \
	BSGraphics::IndexBuffer*    altIndexBuffer;           /* 00 */ \
	std::uint32_t               altPrimCount;             /* 08 */ \
	DirectX::XMFLOAT4X4         materialProjection;       /* 0C */ \
	std::uint32_t               pad1AC;                   /* 4C */ \
	NiPointer<BSShaderProperty> additionalShaderProperty; /* 50 */ \
	std::uint8_t                useAdditionalTriList;     /* 58 */ \
	std::uint8_t                pad1B9;                   /* 59 */ \
	std::uint16_t               pad1BA;                   /* 5A */ \
	NiColorA                    materialParams;           /* 5C */ \
	float                       materialScale;            /* 6C */ \
	float                       normalDampener;           /* 70 */ \
	std::uint32_t               unk1D4;                   /* 74 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(MULTI_INDEX_TRISHAPE_RUNTIME_DATA) == 0x78);

		~BSMultiIndexTriShape() override;  // 00

		// override (BSGeometry)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
#if !defined(ENABLE_SKYRIM_VR) || (!defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_VR))
		// Compatibility between VR and non-VR breaks beyond this point.
		BSMultiIndexTriShape* AsMultiIndexTriShape() override;  // 35 - { return this; }
#endif

		[[nodiscard]] inline MULTI_INDEX_TRISHAPE_RUNTIME_DATA& GetMultiIndexTrishapeRuntimeData() noexcept
		{
			return REL::RelocateMember<MULTI_INDEX_TRISHAPE_RUNTIME_DATA>(this, 0x160, 0x1A8);
		}

		[[nodiscard]] inline const MULTI_INDEX_TRISHAPE_RUNTIME_DATA& GetMultiIndexTrishapeRuntimeData() const noexcept
		{
			return REL::RelocateMember<MULTI_INDEX_TRISHAPE_RUNTIME_DATA>(this, 0x160, 0x1A8);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 160, 1A8
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSMultiIndexTriShape) == 0x1D8);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSMultiIndexTriShape) == 0x220);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSMultiStreamInstanceTriShape.h
===============================================
#pragma once

#include "RE/B/BSInstanceTriShape.h"

namespace RE
{
	class BSMultiStreamInstanceTriShape : public BSInstanceTriShape
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMultiStreamInstanceTriShape;
		inline static auto           Ni_RTTI = NiRTTI_BSMultiStreamInstanceTriShape;

		struct MULTISTREAM_TRISHAPE_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT         \
	BSTArray<void*> unk160; /* 00 */ \
	std::uint32_t   unk178; /* 18 */ \
	std::uint32_t   unk17C; /* 1C */ \
	std::uint64_t   unk180; /* 20 */ \
	std::uint64_t   unk188; /* 28 */ \
	std::uint32_t   unk190; /* 30 */ \
	std::uint32_t   unk194; /* 34 */ \
	std::uint32_t   unk198; /* 38 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(MULTISTREAM_TRISHAPE_RUNTIME_DATA) == 0x40);

		~BSMultiStreamInstanceTriShape() override;  // 00

		// override (BSInstanceTriShape)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
#if !defined(ENABLE_SKYRIM_VR) || (!defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_VR))
		// The following are virtual functions past the point where VR compatibility breaks.
		void OnVisible(NiCullingProcess& a_process) override;  // 34

		// overrides for BSTriShape
		void          Unk_37(void) override;                                                                                               // 37
		void          BeginAddingInstances(std::uint32_t a_numFloatsPerInstance) override;                                                 // 38
		void          AddInstances(std::uint32_t a_numFloatsPerInstance, std::uint16_t& a_instanceData) override;                          // 39
		void          DoneAddingInstances(BSTArray<std::uint32_t>& a_instances) override;                                                  // 3A
		bool          GetIsAddingInstances() override;                                                                                     // 3B
		std::uint32_t AddGroup(std::uint32_t a_numInstances, std::uint16_t& a_instanceData, std::uint32_t a_arg3, float a_arg4) override;  // 3C
		void          RemoveGroup(std::uint32_t a_numInstance) override;                                                                   // 3D
#endif

		[[nodiscard]] inline MULTISTREAM_TRISHAPE_RUNTIME_DATA& GetMultiStreamTrishapeRuntimeData() noexcept
		{
			return REL::RelocateMember<MULTISTREAM_TRISHAPE_RUNTIME_DATA>(this, 0x160, 0x1A8);
		}

		[[nodiscard]] inline const MULTISTREAM_TRISHAPE_RUNTIME_DATA& GetMultiStreamTrishapeRuntimeData() const noexcept
		{
			return REL::RelocateMember<MULTISTREAM_TRISHAPE_RUNTIME_DATA>(this, 0x160, 0x1A8);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 160, 1A8
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSMultiStreamInstanceTriShape) == 0x1A0);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSMultiStreamInstanceTriShape) == 0x1E8);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSMusicEvent.h
===============================================
#pragma once

namespace RE
{
	class BSIMusicType;

	struct BSMusicEvent
	{
	public:
		enum class MUSIC_MESSAGE_TYPE
		{
			kAdd,
			kRemove,
			kRemoveImmediate,
			kPause,
			kUnpause
		};

		BSIMusicType*                                      musicType;  // 00
		stl::enumeration<MUSIC_MESSAGE_TYPE, std::int32_t> msgType;    // 08
		std::uint32_t                                      pad0C;      // 0C
	};
	static_assert(sizeof(BSMusicEvent) == 0x10);
}


===============================================
File: include/RE/B/BSMusicManager.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	class BSIMusicType;
	struct BSMusicEvent;

	class BSMusicManager :
		public BSTSingletonSDM<BSMusicManager>,  // 00
		public BSTEventSink<BSMusicEvent>        // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSMusicManager;

		~BSMusicManager() override;  // 00

		// override (BSTEventSink<BSMusicEvent>)
		BSEventNotifyControl ProcessEvent(const BSMusicEvent* a_event, BSTEventSource<BSMusicEvent>* a_eventSource) override;  // 01

		[[nodiscard]] static BSMusicManager* GetSingleton()
		{
			REL::Relocation<BSMusicManager**> singleton{ RELOCATION_ID(514738, 400896) };
			return *singleton;
		}

		// members
		BSTArray<BSIMusicType*> musicQueue;  // 10
		BSIMusicType*           current;     // 28
		std::uint32_t           unk30;       // 30
		std::uint32_t           pad34;       // 34
	};
	static_assert(sizeof(BSMusicManager) == 0x38);
}


===============================================
File: include/RE/B/BSNavmesh.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/M/MemoryManager.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSNavmeshObstacleData;
	class BSNavmeshObstacleUndoData;
	class BSPathingCell;
	class BSPathingDoor;

	enum class EDGE_EXTRA_INFO_TYPE
	{
		kInvalid = static_cast<std::underlying_type_t<EDGE_EXTRA_INFO_TYPE>>(-1),
		kPortal = 0,
		kLedgeUp = 1,
		kLedgeDown = 2,
		kEnableDisablePortal = 3
	};

	struct BSNavmeshVertex
	{
	public:
		// members
		NiPoint3 location;  // 0
	};
	static_assert(sizeof(BSNavmeshVertex) == 0xC);

	struct BSNavmeshTriangle
	{
	public:
		// reference:
		// edge 0-1 = 0
		// edge 1-2 = 1
		// edge 2-0 = 2
		enum class TriangleFlag
		{
			kNone = 0,
			kEdge0_Link = 1 << 0,
			kEdge1_Link = 1 << 1,
			kEdge2_Link = 1 << 2,
			kDeleted = 1 << 3,
			kNoLargeCreatures = 1 << 4,
			kOverlapping = 1 << 5,
			kPreferred = 1 << 6,
		};

		// reference:
		// quarter = 1/4
		// half = 2/4
		// tri = 3/4
		// full = 4/4
		enum class TraversalFlag
		{
			kNone = 0,
			kEdge0_CoverValueQuarter = 1 << 0,
			kEdge0_CoverValueHalf = 1 << 1,
			kEdge0_CoverValueTri = 1 << 2,
			kEdge0_CoverValueFull = 1 << 3,
			kEdge0_Left = 1 << 4,
			kEdge0_Right = 1 << 5,
			kEdge1_CoverValueQuarter = 1 << 6,
			kEdge1_CoverValueHalf = 1 << 7,
			kEdge1_CoverValueTri = 1 << 8,
			kEdge1_CoverValueFull = 1 << 9,
			kEdge1_Left = 1 << 10,
			kEdge1_Right = 1 << 11
		};

		// members
		std::uint16_t                                  vertices[3];     // 00
		std::uint16_t                                  triangles[3];    // 06 - 0xFF == NONE
		stl::enumeration<TriangleFlag, std::uint16_t>  triangleFlags;   // 0C
		stl::enumeration<TraversalFlag, std::uint16_t> traversalFlags;  // 0E
	};
	static_assert(sizeof(BSNavmeshTriangle) == 0x10);

	struct BSNavmeshTriangleEdgePortal
	{
	public:
		// members
		FormID        otherMeshID;  // 0
		std::uint16_t triangle;     // 4
		std::int8_t   edgeIndex;    // 6
		std::uint8_t  pad7;         // 7
	};
	static_assert(sizeof(BSNavmeshTriangleEdgePortal) == 0x8);

	struct BSNavmeshEdgeExtraInfo
	{
	public:
		// members
		stl::enumeration<EDGE_EXTRA_INFO_TYPE, std::uint32_t> type;    // 0
		BSNavmeshTriangleEdgePortal                           portal;  // 4
	};
	static_assert(sizeof(BSNavmeshEdgeExtraInfo) == 0xC);

	struct BSNavmeshTriangleDoorPortal
	{
	public:
		// members
		BSTSmartPointer<BSPathingDoor> door;                 // 00
		std::uint16_t                  owningTriangleIndex;  // 08
		std::uint16_t                  pad0A;                // 0A
		std::uint32_t                  pad0C;                // 0C
	};
	static_assert(sizeof(BSNavmeshTriangleDoorPortal) == 0x10);

	struct BSNavmeshClosedDoorInfo
	{
	public:
		// members
		BSTSmartPointer<BSPathingDoor> door;           // 00
		std::uint16_t                  triangleIndex;  // 08
		std::uint16_t                  pad0A;          // 0A
		std::uint32_t                  pad0C;          // 0C
	};
	static_assert(sizeof(BSNavmeshClosedDoorInfo) == 0x10);

	struct BSNavmeshCoverEdge
	{
	public:
		// members
		std::uint16_t vertices[2];  // 00
		std::uint32_t data;         // 08
	};
	static_assert(sizeof(BSNavmeshCoverEdge) == 0x8);

	struct BSNavmeshGrid
	{
	public:
		// members
		std::uint32_t                        gridSize;          // 00
		float                                columnSectionLen;  // 04
		float                                rowSectionLen;     // 08
		NiPoint3                             gridBoundsMin;     // 0C
		NiPoint3                             gridBoundsMax;     // 18
		std::uint32_t                        pad24;             // 14
		SimpleArray<BSTArray<std::uint16_t>> gridData;          // 28
	};
	static_assert(sizeof(BSNavmeshGrid) == 0x30);

	class BSNavmesh : public BSIntrusiveRefCounted  // NVNM
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSNavmesh;

		virtual ~BSNavmesh();  // 00

		// add
		virtual std::uint32_t QNavmeshID() = 0;  // 01

		// members
		std::uint32_t                                                pad00C;                 // 00C
		BSTArray<BSNavmeshVertex>                                    vertices;               // 010
		BSTArray<BSNavmeshTriangle>                                  triangles;              // 028
		BSTArray<BSNavmeshEdgeExtraInfo>                             extraEdgeInfo;          // 040
		BSTArray<BSNavmeshTriangleDoorPortal>                        doorPortals;            // 058
		BSTArray<BSNavmeshClosedDoorInfo>                            closedDoors;            // 070
		BSTArray<BSNavmeshCoverEdge>                                 coverArray;             // 088
		BSNavmeshGrid                                                meshGrid;               // 0A0
		BSTArray<NiPointer<BSNavmeshObstacleUndoData>>               obstacles;              // 0D0
		BSTHashMap<std::uint16_t, NiPointer<BSNavmeshObstacleData>>* triangleToObstacleMap;  // 0E8
		BSTArray<void*>                                              unk0F0;                 // 0F0 - obstaclePOVs/disabledLinks?
		BSTSmartPointer<BSPathingCell>                               parentCell;             // 108
		void*                                                        unk110;                 // 110 - navmeshInfo?
	};
	static_assert(sizeof(BSNavmesh) == 0x118);
}


===============================================
File: include/RE/B/BSNavmeshInfoMap.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	struct BSNavmeshInfo;

	class BSNavmeshInfoMap : public BSTSingletonExplicit<BSNavmeshInfoMap>
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSNavmeshInfoMap;

		struct IVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSNavmeshInfoMap__IVisitor;

			virtual ~IVisitor();  // 00

			// add
			virtual BSContainer::ForEachResult Visit(const BSNavmeshInfo* a_info) = 0;
		};
		static_assert(sizeof(IVisitor) == 0x8);

		virtual ~BSNavmeshInfoMap();  // 00

		// add
		virtual BSNavmeshInfo* GetNavMeshInfoFixID(std::uint32_t a_id) = 0;                                                      // 01
		virtual BSNavmeshInfo* GetNavmeshInfo(std::uint32_t a_id) = 0;                                                           // 02
		virtual void           GetAllNavMeshInfo(BSTArray<BSNavmeshInfo*>& a_results) = 0;                                       // 03
		virtual void           BuildListOfConnectedInfos(const BSNavmeshInfo* a_info, BSTArray<BSNavmeshInfo*>& a_results) = 0;  // 04
		virtual void           ForEach(IVisitor* a_visitor) = 0;                                                                 // 05
	};
	static_assert(sizeof(BSNavmeshInfoMap) == 0x8);
}


===============================================
File: include/RE/B/BSNiAllocator.h
===============================================
#pragma once

#include "RE/N/NiAllocator.h"

namespace RE
{
	class BSNiAllocator : public NiAllocator
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSNiAllocator;

		~BSNiAllocator() override;  // 00

		// override (
		void* Allocate(std::size_t& a_sizeInBytes, std::size_t& a_alignment, NiMemEventType a_eventType, bool a_provideAccurateSizeOnDeallocate, const char* a_file, std::int32_t a_line, const char* a_function) override;                                          // 01
		void  Deallocate(void* a_memory, NiMemEventType a_eventType, std::size_t a_sizeInBytes) override;                                                                                                                                                            // 02
		void* Reallocate(void* a_memory, size_t& a_sizeInBytes, std::size_t& a_alignment, NiMemEventType a_eventType, bool a_provideAccurateSizeOnDeallocate, std::size_t a_sizeCurrent, const char* a_file, std::int32_t a_line, const char* a_function) override;  // 03
		bool  TrackAllocate(const void* const a_memory, std::size_t a_sizeInBytes, NiMemEventType a_eventType, const char* a_file, std::int32_t a_line, const char* a_function) override;                                                                            // 04
		bool  TrackDeallocate(const void* const a_memory, NiMemEventType a_eventType) override;                                                                                                                                                                      // 05
		void  Unk_06(void) override;                                                                                                                                                                                                                                 // 06 - implements a realloc
		void  Initialize() override;                                                                                                                                                                                                                                 // 07 - { return; }
		void  Shutdown() override;                                                                                                                                                                                                                                   // 08 - { return; }
		bool  VerifyAddress(const void* a_memory) override;                                                                                                                                                                                                          // 09 - { return true; }
	};
	static_assert(sizeof(BSNiAllocator) == 0x8);
}


===============================================
File: include/RE/B/BSNiNode.h
===============================================
#pragma once

#include "RE/N/NiNode.h"

namespace RE
{
	class BSNiNode : public NiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSNiNode;
		inline static auto           Ni_RTTI = NiRTTI_BSNiNode;

		~BSNiNode() override;  // 00

		// override (NiNode)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSNiNode) == 0x128);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSNiNode) == 0x150);
#endif
}


===============================================
File: include/RE/B/BSOpenVR.h
===============================================
#pragma once

#include "RE/B/BSVRInterface.h"

namespace RE
{
	class BSOpenVR : public BSVRInterface
	{
	public:
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		constexpr static auto RTTI = RTTI_BSOpenVR;
#endif
		~BSOpenVR() override;  // 00

		// override BSVRInterface
		void* Shutdown(void) override;  // 01
		void  Unk_02(void) override;    // 02
		void  Unk_03(void) override;    // 03
		void  Unk_04(void) override;    // 04
		void  Unk_05(void) override;    // 05
		void  Unk_06(void) override;    // 06
		void  Unk_07(void) override;    // 07
		void  Unk_08(void) override;    // 08
		void  Unk_09(void) override;    // 09
		void  Unk_0A(void) override;    // 0A
		void  Unk_0B(void) override;    // 0B
		void  Unk_0C(void) override;    // 0C
		void  Unk_0D(void) override;    // 0D
		void  Unk_0E(void) override;    // 0E
		void  Unk_0F(void) override;    // 0F
		void  Unk_10(void) override;    // 10
		void  Unk_12(void) override;    // 12
		void  Unk_13(void) override;    // 13
		void  Unk_14(void) override;    // 14
		void  Unk_16(void) override;    // 16
		void  Unk_17(void) override;    // 17
	};
}


===============================================
File: include/RE/B/BSOpenVRControllerDevice.h
===============================================
#pragma once

#include "RE/B/BSTrackedControllerDevice.h"

namespace RE
{
	class BSOpenVRControllerDevice : public BSTrackedControllerDevice
	{
	public:
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		inline static constexpr auto RTTI = RTTI_BSOpenVRControllerDevice;
#endif

		~BSOpenVRControllerDevice() override;

		// override BSIInputDevice
		void               Initialize() override;                                                  // 01
		void               Process(float a_arg1) override;                                         // 02
		void               Release() override;                                                     // 03 - { return; }
		bool               GetKeyMapping(std::uint32_t a_key, BSFixedString& a_mapping) override;  // 04
		std::uint32_t      GetMappingKey(BSFixedString a_mapping) override;                        // 05
		bool               GetMappedKeycode(std::uint32_t a_key, std::uint32_t& outKeyCode) override;  // 06
		[[nodiscard]] bool IsEnabled() const override;                                             // 07 - { return true; }
		void               Reset() override;                                                       // 08

	private:
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		uint8_t  unk70[0xBC];  // 78
		uint64_t unk134;       // 134
		uint64_t unk138;       // 13C
		uint32_t unk140;       // 144
		uint32_t unk144;       // 148
		uint32_t unk148{ 4 };  // 14C
#endif
	};
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSOpenVRControllerDevice) == 0x150);
#endif
}


===============================================
File: include/RE/B/BSOrderedNode.h
===============================================
#pragma once

#include "RE/B/BSNiNode.h"

namespace RE
{
	class BSOrderedNode : public BSNiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSOrderedNode;
		inline static auto           Ni_RTTI = NiRTTI_BSOrderedNode;

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT               \
	NiBound       orderedBound;   /* 00 */ \
	bool          useStaticBound; /* 10 */ \
	std::uint32_t pad13C;         /* 11 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x18);

		~BSOrderedNode() override;  // 00

		// override (BSNiNode)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
#if !defined(ENABLE_SKYRIM_VR) || (!defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_VR))
		// The following are virtual functions past the point where VR compatibility breaks.
		void UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;          // 2C
		void UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;  // 2D
		void OnVisible(NiCullingProcess& a_process) override;                                  // 34
#endif

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(BSOrderedNode) == 0x140);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(BSOrderedNode) == 0x168);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSPCGamepadDeviceDelegate.h
===============================================
#pragma once

#include "RE/B/BSGamepadDevice.h"

namespace RE
{
	class BSPCGamepadDeviceHandler;

	class BSPCGamepadDeviceDelegate : public BSGamepadDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSPCGamepadDeviceDelegate;
		inline static constexpr auto VTABLE = VTABLE_BSPCGamepadDeviceDelegate;

		~BSPCGamepadDeviceDelegate() override;  // 00

		// override (BSGamepadDevice)
		void Initialize() override;                               // 01 - { return; }
		void Process(float a_arg1) override;                      // 02 - { return; }
		void Release() override;                                  // 03 - { return; }
		void Reset() override;                                    // 08 - { return; }
		void SetRumble(float a_lValue, float a_rValue) override;  // 09 - { return; }

		// members
		BSPCGamepadDeviceHandler* gamepadDeviceHandler;  // D0

	protected:
		friend class BSGamepadDeviceHandler;
		BSPCGamepadDeviceDelegate();
	};
	static_assert(sizeof(BSPCGamepadDeviceDelegate) == 0xD8);
}


===============================================
File: include/RE/B/BSPCGamepadDeviceHandler.h
===============================================
#pragma once

#include "RE/B/BSIInputDevice.h"

namespace RE
{
	class BSPCGamepadDeviceDelegate;

	class BSPCGamepadDeviceHandler : public BSIInputDevice
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSPCGamepadDeviceHandler;
		inline static constexpr auto VTABLE = VTABLE_BSPCGamepadDeviceHandler;

		~BSPCGamepadDeviceHandler() override;  // 00

		// override (BSIInputDevice)
		void          Initialize() override;                                                      // 01
		void          Process(float a_unk1) override;                                             // 02
		void          Release() override;                                                         // 03
		bool          GetKeyMapping(std::uint32_t a_key, BSFixedString& a_mapping) override;      // 04
		std::uint32_t GetMappingKey(BSFixedString a_mapping) override;                            // 05
		bool          GetMappedKeycode(std::uint32_t a_key, std::uint32_t& outKeyCode) override;  // 06
		bool          IsEnabled() const override;                                                 // 07 - { return currentPCGamePadDelegate != 0; }
		void          Reset() override;                                                           // 08

		void InitializeDelegate();  // called by Initialize() and Process() to initialize the delegate

		// members
		BSPCGamepadDeviceDelegate* currentPCGamePadDelegate;  // 08
	protected:
		friend class BSInputDeviceFactory;
		BSPCGamepadDeviceHandler();
	};

	static_assert(sizeof(BSPCGamepadDeviceHandler) == 0x10);
}


===============================================
File: include/RE/B/BSPCOrbisGamepadDevice.h
===============================================
#pragma once

#include "RE/B/BSPCGamepadDeviceDelegate.h"

namespace RE
{
	// PS4 controller used via HID polling
	class BSPCOrbisGamepadDevice : public BSPCGamepadDeviceDelegate
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSPCOrbisGamepadDevice;
		inline static constexpr auto VTABLE = VTABLE_BSPCOrbisGamepadDevice;

		struct Keys
		{
			enum Key : std::uint32_t
			{
				// Masks for buttonState
				// Key hardware value.  Matches SCE_PAD_BUTTON_* enum values on ORBIS
				KUp = 0x0010,
				kDown = 0x0040,
				kLeft = 0x0080,
				kRight = 0x0020,
				kPS3_Start = 0x0008,
				kPS3_Back = 0x00100000,  // This is mapped to the touchpad on the PS4 controller
				kPS3_L3 = 0x0002,
				kPS3_R3 = 0x0004,
				kPS3_LB = 0x0400,
				kPS3_RB = 0x0800,
				kPS3_A = 0x4000,
				kPS3_B = 0x2000,
				kPS3_X = 0x8000,
				kPS3_Y = 0x1000,

				// Unused by Skyrim
				kPS4_Share = 0x0001,   // Skyrim uses the touchpad for Back and leaves the Share button unused
				kPS4_L2 = 0x0100,      // Skyrim uses trigger axis read instead of button press
				kPS4_R2 = 0x0200,      // Skyrim uses trigger axis read instead of button press
				kPS4_PSBtn = 0x10000,  // Playstation button

				// arbitrary values
				// IDs meant to be used with ButtonEvent
				kPS3_LT = 0x0009,
				kPS3_RT = 0x000a,
				// IDs meant to be used with ThumbstickEvent
				kPS3_LS = 0x000b,
				kPS3_RS = 0x000c,
			};
		};
		using Key = Keys::Key;

		struct ButtonState
		{
			bool Share: 1;            // 0x0001 -- unused by Skyrim
			bool L3: 1;               // 0x0002
			bool R3: 1;               // 0x0004
			bool Start: 1;            // 0x0008
			bool Up: 1;               // 0x0010
			bool Right: 1;            // 0x0020
			bool Down: 1;             // 0x0040
			bool Left: 1;             // 0x0080
			bool L2btn: 1;            // 0x0100 -- unused by Skyrim, which uses axis data
			bool R2btn: 1;            // 0x0200 -- unused by Skyrim, which uses axis data
			bool LB: 1;               // 0x0400
			bool RB: 1;               // 0x0800
			bool Triangle_Y: 1;       // 0x1000
			bool Circle_B: 1;         // 0x2000
			bool Cross_A: 1;          // 0x4000
			bool Square_X: 1;         // 0x8000
			bool PSbtn: 1;            // 0x00010000 -- unused by Skyrim
			bool _unused20000: 1;     // 0x00020000
			bool _unused40000: 1;     // 0x00040000
			bool _unused80000: 1;     // 0x00080000
			bool Touchpad: 1;         // 0x00100000
			bool _unused200000: 1;    // 0x00200000
			bool _unused400000: 1;    // 0x00400000
			bool _unused800000: 1;    // 0x00800000
			bool _unused1000000: 1;   // 0x01000000
			bool _unused2000000: 1;   // 0x02000000
			bool _unused4000000: 1;   // 0x04000000
			bool _unused8000000: 1;   // 0x08000000
			bool _unused10000000: 1;  // 0x10000000
			bool _unused20000000: 1;  // 0x20000000
			bool _unused40000000: 1;  // 0x40000000
			bool _Intercepted: 1;     // 0x80000000
		};
		static_assert(sizeof(ButtonState) == 0x4);

		struct Vector3
		{
			float x;  // 00
			float y;  // 04
			float z;  // 08
		};
		static_assert(sizeof(Vector3) == 0x0C);

		struct Vector4
		{
			float x;  // 00
			float y;  // 04
			float z;  // 08
			float w;  // 0C
		};
		static_assert(sizeof(Vector4) == 0x10);

		struct PadTouch
		{
			std::uint16_t x;          // 00
			std::uint16_t y;          // 02
			std::uint8_t  touch_id;   // 04
			std::uint8_t  pad_05[3];  // 05
		};
		static_assert(sizeof(PadTouch) == 0x08);

		struct TouchPadData
		{
			std::uint8_t  touchNum;   // 00 - Number of touch reports
			std::uint8_t  pad_01[3];  // 01
			std::uint32_t pad_04;     // 04
			PadTouch      touch[2];   // 08 - Touch Data for max number of touch points = 2
		};
		static_assert(sizeof(TouchPadData) == 0x18);

		struct UnusedExtensionData
		{
			std::uint32_t extUnitId;   // 00
			std::uint8_t  pad04;       // 04
			std::uint8_t  dataLength;  // 05
			std::uint8_t  data[10];    // 06
		};
		static_assert(sizeof(UnusedExtensionData) == 0x10);

		struct GamepadData
		{
			std::uint32_t       buttonState;      // 00
			std::byte           rawLeftStickX;    // 04
			std::byte           rawLeftStickY;    // 05
			std::byte           rawRightStickX;   // 06
			std::byte           rawRightStickY;   // 07
			std::byte           rawLeftTrigger;   // 08
			std::byte           rawRightTrigger;  // 09
			std::byte           pad_0A[2];        // 0A
			Vector4             orientation;      // 0C
			Vector3             acceleration;     // 1C
			Vector3             angularVelocity;  // 28
			TouchPadData        touchPadData;     // 34
			bool                padConnected;     // 4C
			std::byte           pad_4D[3];        // 4D
			std::uint64_t       timestamp;        // 50
			UnusedExtensionData unusedExtData;    // 58 -- unused
			uint8_t             connectedCount;   // 68 -- Controller handle connected count
			uint8_t             pad_69[2];        // 69 -- nice.
			uint8_t             specialDataLen;   // 6B
			uint8_t             specialData[12];  // 6C -- Device data for special controllers
		};
		static_assert(sizeof(GamepadData) == 0x78);

		~BSPCOrbisGamepadDevice() override;  // 00

		// override (BSPCGamepadDeviceDelegate)
		void Initialize() override;                                                                   // 01
		void Process(float a_arg1) override;                                                          // 02
		void Release() override;                                                                      // 03
		void Reset() override;                                                                        // 08 - { memset(this+0xD8, 0, 0x120); }
		void SetRumble(float lValue, float rValue) override;                                          // 09
		void SetLEDColor(ColorParam* colorParam) override;                                            // 0A
		void ResetLEDColor() override;                                                                // 0B
		void ProcessRawInput(int32_t a_rawX, int32_t a_rawY, float& a_outX, float& a_outY) override;  // 0D
		void Unk_0E(void) override;                                                                   // 0E - { return; }

		ButtonState GetPreviousButtonState() const
		{
			return stl::unrestricted_cast<ButtonState>(previousPadState.buttonState);
		}

		ButtonState GetCurrentButtonState() const
		{
			return stl::unrestricted_cast<ButtonState>(currentPadState.buttonState);
		}

		// members
		GamepadData previousPadState;  // D8
		float       previousLT;        // 150
		float       previousRT;        // 154
		float       previousLX;        // 158
		float       previousLY;        // 15C
		float       previousRX;        // 160
		float       previousRY;        // 164
		GamepadData currentPadState;   // 168
		float       currentLT;         // 1E0
		float       currentRT;         // 1E4
		float       currentLX;         // 1E8
		float       currentLY;         // 1EC
		float       currentRX;         // 1F0
		float       currentRY;         // 1F4

	protected:
		friend class BSGamepadDeviceHandler;
		BSPCOrbisGamepadDevice();
	};
	static_assert(sizeof(BSPCOrbisGamepadDevice) == 0x1F8);
}


===============================================
File: include/RE/B/BSParticleShaderCubeEmitter.h
===============================================
#pragma once

#include "RE/B/BSParticleShaderEmitter.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class BSParticleShaderCubeEmitter : public BSParticleShaderEmitter
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSParticleShaderCubeEmitter;

		~BSParticleShaderCubeEmitter() override;  // 00

		// override (BSParticleShaderEmitter)
		bool Generate(bool a_arg1, NiPoint3& a_arg2, NiPoint3& a_arg3) override;  // 03 - { return false; }

		// members
		alignas(0x10) DirectX::XMFLOAT4X4 occlusionProjection;  // ED0
		NiPoint3 cameraOffsetVector;                            // F10
		NiPoint3 offsetVector;                                  // F1C
		NiPoint3 compositeOffsetVector;                         // F28
		NiPoint3 frameVelocityVector;                           // F34
		NiPoint3 windVelocity;                                  // F40
		NiPoint3 gravityVelocity;                               // F4C
		float    rotation;                                      // F58
		float    rotationVelocity;                              // F5C
		float    cubeSize;                                      // F60
		float    density;                                       // F64
		NiPoint3 instanceOffsets[10];                           // F68
	};
	static_assert(sizeof(BSParticleShaderCubeEmitter) == 0xFE0);
}


===============================================
File: include/RE/B/BSParticleShaderEmitter.h
===============================================
#pragma once

#include "RE/N/NiRefObject.h"

namespace RE
{
	class BSParticleShaderProperty;
	class NiAVObject;

	class BSParticleShaderEmitter : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSParticleShaderEmitter;

		enum class EMITTER_TYPE
		{
			kGeometry = 0,
			kCollision = 1,
			kRay = 2,
			kSnow = 3,
			kRain = 4
		};

		class TextureAnimInfo
		{
		public:
			// members
			float         currentFrame;  // 00
			std::uint32_t totalFrames;   // 04
		};
		static_assert(sizeof(TextureAnimInfo) == 0x08);

		struct ParticleData
		{
		public:
			// members
			float        XPos;           // 00
			float        YPos;           // 04
			float        ZPos;           // 08
			float        age;            // 0C
			float        XVel;           // 10
			float        YVel;           // 14
			float        ZVel;           // 18
			float        lifeAdjust;     // 1C
			float        rotationStart;  // 20
			float        rotationSpeed;  // 24
			float        speedMult;      // 28
			std::uint8_t texCoordU;      // 29
			std::uint8_t texCoordV;      // 2A
			std::uint8_t vertexX;        // 2B
			std::uint8_t vertexY;        // 2C
		};
		static_assert(sizeof(ParticleData) == 0x30);

		virtual ~BSParticleShaderEmitter();  // 00

		// add
		virtual NiAVObject* GetBoundsObject();                                              // 02
		virtual bool        Generate(bool a_arg1, NiPoint3& a_arg2, NiPoint3& a_arg3) = 0;  // 03

		// members
		BSParticleShaderProperty*                     property;          // 10
		stl::enumeration<EMITTER_TYPE, std::uint16_t> emitterType;       // 18
		std::uint16_t                                 particleCount;     // 1A
		float                                         alpha;             // 1C
		float                                         generateReminder;  // 20
		float                                         maxParticleRatio;  // 24
		TextureAnimInfo*                              textureAnims;      // 28
		ParticleData                                  instanceData[78];  // 30
	};
	static_assert(sizeof(BSParticleShaderEmitter) == 0xED0);
}


===============================================
File: include/RE/B/BSParticleShaderObjectEmitter.h
===============================================
#pragma once

#include "RE/B/BSParticleShaderEmitter.h"

namespace RE
{
	class BSParticleShaderObjectEmitter : public BSParticleShaderEmitter
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSParticleShaderObjectEmitter;

		~BSParticleShaderObjectEmitter() override;  // 00

		// override (BSParticleShaderEmitter)
		NiAVObject* GetBoundsObject() override;  // 02

		// add
		virtual void          CollectObjects(NiAVObject* a_targetRoot, std::uint16_t a_depthLimit, std::uint16_t a_arg3, bool a_nodeFilterFunc(const BSFixedString&)) = 0;  // 03
		virtual std::uint32_t GetObjectCount() = 0;                                                                                                                         // 05
		virtual NiAVObject*   GetObjectAt(std::size_t a_index) = 0;                                                                                                         // 06

		// members
		NiPointer<NiAVObject> targetRoot;    // ED0
		NiAVObject*           boundsObject;  // ED8
	};
	static_assert(sizeof(BSParticleShaderObjectEmitter) == 0xEE0);
}


===============================================
File: include/RE/B/BSParticleShaderProperty.h
===============================================
#pragma once

#include "RE/B/BSShaderProperty.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiSourceTexture;
	class BSParticleShaderGeometry;
	class BSParticleShaderEmitter;

	class BSParticleShaderProperty : public BSShaderProperty
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSParticleShaderProperty;
		inline static auto           Ni_RTTI = NiRTTI_BSParticleShaderProperty;

		virtual ~BSParticleShaderProperty();  // 00

		// override (BSShaderProperty)
		const NiRTTI*    GetRTTI() const override;                                                                                    // 02
		bool             SetupGeometry(BSGeometry* a_geometry) override;                                                              // 27 - { particleShaderGeometry = newGeometry; }
		RenderPassArray* GetRenderPasses(BSGeometry* a_geometry, std::uint32_t a_arg2, BSShaderAccumulator* a_accumulator) override;  // 2A
		std::int32_t     QShader() override;                                                                                          // 35 - { return 5; }
		NiSourceTexture* GetBaseTexture() override;                                                                                   // 37 - { return particleShaderTexture; }

		// members
		bool                                         useWorldSpace;                    // 088
		bool                                         particleGreyscaleAlpha;           // 08A
		std::uint8_t                                 unk8B;                            // 08B
		float                                        particleLifetime;                 // 08C
		float                                        particleLifetimeVariance;         // 090
		float                                        initialSpeedAlongNormal;          // 094
		float                                        initialSpeedAlongNormalVariance;  // 098
		float                                        accelerationAlongNormal;          // 09C
		float                                        initialVelocity1;                 // 0A0
		float                                        initialVelocity2;                 // 0A4
		float                                        intialVelocity3;                  // 0A8
		float                                        acceleration1;                    // 0AC
		float                                        acceleration2;                    // 0B0
		float                                        acceleration3;                    // 0B4
		float                                        birthPositionOffset;              // 0B8
		float                                        birthPositionVarianceOffset;      // 0BC
		float                                        particleShaderInitialRotation;    // 0C0
		float                                        intialRotationVariance;           // 0C4
		float                                        rotationSpeed;                    // 0C8
		float                                        rotationSpeedVariance;            // 0CC
		bool                                         unk0D0;                           // 0D0
		std::uint8_t                                 pad0D1;                           // 0D1
		std::uint16_t                                pad0D2;                           // 0D2
		float                                        animatedStartFrame;               // 0D4
		float                                        animatedStartFrameVariance;       // 0D8
		float                                        animatedEndFrame;                 // 0DC
		float                                        animatedEndFrameVariance;         // 0E0
		float                                        animatedLoopStartVariance;        // 0E4
		float                                        animatedFrameCount;               // 0E8
		float                                        animatedFrameCountVariance;       // 0EC
		std::uint32_t                                colorScale;                       // 0F0
		float                                        colorKey1Time;                    // 0F4
		float                                        colorKey2Time;                    // 0F8
		float                                        colorKey3Time;                    // 0FC
		NiColorA                                     colorKey1;                        // 100
		NiColorA                                     colorKey2;                        // 110
		NiColorA                                     colorKey3;                        // 120
		float                                        scaleKey1;                        // 130
		float                                        scaleKey2;                        // 134
		float                                        scaleKey1Time;                    // 138
		float                                        scaleKey2Time;                    // 13C
		NiPointer<NiSourceTexture>                   particleShaderTexture;            // 140
		NiPointer<NiSourceTexture>                   particlePaletteTexture;           // 148
		BSTArray<NiPointer<BSParticleShaderEmitter>> particleEmitters;                 // 150
		NiPointer<BSParticleShaderGeometry>          particleShaderGeometry;           // 168
		float                                        unk170;                           // 170
		float                                        textureCountU;                    // 174
		float                                        textureCountV;                    // 178
		NiPoint3                                     windPoint;                        // 17C
		float                                        explosionWindSpeed;               // 188
		std::uint32_t                                unk18C;                           // 18C
		BSParticleShaderEmitter*                     particleEmitter;                  // 190
	};
	static_assert(sizeof(BSParticleShaderProperty) == 0x198);
}


===============================================
File: include/RE/B/BSPathingCell.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"

namespace RE
{
	class BSPathingCell : public BSIntrusiveRefCounted
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSPathingCell;

		virtual ~BSPathingCell();  // 00

		// add
		virtual std::uint32_t GetType() const = 0;  // 01 - crc32 hash of class name
		virtual void          Unk_02(void) = 0;     // 02
		virtual void          Unk_03(void) = 0;     // 03
		virtual void          Unk_04(void) = 0;     // 04
		virtual void          Unk_05(void) = 0;     // 05
		virtual void          Unk_06(void) = 0;     // 06
		virtual void          Unk_07(void) = 0;     // 07
		virtual void          Unk_08(void) = 0;     // 08
		virtual void          Unk_09(void) = 0;     // 09
		virtual void          Unk_0A(void) = 0;     // 0A

		// members
		std::uint32_t unk0C;  // 0C
	};
	static_assert(sizeof(BSPathingCell) == 0x10);
}


===============================================
File: include/RE/B/BSPointerHandle.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class Actor;
	class HandleManager;
	class Projectile;
	class TESObjectREFR;

	template <std::uint32_t = 21, std::uint32_t = 5>
	class BSUntypedPointerHandle;

	template <class, class = BSUntypedPointerHandle<>>
	class BSPointerHandle;

	template <class, class = HandleManager>
	class BSPointerHandleManagerInterface;

	template <std::uint32_t FREE_LIST_BITS, std::uint32_t AGE_SHIFT>
	class BSUntypedPointerHandle
	{
	public:
		using value_type = std::uint32_t;

		enum : std::uint32_t
		{
			kFreeListBits = FREE_LIST_BITS,
			kAgeShift = AGE_SHIFT,
		};

		BSUntypedPointerHandle() noexcept = default;
		BSUntypedPointerHandle(const BSUntypedPointerHandle&) noexcept = default;

		BSUntypedPointerHandle(BSUntypedPointerHandle&& a_rhs) noexcept :
			_handle(a_rhs._handle)
		{
			a_rhs.reset();
		}

		explicit BSUntypedPointerHandle(value_type a_handle) noexcept :
			_handle(a_handle)
		{}

		~BSUntypedPointerHandle() noexcept { reset(); }

		BSUntypedPointerHandle& operator=(const BSUntypedPointerHandle&) noexcept = default;

		BSUntypedPointerHandle& operator=(BSUntypedPointerHandle&& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				_handle = a_rhs._handle;
				a_rhs.reset();
			}
			return *this;
		}

		BSUntypedPointerHandle& operator=(value_type a_rhs) noexcept
		{
			_handle = a_rhs;
			return *this;
		}

		[[nodiscard]] explicit operator bool() const noexcept { return has_value(); }
		[[nodiscard]] bool     has_value() const noexcept { return _handle != 0; }

		[[nodiscard]] value_type value() const noexcept { return _handle; }

		void reset() noexcept { _handle = 0; }

		[[nodiscard]] friend bool operator==(const BSUntypedPointerHandle& a_lhs, const BSUntypedPointerHandle& a_rhs) noexcept
		{
			return a_lhs.value() == a_rhs.value();
		}

		[[nodiscard]] friend bool operator!=(const BSUntypedPointerHandle& a_lhs, const BSUntypedPointerHandle& a_rhs) noexcept
		{
			return !(a_lhs == a_rhs);
		}

	private:
		// members
		value_type _handle{ 0 };  // 0
	};

	extern template class BSUntypedPointerHandle<>;

	template <class T, class Handle>
	class BSPointerHandle
	{
	public:
		using native_handle_type = typename Handle::value_type;

		BSPointerHandle() noexcept = default;
		BSPointerHandle(const BSPointerHandle&) noexcept = default;
		BSPointerHandle(BSPointerHandle&&) noexcept = default;

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					T*>,
				int> = 0>
		explicit BSPointerHandle(Y* a_rhs)
		{
			get_handle(a_rhs);
		}

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					T*>,
				int> = 0>
		BSPointerHandle(const BSPointerHandle<Y, Handle>& a_rhs) noexcept :
			_handle(a_rhs._handle)
		{}

		BSPointerHandle& operator=(const BSPointerHandle&) noexcept = default;
		BSPointerHandle& operator=(BSPointerHandle&&) noexcept = default;

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					T*>,
				int> = 0>
		BSPointerHandle& operator=(Y* a_rhs)
		{
			get_handle(a_rhs);
			return *this;
		}

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					T*>,
				int> = 0>
		BSPointerHandle& operator=(const BSPointerHandle<Y, Handle>& a_rhs) noexcept
		{
			_handle = a_rhs._handle;
			return *this;
		}

		~BSPointerHandle() noexcept = default;

		void reset() noexcept { _handle.reset(); }

		[[nodiscard]] NiPointer<T> get() const
		{
			NiPointer<T> ptr;
			get_smartptr(ptr);
			return ptr;
		}

		[[nodiscard]] native_handle_type native_handle() const noexcept { return _handle.value(); }

		[[nodiscard]] explicit operator bool() const noexcept { return _handle.has_value(); }

		[[nodiscard]] friend bool operator==(const BSPointerHandle& a_lhs, const BSPointerHandle& a_rhs) noexcept
		{
			return a_lhs._handle == a_rhs._handle;
		}

		[[nodiscard]] friend bool operator!=(const BSPointerHandle& a_lhs, const BSPointerHandle& a_rhs) noexcept
		{
			return !(a_lhs == a_rhs);
		}

	private:
		template <class, class>
		friend class BSPointerHandle;

		void get_handle(T* a_ptr);
		bool get_smartptr(NiPointer<T>& a_smartPointerOut) const;

		Handle _handle;
	};

	extern template class BSPointerHandle<Actor>;
	extern template class BSPointerHandle<Projectile>;
	extern template class BSPointerHandle<TESObjectREFR>;

	using ActorHandle = BSPointerHandle<Actor>;
	using ProjectileHandle = BSPointerHandle<Projectile>;
	using ObjectRefHandle = BSPointerHandle<TESObjectREFR>;

	template <class T>
	struct BSCRC32<BSPointerHandle<T>>
	{
	public:
		[[nodiscard]] std::uint32_t operator()(const BSPointerHandle<T>& a_handle) const noexcept
		{
			return BSCRC32<typename BSPointerHandle<T>::native_handle_type>()(a_handle.native_handle());
		}
	};

	template <class T, class Manager>
	class BSPointerHandleManagerInterface
	{
	public:
		using value_type = T;

		static BSPointerHandle<T> GetHandle(T* a_ptr)
		{
			using func_t = decltype(&BSPointerHandleManagerInterface<T, Manager>::GetHandle);
			REL::Relocation<func_t> func{ RELOCATION_ID(15967, 16212) };
			return func(a_ptr);
		}

		static bool GetSmartPointer(const BSPointerHandle<T>& a_handle, NiPointer<T>& a_smartPointerOut)
		{
			using func_t = decltype(&BSPointerHandleManagerInterface<T, Manager>::GetSmartPointer);
			REL::Relocation<func_t> func{ RELOCATION_ID(12204, 12332) };
			return func(a_handle, a_smartPointerOut);
		}
	};

	extern template class BSPointerHandleManagerInterface<Actor>;
	extern template class BSPointerHandleManagerInterface<Projectile>;
	extern template class BSPointerHandleManagerInterface<TESObjectREFR>;

	template <class T, class Handle>
	void BSPointerHandle<T, Handle>::get_handle(T* a_ptr)
	{
		*this = BSPointerHandleManagerInterface<T>::GetHandle(a_ptr);
	}

	template <class T, class Handle>
	bool BSPointerHandle<T, Handle>::get_smartptr(NiPointer<T>& a_smartPointerOut) const
	{
		return BSPointerHandleManagerInterface<T>::GetSmartPointer(*this, a_smartPointerOut);
	}
}


===============================================
File: include/RE/B/BSPointerHandleManager.h
===============================================
#pragma once

#include "RE/B/BSHandleRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	template <class T>
	class BSPointerHandleManager
	{
	public:
		struct Entry
		{
		public:
			enum EntryBitfieldConstants : std::uint32_t
			{
				//kAgeInc = (1 << T::kFreeListBits),	// 0x100000
				//kFreeListMask = kAgeInc - 1,	// 0xFFFFF
				//kInUseBit = kAgeInc << kAgeShift	// 0x4000000
			};

			// members
			std::uint32_t                handleEntryBits;  // 00
			std::uint32_t                pad04;            // 04
			NiPointer<BSHandleRefObject> pointer;          // 08
		};

		[[nodiscard]] static auto GetHandleEntries()
		{
			REL::Relocation<Entry(*)[0x100000]> entries{ RELOCATION_ID(514478, 400622) };
			return std::span<Entry, 0x100000>{ *entries };
		}
	};
}


===============================================
File: include/RE/B/BSPointerHandleSmartPointer.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	template <class T>
	class BSPointerHandleSmartPointer : public NiPointer<typename T::value_type>
	{
	public:
	};

	class Actor;
	using ActorHandlePtr = BSPointerHandleSmartPointer<BSPointerHandleManagerInterface<Actor>>;
	static_assert(sizeof(ActorHandlePtr) == 0x8);
}


===============================================
File: include/RE/B/BSPortalGraph.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiAVObject;
	class NiNode;

	class BSPortalGraph : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSPortalGraph;

		~BSPortalGraph() override;  // 00

		// members
		std::uint64_t                   unk10;             // 10
		std::uint64_t                   unk18;             // 18
		std::uint32_t                   unk20;             // 20
		std::uint32_t                   unk24;             // 24
		std::uint64_t                   unk28;             // 28
		std::uint64_t                   unk30;             // 30
		std::uint32_t                   unk38;             // 38
		std::uint32_t                   unk3C;             // 3C
		BSTArray<void*>                 unk40;             // 40
		BSTArray<void*>                 unk58;             // 58
		NiPointer<NiNode>               portalSharedNode;  // 70
		BSTArray<NiPointer<NiAVObject>> unk78;             // 78
		BSTArray<NiPointer<NiAVObject>> unk90;             // 90
		BSTArray<void*>                 unkA8;             // A8
		FormID                          cellID;            // C0
		std::uint32_t                   padC4;             // C4
	};
	static_assert(sizeof(BSPortalGraph) == 0xC8);
}


===============================================
File: include/RE/B/BSPrecomputedNavmeshInfoPathMap.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	struct BSNavmeshInfo;

	class BSPrecomputedNavmeshInfoPathMap : public BSTSingletonExplicit<BSPrecomputedNavmeshInfoPathMap>
	{
	public:
		// members
		BSTArray<BSTArray<const BSNavmeshInfo*>*>       allPaths;        // 00
		BSTHashMap<const BSNavmeshInfo*, std::uint32_t> infoToIndexMap;  // 18
	};
	static_assert(sizeof(BSPrecomputedNavmeshInfoPathMap) == 0x48);
}


===============================================
File: include/RE/B/BSReloadShaderI.h
===============================================
#pragma once

#include "RE/I/ImageSpaceEffect.h"

namespace RE
{
	class BSReloadShaderI
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSReloadShaderI;

		virtual void Unk_00(void) = 0;  // 00
	};
	static_assert(sizeof(BSReloadShaderI) == 0x8);
}


===============================================
File: include/RE/B/BSRenderManager.h
===============================================


===============================================
File: include/RE/B/BSRenderPass.h
===============================================
#pragma once

namespace RE
{
	class BSGeometry;
	class BSLight;
	class BSShader;
	class BSShaderProperty;

	class BSRenderPass
	{
	public:
		struct LODMode
		{
			std::uint8_t index: 7;
			bool         singleLevel: 1;
		};
		static_assert(sizeof(LODMode) == 0x1);

		// members
		BSShader*         shader;            // 00
		BSShaderProperty* shaderProperty;    // 08
		BSGeometry*       geometry;          // 10
		std::uint32_t     passEnum;          // 18
		std::uint8_t      accumulationHint;  // 1C
		std::uint8_t      extraParam;        // 1D
		LODMode           LODMode;           // 1E
		std::uint8_t      numLights;         // 1F
		std::uint16_t     unk20;             // 20
		BSRenderPass*     next;              // 28
		BSRenderPass*     passGroupNext;     // 30
		BSLight**         sceneLights;       // 38
		std::uint32_t     cachePoolId;       // 40
		std::uint32_t     pad44;             // 44
	};
	static_assert(sizeof(BSRenderPass) == 0x48);
}


===============================================
File: include/RE/B/BSResourceEntryDB.h
===============================================
#pragma once

namespace RE
{
	namespace BSResource
	{
		// TBD
		class IEntryDB
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource__IEntryDB;
			inline static constexpr auto VTABLE = VTABLE_BSResource__IEntryDB;

			virtual ~IEntryDB();

			// add
			virtual void Unk_01(void) = 0;  // 01
			virtual void Unk_02(void) = 0;  // 02
			virtual void Unk_03(void) = 0;  // 03
			virtual void Unk_04(void) = 0;  // 04
			virtual void Unk_05(void) = 0;  // 05

			// members
			std::uint8_t unk00[0xC8];  // 08
		};
		static_assert(sizeof(IEntryDB) == 0xD0);
	}
}


===============================================
File: include/RE/B/BSResourceNiBinaryStream.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/E/ErrorCodes.h"
#include "RE/N/NiBinaryStream.h"
#include "RE/S/Stream.h"

namespace RE
{
	namespace BSResource
	{
		class Location;
	}

	class BSResourceNiBinaryStream : public NiBinaryStream
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSResourceNiBinaryStream;
		inline static constexpr auto VTABLE = VTABLE_BSResourceNiBinaryStream;

		struct BufferType
		{
		public:
		};

		BSResourceNiBinaryStream();
		BSResourceNiBinaryStream(const char* a_fileName);
		BSResourceNiBinaryStream(const std::string& a_fileName);
		~BSResourceNiBinaryStream() override;  // 00

		// override (NiBinaryStream)
		bool          good() const override;                    // 01 - { return static_cast<bool>(stream); }
		void          seek(std::int32_t a_numBytes) override;   // 02
		std::uint32_t tell() const override;                    // 03 - { return streamPos; }
		void          get_info(BufferInfo& a_buf) override;     // 04
		void          set_endian_swap(bool a_doSwap) override;  // 05

		// members
		BSTSmartPointer<BSResource::Stream> stream;     // 20
		BufferType*                         buffer;     // 28
		std::uint32_t                       streamPos;  // 30
		BSResource::ErrorCode               lastError;  // 34

	private:
		BSResourceNiBinaryStream* ctor(const char* a_name, bool a_writeable = false, BSResource::Location* a_optionalStart = 0);
		void                      dtor();
	};
	static_assert(sizeof(BSResourceNiBinaryStream) == 0x38);
}


===============================================
File: include/RE/B/BSResponse.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTObjectDictionary.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/D/DoNothingUnhandledPolicy.h"
#include "RE/I/IHandlerFunctor.h"

namespace RE
{
	template <class Type, class Handler, class Parameter, template <class> class Parent>
	class BSResponse :
		public Parent<Parameter>,
		public BSIntrusiveRefCounted
	{
	public:
		using functor_type = IHandlerFunctor<Handler, Parameter>;

		BSResponse() = default;
		~BSResponse() override = default;  // 00

		using BSIntrusiveRefCounted::operator new;
		using BSIntrusiveRefCounted::operator delete;

		[[nodiscard]] inline BSTSmartPointer<functor_type> GetHandler(const Type& a_type)
		{
			auto it = handlerMap.find(a_type);
			if (it != handlerMap.end()) {
				return it->second;
			} else if (backupResponse) {
				return backupResponse->GetHandler(a_type);
			} else {
				return nullptr;
			}
		}

		// members
		BSTHashMap<Type, BSTSmartPointer<functor_type>>               handlerMap;      // ??
		BSTSmartPointer<BSResponse<Type, Handler, Parameter, Parent>> backupResponse;  // ??
	};

	template <class T, class Key>
	class ResponseDefinitionMissPolicy
	{
	public:
		virtual ~ResponseDefinitionMissPolicy();  // 00
	};
	//static_assert(sizeof(ResponseDefinitionMissPolicy) == 0x8);

	template <class T, class Key>
	class PreloadResponsesInitializationPolicy
	{
	public:
		virtual ~PreloadResponsesInitializationPolicy();  // 00
	};
	//static_assert(sizeof(PreloadResponsesInitializationPolicy) == 0x8);

	class Actor;
	using AnimResponse = BSResponse<BSFixedString, Actor, BSFixedString, DoNothingUnhandledPolicy>;
	static_assert(sizeof(AnimResponse) == 0x48);

	class ResponseDictionary :
		public BSTObjectDictionary<
			BSTSmartPointer<AnimResponse>,
			BSFixedString,
			ResponseDefinitionMissPolicy,
			PreloadResponsesInitializationPolicy>
	{
	public:
		static ResponseDictionary* GetSingleton();
	};
	static_assert(sizeof(ResponseDictionary) == 0x50);
}


===============================================
File: include/RE/B/BSSaveDataSystemUtility.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTEvent.h"

namespace RE
{
	class BSSaveDataEvent;

	class BSSaveDataSystemUtility :
		public BSTEventSource<BSSaveDataEvent>  // 008
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSSaveDataSystemUtility;

		class Entry
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSSaveDataSystemUtility__Entry;

			virtual void Unk_00(void);  // 00

			// members
			std::uint64_t unk008;  // 008
			std::uint64_t unk010;  // 010
			std::uint64_t unk018;  // 018
			std::uint64_t unk020;  // 020
			std::uint64_t unk028;  // 028
			std::uint64_t unk030;  // 030
			std::uint64_t unk038;  // 038
			std::uint64_t unk040;  // 040
			std::uint64_t unk048;  // 048
			std::uint64_t unk050;  // 050
			std::uint64_t unk058;  // 058
			std::uint64_t unk060;  // 060
			std::uint64_t unk068;  // 068
			std::uint64_t unk070;  // 070
			std::uint64_t unk078;  // 078
			std::uint64_t unk080;  // 080
			std::uint64_t unk088;  // 088
			std::uint64_t unk090;  // 090
			std::uint64_t unk098;  // 098
			std::uint64_t unk0A0;  // 0A0
			std::uint64_t unk0A8;  // 0A8
			std::uint64_t unk0B0;  // 0B0
			std::uint64_t unk0B8;  // 0B8
			std::uint64_t unk0C0;  // 0C0
			std::uint64_t unk0C8;  // 0C8
			std::uint64_t unk0D0;  // 0D0
			std::uint64_t unk0D8;  // 0D8
			std::uint64_t unk0E0;  // 0E0
			std::uint64_t unk0E8;  // 0E8
			std::uint64_t unk0F0;  // 0F0
			std::uint64_t unk0F8;  // 0F8
			std::uint64_t unk100;  // 100
			std::uint64_t unk108;  // 108
			std::uint64_t unk110;  // 110
			std::uint64_t unk118;  // 118
			std::uint64_t unk120;  // 120
			std::uint64_t unk128;  // 128
			BSString      unk130;  // 130
			BSString      unk140;  // 140
			BSString      unk150;  // 150
			std::uint64_t unk160;  // 160
			std::uint64_t unk168;  // 168
			std::uint64_t unk170;  // 170
			std::uint64_t unk178;  // 178
			std::uint64_t unk180;  // 180
			std::uint64_t unk188;  // 188
			std::uint64_t unk190;  // 190
		};

		virtual ~BSSaveDataSystemUtility();  // 00

		// add
		virtual bool    CreateSaveDirectory(const char* a_pathName, bool a_ignoreINI) = 0;                               // 01
		virtual errno_t PrepareFileSavePath(const char* a_fileName, char* a_dst, bool a_tmpSave, bool a_ignoreINI) = 0;  // 02 - a_dst must be 0x104 in length
		virtual void    Unk_03(void);                                                                                    // 03 - { return Unk_04(); }
		virtual void    Unk_04(void);                                                                                    // 04 - { return; }
		virtual void    Unk_05(void);                                                                                    // 05
		virtual void    Unk_06(void) = 0;                                                                                // 06
		virtual void    Unk_07(void);                                                                                    // 07
		virtual void    Unk_08(void);                                                                                    // 08 - { return; }
		virtual void    Unk_09(void);                                                                                    // 09 - { return; }
		virtual void    Unk_0A(void);                                                                                    // 0A
		virtual void    Unk_0B(void);                                                                                    // 0B - { return; }
		virtual void    Unk_0C(void);                                                                                    // 0C
		virtual void    Unk_0D(void);                                                                                    // 0D - { return; }
		virtual void    Unk_0E(void);                                                                                    // 0E - { return 1; }
		virtual void    Unk_0F(void);                                                                                    // 0F - { return 1; }
		virtual void    Unk_10(void);                                                                                    // 10 - { return 0; }
		virtual void    Unk_11(void);                                                                                    // 11 - { return; }

		// members
		std::uint32_t unk060;       // 060
		std::uint32_t profileHash;  // 064
		std::uint64_t unk068;       // 068
		Entry         entry;        // 070
		std::uint64_t unk208;       // 208
		std::uint64_t unk210;       // 210
		std::uint64_t unk218;       // 218
		std::uint64_t unk220;       // 220
	};
	static_assert(sizeof(BSSaveDataSystemUtility) == 0x228);
}


===============================================
File: include/RE/B/BSScaleformManager.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTSingleton.h"
#include "RE/G/GFxMovieView.h"
#include "RE/G/GPtr.h"

namespace RE
{
	class BSScaleformImageLoader;
	class GFxDrawTextManager;
	class GFxLoader;
	class GFxMovieDef;
	class GFxRenderConfig;
	class IMenu;

	struct BSScaleformRenderer
	{
	public:
		// members
		GPtr<GFxRenderConfig> config;  // 0
	};
	static_assert(sizeof(BSScaleformRenderer) == 0x8);

	class BSScaleformManager : public BSTSingletonSDM<BSScaleformManager>
	{
	public:
		using ScaleModeType = GFxMovieView::ScaleModeType;

		static BSScaleformManager* GetSingleton();
		static bool                FileExists(const char* a_fileName);

		bool IsValidName(const char* a_name);

		bool LoadMovie(IMenu* a_menu, GPtr<GFxMovieView>& a_viewOut, const char* a_fileName, ScaleModeType a_mode = ScaleModeType::kShowAll, float a_backGroundAlpha = 0.0);

		bool LoadMovieEx(IMenu* a_menu, std::string_view a_fileName, std::function<void(GFxMovieDef*)> a_callback);
		bool LoadMovieEx(IMenu* a_menu, std::string_view a_fileName, ScaleModeType a_mode, std::function<void(GFxMovieDef*)> a_callback);
		bool LoadMovieEx(IMenu* a_menu, std::string_view a_fileName, ScaleModeType a_mode, float a_backGroundAlpha, std::function<void(GFxMovieDef*)> a_callback);

		bool LoadMovie_Impl(IMenu* a_menu, GPtr<GFxMovieView>& a_viewOut, const char* a_fileName, ScaleModeType a_mode = ScaleModeType::kShowAll, float a_backGroundAlpha = 0.0);

		// members
		std::uint8_t                 pad01;           // 01
		std::uint16_t                pad02;           // 02
		std::uint32_t                pad04;           // 04
		GFxLoader*                   loader;          // 08
		BSScaleformRenderer*         renderer;        // 10
		GPtr<GFxDrawTextManager>     textManager;     // 18
		GPtr<BSScaleformImageLoader> imageLoader;     // 20
		BSString                     validNameChars;  // 28
		std::uint64_t                unk38;           // 38

	private:
		static std::optional<std::string>                           BuildFilePath(std::string_view a_fileName);
		static std::tuple<float, float, std::int32_t, std::int32_t> CollectDisplayInfo();
	};
	static_assert(sizeof(BSScaleformManager) == 0x40);
}


===============================================
File: include/RE/B/BSScaleformTranslator.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"
#include "RE/G/GFxTranslator.h"

namespace RE
{
	struct BSTranslator
	{
	public:
		// members
		BSTHashMap<BSFixedStringW, BSFixedStringW> translationMap;  // 00
	};
	static_assert(sizeof(BSTranslator) == 0x30);

	class BSScaleformTranslator : public GFxTranslator
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSScaleformTranslator;
		inline static constexpr auto VTABLE = VTABLE_BSScaleformTranslator;

		~BSScaleformTranslator() override;  // 00

		// override (GFxTranslator)
		void Translate(TranslateInfo* a_translateInfo) override;  // 02

		static void GetCachedString(wchar_t** a_pOut, wchar_t* a_bufIn, std::uint32_t a_unused);

		// members
		BSTranslator translator;  // 20
	};
	static_assert(sizeof(BSScaleformTranslator) == 0x50);
}


===============================================
File: include/RE/B/BSSceneGraph.h
===============================================
#pragma once

#include "RE/N/NiNode.h"

namespace RE
{
	class NiCamera;

	class BSSceneGraph : public NiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSSceneGraph;
		inline static constexpr auto Ni_RTTI = NiRTTI_BSSceneGraph;

		~BSSceneGraph() override;  // 00

		// override (NiNode)
		const NiRTTI* GetRTTI() const override;  // 02

		// add
		virtual float GetFarDistance();                                    // 3E
		virtual float GetNearDistance();                                   // 3F - { return fNearDistance:Display; }
		virtual void  SetViewDistanceBasedOnFrameRate(float a_frameRate);  // 40

		struct BS_SCENE_GRAPH_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                        \
	NiPointer<NiCamera> camera;    /* 128 */        \
	std::uint64_t       unk130;    /* 130 - 0x18 */ \
	bool                unk138;    /* 138 */        \
	std::uint8_t        pad139;    /* 139 */        \
	std::uint16_t       pad13A;    /* 13A */        \
	float               cameraFOV; /* 13C */

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline BS_SCENE_GRAPH_RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<BS_SCENE_GRAPH_RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const BS_SCENE_GRAPH_RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<BS_SCENE_GRAPH_RUNTIME_DATA>(this, 0x128, 0x150);
		}

#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT
#endif
	};
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/B/BSScriptObjectBindPolicy.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
		class Object;
		struct IVMObjectBindInterface;

		class ObjectBindPolicy
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__ObjectBindPolicy;

			virtual ~ObjectBindPolicy();  // 00

			// add
			virtual void Unk_01(VMHandle a_handle) = 0;  // 01
			virtual void Unk_02(VMHandle a_handle) = 0;  // 02
			virtual void Unk_03(VMHandle a_handle) = 0;  // 03
			virtual void Unk_04() = 0;                   // 04
			virtual void Unk_05(void) = 0;               // 05
			virtual void Unk_06(void) = 0;               // 06
			virtual void Unk_07(void) = 0;               // 07
			virtual void Unk_08(void) = 0;               // 08
			virtual void Unk_09(void) = 0;               // 09
			virtual void Unk_0A(void) = 0;               // 0A
			virtual void Unk_0B(void) = 0;               // 0B
			virtual void Unk_0C(void) = 0;               // 0C

			void BindObject(BSTSmartPointer<Object>& a_objectPtr, VMHandle a_handle);

			// members
			IVirtualMachine*               vm;                   // 08
			IVMObjectBindInterface*        bindInterface;        // 10
			mutable BSSpinLock             attachedScriptsLock;  // 18
			BSTHashMap<VMHandle, UnkValue> attachedScripts;      // 20
		};
		static_assert(sizeof(ObjectBindPolicy) == 0x50);
	}
}


===============================================
File: include/RE/B/BSShader.h
===============================================
#pragma once

#include "RE/B/BSReloadShaderI.h"
#include "RE/N/NiBoneMatrixSetterI.h"
#include "RE/N/NiRefObject.h"

namespace RE
{
	class BSRenderPass;
	class BSShaderMaterial;

	struct ID3D11Buffer;
	struct ID3D11PixelShader;
	struct ID3D11VertexShader;

	namespace BSGraphics
	{
		class ConstantGroup
		{
		public:
			// members
			ID3D11Buffer* buffer;  // 00
			void*         data;    // 08
		};
		static_assert(sizeof(ConstantGroup) == 0x10);

		class PixelShader
		{
		public:
			// members
			std::uint32_t      id;                  // 00
			ID3D11PixelShader* shader;              // 08
			ConstantGroup      constantBuffers[3];  // 10
			std::int8_t        constantTable[64];   // 58
		};
		static_assert(sizeof(PixelShader) == 0x80);

		class VertexShader
		{
		public:
			// members
			std::uint32_t       id;                  // 00
			ID3D11VertexShader* shader;              // 08
			std::uint32_t       byteCodeSize;        // 10
			ConstantGroup       constantBuffers[3];  // 18
			std::uint64_t       shaderDesc;          // 48
			std::int8_t         constantTable[20];   // 50
			std::uint32_t       pad64;               // 64
			std::uint8_t        rawBytecode[0];      // 68
		};
		static_assert(sizeof(VertexShader) == 0x68);
	}

	namespace BSShaderTechniqueIDMap
	{
		template <class T>
		struct HashPolicy
		{
			[[nodiscard]] std::uint32_t operator()(const T a_shader) const noexcept
			{
				assert(a_shader != nullptr);
				return a_shader->id;
			}
		};

		template <class T>
		struct ComparePolicy
		{
			[[nodiscard]] bool operator()(const T a_lhs, const T a_rhs) const noexcept
			{
				assert(a_lhs != nullptr);
				assert(a_rhs != nullptr);
				return a_lhs->id == a_rhs->id;
			}
		};

		template <class T>
		using MapType = BSTSet<T, HashPolicy<T>, ComparePolicy<T>>;
	}

	class BSShader :
		public NiRefObject,          // 00
		public NiBoneMatrixSetterI,  // 10
		public BSReloadShaderI       // 18
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSShader;
		inline static constexpr auto VTABLE = VTABLE_BSShader;

		~BSShader() override;  // 00

		// add
		virtual bool SetupTechnique(std::uint32_t a_technique) = 0;                                              // 02
		virtual void RestoreTechnique(std::uint32_t a_technique) = 0;                                            // 03
		virtual void SetupMaterial(const BSShaderMaterial* a_material);                                          // 04
		virtual void RestoreMaterial(const BSShaderMaterial* a_material);                                        // 05
		virtual void SetupGeometry(BSRenderPass* a_currentPass, std::uint32_t a_flags) = 0;                      // 06
		virtual void RestoreGeometry(BSRenderPass* a_currentPass, std::uint32_t a_renderFlags) = 0;              // 07
		virtual void GetTechniqueName(std::uint32_t a_techniqueID, char* a_buffer, std::uint32_t a_bufferSize);  // 08
		virtual void ReloadShaders(bool a_clear);                                                                // 09

		// members
		std::int32_t                                               shaderType;     // 20
		BSShaderTechniqueIDMap::MapType<BSGraphics::VertexShader*> vertexShaders;  // 28
		BSShaderTechniqueIDMap::MapType<BSGraphics::PixelShader*>  pixelShaders;   // 58
		const char*                                                fxpFilename;    // 88
	};
	static_assert(sizeof(BSShader) == 0x90);
}


===============================================
File: include/RE/B/BSShaderManager.h
===============================================
#pragma once

#include "RE/N/NiBound.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint2.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTransform.h"

namespace RE
{
	class ShadowSceneNode;
	class NiTexture;

	class BSShaderManager
	{
	public:
		enum BSShaderTimerMode
		{
			kDefault = 0,
			kDelta,
			kSystem,
			kRealDelta,

			kTotal = 5,
		};

		class State
		{
		public:
			static BSShaderManager::State& GetSingleton()
			{
				REL::Relocation<BSShaderManager::State*> singleton{ RELOCATION_ID(514167, 400315) };
				return *singleton;
			}

			// members
			ShadowSceneNode* shadowSceneNode[4];                      // 000
			float            timerValues[BSShaderTimerMode::kTotal];  // 020
			NiColorA         loadedRange;                             // 034
			bool             interior;                                // 044
			bool             liteBrite;                               // 045
			bool             characterLightEnabled;                   // 046
			std::uint8_t     pad47;                                   // 047
			void*            unk48;                                   // 048
			void*            unk50;                                   // 050
			void*            unk58;                                   // 058
			void*            unk60;                                   // 060
			void*            unk68;                                   // 068
			void*            unk70;                                   // 070
			void*            unk78;                                   // 078
			void*            unk80;                                   // 080
			void*            unk88;                                   // 088
			std::uint64_t    unk90;                                   // 090
			float            landLOFadeSeconds;                       // 098
			float            invFrameBufferRange;                     // 09C
			float            leafAnimDampenDistStartSPU;              // 0A0
			float            leafAnimDampenDistEndSPU;                // 0A4
			NiPoint2         oldGridArrayCenter;                      // 0A8
			NiPoint2         gridArrayCenter;                         // 0B0
			float            gridArrayLerpStart;                      // 0B8
			std::uint32_t    currentShaderTechnique;                  // 0BC
			std::uint8_t     sceneGraph;                              // 0C0
			std::uint32_t    debugMode;                               // 0C4
			NiTransform      directionalAmbientTransform;             // 0C8
			NiColorA         ambientSpecular;                         // 0FC
			float            characterLightParams[4];                 // 10C - { Primary, Secondary, Luminance, Max Luminance }
			bool             ambientSpecularEnabled;                  // 11C
			std::uint32_t    textureTransformCurrentBuffer;           // 120
			std::uint32_t    textureTransformFlipMode;                // 124
			std::uint32_t    cameraInWaterState;                      // 128
			NiBound          cachedPlayerBound;                       // 12C
			std::uint32_t    pad13C;                                  // 13C
			std::uint32_t    pad140;                                  // 140
			float            waterIntersect;                          // 144
		};
		static_assert(sizeof(State) == 0x148);

		static void GetTexture(const char* a_path, bool a_demand, NiPointer<NiTexture>& a_textureOut, bool a_isHeightMap)
		{
			using func_t = decltype(&BSShaderManager::GetTexture);
			REL::Relocation<func_t> func{ RELOCATION_ID(98986, 105640) };
			return func(a_path, a_demand, a_textureOut, a_isHeightMap);
		}
	};
}


===============================================
File: include/RE/B/BSShaderMaterial.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/N/NiPoint2.h"

namespace RE
{
	class BSShaderMaterial : public BSIntrusiveRefCounted
	{
	public:
		inline static constexpr auto RTTI = RTTI_BSShaderMaterial;

		enum class Feature
		{
			kNone = static_cast<std::underlying_type_t<Feature>>(-1),
			kDefault = 0,
			kEnvironmentMap = 1,
			kGlowMap = 2,
			kParallax = 3,
			kFaceGen = 4,
			kFaceGenRGBTint = 5,
			kHairTint = 6,
			kParallaxOcc = 7,
			kMultiTexLand = 8,
			kLODLand = 9,
			kUnknown = 10,
			kMultilayerParallax = 11,
			kTreeAnim = 12,
			kMultiIndexTriShapeSnow = 14,
			kLODObjectsHD = 15,
			kEye = 16,
			kCloud = 17,
			kLODLandNoise = 18,
			kMultiTexLandLODBlend = 19
		};

		enum class Type
		{
			kBase = 0,
			kEffect = 1,
			kLighting = 2,
			kWater = 3
		};

		virtual ~BSShaderMaterial();  // 00

		// add
		virtual BSShaderMaterial* Create();                                // 01
		virtual void              CopyMembers(BSShaderMaterial* a_other);  // 02
		virtual bool              DoIsCopy(BSShaderMaterial* a_other);     // 03
		virtual std::uint32_t     ComputeCRC32(void);                      // 04
		virtual BSShaderMaterial* GetDefault();                            // 05
		virtual Feature           GetFeature() const;                      // 06 - { return Feature::kDefault; }
		virtual Type              GetType() const;                         // 07 - { return Type::kBase; }

		// members
		NiPoint2      texCoordOffset[2];  // 0C
		NiPoint2      texCoordScale[2];   // 1C
		std::uint32_t hashKey;            // 2C
		std::uint32_t unk30;              // 30
		std::uint32_t unk34;              // 34
	};
	static_assert(sizeof(BSShaderMaterial) == 0x38);
}


===============================================
File: include/RE/B/BSShaderProperty.h
===============================================
#pragma once

#include "RE/B/BSEffectShaderData.h"
#include "RE/B/BSShaderMaterial.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/N/NiShadeProperty.h"

namespace RE
{
	class BSRenderPass;
	class BSShaderAccumulator;
	class BSShaderMaterial;
	class BSShaderPropertyLightData;
	class NiSourceTexture;

	class BSShaderProperty : public NiShadeProperty
	{
	private:
		static constexpr auto BIT64 = static_cast<std::uint64_t>(1);

	public:
		inline static constexpr auto RTTI = RTTI_BSShaderProperty;
		inline static auto           Ni_RTTI = NiRTTI_BSShaderProperty;

		class ForEachVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSShaderProperty__ForEachVisitor;

			virtual ~ForEachVisitor();  // 00

			// add
			virtual std::uint32_t Accept(NiSourceTexture* a_texture) = 0;  // 01
		};

		struct RenderPassArray
		{
			BSRenderPass* head;  // 0
		};
		static_assert(sizeof(RenderPassArray) == 0x8);

		enum class EShaderPropertyFlag : std::uint64_t
		{
			kSpecular = BIT64 << 0,
			kSkinned = BIT64 << 1,
			kTempRefraction = BIT64 << 2,
			kVertexAlpha = BIT64 << 3,
			kGrayscaleToPaletteColor = BIT64 << 4,
			kGrayscaleToPaletteAlpha = BIT64 << 5,
			kFalloff = BIT64 << 6,
			kEnvMap = BIT64 << 7,
			kReceiveShadows = BIT64 << 8,
			kCastShadows = BIT64 << 9,
			kFace = BIT64 << 10,
			kParallax = BIT64 << 11,
			kModelSpaceNormals = BIT64 << 12,
			kNonProjectiveShadows = BIT64 << 13,
			kMultiTextureLandscape = BIT64 << 14,
			kRefraction = BIT64 << 15,
			kRefractionFalloff = BIT64 << 16,
			kEyeReflect = BIT64 << 17,
			kHairTint = BIT64 << 18,
			kScreendoorAlphaFade = BIT64 << 19,
			kLocalMapClear = BIT64 << 20,
			kFaceGenRGBTint = BIT64 << 21,
			kOwnEmit = BIT64 << 22,
			kProjectedUV = BIT64 << 23,
			kMultipleTextures = BIT64 << 24,
			kRemappableTextures = BIT64 << 25,
			kDecal = BIT64 << 26,
			kDynamicDecal = BIT64 << 27,
			kParallaxOcclusion = BIT64 << 28,
			kExternalEmittance = BIT64 << 29,
			kSoftEffect = BIT64 << 30,
			kZBufferTest = BIT64 << 31,
			kZBufferWrite = BIT64 << 32,
			kLODLandscape = BIT64 << 33,
			kLODObjects = BIT64 << 34,
			kNoFade = BIT64 << 35,
			kTwoSided = BIT64 << 36,
			kVertexColors = BIT64 << 37,
			kGlowMap = BIT64 << 38,
			kAssumeShadowmask = BIT64 << 39,
			kCharacterLighting = BIT64 << 40,
			kMultiIndexSnow = BIT64 << 41,
			kVertexLighting = BIT64 << 42,
			kUniformScale = BIT64 << 43,
			kFitSlope = BIT64 << 44,
			kBillboard = BIT64 << 45,
			kNoLODLandBlend = BIT64 << 46,
			kEnvmapLightFade = BIT64 << 47,
			kWireframe = BIT64 << 48,
			kWeaponBlood = BIT64 << 49,
			kHideOnLocalMap = BIT64 << 50,
			kPremultAlpha = BIT64 << 51,
			kCloudLOD = BIT64 << 52,
			kAnisotropicLighting = BIT64 << 53,
			kNoTransparencyMultiSample = BIT64 << 54,
			kMenuScreen = BIT64 << 55,
			kMultiLayerParallax = BIT64 << 56,
			kSoftLighting = BIT64 << 57,
			kRimLighting = BIT64 << 58,
			kBackLighting = BIT64 << 59,
			kSnow = BIT64 << 60,
			kTreeAnim = BIT64 << 61,
			kEffectLighting = BIT64 << 62,
			kHDLODObjects = BIT64 << 63
		};

		enum class EShaderPropertyFlag8 : std::uint8_t
		{
			kSpecular = 0,
			kSkinned = 1,
			kTempRefraction = 2,
			kVertexAlpha = 3,
			kGrayscaleToPaletteColor = 4,
			kGrayscaleToPaletteAlpha = 5,
			kFalloff = 6,
			kEnvMap = 7,
			kReceiveShadows = 8,
			kCastShadows = 9,
			kFace = 10,
			kParallax = 11,
			kModelSpaceNormals = 12,
			kNonProjectiveShadows = 13,
			kMultiTextureLandscape = 14,
			kRefraction = 15,
			kRefractionFalloff = 16,
			kEyeReflect = 17,
			kHairTint = 18,
			kScreendoorAlphaFade = 19,
			kLocalMapClear = 20,
			kFaceGenRGBTint = 21,
			kOwnEmit = 22,
			kProjectedUV = 23,
			kMultipleTextures = 24,
			kRemappableTextures = 25,
			kDecal = 26,
			kDynamicDecal = 27,
			kParallaxOcclusion = 28,
			kExternalEmittance = 29,
			kSoftEffect = 30,
			kZBufferTest = 31,
			kZBufferWrite = 32,
			kLODLandscape = 33,
			kLODObjects = 34,
			kNoFade = 35,
			kTwoSided = 36,
			kVertexColors = 37,
			kGlowMap = 38,
			kAssumeShadowmask = 39,
			kCharacterLighting = 40,
			kMultiIndexSnow = 41,
			kVertexLighting = 42,
			kUniformScale = 43,
			kFitSlope = 44,
			kBillboard = 45,
			kNoLODLandBlend = 46,
			kEnvmapLightFade = 47,
			kWireframe = 48,
			kWeaponBlood = 49,
			kHideOnLocalMap = 50,
			kPremultAlpha = 51,
			kCloudLOD = 52,
			kAnisotropicLighting = 53,
			kNoTransparencyMultiSample = 54,
			kMenuScreen = 55,
			kMultiLayerParallax = 56,
			kSoftLighting = 57,
			kRimLighting = 58,
			kBackLighting = 59,
			kSnow = 60,
			kTreeAnim = 61,
			kEffectLighting = 62,
			kHDLODObjects = 63
		};

		~BSShaderProperty() override;  // 00

		// override (NiShadeProperty)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17 - { return 0; }
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiShadeProperty::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiShadeProperty::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C - { return false; }
		void          PostLinkObject(NiStream& a_stream) override;        // 1E - { NiObjectNET::PostLinkObject(a_stream); }
		bool          SetupGeometry(BSGeometry* a_geometry) override;     // 27 - { return 1; }
		void          Unk_29(void) override;                              // 29

		// add
		virtual RenderPassArray*               GetRenderPasses(BSGeometry* a_geometry, std::uint32_t a_arg2, BSShaderAccumulator* a_accumulator) = 0;  // 2A
		virtual void                           Unk_2B(void);                                                                                           // 2B - { return 0; }
		virtual void                           Unk_2C(void);                                                                                           // 2C - { return 0; }
		virtual void                           Unk_2D(void);                                                                                           // 2D - { return 0; }
		virtual void                           Unk_2E(void);                                                                                           // 2E - { return 1; }
		virtual void                           Unk_2F(void);                                                                                           // 2F - { return 0; }
		virtual bool                           CanMerge(const BSShaderProperty* a_other);                                                              // 30
		virtual void                           SetMaterialAlpha(float a_alpha);                                                                        // 31 - { return; }
		[[nodiscard]] virtual float            QMaterialAlpha();                                                                                       // 32 - { return 1.0; }
		virtual std::int32_t                   ForEachTexture(ForEachVisitor& a_visitor);                                                              // 33 - { return 1; }
		virtual void                           DoClearRenderPasses();                                                                                  // 34
		virtual std::int32_t                   QShader();                                                                                              // 35 - { return 0; }
		virtual void                           Unk_36(void);                                                                                           // 36 - { return 0; }
		[[nodiscard]] virtual NiSourceTexture* GetBaseTexture();                                                                                       // 37 - { return 0; }
		virtual void                           Unk_38(void);                                                                                           // 38 - { return 0; }
		[[nodiscard]] virtual bool             AcceptsEffectData() const;                                                                              // 39 - { return false; }
		virtual void                           Unk_3A(void);                                                                                           // 3A - { return; }
		virtual void                           Unk_3B(void);                                                                                           // 3B - { return; }
		virtual void                           Unk_3C(void);                                                                                           // 3C - { return 0; }
		virtual std::uint32_t                  DetermineUtilityShaderDecl();                                                                           // 3D - { return 0; }
		virtual BSShaderMaterial::Type         GetMaterialType();                                                                                      // 3E - { return 0; }

		void SetEffectShaderData(const BSTSmartPointer<BSEffectShaderData>& a_data);
		void SetMaterial(BSShaderMaterial* a_material, bool a_unk1);
		void SetFlags(EShaderPropertyFlag8 a_flag, bool a_set);

		// members
		float                                                alpha;                // 30
		std::int32_t                                         lastRenderPassState;  // 34
		stl::enumeration<EShaderPropertyFlag, std::uint64_t> flags;                // 38
		RenderPassArray                                      renderPassList;       // 40
		std::uint64_t                                        unk48;                // 48
		RenderPassArray                                      debugRenderPassList;  // 50
		std::uint64_t                                        unk58;                // 58
		BSFadeNode*                                          fadeNode;             // 60
		BSTSmartPointer<BSEffectShaderData>                  effectData;           // 68
		BSShaderPropertyLightData*                           lightData;            // 70
		BSShaderMaterial*                                    material;             // 78
		std::uint64_t                                        unk80;                // 80
	};
	static_assert(sizeof(BSShaderProperty) == 0x88);
}


===============================================
File: include/RE/B/BSShaderPropertyLightData.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"

namespace RE
{
	class BSLight;

	class BSShaderPropertyLightData
	{
	public:
		// members
		BSTArray<BSLight*> lights;  // 00
		std::int32_t       unk18;   // 18
		std::uint32_t      unk1C;   // 1C
		std::uint8_t       unk20;   // 20
	};
	static_assert(sizeof(BSShaderPropertyLightData) == 0x28);
}
