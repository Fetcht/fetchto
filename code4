===============================================
File: include/RE/I/InventoryMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class GFxMovieView;
	class TESObjectREFR;
	struct BottomBar;
	struct ItemCard;
	struct ItemList;

	// menuDepth = 0
	// flags = kPausesGame | kDisablePauseMenu | kUpdateUsesCursor | kInventoryItemMenu | kCustomRendering
	// context = kNone
	class InventoryMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_InventoryMenu;
		constexpr static std::string_view MENU_NAME = "InventoryMenu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                       \
	GFxValue        root;            /* 00 - kDisplayObject - "_level0.Menu_mc" */ \
	ItemList*       itemList;        /* 18 */                                      \
	ItemCard*       itemCard;        /* 20 */                                      \
	BottomBar*      bottomBar;       /* 28 */                                      \
	BSTArray<void*> unk60;           /* 30 */                                      \
	std::uint8_t    unk78;           /* 48 */                                      \
	std::uint8_t    pad79;           /* 49 */                                      \
	std::uint16_t   pad7A;           /* 4A */                                      \
	std::uint32_t   unk7C;           /* 4C */                                      \
	bool            pcControlsReady; /* 50 */                                      \
	std::uint8_t    unk81;           /* 51 */                                      \
	std::uint16_t   pad82;           /* 52 */                                      \
	std::uint32_t   pad84;           /* 54 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x58);

		~InventoryMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04
		void               PostDisplay() override;                           // 06

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(InventoryMenu) == 0x88);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(InventoryMenu) == 0x98);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/I/InventoryUpdateData.h
===============================================
#pragma once

#include "RE/I/IUIMessageData.h"

namespace RE
{
	class InventoryUpdateData : public IUIMessageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_InventoryUpdateData;

		~InventoryUpdateData() override = default;  // 00

		// members
		RefHandle     unk10;  // 10
		std::uint32_t pad14;  // 14
		TESForm*      unk18;  // 18
	};
	static_assert(sizeof(InventoryUpdateData) == 0x20);
}


===============================================
File: include/RE/I/InvisibilityEffect.h
===============================================
#pragma once

#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class InvisibilityEffect :
		public ValueModifierEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_InvisibilityEffect;
		inline static constexpr auto VTABLE = VTABLE_InvisibilityEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;                     // 04
		virtual void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 0A
		virtual void Revert(BGSLoadFormBuffer* a_buf) override;          // 0B
		virtual ~InvisibilityEffect();                                   // 13
		virtual void Start() override;                                   // 14
		virtual void Finish() override;                                  // 15
	};
	static_assert(sizeof(InvisibilityEffect) == 0x98);
}


===============================================
File: include/RE/I/ItemCard.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/G/GFxValue.h"
#include "RE/G/GPtr.h"

namespace RE
{
	class GFxMovieView;

	struct ItemCard
	{
	public:
		// members
		GFxValue           obj;       // 00 - kObject
		BSString           infoText;  // 18
		void*              unk28;     // 28
		std::uint32_t      unk30;     // 30
		std::uint32_t      pad34;     // 34
		GPtr<GFxMovieView> view;      // 38
	};
	static_assert(sizeof(ItemCard) == 0x40);
}


===============================================
File: include/RE/I/ItemCrafted.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class TESForm;

	struct ItemCrafted
	{
	public:
		struct Event
		{
		public:
			// members
			TESForm*      item;   // 00
			bool          unk08;  // 08 - weapon smithing/alchemy = true
			bool          unk09;  // 09 - enchanting = true
			bool          unk0A;  // 0A - weapon smithing = true/false
			std::uint8_t  pad0B;  // 0B
			std::uint32_t pad0C;  // 0C
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<ItemCrafted::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/I/ItemHarvested.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class TESBoundObject;
	class Actor;

	struct TESHarvestedEvent
	{
	public:
		struct ItemHarvested
		{
		public:
			// members
			TESBoundObject* produceItem;  // 00
			Actor*          harvester;    // 08
		};
		static_assert(sizeof(ItemHarvested) == 0x10);

		static BSTEventSource<TESHarvestedEvent::ItemHarvested>* GetEventSource();
	};
}


===============================================
File: include/RE/I/ItemList.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/G/GPtr.h"
#include "RE/S/StandardItemData.h"

namespace RE
{
	class GFxMovieView;
	class TESObjectREFR;

	struct ItemList
	{
	public:
		struct Item
		{
		public:
			// members
			StandardItemData data;   // 00
			GFxValue         obj;    // 18 - kObject
			std::uint64_t    unk30;  // 30
			std::uint64_t    unk38;  // 38
		};
		static_assert(sizeof(Item) == 0x40);

		Item* GetSelectedItem();
		void  Update();
		void  Update(TESObjectREFR* a_owner);

		// members
		GPtr<GFxMovieView> view;       // 00
		GFxValue           root;       // 08 - kDisplayObject - "_level0.Menu_mc.inventoryLists.panelContainer.itemList"
		GFxValue           entryList;  // 20 - kArray - root.GetMember("entryList", &entryList);
		BSTArray<Item*>    items;      // 38
		bool               unk50;      // 50
		std::uint8_t       pad51;      // 51
		std::uint16_t      pad52;      // 52
		std::uint32_t      pad54;      // 54

	protected:
		void Update_Impl(TESObjectREFR* a_owner);
	};
	static_assert(sizeof(ItemList) == 0x58);
}


===============================================
File: include/RE/I/ItemsPickpocketed.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	struct ItemsPickpocketed
	{
	public:
		struct Event
		{
		public:
			// members
			std::int32_t  numItems;  // 0
			std::uint32_t pad4;      // 4
		};
		static_assert(sizeof(Event) == 0x8);

		static BSTEventSource<Event>* GetEventSource();
		static void                   SendEvent(std::int32_t a_numItems);
	};
}


===============================================
File: include/RE/J/JournalMenu.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/I/IMenu.h"
#include "RE/J/Journal_QuestsTab.h"
#include "RE/J/Journal_StatsTab.h"
#include "RE/J/Journal_SystemTab.h"
#include "RE/M/MenuEventHandler.h"

namespace RE
{
	class BSSystemEvent;

	// menuDepth = 5
	// flags = kPausesGame | kUsesMenuContext | kFreezeFrameBackground | kRequiresUpdate | kTopmostRenderedMenu | kUpdateUsesCursor | kAllowSaving
	// kDisablePauseMenu if game load prevented
	// context = kJournal
	class JournalMenu :
		public IMenu,  // 00
#ifndef SKYRIM_CROSS_VR
		public MenuEventHandler,            // 30
		public BSTEventSink<BSSystemEvent>  // 40
#else
		public MenuEventHandler  // 30
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_JournalMenu;
		inline static constexpr auto      VTABLE = VTABLE_JournalMenu;
		constexpr static std::string_view MENU_NAME = "Journal Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT              \
	Journal_QuestsTab questsTab; /* 00 */ \
	Journal_StatsTab  statsTab;  /* 38 */ \
	Journal_SystemTab systemTab; /* 50 */ \
	std::uint64_t     unkD0;     /* 88 */ \
	std::uint64_t     unkD8;     /* 90 */ \
	std::uint64_t     unkE0;     /* 98 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0xA0);

		~JournalMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;                       // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05
		void               PostDisplay() override;                                                // 06

#ifndef SKYRIM_CROSS_VR
		// override (MenuEventHandler)
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03

		// override (BSTEventSink<BSSystemEvent>)
		BSEventNotifyControl ProcessEvent(const BSSystemEvent* a_event, BSTEventSource<BSSystemEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<JournalMenu*>(this)->AsMenuEventHandler();
		}

		[[nodiscard]] BSTEventSink<BSSystemEvent>* AsBSSystemEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BSSystemEvent>>(this, 0x40, 0x50);
		}

		[[nodiscard]] const BSTEventSink<BSSystemEvent>* AsBSSystemEventSink() const noexcept
		{
			return const_cast<JournalMenu*>(this)->AsBSSystemEventSink();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x48, 0x58);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x48, 0x58);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 48, 58
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(JournalMenu) == 0xE8);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(JournalMenu) == 0xF8);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/J/JournalTab.h
===============================================
#pragma once

#include "RE/F/FxDelegateHandler.h"
#include "RE/G/GPtr.h"

namespace RE
{
	class GFxMovieView;

	class JournalTab : public FxDelegateHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_JournalTab;

		~JournalTab() override;  // 00

		// add
		virtual void Unk_02(void);  // 02 - { return; }
		virtual void Unk_03(void);  // 03 - { return; }

		// members
		GPtr<GFxMovieView> view;  // 10
	};
	static_assert(sizeof(JournalTab) == 0x18);
}


===============================================
File: include/RE/J/Journal_QuestsTab.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"
#include "RE/J/JournalTab.h"

namespace RE
{
	class Journal_QuestsTab : public JournalTab
	{
	public:
		inline static constexpr auto RTTI = RTTI_Journal_QuestsTab;

		~Journal_QuestsTab() override;  // 00

		// override (JournalTab)
		void Accept(CallbackProcessor* a_cbReg) override;  // 01

		// members
		GFxValue      unk18;  // 18
		bool          unk30;  // 30
		std::uint8_t  unk31;  // 31
		std::uint16_t unk32;  // 32
		std::uint32_t unk34;  // 34
	};
	static_assert(sizeof(Journal_QuestsTab) == 0x38);
}


===============================================
File: include/RE/J/Journal_StatsTab.h
===============================================
#pragma once

#include "RE/J/JournalTab.h"

namespace RE
{
	class Journal_StatsTab : public JournalTab
	{
	public:
		inline static constexpr auto RTTI = RTTI_Journal_StatsTab;

		~Journal_StatsTab() override;  // 00

		// override (JournalTab)
		void Accept(CallbackProcessor* a_cbReg) override;  // 01
	};
	static_assert(sizeof(Journal_StatsTab) == 0x18);
}


===============================================
File: include/RE/J/Journal_SystemTab.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/J/JournalTab.h"

namespace RE
{
	class BSSaveDataEvent;
	struct BGSSaveLoadManagerEvent;
	struct BSGamerProfileEvent;
	struct BSRemoteGamepadEvent;

	class Journal_SystemTab :
		public JournalTab,                             // 00
		public BSTEventSink<BSSaveDataEvent>,          // 18
		public BSTEventSink<BSGamerProfileEvent>,      // 20
		public BSTEventSink<BGSSaveLoadManagerEvent>,  // 28
		public BSTEventSink<BSRemoteGamepadEvent>      // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_Journal_SystemTab;

		~Journal_SystemTab() override;  // 00

		// override (JournalTab)
		void Accept(CallbackProcessor* a_cbReg) override;  // 01

		// override (BSTEventSink<BSSaveDataEvent>)
		BSEventNotifyControl ProcessEvent(const BSSaveDataEvent* a_event, BSTEventSource<BSSaveDataEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BSGamerProfileEvent>)
		BSEventNotifyControl ProcessEvent(const BSGamerProfileEvent* a_event, BSTEventSource<BSGamerProfileEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BGSSaveLoadManagerEvent>)
		BSEventNotifyControl ProcessEvent(const BGSSaveLoadManagerEvent* a_event, BSTEventSource<BGSSaveLoadManagerEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BSRemoteGamepadEvent>)
		BSEventNotifyControl ProcessEvent(const BSRemoteGamepadEvent* a_event, BSTEventSource<BSRemoteGamepadEvent>* a_eventSource) override;  // 01
	};
	static_assert(sizeof(Journal_SystemTab) == 0x38);
}


===============================================
File: include/RE/J/JumpHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	struct JumpHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_JumpHandler;
		inline static constexpr auto VTABLE = VTABLE_JumpHandler;

		~JumpHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04
	};
	static_assert(sizeof(JumpHandler) == 0x10);
}


===============================================
File: include/RE/K/KinectEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/I/IDEvent.h"

namespace RE
{
	class KinectEvent : public IDEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_KinectEvent;

		~KinectEvent() override;  // 00

		// members
		BSFixedString heard;  // 28
	};
	static_assert(sizeof(KinectEvent) == 0x30);
}


===============================================
File: include/RE/K/KinectMenu.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class MenuOpenCloseEvent;

	// menuDepth = 6
	// flags = kAllowSaving | kCustomRendering | kAssignCursorToRenderer
	// context = kNone
	class KinectMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                            // 00
		public BSTEventSink<MenuOpenCloseEvent>  // 30
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_KinectMenu;
		constexpr static std::string_view MENU_NAME = "Kinect Menu";

		~KinectMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04

#ifndef SKYRIM_CROSS_VR
		// override (BSTEventSink<MenuOpenCloseEvent>)
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<MenuOpenCloseEvent>>(this, 0x30, 0x40);
		}

		[[nodiscard]] const BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() const noexcept
		{
			return const_cast<KinectMenu*>(this)->AsMenuOpenCloseEventSink();
		}

		[[nodiscard]] inline GFxValue GetRoot() const noexcept
		{
			return REL::RelocateMember<GFxValue>(this, 0x38, 0x48);
		}

		inline void SetRoot(GFxValue a_root) noexcept
		{
			REL::RelocateMember<GFxValue>(this, 0x38, 0x48) = a_root;
		}

		// members
#ifndef SKYRIM_CROSS_VR
		GFxValue root;  // 38, 48 - "Menu_mc"
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(KinectMenu) == 0x50);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(KinectMenu) == 0x60);
#endif
}


===============================================
File: include/RE/L/LegendarySkillResetConfirmCallback.h
===============================================
#pragma once

#include "RE/I/IMessageBoxCallback.h"

namespace RE
{
	class LegendarySkillResetConfirmCallback : public RE::IMessageBoxCallback
	{
	public:
		inline static constexpr auto RTTI = RTTI___LegendarySkillResetConfirmCallback;

		virtual ~LegendarySkillResetConfirmCallback();  // 00

		// override (IMessageBoxCallback)
		void Run(Message a_msg) override;  // 01

		// members
		std::uint64_t  unk10;  // 10
		std::uint32_t  unk18;  // 18
		RE::ActorValue skill;  // 1C
	};
	static_assert(sizeof(LegendarySkillResetConfirmCallback) == 0x20);
}


===============================================
File: include/RE/L/LevelIncrease.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class PlayerCharacter;

	struct LevelIncrease
	{
	public:
		struct Event
		{
		public:
			// members
			PlayerCharacter* player;    // 00
			std::uint16_t    newLevel;  // 08
			std::uint16_t    pad0A;     // 0A
			std::uint32_t    pad0C;     // 0C
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<LevelIncrease::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/L/LevelUpMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 3
	// flags = kPausesGame | kModal | kDisablePauseMenu
	// kUsesCursor is gamepad is disabled
	// context = kMenuMode
	class LevelUpMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_LevelUpMenu;
		constexpr static std::string_view MENU_NAME = "LevelUp Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT      \
	bool          unk30; /* 00 */ \
	std::uint8_t  pad31; /* 01 */ \
	std::uint16_t pad32; /* 02 */ \
	std::uint32_t pad34; /* 04 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x8);

		~LevelUpMenu() override;  // 00

		// override (IMenu)
		void Accept(CallbackProcessor* a_cbReg) override;  // 01

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(LevelUpMenu) == 0x38);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(LevelUpMenu) == 0x48);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/L/LightEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class NiPointLight;

	class LightEffect : public ActiveEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_LightEffect;
		inline static constexpr auto VTABLE = VTABLE_LightEffect;

		// override (ActiveEffect)
		void Update(float a_delta) override;                                     // 04
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;                  // 0A
		void Revert(BGSLoadFormBuffer* a_buf) override;                          // 0B
		void SwitchAttachedRoot(NiNode* a_root, NiNode* a_attachRoot) override;  // 0E

		~LightEffect() override;  // 13

		void Start() override;   // 14
		void Finish() override;  // 15

		// members
		NiPointer<NiPointLight> light;  // 90
	};
	static_assert(sizeof(LightEffect) == 0x98);
}


===============================================
File: include/RE/L/LinkerProcessor.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/I/IObjectProcessor.h"

namespace RE
{
	namespace BSScript
	{
		class ErrorLogger;
		class IVirtualMachine;
		class ObjectTypeInfo;

		class LinkerProcessor : public IObjectProcessor
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__LinkerProcessor;
			inline static constexpr auto VTABLE = VTABLE_BSScript__LinkerProcessor;

			~LinkerProcessor() override;  // 00

			// override (IObjectProcessor)
			IObjectProcessor* Clone() override;                                    // 01
			void              SetLoader(ILoader* a_loader) override;               // 02 - { loader = a_loader; }
			bool              Process(const BSFixedString& a_className) override;  // 03

			// members
			IVirtualMachine*                                            vm;                  // 08
			ErrorLogger*                                                errorHandler;        // 10
			ILoader*                                                    loader;              // 18
			bool                                                        allowRelinking;      // 20 - whether to allow relinking when calling `Process` on already linked class
			BSScrapArray<BSFixedString>                                 loadedParents;       // 28
			BSScrapArray<BSFixedString>                                 objectsToTypecheck;  // 48
			BSScrapArray<BSFixedString>                                 processQueue;        // 68
			BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>* classMap;            // 88
		};
		static_assert(sizeof(LinkerProcessor) == 0x90);
	}
}


===============================================
File: include/RE/L/LoadStorageWrapper.h
===============================================
#pragma once

#include "RE/B/BSMemStorage.h"

namespace RE
{
	class LoadStorageWrapper : public BSMemStorage
	{
	public:
		inline static constexpr auto RTTI = RTTI_LoadStorageWrapper;
		inline static constexpr auto VTABLE = VTABLE_LoadStorageWrapper;

		~LoadStorageWrapper() override;  // 00

		// override BSMemStorage
		std::size_t              GetSize() const override;                                                       // 01
		std::size_t              GetPosition() const override;                                                   // 02
		BSStorageDefs::ErrorCode Seek(std::size_t a_offset, BSStorageDefs::SeekMode a_seekMode) const override;  // 03
		BSStorageDefs::ErrorCode Read(std::size_t a_numBytes, std::byte* a_bytes) const override;                // 04
		BSStorageDefs::ErrorCode Write(std::size_t a_numBytes, const std::byte* a_bytes) override;               // 05
	};
	static_assert(sizeof(LoadStorageWrapper) == 0x30);
}


===============================================
File: include/RE/L/LoadWaitSpinner.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class BSSystemEvent;
	struct BGSSaveLoadManagerEvent;
	struct BSGamerProfileEvent;

	// menuDepth = 10
	// flags = kAlwaysOpen | kAllowSaving
	// context = kNone
	class LoadWaitSpinner :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                                 // 00
		public BSTEventSink<BSSystemEvent>,           // 30
		public BSTEventSink<BSGamerProfileEvent>,     // 38
		public BSTEventSink<BGSSaveLoadManagerEvent>  // 40
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_LoadWaitSpinner;
		constexpr static std::string_view MENU_NAME = "LoadWaitSpinner";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                           \
	GFxValue              root;   /* 00 - "Menu_mc" */ \
	volatile std::int32_t unk60;  /* 18 */             \
	bool                  fadeIn; /* 1C */             \
	std::uint8_t          pad65;  /* 1D */             \
	std::uint16_t         pad66;  /* 1E */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x20);

		~LoadWaitSpinner() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01 - { return; }
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

#ifndef SKYRIM_CROSS_VR
		// override (BSTEventSink<BSSystemEvent>)
		BSEventNotifyControl ProcessEvent(const BSSystemEvent* a_event, BSTEventSource<BSSystemEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BSGamerProfileEvent>)
		BSEventNotifyControl ProcessEvent(const BSGamerProfileEvent* a_event, BSTEventSource<BSGamerProfileEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BGSSaveLoadManagerEvent>)
		BSEventNotifyControl ProcessEvent(const BGSSaveLoadManagerEvent* a_event, BSTEventSource<BGSSaveLoadManagerEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] BSTEventSink<BSSystemEvent>* AsBSSystemEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BSSystemEvent>>(this, 0x30, 0x40);
		}

		[[nodiscard]] const BSTEventSink<BSSystemEvent>* AsBSSystemEventSink() const noexcept
		{
			return const_cast<LoadWaitSpinner*>(this)->AsBSSystemEventSink();
		}

		[[nodiscard]] BSTEventSink<BSGamerProfileEvent>* AsBSGamerProfileEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BSGamerProfileEvent>>(this, 0x38, 0x48);
		}

		[[nodiscard]] const BSTEventSink<BSGamerProfileEvent>* AsBSGamerProfileEventSink() const noexcept
		{
			return const_cast<LoadWaitSpinner*>(this)->AsBSGamerProfileEventSink();
		}

		[[nodiscard]] BSTEventSink<BGSSaveLoadManagerEvent>* AsBGSSaveLoadManagerEvent() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BGSSaveLoadManagerEvent>>(this, 0x40, 0x50);
		}

		[[nodiscard]] const BSTEventSink<BGSSaveLoadManagerEvent>* AsBGSSaveLoadManagerEvent() const noexcept
		{
			return const_cast<LoadWaitSpinner*>(this)->AsBGSSaveLoadManagerEvent();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x48, 0x58);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x48, 0x58);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 48, 58
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(LoadWaitSpinner) == 0x68);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(LoadWaitSpinner) == 0x78);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/L/LoadingMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class BGSLocation;
	class TESLoadScreen;

	// menuDepth = 9
	// flags = kPausesGame | kAlwaysOpen | kAllowSaving | kApplicationMenu
	// context = kNone
	class LoadingMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_LoadingMenu;
		inline static constexpr auto      VTABLE = VTABLE_LoadingMenu;
		constexpr static std::string_view MENU_NAME = "Loading Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                    \
	GFxValue                 root;             /* 30 - "Menu_mc" */ \
			BGSLocation*             currentLocation;  /* 48 */ \
			bool                     unk50;            /* 50 */ \
			bool                     unk51;            /* 51 */ \
			std::uint16_t            pad52;            /* 52 */ \
			std::uint32_t            pad54;            /* 54 */ \
			BSTArray<TESLoadScreen*> loadScreens;      /* 58 */ \
			std::uint32_t            unk70;            /* 70 */ \
			std::uint32_t            pad74;            /* 74 */ \
			std::uint64_t            unk78;            /* 78 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x50);

		~LoadingMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(LoadingMenu) == 0x80);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(LoadingMenu) == 0x90);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/L/LocalMapCamera.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESCamera.h"
#include "RE/T/TESCameraState.h"

namespace RE
{
	class NiCamera;

	class LocalMapCamera : public TESCamera
	{
	public:
		inline static constexpr auto RTTI = RTTI_LocalMapCamera;

		class DefaultState : public TESCameraState
		{
		public:
			inline static constexpr auto RTTI = RTTI_LocalMapCamera__DefaultState;
			inline static constexpr auto VTABLE = VTABLE_LocalMapCamera__DefaultState;

			~DefaultState() override;  // 00

			// add
			void Begin() override;                                               // 01
			void Update(BSTSmartPointer<TESCameraState>& a_nextState) override;  // 03

			// members
			NiPoint3      initialPosition;       // 20
			NiPoint3      translation;           // 2C
			float         zoom;                  // 38
			float         minFrustumHalfWidth;   // 3C
			float         minFrustumHalfHeight;  // 40
			std::uint32_t pad44;                 // 44
		};
		static_assert(sizeof(DefaultState) == 0x48);

		LocalMapCamera(float a_zRotation);
		~LocalMapCamera() override;  // 00

		void SetAreaBounds(NiPoint3& a_maxExtent, NiPoint3& a_minExtent);
		void SetDefaultStateInitialPosition(NiPoint3& a_position);
		void SetDefaultStateMinFrustumDimensions(float a_width, float a_height);
		void SetDefaultStateTranslation(float a_x, float a_y, float a_z);
		void SetNorthRotation(float a_northRotation);

		// members
		NiPoint3                      maxExtent;     // 38
		NiPoint3                      minExtent;     // 44
		BSTSmartPointer<DefaultState> defaultState;  // 50
		NiPointer<NiCamera>           camera;        // 58
		float                         zRotation;     // 60
		std::uint32_t                 pad64;         // 64

	protected:
		LocalMapCamera* Ctor(float a_zRotation);
	};
	static_assert(sizeof(LocalMapCamera) == 0x68);
}


===============================================
File: include/RE/L/LocalMapMenu.h
===============================================
#pragma once

#include "RE/B/BSCullingProcess.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/G/GFxValue.h"
#include "RE/I/ImageData.h"
#include "RE/I/ImageSpaceShaderParam.h"
#include "RE/L/LocalMapCamera.h"
#include "RE/M/MenuEventHandler.h"
#include "RE/N/NiCamera.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSShaderAccumulator;
	class NiNode;

	struct LocalMapMenu
	{
	public:
		struct LocalMapCullingProcess
		{
		public:
			struct Data
			{
			public:
				// members
				NiPointer<BSShaderAccumulator> shaderAccumulator;  // 00
				void*                          unk08;              // 08 - smart ptr
				NiPointer<NiCamera>            camera;             // 10
				std::uint64_t                  unk18;              // 18
				std::uint64_t                  unk20;              // 20
				std::uint64_t                  unk28;              // 28
				std::uint64_t                  unk30;              // 30
				std::uint64_t                  unk38;              // 38
				void*                          unk40;              // 40 - smart ptr
			};
			static_assert(sizeof(Data) == 0x48);

			[[nodiscard]] inline LocalMapCamera* GetLocalMapCamera() const noexcept
			{
				return &REL::RelocateMember<LocalMapCamera>(this, 0x30260, 0x30270);
			}

			void SetLocalMapCamera(const LocalMapCamera& localMapCamera) noexcept
			{
				REL::RelocateMember<LocalMapCamera>(this, 0x30260, 0x30270) = localMapCamera;
			}

			// members
			BSCullingProcess cullingProcess;  // 00000
			Data             unk301F8;        // 301F8
			std::uint64_t    unk30240;        // 30240
			std::uint64_t    unk30248;        // 30248
#ifndef ENABLE_SKYRIM_VR
			std::uint64_t                  unk30250;  // 30250
			std::uint64_t                  unk30258;  // 30258
			LocalMapCamera                 camera;    // 30260
			NiPointer<BSShaderAccumulator> unk302C8;  // 302C8
			ImageSpaceShaderParam          unk302D0;  // 302D0
			std::uint64_t                  unk30350;  // 30350
			NiPointer<NiNode>              unk30358;  // 30358
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
			std::uint64_t                  padVR1;    // 30250
			std::uint64_t                  padVR2;    // 30258
			std::uint64_t                  unk30260;  // 30260
			std::uint64_t                  unk30268;  // 30268
			LocalMapCamera                 camera;    // 30270
			NiPointer<BSShaderAccumulator> unk302D8;  // 302D8
			ImageSpaceShaderParam          unk302E0;  // 302E0
			std::uint64_t                  unk30360;  // 30360
			NiPointer<NiNode>              unk30368;  // 30368
			BSTArray<void*>                unk30370;  // 30370
			BSTArray<void*>                unk30388;  // 30388
			BSTArray<void*>                unk303A0;  // 303A0
			void*                          unk303B8;  // 303B8
			NiCamera*                      unk303C0;  // 303C0
			std::uint32_t                  unk303C8;  // 303C8
			std::uint32_t                  pad303CC;  // 303CC
			std::uint64_t                  unk303D0;  // 303D0
#else
			std::uint64_t unk30250;         // 30250
			std::uint64_t unk30258;         // 30258
			std::uint8_t  unk30260[0x100];  // 30260
#endif
		};
#ifndef ENABLE_SKYRIM_VR
		static_assert(sizeof(LocalMapCullingProcess) == 0x30360);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		static_assert(sizeof(LocalMapCullingProcess) == 0x303D8);
#endif

		class InputHandler : public MenuEventHandler
		{
		public:
			inline static constexpr auto RTTI = RTTI_LocalMapMenu__InputHandler;

			~InputHandler() override;  // 00

			// override (MenuEventHandler)
			bool CanProcess(InputEvent* a_event) override;              // 01
			bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03
			bool ProcessMouseMove(MouseMoveEvent* a_event) override;    // 04
			bool ProcessButton(ButtonEvent* a_event) override;          // 05

			// members
			LocalMapMenu* localMapMenu;  // 10
		};
		static_assert(sizeof(InputHandler) == 0x18);

		struct RUNTIME_DATA
		{
			ImageData                     unk303A0;  // 00
			GFxValue                      unk303B8;  // 18
			GFxValue                      unk303D0;  // 30
			void*                         unk303E8;  // 48
			BSTSmartPointer<InputHandler> unk303F0;  // 50
			std::uint64_t                 unk303F8;  // 58
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x60);

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x303A0, 0x30418);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x303A0, 0x30418);
		}

		// members
		BSTArray<void*>        unk00000;             // 00000
		GFxValue               unk00018;             // 00018
		float                  unk00030;             // 00030
		float                  unk00034;             // 00034
		float                  unk00038;             // 00038
		float                  unk0003C;             // 0003C
		LocalMapCullingProcess localCullingProcess;  // 00040
		RUNTIME_DATA           runtimeData;          // 303A0, 30418
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		std::uint32_t unk30478;  // 30478
		std::uint32_t pad3047C;  // 3047C
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(LocalMapMenu) == 0x30400);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(LocalMapMenu) == 0x30480);
#endif
}


===============================================
File: include/RE/L/Location.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/E/ErrorCodes.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	namespace BSResource
	{
		class AsyncStream;
		class LocationTraverser;
		class Stream;
		struct Info;

		class Location
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource__Location;

			Location();
			virtual ~Location();  // 00

			// add
			virtual ErrorCode                   DoMount();                                                                                                             // 01 - { return ErrorCode::kNone; }
			virtual void                        DoUnmount();                                                                                                           // 02 - { return; }
			virtual ErrorCode                   DoCreateStream(const char* a_path, BSTSmartPointer<Stream>& a_stream, Location*& a_location, bool a_readOnly) = 0;     // 03
			virtual ErrorCode                   DoCreateAsyncStream(const char* a_path, BSTSmartPointer<AsyncStream>& a_out, Location*& a_location, bool a_readOnly);  // 04 - { return ErrorCode::kUnsupported; }
			virtual ErrorCode                   DoTraversePrefix(const char* a_path, LocationTraverser& a_traverser) = 0;                                              // 05
			virtual ErrorCode                   DoGetInfo1(const char* a_path, Info& a_info, Location*& a_location);                                                   // 06 - { return ErrorCode::kUnsupported; }
			virtual ErrorCode                   DoGetInfo2(const char* a_path, Info& a_info, LocationTraverser* a_traverser);                                          // 07 - { return ErrorCode::kUnsupported; }
			virtual ErrorCode                   DoDelete(const char* a_path);                                                                                          // 08 - { return ErrorCode::kUnsupported; }
			[[nodiscard]] virtual const char*   DoGetName() const;                                                                                                     // 09 - { return 0; }
			[[nodiscard]] virtual std::uint32_t DoQBufferHint() const;                                                                                                 // 0A - { return 0x80000; }
			[[nodiscard]] virtual std::uint32_t DoGetMinimumAsyncPacketSize() const;                                                                                   // 0B - { return 0x80000; }

			TES_HEAP_REDEFINE_NEW();

			ErrorCode DoGetInfo(const char* a_path, Info& a_info, Location*& a_location);
			ErrorCode DoGetInfo(const char* a_path, Info& a_info, LocationTraverser* a_traverser);

			// members
			bool          mounted;  // 08
			std::uint8_t  pad09;    // 09
			std::uint16_t pad0A;    // 0A
			std::uint32_t pad0C;    // 0C
		};
		static_assert(sizeof(Location) == 0x10);
	}
}


===============================================
File: include/RE/L/LocationCleared.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	struct LocationCleared
	{
	public:
		struct Event
		{
			// empty
		};

		static BSTEventSource<Event>* GetEventSource();
	};
}


===============================================
File: include/RE/L/LocationDiscovery.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class MapMarkerData;

	struct LocationDiscovery
	{
	public:
		struct Event
		{
		public:
			// members
			MapMarkerData* mapMarkerData;  // 00
			const char*    worldspaceID;   // 08
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<LocationDiscovery::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/L/LocationTraverser.h
===============================================
#pragma once

namespace RE
{
	namespace BSResource
	{
		class Location;

		class LocationTraverser
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource__LocationTraverser;

			// add
			virtual void ProcessName(const char* a_name, Location& a_location) = 0;  // 00
		};
		static_assert(sizeof(LocationTraverser) == 0x8);
	}
}


===============================================
File: include/RE/L/LocationTree.h
===============================================
#pragma once

#include "RE/L/Location.h"

namespace RE
{
	namespace BSResource
	{
		class LocationTree : public Location
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource____LocationTree;

			~LocationTree() override;  // 00

			// override (Location)
			ErrorCode DoCreateStream(const char* a_path, BSTSmartPointer<Stream>& a_stream, Location*& a_location, bool a_readOnly) override;         // 03
			ErrorCode DoCreateAsyncStream(const char* a_path, BSTSmartPointer<AsyncStream>& a_out, Location*& a_location, bool a_readOnly) override;  // 04
			ErrorCode DoTraversePrefix(const char* a_path, LocationTraverser& a_traverser) override;                                                  // 05
			ErrorCode DoGetInfo1(const char* a_path, Info& a_info, Location*& a_location) override;                                                   // 06
			ErrorCode DoGetInfo2(const char* a_path, Info& a_info, LocationTraverser* a_traverser) override;                                          // 07
			ErrorCode DoDelete(const char* a_path) override;                                                                                          // 08

			// members
			Location* lhs;  // 10
			Location* rhs;  // 18
		};
		static_assert(sizeof(LocationTree) == 0x20);
	}
}


===============================================
File: include/RE/L/LockEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class LockEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_LockEffect;
		inline static constexpr auto VTABLE = VTABLE_LockEffect;

		// override (ActiveEffect)
		virtual ~LockEffect();          // 13
		virtual void Start() override;  // 14
	};
	static_assert(sizeof(LockEffect) == 0x90);
}


===============================================
File: include/RE/L/LockpickingMenu.h
===============================================
#pragma once

#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTEvent.h"
#include "RE/I/IMenu.h"
#include "RE/M/MenuEventHandler.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class MenuOpenCloseEvent;
	class NiAVObject;
	class NiControllerManager;
	class NiControllerSequence;
	class TESObjectREFR;

	// menuDepth = 3
	// flags = kPausesGame | kDisablePauseMenu | kRequiresUpdate
	// context = kLockpicking
	class LockpickingMenu :
		public IMenu,  // 00
#ifndef SKYRIM_CROSS_VR
		public MenuEventHandler,                 // 30
		public BSTEventSink<MenuOpenCloseEvent>  // 40
#else
		public MenuEventHandler  // 30
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_LockpickingMenu;
		inline static constexpr auto      VTABLE = VTABLE_LockpickingMenu;
		constexpr static std::string_view MENU_NAME = "Lockpicking Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                            \
	void*                 lockpickShiv;        /* 00 */ \
	void*                 lockpick;            /* 08 */ \
	NiMatrix3             pickRotation;        /* 10 */ \
	NiPoint3              lockRotCenter;       /* 34 */ \
	NiControllerManager*  lockController;      /* 40 */ \
	NiControllerSequence* lockIntro;           /* 48 */ \
	NiControllerSequence* lockRotate;          /* 50 */ \
	NiControllerManager*  pickController;      /* 58 */ \
	NiControllerSequence* pickIntro;           /* 60 */ \
	NiControllerSequence* pickDamage;          /* 68 */ \
	NiControllerSequence* pickBreak;           /* 70 */ \
	NiControllerSequence* currentPickSequence; /* 78 */ \
	float                 pickKeyTime;         /* 80 */ \
	std::uint32_t         unk0CC;              /* 84 */ \
	NiControllerSequence* currentLockSequence; /* 88 */ \
	float                 lockKeyTime;         /* 90 */ \
	float                 pickAngle;           /* 94 */ \
	float                 lockAngle;           /* 98 */ \
	float                 damagePickAngle;     /* 9C */ \
	float                 pickBreakSeconds;    /* A0 */ \
	BSSoundHandle         pickTensionSound;    /* A4 */ \
	float                 unk0F8;              /* B0 */ \
	float                 sweetSpotAngle;      /* B4 */ \
	float                 partialPickAngle;    /* B8 */ \
	std::uint32_t         numBrokenPicks;      /* BC */ \
	bool                  init3DElements;      /* C0 */ \
    bool                  animating;           /* C1 */ \
	bool                  unk10A;              /* C2 */ \
	bool                  menuCleared;         /* C3 */ \
	bool                  animationFinished;   /* C4 */ \
	bool                  isLockpickingCrime;  /* C5 */ \
	std::uint8_t          unk10E;              /* C6 */ \
	std::uint8_t          pad10F;              /* C7 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0xC8);

		~LockpickingMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04

#ifndef SKYRIM_CROSS_VR
		// override (MenuEventHandler)
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03
		bool ProcessMouseMove(MouseMoveEvent* a_event) override;    // 04
		bool ProcessButton(ButtonEvent* a_event) override;          // 05

		// override (BSTEventSink<MenuOpenCloseEvent>)
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] static TESObjectREFR* GetTargetReference();

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<LockpickingMenu*>(this)->AsMenuEventHandler();
		}

		[[nodiscard]] BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<MenuOpenCloseEvent>>(this, 0x40, 0x50);
		}

		[[nodiscard]] const BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() const noexcept
		{
			return const_cast<LockpickingMenu*>(this)->AsMenuOpenCloseEventSink();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x48, 0x58);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x48, 0x58);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 48, 58
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(LockpickingMenu) == 0x110);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(LockpickingMenu) == 0x120);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/L/LogEvent.h
===============================================
#pragma once

#include "RE/E/ErrorLogger.h"

namespace RE
{
	namespace BSScript
	{
		struct LogEvent
		{
		public:
			// members
			const char* const           errorMsg;  // 00
			const ErrorLogger::Severity severity;  // 08
			std::uint32_t               pad0C;     // 0C
		};
		static_assert(sizeof(LogEvent) == 0x10);
	}
}


===============================================
File: include/RE/L/Logger.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/E/ErrorLogger.h"

namespace RE
{
	namespace SkyrimScript
	{
		class Logger : public BSScript::ErrorLogger
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript__Logger;

			~Logger() override;  // 00

			// override (BSScript::ErrorLogger)
			void PostErrorImpl(const char* a_logEvent, Severity a_severity) override;  // 01

			// members
			BSFixedString logName;  // 98
			BSFixedString logPath;  // A0
			std::uint64_t unkA8;    // A8
		};
		static_assert(sizeof(Logger) == 0xB0);
	}
}


===============================================
File: include/RE/L/LoggingDisabler.h
===============================================
#pragma once

#include "RE/G/GFxLog.h"

namespace RE
{
	class LoggingDisabler : public GFxLog
	{
	public:
		inline static constexpr auto RTTI = RTTI___LoggingDisabler;

		LoggingDisabler() = default;

		~LoggingDisabler() override = default;  // 00

		// override (GFxLog)
		void LogMessageVarg([[maybe_unused]] LogMessageType a_messageType, [[maybe_unused]] const char* a_fmt, [[maybe_unused]] std::va_list a_argList) override{};  // 01
	};
	static_assert(sizeof(LoggingDisabler) == 0x20);
}


===============================================
File: include/RE/L/LookHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	struct LookHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_LookHandler;
		inline static constexpr auto VTABLE = VTABLE_LookHandler;

		~LookHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                          // 01
		void ProcessThumbstick(ThumbstickEvent* a_event, PlayerControlsData* a_data) override;  // 02
		void ProcessMouseMove(MouseMoveEvent* a_event, PlayerControlsData* a_data) override;    // 03
	};
	static_assert(sizeof(LookHandler) == 0x10);
}


===============================================
File: include/RE/L/LooseFileLocation.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/L/Location.h"

namespace RE
{
	namespace BSResource
	{
		struct BSSystemDir
		{
		public:
			// members
			void*                    handle;             // 000
			WinAPI::WIN32_FIND_DATAA findData;           // 008
			char                     dirPath[MAX_PATH];  // 148
			ErrorCode                lastError;          // 24C
			std::uint64_t            entryPos;           // 250
		};
		static_assert(sizeof(BSSystemDir) == 0x258);

		class LooseFileLocation : public Location
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource__LooseFileLocation;

			~LooseFileLocation() override;  // 00

			// override (Location)
			ErrorCode                   DoCreateStream(const char* a_path, BSTSmartPointer<Stream>& a_stream, Location*& a_location, bool a_readOnly) override;         // 03
			ErrorCode                   DoCreateAsyncStream(const char* a_path, BSTSmartPointer<AsyncStream>& a_out, Location*& a_location, bool a_readOnly) override;  // 04
			ErrorCode                   DoTraversePrefix(const char* a_path, LocationTraverser& a_traverser) override;                                                  // 05
			ErrorCode                   DoGetInfo1(const char* a_path, Info& a_info, Location*& a_location) override;                                                   // 06
			ErrorCode                   DoGetInfo2(const char* a_path, Info& a_info, LocationTraverser* a_traverser) override;                                          // 07
			ErrorCode                   DoDelete(const char* a_path) override;                                                                                          // 08
			const char*                 DoGetName() const override;                                                                                                     // 09 - { return directory.c_str(); }
			[[nodiscard]] std::uint32_t DoGetMinimumAsyncPacketSize() const override;                                                                                   // 0B - { return minimumAsyncPacketSize; }

			// members
			BSFixedString prefix;                  // 10
			std::uint32_t minimumAsyncPacketSize;  // 18
			bool          asyncSupported;          // 1C
			std::uint8_t  pad1D;                   // 1D
			std::uint16_t pad1E;                   // 1E
		};
		static_assert(sizeof(LooseFileLocation) == 0x20);
	}
}


===============================================
File: include/RE/L/LooseFileStream.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/L/LooseFileStreamBase.h"
#include "RE/S/Stream.h"

namespace RE
{
	namespace BSResource
	{
		class Location;

		class LooseFileStream :
			public LooseFileStreamBase,  // 10
			public Stream                // 00
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource____LooseFileStream;

			~LooseFileStream() override;  // 00

			// override (Stream)
			ErrorCode DoOpen() override;                                                                                // 01
			void      DoClose() override;                                                                               // 02
			ErrorCode DoGetInfo(Info& a_info) override;                                                                 // 04
			void      DoClone(BSTSmartPointer<Stream>& a_out) const override;                                           // 05
			ErrorCode DoRead(void* a_buffer, std::uint64_t a_toRead, std::uint64_t& a_read) const override;             // 06
			ErrorCode DoWrite(const void* a_buffer, std::uint64_t a_toWrite, std::uint64_t& a_written) const override;  // 07
			ErrorCode DoSeek(std::uint64_t a_toSeek, SeekMode a_mode, std::uint64_t& a_sought) const override;          // 08
			ErrorCode DoSetEndOfStream() override;                                                                      // 09
			bool      DoGetName(BSFixedString& a_dst) const override;                                                   // 0A
			ErrorCode DoCreateAsync(BSTSmartPointer<AsyncStream>& a_streamOut) const override;                          // 0B
#ifndef ENABLE_SKYRIM_AE
			static LooseFileStream* Create(BSFixedString a_prefix, BSFixedString a_dirName, BSFixedString a_fileName, std::uint32_t a_fileSize, bool a_readOnly, Location* a_location);
#endif

			// members
			Location*     location;  // 38
			std::uint64_t filePos;   // 40
			void*         buffer;    // 48

		private:
#ifndef ENABLE_SKYRIM_AE
			LooseFileStream* Ctor(const BSFixedString& a_prefix, const BSFixedString& a_dirName, const BSFixedString& a_fileName, std::uint32_t a_fileSize, bool a_readOnly, Location* a_location);
#endif
		};
		static_assert(sizeof(LooseFileStream) == 0x50);
	}
}


===============================================
File: include/RE/L/LooseFileStreamBase.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSSystemFile.h"

namespace RE
{
	namespace BSResource
	{
		struct LooseFileStreamBase
		{
		public:
			// members
			BSFixedString prefix;    // 00
			BSFixedString dirName;   // 08
			BSFixedString fileName;  // 10
			BSSystemFile  file;      // 18
		};
		static_assert(sizeof(LooseFileStreamBase) == 0x28);
	}
}


===============================================
File: include/RE/M/MagicCaster.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/bhkPickData.h"
#include "RE/M/MagicSystem.h"

namespace RE
{
	class Actor;
	class ActiveEffect;
	class BGSSaveGameBuffer;
	class BGSLoadGameBuffer;
	class MagicItem;
	class MagicTarget;
	class NiNode;
	class TESBoundObject;
	class TESObjectCELL;
	class TESObjectREFR;

	struct Effect;

	class MagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_MagicCaster;

		enum class State
		{
			kNone = 0,
			kUnk01,  // Start?
			kUnk02,  // StartCharge?
			kReady,
			kUnk04,  // PreStart?
			kCharging,
			kCasting,
			kUnk07,  // Unknown
			kUnk08,  // Interrupt
			kUnk09,  // Interrupt/Deselect
		};

		virtual ~MagicCaster();  // 00

		// add
		virtual void                       CastSpellImmediate(MagicItem* a_spell, bool a_noHitEffectArt, TESObjectREFR* a_target, float a_effectiveness, bool a_hostileEffectivenessOnly, float a_magnitudeOverride, Actor* a_blameActor);  // 01
		virtual void                       FindTouchTarget();                                                                                                                                                                               // 02
		virtual void                       RequestCastImpl();                                                                                                                                                                               // 03
		virtual bool                       StartChargeImpl();                                                                                                                                                                               // 04
		virtual void                       StartReadyImpl();                                                                                                                                                                                // 05
		virtual void                       StartCastImpl();                                                                                                                                                                                 // 06
		virtual void                       FinishCastImpl();                                                                                                                                                                                // 07 - { return; }
		virtual void                       InterruptCastImpl(bool a_depleteEnergy);                                                                                                                                                         // 08 - { return; }
		virtual void                       SpellCast(bool a_doCast, std::uint32_t a_arg2, MagicItem* a_spell);                                                                                                                              // 09 - { return; }
		virtual bool                       CheckCast(MagicItem* a_spell, bool a_dualCast, float* a_alchStrength, MagicSystem::CannotCastReason* a_reason, bool a_useBaseValueForCost);                                                      // 0A
		virtual TESObjectREFR*             GetCasterStatsObject() const;                                                                                                                                                                    // 0B - { return 0; }
		virtual Actor*                     GetCasterAsActor() const;                                                                                                                                                                        // 0C - { return 0; }
		virtual TESObjectREFR*             GetCasterObjectReference(Actor** a_outCaster) const;                                                                                                                                             // 0D
		virtual NiNode*                    GetMagicNode();                                                                                                                                                                                  // 0E - { return 0; }
		virtual void                       ClearMagicNode();                                                                                                                                                                                // 0F - { return; }
		virtual void                       SetCurrentSpellImpl(MagicItem* a_spell);                                                                                                                                                         // 10 - { return; }
		virtual void                       SelectSpellImpl();                                                                                                                                                                               // 11 - { return; }
		virtual void                       DeselectSpellImpl();                                                                                                                                                                             // 12 - { return; }
		virtual void                       SetSkipCheckCast();                                                                                                                                                                              // 13 - { return; }
		virtual void                       SetCastingTimerForCharge();                                                                                                                                                                      // 14
		virtual MagicSystem::CastingSource GetCastingSource() const;                                                                                                                                                                        // 15 - { return 0; }
		virtual bool                       GetIsDualCasting() const;                                                                                                                                                                        // 16 - { return 0; }
		virtual void                       SetDualCasting(bool a_set);                                                                                                                                                                      // 17 - { return; }
		virtual void                       SaveGame(BGSSaveGameBuffer* a_buf);                                                                                                                                                              // 18
		virtual void                       LoadGame(BGSLoadGameBuffer* a_buf);                                                                                                                                                              // 19
		virtual void                       FinishLoadGame(BGSLoadGameBuffer* a_buf);                                                                                                                                                        // 1A
		virtual void                       PrepareSound(MagicSystem::SoundID a_sound, MagicItem* a_spell);                                                                                                                                  // 1B
		virtual void                       AdjustActiveEffect(ActiveEffect* a_activeEffect, float a_power, bool a_arg3);                                                                                                                    // 1C

		MagicTarget* FindPickTarget(NiPoint3& a_targetLocation, TESObjectCELL** a_targetCell, bhkPickData& a_pickData);
		bool         FindTargets(float a_effectivenessMult, std::uint32_t& a_targetCount, TESBoundObject* a_source, bool a_loadCast, bool a_adjustOnlyHostileEffectiveness);
		void         FinishCast();
		float        GetCurrentSpellCost();
		void         InterruptCast(bool a_refund);
		void         PlayReleaseSound(MagicItem* a_item);
		bool         TestProjectilePlacement(const Effect& a_effect, const bhkPickData& a_pickData);
		void         UpdateImpl(float a_delta);

		// members
		BSTArray<BSSoundHandle>                sounds;             // 08
		ObjectRefHandle                        desiredTarget;      // 20
		std::uint32_t                          pad24;              // 24
		MagicItem*                             currentSpell;       // 28
		stl::enumeration<State, std::uint32_t> state;              // 30
		float                                  castingTimer;       // 34
		float                                  currentSpellCost;   // 38
		float                                  magnitudeOverride;  // 3C
		float                                  nextTargetUpdate;   // 40
		float                                  projectileTimer;    // 44
	};
	static_assert(sizeof(MagicCaster) == 0x48);
}


===============================================
File: include/RE/M/MagicFavorites.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	class TESForm;

	class MagicFavorites :
		public BSTSingletonSDM<MagicFavorites>  // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_MagicFavorites;

		virtual ~MagicFavorites();  // 00

		static MagicFavorites* GetSingleton();

		void RemoveFavorite(TESForm* a_form);
		void SetFavorite(TESForm* a_form);

		// members
		std::uint8_t       pad09;    // 09
		std::uint16_t      pad0A;    // 0A
		std::uint32_t      pad0C;    // 0C
		BSTArray<TESForm*> spells;   // 10
		BSTArray<TESForm*> hotkeys;  // 28
	};
	static_assert(sizeof(MagicFavorites) == 0x40);
}


===============================================
File: include/RE/M/MagicFormulas.h
===============================================
#pragma once

namespace RE
{
	namespace MagicFormulas
	{
		float CalcDualCastCost(float a_spellCost);
		float GetWortcraftEffectStrength(float a_alchemySkill);
	}
}


===============================================
File: include/RE/M/MagicItem.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/E/EffectArchetypes.h"
#include "RE/M/MagicItemDataCollector.h"
#include "RE/M/MagicItemTraversalFunctor.h"
#include "RE/M/MagicSystem.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class Actor;
	class ActorValueInfo;
	class Character;
	class EffectItem;
	class EffectSetting;
	class QueuedFile;
	class TESModel;
	class TESObjectWEAP;
	struct Effect;

	class MagicItem :
		public TESBoundObject,  // 00
		public TESFullName,     // 30
		public BGSKeywordForm   // 40
	{
	public:
		inline static constexpr auto RTTI = RTTI_MagicItem;

		class PreloadableVisitor
		{
		public:
			// add
			virtual void VisitModel(TESModel* a_model) = 0;         // 00
			virtual void VisitWeapon(TESObjectWEAP* a_weapon) = 0;  // 01
		};
		static_assert(sizeof(PreloadableVisitor) == 0x8);

		struct SkillUsageData
		{
		public:
			// members
			EffectItem*   effect;     // 00
			ActorValue    skill;      // 08
			float         magnitude;  // 0C
			bool          custom;     // 10
			std::uint8_t  pad11;      // 11
			std::uint16_t pad12;      // 12
			std::uint32_t pad14;      // 14
		};
		static_assert(sizeof(SkillUsageData) == 0x18);

		class Data
		{
		public:
			// members
			std::int32_t  costOverride;  // 0
			std::uint32_t flags;         // 4
		};
		static_assert(sizeof(Data) == 0x8);

		~MagicItem() override;  // 00

		// override (TESBoundObject)
		void InitializeData() override;          // 04 - { TESForm::InitDefaults(); }
		bool Load(TESFile* a_mod) override;      // 06
		void InitItemImpl() override;            // 13
		bool IsMagicItem() const override;       // 29 - { return true; }
		void Copy(TESForm* a_srcForm) override;  // 2F
		bool IsAutoCalc() const override;        // 3E - { return (GetData().flags & 1) == 0; }

		// override (BGSKeywordForm)
		bool HasKeyword(const BGSKeyword* a_keyword) const override;  // 04

		// add
		[[nodiscard]] virtual MagicSystem::SpellType   GetSpellType() const = 0;                                     // 53
		virtual void                                   SetCastingType(MagicSystem::CastingType a_type);              // 54 - { return; }
		[[nodiscard]] virtual MagicSystem::CastingType GetCastingType() const = 0;                                   // 55
		virtual void                                   SetDelivery(MagicSystem::Delivery a_delivery);                // 56 - { return; }
		[[nodiscard]] virtual MagicSystem::Delivery    GetDelivery() const = 0;                                      // 57
		[[nodiscard]] virtual bool                     IsValidDelivery(MagicSystem::Delivery a_delivery);            // 58 - { return true; }
		[[nodiscard]] virtual float                    GetFixedCastDuration() const;                                 // 59 - { return 0.0; }
		[[nodiscard]] virtual float                    GetRange() const;                                             // 5A - { return 0.0; }
		[[nodiscard]] virtual bool                     IgnoresResistance() const;                                    // 5B - { return false; }
		[[nodiscard]] virtual bool                     IgnoreLOS() const;                                            // 5C - { return false; }
		[[nodiscard]] virtual bool                     IsFood() const;                                               // 5D - { return false; }
		[[nodiscard]] virtual bool                     GetNoAbsorb() const;                                          // 5E - { return false; }
		[[nodiscard]] virtual bool                     GetNoDualCastModifications() const;                           // 5F - { return false; }
		virtual bool                                   GetSkillUsageData(SkillUsageData& a_data) const;              // 60 - { return false; }
		[[nodiscard]] virtual bool                     IsPoison() const;                                             // 61 - { return GetSpellType() == MagicSystem::SpellType::kPoison; }
		[[nodiscard]] virtual bool                     IsMedicine() const;                                           // 62 - { return false; }
		virtual void                                   AdjustCost(float& a_cost, Actor* a_actor) const;              // 63 - { return; }
		[[nodiscard]] virtual float                    GetChargeTime() const;                                        // 64 - { return 0.0; }
		[[nodiscard]] virtual std::uint32_t            GetMaxEffectCount() const;                                    // 65 - { return 0; }
		[[nodiscard]] virtual ActorValue               GetAssociatedSkill() const;                                   // 66 - { return ActorValue::kNone; }
		[[nodiscard]] virtual bool                     IsTwoHanded() const;                                          // 67 - { return false; }
		[[nodiscard]] virtual std::uint32_t            GetChunkID() = 0;                                             // 68
		virtual void                                   CopyMagicItemData(MagicItem* a_src) = 0;                      // 69
		virtual void                                   LoadMagicItemChunk(TESFile* a_mod, std::uint32_t a_chunkID);  // 6A - { return; }
		virtual void                                   LoadChunkDataPostProcess(TESFile* a_mod);                     // 6B - { return; }
		[[nodiscard]] virtual const Data*              GetData1() const = 0;                                         // 6C
		[[nodiscard]] virtual Data*                    GetData2() = 0;                                               // 6D
		[[nodiscard]] virtual std::uint32_t            GetDataSize() const = 0;                                      // 6E
		virtual void                                   InitFromChunk(TESFile* a_mod) = 0;                            // 6F
		virtual void                                   InitChunk() = 0;                                              // 70

		[[nodiscard]] float                  CalculateMagickaCost(Actor* a_caster) const;
		[[nodiscard]] float                  CalculateTotalGoldValue(Actor* a_caster = nullptr) const;
		[[nodiscard]] MagicItemDataCollector CollectData() const;
		[[nodiscard]] EffectSetting*         GetAVEffect() const;
		[[nodiscard]] Effect*                GetCostliestEffectItem(MagicSystem::Delivery a_delivery = MagicSystem::Delivery::kTotal, bool a_positiveArea = false) const;
		[[nodiscard]] Data*                  GetData();
		[[nodiscard]] const Data*            GetData() const;
		[[nodiscard]] bool                   IsValid() const;
		[[nodiscard]] std::int32_t           GetLargestArea() const;
		[[nodiscard]] std::uint32_t          GetLongestDuration() const;
		[[nodiscard]] bool                   HasEffect(EffectArchetype a_archetype);
		[[nodiscard]] bool                   IsPermanent() const;
		void                                 Traverse(MagicItemTraversalFunctor& a_visitor) const;

		// members
		BSTArray<Effect*>           effects;          // 58
		std::int32_t                hostileCount;     // 70
		std::uint32_t               pad74;            // 74
		EffectSetting*              avEffectSetting;  // 78
		std::uint32_t               preloadCount;     // 80
		std::uint32_t               pad84;            // 84
		BSTSmartPointer<QueuedFile> preloadedItem;    // 88

	protected:
		float CalculateCost(Actor* a_caster) const;
	};
	static_assert(sizeof(MagicItem) == 0x90);
}


===============================================
File: include/RE/M/MagicItemDataCollector.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/M/MagicItemTraversalFunctor.h"

namespace RE
{
	class MagicItem;

	class MagicItemDataCollector : public MagicItemTraversalFunctor
	{
	public:
		inline static constexpr auto RTTI = RTTI_MagicItemDataCollector;
		inline static constexpr auto VTABLE = VTABLE_MagicItemDataCollector;

		enum class Flags
		{
			kNone = 0,
			kSkipCostiest = 1 << 0,
			kSkipProjectiles = 1 << 1,
			kSkipArea = 1 << 2,
			kOnlyFirstEffect = 1 << 3
		};

		MagicItemDataCollector() = delete;
		MagicItemDataCollector(const MagicItem* a_magicItem);
		~MagicItemDataCollector() override = default;

		// override (MagicItemTraversalFunctor)
		BSContainer::ForEachResult operator()(Effect* a_effect) override;

		// members
		BSTArray<Effect*>                      projectileEffectList;       // 10
		Effect*                                costliestEffect;            // 28
		std::int32_t                           maxCost;                    // 30
		std::uint32_t                          pad34;                      // 34
		Effect*                                largestAreaEffect;          // 38
		float                                  highestArea;                // 40
		stl::enumeration<Flags, std::uint32_t> flags;                      // 44
		bool                                   summonsExtraLargeCreature;  // 48
		std::uint8_t                           pad49;                      // 49
		std::uint16_t                          pad4A;                      // 4A
		std::uint32_t                          pad4C;                      // 4C
	};
	static_assert(sizeof(MagicItemDataCollector) == 0x50);
}


===============================================
File: include/RE/M/MagicItemTraversalFunctor.h
===============================================
#pragma once

#include "RE/B/BSContainer.h"

namespace RE
{
	struct Effect;

	class MagicItemTraversalFunctor
	{
	public:
		inline static constexpr auto RTTI = RTTI_MagicItemTraversalFunctor;

		MagicItemTraversalFunctor() = default;
		virtual ~MagicItemTraversalFunctor() = default;  // 00

		// add
		virtual BSContainer::ForEachResult operator()(Effect* a_effect) = 0;

		TES_HEAP_REDEFINE_NEW();

		// members
		std::uint32_t index{ 0 };  // 08
		std::uint32_t pad0C{ 0 };  // 0C
	};
	static_assert(sizeof(MagicItemTraversalFunctor) == 0x10);
}


===============================================
File: include/RE/M/MagicMenu.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	struct BottomBar;
	struct ItemCard;

	// menuDepth = 0
	// flags = kPausesGame | kUsesMenuContext | kDisablePauseMenu | kUpdateUsesCursor | kInventoryItemMenu | kCustomRendering
	// context = kItemMenu
	class MagicMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_MagicMenu;
		constexpr static std::string_view MENU_NAME = "MagicMenu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                  \
	void*         unk30;           /* 00 - some variation of the item list */ \
	ItemCard*     itemCard;        /* 08 */                                   \
	BottomBar*    bottomBar;       /* 10 */                                   \
	GFxValue      root;            /* 18 - "Menu_mc" */                       \
	bool          pcControlsReady; /* 30 */                                   \
	std::uint8_t  pad61;           /* 31 */                                   \
	std::uint16_t pad62;           /* 32 */                                   \
	std::uint32_t pad64;           /* 34 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x38);

		~MagicMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04
		void               PostDisplay() override;                           // 06

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(MagicMenu) == 0x68);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(MagicMenu) == 0x78);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/M/MagicSystem.h
===============================================
#pragma once

namespace RE
{
	class BGSSoundDescriptorForm;

	namespace MagicSystem
	{
		enum class CannotCastReason
		{
			kOK = 0,
			kMagicka = 1,
			kPowerUsed = 2,
			kRangedUnderWater = 3,
			kMultipleCast = 4,
			kItemCharge = 5,
			kCastWhileShouting = 6,
			kShoutWhileCasting = 7,
			kShoutWhileRecovering = 8
		};

		enum class CastingSource
		{
			kLeftHand = 0,
			kRightHand = 1,
			kOther = 2,
			kInstant = 3
		};

		enum class CastingType
		{
			kConstantEffect = 0,
			kFireAndForget = 1,
			kConcentration = 2,
			kScroll = 3
		};

		enum class Delivery
		{
			kSelf = 0,
			kTouch = 1,
			kAimed = 2,
			kTargetActor = 3,
			kTargetLocation = 4,

			kTotal
		};

		enum class SoundID
		{
			kDrawSheatheLPM = 0,
			kCharge = 1,
			kReadyLoop = 2,
			kRelease = 3,
			kCastLoop = 4,
			kHit = 5
		};

		enum class SpellType
		{
			kSpell = 0,
			kDisease = 1,
			kPower = 2,
			kLesserPower = 3,
			kAbility = 4,
			kPoison = 5,
			kEnchantment = 6,

			kPotion = 7,
			kAlchemy = static_cast<std::underlying_type_t<SpellType>>(kPotion),

			kWortCraft = 8,
			kIngredient = static_cast<std::underlying_type_t<SpellType>>(kWortCraft),

			kLeveledSpell = 9,
			kAddiction = 10,
			kVoicePower = 11,
			kStaffEnchantment = 12,
			kScroll = 13
		};

		enum class WardState
		{
			kNone = 0,
			kAbsorb = 1,
			kBreak = 2,

			kTotal
		};

		const char*             GetCannotCastString(CannotCastReason a_reason);
		float                   GetMagicCasterTargetUpdateInterval();
		BGSSoundDescriptorForm* GetMagicFailureSound(SpellType a_type);
	}
}


===============================================
File: include/RE/M/MagicTarget.h
===============================================
#pragma once

#include "RE/B/BSContainer.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/E/EffectArchetypes.h"
#include "RE/M/MagicSystem.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class Actor;
	class ActiveEffect;
	class BGSKeyword;
	class EffectItem;
	class EffectSetting;
	class MagicItem;
	class TESBoundObject;
	class TESObjectREFR;

	struct Effect;

	class MagicTarget
	{
	public:
		inline static constexpr auto RTTI = RTTI_MagicTarget;
		inline static constexpr auto VTABLE = VTABLE_MagicTarget;

		using Archetype = EffectArchetypes::ArchetypeID;

		class ForEachActiveEffectVisitor
		{
		public:
			inline static constexpr auto RTTI = RTTI_MagicTarget__ForEachActiveEffectVisitor;
			inline static constexpr auto VTABLE = VTABLE_MagicTarget__ForEachActiveEffectVisitor;

			virtual ~ForEachActiveEffectVisitor(){};  // 00

			// add
			virtual BSContainer::ForEachResult Accept(ActiveEffect* a_effect) = 0;  // 01
		};
		static_assert(sizeof(ForEachActiveEffectVisitor) == 0x8);

		struct SpellDispelData
		{
			MagicItem*                    spell;         // 00
			BSPointerHandle<Actor>        caster;        // 08
			std::uint32_t                 pad0C;         // 0C
			BSTSmartPointer<ActiveEffect> activeEffect;  // 10
			SpellDispelData*              next;          // 18
		};
		static_assert(sizeof(SpellDispelData) == 0x20);

		struct AddTargetData
		{
			TESObjectREFR*             caster;          // 00
			MagicItem*                 magicItem;       // 08
			Effect*                    effect;          // 10
			TESBoundObject*            source;          // 18
			std::uint64_t              unk20;           // 20 - MagicCaster::PostCreationCallback
			std::uint64_t              unk28;           // 28 - MagicTarget**
			NiPoint3                   explosionPoint;  // 30
			float                      magnitude;       // 3C
			float                      unk40;           // 40
			MagicSystem::CastingSource castingSource;   // 44
			std::uint8_t               unk48;           // 48
			bool                       dualCasted;      // 49
			std::uint16_t              pad4A;           // 4A
			std::uint32_t              pad4C;           // 4C
		};
		static_assert(sizeof(AddTargetData) == 0x50);

		virtual ~MagicTarget();  // 00

		// add
		virtual bool                         AddTarget(AddTargetData& a_targetData);                                               // 01
		virtual TESObjectREFR*               GetTargetStatsObject();                                                               // 02 - { return false; }
		[[nodiscard]] virtual bool           MagicTargetIsActor() const;                                                           // 03 - { return false; }
		virtual bool                         IsInvulnerable();                                                                     // 04 - { return false; }
		virtual void                         InvalidateCommandedActorEffect(ActiveEffect* a_effect);                               // 05 - { return; }
		virtual bool                         CanAddActiveEffect() = 0;                                                             // 06
		virtual BSSimpleList<ActiveEffect*>* GetActiveEffectList() = 0;                                                            // 07
		virtual void                         EffectAdded(ActiveEffect* a_effect);                                                  // 08 - { return; }
		virtual void                         EffectRemoved(ActiveEffect* a_effect);                                                // 09 - { return; }
		virtual float                        CheckResistance(MagicItem* a_magicItem, Effect* a_effect, TESBoundObject* a_object);  // 0A - { return 1.0; }
		virtual bool                         CheckAbsorb(Actor* a_actor, MagicItem* a_magicItem, const Effect* a_effect);          // 0B - { return false; }

		bool DispelEffect(MagicItem* a_spell, BSPointerHandle<Actor>& a_caster, ActiveEffect* a_effect = nullptr);
		void DispelEffectsWithArchetype(Archetype a_type, bool a_force);
		bool HasEffectWithArchetype(Archetype a_type);
		bool HasMagicEffect(EffectSetting* a_effect);
		bool HasMagicEffectWithKeyword(BGSKeyword* a_keyword, std::uint64_t a_arg2);
		void VisitEffects(ForEachActiveEffectVisitor& visitor);

		// members
		SpellDispelData* postUpdateDispelList;  // 08
		std::uint8_t     flags;                 // 10
		std::uint8_t     pad11;                 // 11
		std::uint16_t    pad12;                 // 12
		std::uint32_t    pad14;                 // 14
	};
	static_assert(sizeof(MagicTarget) == 0x18);
}


===============================================
File: include/RE/M/MagicUtilities.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/M/MagicItem.h"
#include "RE/M/MagicSystem.h"

namespace RE
{
	namespace MagicUtilities
	{
		ActorValue                    GetAssociatedResource(MagicItem* a_item, MagicSystem::CastingSource a_castingSource);
		MagicSystem::CannotCastReason GetAssociatedResourceReason(MagicItem* a_item, MagicSystem::CastingSource a_castingSource);
		bool                          UsesResourceOnRelease(MagicItem* a_item, MagicSystem::CastingSource a_castingSource);
		bool                          UsesResourceWhileCasting(MagicItem* a_item, MagicSystem::CastingSource a_castingSource);
		bool                          UsesResourceWhileCharging(MagicItem* a_item, MagicSystem::CastingSource a_castingSource);
	}
}


===============================================
File: include/RE/M/Main.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/B/BSTMessageQueue.h"
#include "RE/S/ScrapHeap.h"

namespace RE
{
	class NiNode;
	class NiCamera;
	class Scenegraph;
	class ScrapHeap;
	struct BSGamerProfileEvent;
	struct BSPackedTask;
	struct PositionPlayerEvent;

	struct BSPackedTaskQueue
	{
	public:
		using UnpackFunc_t = void(const BSPackedTask*);

		struct Semaphore
		{
		public:
			// members
			void*         handle;    // 00
			std::uint32_t size;      // 08
			std::uint32_t capacity;  // 0C
		};
		static_assert(sizeof(Semaphore) == 0x10);

		// members
		BSTCommonScrapHeapMessageQueue<BSPackedTask> queue;       // 00
		mutable Semaphore                            semaphore;   // 28
		UnpackFunc_t*                                unpackFunc;  // 38
	};
	static_assert(sizeof(BSPackedTaskQueue) == 0x40);

	struct BSSaveDataSystemUtilityImage
	{
	public:
		// members
		std::uint32_t size;    // 00
		std::uint32_t width;   // 04
		std::uint32_t height;  // 08
		std::uint32_t pad0C;   // 0C
		char*         buffer;  // 10
	};
	static_assert(sizeof(BSSaveDataSystemUtilityImage) == 0x18);

	class Main :
		public BSTEventSink<PositionPlayerEvent>,  // 00
		public BSTEventSink<BSGamerProfileEvent>   // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_Main;

		~Main() override;  // 00

		// override (BSTEventSink<PositionPlayerEvent>)
		BSEventNotifyControl ProcessEvent(const PositionPlayerEvent* a_event, BSTEventSource<PositionPlayerEvent>* a_eventSource) override;  // 01 - { return BSEventNotifyControl::kContinue; }

		// override (BSTEventSink<BSGamerProfileEvent>)
		BSEventNotifyControl ProcessEvent(const BSGamerProfileEvent* a_event, BSTEventSource<BSGamerProfileEvent>* a_eventSource) override;  // 01

		static Main* GetSingleton();

		static float       QFrameAnimTime();
		static NiCamera*   WorldRootCamera();
		static Scenegraph* WorldRootNode();

		void SetActive(bool a_active);

		// members
		bool                         quitGame;                     // 010
		bool                         resetGame;                    // 011
		bool                         fullReset;                    // 012
		bool                         gameActive;                   // 013
		bool                         onIdle;                       // 014
		bool                         reloadContent;                // 015
		bool                         freezeTime;                   // 016
		bool                         freezeNextFrame;              // 017
		WinAPI::HWND                 wnd;                          // 018
		WinAPI::HINSTANCE            instance;                     // 020
		std::uint32_t                threadID;                     // 028
		std::uint32_t                unk02C;                       // 02C
		std::uint64_t                unk030;                       // 030
		ScrapHeap                    packedTaskHeap;               // 038
		BSPackedTaskQueue            taskQueue;                    // 0C8
		ScrapHeap                    secondaryPackedTaskHeap;      // 108
		BSPackedTaskQueue            secondaryTaskQueue;           // 198
		std::uint8_t                 unk1D8;                       // 1D8
		std::uint8_t                 unk1D9;                       // 1D9
		std::uint16_t                unk1DA;                       // 1DA
		std::uint32_t                unk1DC;                       // 1DC
		BSSaveDataSystemUtilityImage saveDataBackgroundImages[3];  // 1E0
		BSSaveDataSystemUtilityImage saveDataIconImages[3];        // 228
	};
	static_assert(sizeof(Main) == 0x270);
}


===============================================
File: include/RE/M/MainMenu.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/G/GFxFunctionHandler.h"
#include "RE/I/IMenu.h"
#include "RE/I/ImageData.h"

namespace RE
{
	class BSSaveDataEvent;
	class BSSystemEvent;

	// menuDepth = 0
	// flags = kPausesGame | kDisablePauseMenu | kRequiresUpdate | kUpdateUsesCursor | kApplicationMenu
	// context = kMenuMode
	class MainMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                          // 00
		public BSTEventSink<BSSystemEvent>,    // 30
		public BSTEventSink<BSSaveDataEvent>,  // 38
		public GFxFunctionHandler              // 40
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_MainMenu;
		constexpr static std::string_view MENU_NAME = "Main Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT      \
	ImageData     unk50; /* 00 */ \
	std::uint32_t unk68; /* 18 */ \
	std::uint8_t  unk6C; /* 1C */ \
	std::uint8_t  unk6D; /* 1D */ \
	std::uint8_t  unk6E; /* 1E */ \
	std::uint8_t  pad6F; /* 1F */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x20);

		~MainMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;                       // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05

#ifndef SKYRIM_CROSS_VR
		// override (BSTEventSink<BSSystemEvent>)
		BSEventNotifyControl ProcessEvent(const BSSystemEvent* a_event, BSTEventSource<BSSystemEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BSSaveDataEvent>)
		BSEventNotifyControl ProcessEvent(const BSSaveDataEvent* a_event, BSTEventSource<BSSaveDataEvent>* a_eventSource) override;  // 01

		// override (GFxFunctionHandler)
		void Call(Params& a_params) override;  // 01
#endif

		[[nodiscard]] BSTEventSink<BSSystemEvent>* AsBSSystemEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BSSystemEvent>>(this, 0x30, 0x40);
		}

		[[nodiscard]] const BSTEventSink<BSSystemEvent>* AsBSSystemEventSink() const noexcept
		{
			return const_cast<MainMenu*>(this)->AsBSSystemEventSink();
		}

		[[nodiscard]] BSTEventSink<BSSaveDataEvent>* AsBSSaveDataEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<BSSaveDataEvent>>(this, 0x38, 0x48);
		}

		[[nodiscard]] const BSTEventSink<BSSaveDataEvent>* AsBSSaveDataEventSink() const noexcept
		{
			return const_cast<MainMenu*>(this)->AsBSSaveDataEventSink();
		}

		[[nodiscard]] GFxFunctionHandler* AsGFxFunctionHandler() noexcept
		{
			return &REL::RelocateMember<GFxFunctionHandler>(this, 0x40, 0x50);
		}

		[[nodiscard]] const GFxFunctionHandler* AsGFxFunctionHandler() const noexcept
		{
			return const_cast<MainMenu*>(this)->AsGFxFunctionHandler();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x50, 0x60);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x50, 0x60);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 50, 60
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(MainMenu) == 0x70);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(MainMenu) == 0x80);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/M/MapCamera.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/T/TESCamera.h"

namespace RE
{
	namespace MapCameraStates
	{
		class Exit : public TESCameraState
		{
		public:
			inline static constexpr auto RTTI = RTTI_MapCameraStates__Exit;
			inline static constexpr auto VTABLE = VTABLE_MapCameraStates__Exit;
		};

		class Transition : public TESCameraState
		{
		public:
			inline static constexpr auto RTTI = RTTI_MapCameraStates__Transition;
			inline static constexpr auto VTABLE = VTABLE_MapCameraStates__Transition;

			std::uint32_t unk20;
			std::uint32_t unk24;
			std::uint32_t unk28;
			std::uint32_t unk2C;
			std::uint32_t unk30;
			std::uint32_t unk34;
			std::uint32_t unk38;
			std::uint32_t unk3C;
			NiPoint3      currentPosition;  // 40
			NiPoint3      zoomDestination;  // 4C
			std::uint32_t unk58;
			std::uint32_t unk5C;
			NiPoint3      zoomOrigin;  // 60
		};
		static_assert(sizeof(Transition) == 0x70);

		class World : public TESCameraState
		{
		public:
			inline static constexpr auto RTTI = RTTI_MapCameraStates__World;
			inline static constexpr auto VTABLE = VTABLE_MapCameraStates__World;

			struct MapData
			{
				void*         unk00;
				void*         unk08;
				std::uint32_t unk10;
				std::uint32_t unk14;
				std::uint32_t unk18;
				NiPoint2      minimumCoordinates;
				NiPoint2      maximumCoordinates;
			};

			NiPoint3      currentPosition;              // 20
			NiPoint3      currentPositionScrollOffset;  // 2C
			NiPoint3      unk38;                        // 38
			NiPoint3      unk44;                        // 44
			std::uint32_t unk50;                        // 50
			std::uint32_t unk54;                        // 54
			std::float_t  multiplierOfUnk44;            // 58
			std::uint32_t unk5C;
			std::uint32_t unk60;
			std::uint32_t unk64;
			MapData*      mapData;  // 68
		};
		static_assert(sizeof(World) == 0x70);
	}

	class TESWorldSpace;
	struct IMapCameraCallbacks;

	class MapCamera : public TESCamera
	{
	public:
		inline static constexpr auto RTTI = RTTI_MapCamera;

		~MapCamera() override;  // 00

		// add
		virtual void Unk_03(void);  // 03

		// members
		float                                        unk38;       // 38
		float                                        unk3C;       // 3C
		float                                        unk40;       // 40
		float                                        unk44;       // 44
		float                                        unk48;       // 48
		std::uint32_t                                unk4C;       // 4C
		TESWorldSpace*                               worldSpace;  // 50
		IMapCameraCallbacks*                         unk58;       // 58
		std::uint32_t                                unk60;       // 60
		std::uint32_t                                unk64;       // 64
		BSTSmartPointer<MapCameraStates::World>      unk68[2];    // 68
		BSTSmartPointer<MapCameraStates::Exit>       unk78;       // 78
		BSTSmartPointer<MapCameraStates::Transition> unk80;       // 80
		std::uint8_t                                 unk88;       // 88
		std::uint8_t                                 pad89;       // 89
		std::uint16_t                                pad8A;       // 8A
		std::uint32_t                                pad8C;       // 8C
	};
	static_assert(sizeof(MapCamera) == 0x90);
}


===============================================
File: include/RE/M/MapInputHandler.h
===============================================
#pragma once

#include "RE/M/MenuEventHandler.h"

namespace RE
{
	class MapMenu;

	class MapInputHandler : public MenuEventHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_MapInputHandler;

		virtual ~MapInputHandler();  // 00

		// members
		MapMenu* mapMenu;  // 10
	};
	static_assert(sizeof(MapInputHandler) == 0x18);
}


===============================================
File: include/RE/M/MapLookHandler.h
===============================================
#pragma once

#include "RE/M/MapInputHandler.h"

namespace RE
{
	class MapLookHandler : public MapInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_MapLookHandler;

		~MapLookHandler() override;  // 00

		// override (MapInputHandler)
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03
		bool ProcessMouseMove(MouseMoveEvent* a_event) override;    // 04
		bool ProcessButton(ButtonEvent* a_event) override;          // 05

		// members
		std::uint64_t unk18;  // 18
	};
	static_assert(sizeof(MapLookHandler) == 0x20);
}


===============================================
File: include/RE/M/MapMenu.h
===============================================
#pragma once

#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMapCameraCallbacks.h"
#include "RE/I/IMenu.h"
#include "RE/L/LocalMapMenu.h"
#include "RE/M/MapCamera.h"
#include "RE/W/WorldSpaceMenu.h"

namespace RE
{
	class BSAudioManager;
	class MapLookHandler;
	class MapMoveHandler;
	class MapZoomHandler;
	class MenuOpenCloseEvent;
	class TESWorldSpace;

	// menuDepth = 3
	// flags = kPausesGame | kUsesCursor | kRendersOffscreenTargets | kCustomRendering
	// context = kMap
	class MapMenu :
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		public WorldSpaceMenu,                    // 00000
		public BSTEventSink<MenuOpenCloseEvent>,  // 00058
		public IMapCameraCallbacks                // 00060
#elif !defined(ENABLE_SKYRIM_VR)
		public IMenu,                             // 00000
		public BSTEventSink<MenuOpenCloseEvent>,  // 00030
		public IMapCameraCallbacks                // 00038
#else
		public IMenu
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_MapMenu;
		constexpr static std::string_view MENU_NAME = "MapMenu";

		struct Unk30470Entry
		{
			TESFullName*  unk00;
			std::uint32_t unk08;
			std::uint32_t unk0C;
			TESForm*      unk10;
			std::uint32_t unk18;
			std::uint32_t unk1C;
			std::uint32_t unk20;
			std::uint32_t unk24;
			std::uint32_t unk28;
			std::uint32_t unk2C;
			std::uint32_t unk30;
			std::uint32_t unk34;
		};
		static_assert(sizeof(Unk30470Entry) == 0x38);

		struct Unk30488Entry
		{
			std::uint32_t unk00;
			std::uint32_t unk04;
			std::uint32_t unk08;
			std::uint32_t unk0C;
			const char*   label;
			std::uint32_t unk18;
			std::uint32_t unk1C;
			std::uint32_t unk20;
			std::uint32_t unk24;
			std::uint32_t unk28;
			std::uint32_t unk2C;
			std::uint32_t unk30;
			std::uint32_t unk34;
			std::uint32_t unk38;
			std::uint32_t unk3C;
			std::uint32_t unk40;
			std::uint32_t unk44;
		};
		static_assert(sizeof(Unk30488Entry) == 0x48);

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                               \
	BSTSmartPointer<MapMoveHandler> moveHandler;  /* 00 */ \
	BSTSmartPointer<MapLookHandler> lookHandler;  /* 08 */ \
	BSTSmartPointer<MapZoomHandler> zoomHandler;  /* 10 */ \
	ObjectRefHandle                 mapMarker;     /* 18 */ \
	LocalMapMenu                    localMapMenu; /* 20 */

			RUNTIME_DATA_CONTENT
		};
#ifndef ENABLE_SKYRIM_VR
		static_assert(sizeof(RUNTIME_DATA) == 0x30420);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		static_assert(sizeof(RUNTIME_DATA) == 0x304A0);
#endif

		struct RUNTIME_DATA2
		{
#define RUNTIME_DATA2_CONTENT                      \
	RefHandle                unk30460;   /* 000 */ \
	std::uint32_t            unk30464;   /* 004 */ \
	std::uint32_t            unk30468;   /* 008 */ \
	std::uint32_t            unk3046C;   /* 00C */ \
	BSTArray<Unk30470Entry*> unk30470;   /* 010 */ \
	BSTArray<Unk30488Entry*> unk30488;   /* 028 */ \
	MapCamera                camera;     /* 040 */ \
	std::uint64_t            unk30530;   /* 0D0 */ \
	TESWorldSpace*           worldSpace; /* 0D8 */ \
	GFxValue                 unk30540;   /* 0E0 */ \
	std::uint64_t            unk30558;   /* 0F8 */ \
	std::uint64_t            unk30560;   /* 100 */ \
	std::uint64_t            unk30568;   /* 108 */ \
	std::uint32_t            unk30570;   /* 110 */ \
	BSSoundHandle            unk30574;   /* 114 */ \
	std::uint64_t            unk30580;   /* 120 */ \
	std::uint64_t            unk30588;   /* 128 */ \
	std::uint64_t            unk30590;   /* 130 */
            RUNTIME_DATA2_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA2) == 0x138);

		~MapMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;                       // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05
		void               RefreshPlatform() override;                                            // 08

		// override (BSTEventSink<MenuOpenCloseEvent>)
#ifndef SKYRIM_CROSS_VR
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01
#endif

		void PlaceMarker()
		{
			using func_t = decltype(&MapMenu::PlaceMarker);
			REL::Relocation<func_t> func{ RELOCATION_ID(52226, 53113) };
			return func(this);
		}

		[[nodiscard]] WorldSpaceMenu* AsWorldSpaceMenu() noexcept
		{
			if SKYRIM_REL_CONSTEXPR (!REL::Module::IsVR()) {
				return nullptr;
			}
			return &REL::RelocateMember<WorldSpaceMenu>(this, 0, 0);
		}

		[[nodiscard]] const WorldSpaceMenu* AsWorldSpaceMenu() const noexcept
		{
			return const_cast<MapMenu*>(this)->AsWorldSpaceMenu();
		}

		[[nodiscard]] BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<MenuOpenCloseEvent>>(this, 0x30, 0x58);
		}

		[[nodiscard]] const BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() const noexcept
		{
			return const_cast<MapMenu*>(this)->AsMenuOpenCloseEventSink();
		}

		[[nodiscard]] IMapCameraCallbacks* AsIMapCameraCallbacks() noexcept
		{
			return &REL::RelocateMember<IMapCameraCallbacks>(this, 0x38, 0x60);
		}

		[[nodiscard]] const IMapCameraCallbacks* AsIMapCameraCallbacks() const noexcept
		{
			return const_cast<MapMenu*>(this)->AsIMapCameraCallbacks();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x68);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x68);
		}

		[[nodiscard]] inline RUNTIME_DATA2& GetRuntimeData2() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA2>(this, 0x30460, 0x30508);
		}

		[[nodiscard]] inline const RUNTIME_DATA2& GetRuntimeData2() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA2>(this, 0x30460, 0x30508);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT       // 40, 68
			RUNTIME_DATA2_CONTENT  // 30460, 30508
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(MapMenu) == 0x30598);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(MapMenu) == 0x30640);
#endif
}

#undef RUNTIME_DATA_CONTENT
#undef RUNTIME_DATA2_CONTENT


===============================================
File: include/RE/M/MapMoveHandler.h
===============================================
#pragma once

#include "RE/M/MapInputHandler.h"

namespace RE
{
	class MapMoveHandler : public MapInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_MapMoveHandler;

		~MapMoveHandler() override;  // 00

		// override (MapInputHandler)
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03

		// members
		std::uint64_t unk18;  // 18
	};
	static_assert(sizeof(MapMoveHandler) == 0x20);
}


===============================================
File: include/RE/M/MapZoomHandler.h
===============================================
#pragma once

#include "RE/M/MapInputHandler.h"

namespace RE
{
	class MapZoomHandler : public MapInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_MapZoomHandler;

		~MapZoomHandler() override;  // 00

		// override (MapInputHandler)
		bool CanProcess(InputEvent* a_event) override;      // 01
		bool ProcessButton(ButtonEvent* a_event) override;  // 05
	};
	static_assert(sizeof(MapZoomHandler) == 0x18);
}


===============================================
File: include/RE/M/MarkerUsedData.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/B/BSPointerHandle.h"

namespace RE
{
	struct MarkerUsedData
	{
	public:
		// members
		ActorHandle   actorinMarker;  // 0
		std::uint32_t markerID;       // 4
		AITimeStamp   expiration;     // 8
	};
	static_assert(sizeof(MarkerUsedData) == 0xC);
}


===============================================
File: include/RE/M/MaterialIDs.h
===============================================
#pragma once

namespace RE
{
	enum class MATERIAL_ID : std::uint32_t
	{
		kNone = 0,
		kStoneBroken = 131151687,
		kBlockBlade1Hand = 165778930,
		kMeat = 220124585,
		kCarriageWheel = 322207473,
		kMetalLight = 346811165,
		kWoodLight = 365420259,
		kSnow = 398949039,
		kGravel = 428587608,
		kChainMetal = 438912228,
		kBottle = 493553910,
		kWood = 500811281,
		kAsh = 534864873,
		kSkin = 591247106,
		kBlockBlunt = 593401068,
		kDLC1DeerSkin = 617099282,
		kInsect = 668408902,
		kBarrel = 732141076,
		kCeramicMedium = 781661019,
		kBasket = 790784366,
		kIce = 873356572,
		kGlassStairs = 880200008,
		kStoneStairs = 899511101,
		kWater = 1024582599,
		kDraugrSkeleton = 1028101969,
		kBlade1Hand = 1060167844,
		kBook = 1264672850,
		kCarpet = 1286705471,
		kMetalSolid = 1288358971,
		kAxe1Hand = 1305674443,
		kBlockBlade2Hand = 1312943906,
		kOrganicLarge = 1322093133,
		kAmulet = 1440721808,
		kWoodStairs = 1461712277,
		kMud = 1486385281,
		kBoulderSmall = 1550912982,
		kSnowStairs = 1560365355,
		kStoneHeavy = 1570821952,
		kDragonSkeleton = 1574477864,
		kTrap = 1591009235,
		kBowsStaves = 1607128641,
		kAlduin = 1730220269,
		kBlockBowsStaves = 1763418903,
		kWoodAsStairs = 1803571212,
		kSteelGreatSword = 1820198263,
		kGrass = 1848600814,
		kBoulderLarge = 1885326971,
		kStoneAsStairs = 1886078335,
		kBlade2Hand = 2022742644,
		kBottleSmall = 2025794648,
		kBoneActor = 2058949504,
		kSand = 2168343821,
		kMetalHeavy = 2229413539,
		kDLC1SabreCatPelt = 2290050264,
		kIceForm = 2431524493,
		kDragon = 2518321175,
		kBlade1HandSmall = 2617944780,
		kSkinSmall = 2632367422,
		kPotsPans = 2742858142,
		kSkinSkeleton = 2821299363,
		kBlunt1Hand = 2872791301,
		kStoneStairsBroken = 2892392795,
		kSkinLarge = 2965929619,
		kOrganic = 2974920155,
		kBone = 3049421844,
		kWoodHeavy = 3070783559,
		kChain = 3074114406,
		kDirt = 3106094762,
		kGhost = 3312543676,
		kSkinMetalLarge = 3387452107,
		kBlockAxe = 3400476823,
		kArmorLight = 3424720541,
		kShieldLight = 3448167928,
		kCoin = 3589100606,
		kBlockBlunt2Hand = 3662306947,
		kShieldHeavy = 3702389584,
		kArmorHeavy = 3708432437,
		kArrow = 3725505938,
		kGlass = 3739830338,
		kStone = 3741512247,
		kWaterPuddle = 3764646153,
		kCloth = 3839073443,
		kSkinMetalSmall = 3855001958,
		kWard = 3895166727,
		kWeb = 3934839107,
		kTrailerSteelSword = 3941234649,
		kBlunt2Hand = 3969592277,
		kDLC1SwingingBridge = 4239621792,
		kBoulderMedium = 4283869410
	};

	[[nodiscard]] std::string_view MaterialIDToString(MATERIAL_ID a_materialID) noexcept;
}

namespace std
{
	[[nodiscard]] inline std::string to_string(RE::MATERIAL_ID a_materialID)
	{
		return RE::MaterialIDToString(a_materialID).data();
	}
}

namespace fmt
{
	template <>
	struct formatter<RE::MATERIAL_ID>
	{
		template <class ParseContext>
		constexpr auto parse(ParseContext& a_ctx)
		{
			return a_ctx.begin();
		}

		template <class FormatContext>
		auto format(const RE::MATERIAL_ID& a_materialID, FormatContext& a_ctx)
		{
			return fmt::format_to(a_ctx.out(), "{}", RE::MaterialIDToString(a_materialID));
		}
	};
}

#ifdef __cpp_lib_format
namespace std
{
	template <class CharT>
	struct formatter<RE::MATERIAL_ID, CharT> : std::formatter<std::string_view, CharT>
	{
		template <class FormatContext>
		auto format(RE::MATERIAL_ID a_materialID, FormatContext& a_ctx)
		{
			return formatter<std::string_view, CharT>::format(RE::MaterialIDToString(a_materialID), a_ctx);
		}
	};
}
#endif


===============================================
File: include/RE/M/MemoryHeap.h
===============================================
#pragma once

#include "RE/A/AbstractHeap.h"

namespace RE
{
	class MemoryHeap : public AbstractHeap
	{
	public:
		inline static constexpr auto RTTI = RTTI_MemoryHeap;

		~MemoryHeap() override;  // 00

		// override (AbstractHeap)
		std::size_t Size(const void* a_block) const override;                                                           // 01
		void*       Allocate(std::size_t a_size, std::uint32_t a_alignment) override;                                   // 08
		void        Deallocate(void* a_pointer, std::uint32_t) override;                                                // 09
		std::size_t TotalSize(const void* a_pointer) const override;                                                    // 0B
		void        GetHeapStats(HeapStats* a_stats, bool a_fullBlockInfo) override;                                    // 0C
		void*       DoHeapAllocation(std::size_t a_size, std::size_t a_initialSize) override;                           // 0F
		void        DoHeapFree(void* a_ptr) override;                                                                   // 10
		std::size_t CreateMorePages(void* a_memory, std::size_t a_currentSize, std::size_t a_requestedBytes) override;  // 11
		std::size_t CleanExtraPages(void* a_memory, std::size_t a_currentSize, std::size_t a_freeBytes) override;       // 12
		void        DecommitPages(HeapBlock* a_block) override;                                                         // 13

		// members
		bool          deletingHeap;  // 2A8
		std::uint8_t  pad2A9;        // 2A9
		std::uint16_t pad2AA;        // 2AA
		std::uint32_t pad2AC;        // 2AC
	};
	static_assert(sizeof(MemoryHeap) == 0x2B0);
}


===============================================
File: include/RE/M/MemoryManager.h
===============================================
#pragma once

#include "RE/S/ScrapHeap.h"

namespace RE
{
	namespace CompactingStore
	{
		class Store;
	}

	class BSSmallBlockAllocator;
	class IMemoryHeap;

	class MemoryManager
	{
	public:
		struct ThreadScrapHeap
		{
		public:
			// members
			ScrapHeap        heap;          // 00
			ThreadScrapHeap* next;          // 90
			std::uint32_t    owningThread;  // 98
			std::uint32_t    pad;           // 9C
		};
		static_assert(sizeof(ThreadScrapHeap) == 0xA0);

		[[nodiscard]] static MemoryManager* GetSingleton()
		{
			using func_t = decltype(&MemoryManager::GetSingleton);
			REL::Relocation<func_t> func{ RELOCATION_ID(11045, 11141) };
			return func();
		}

		[[nodiscard]] void* Allocate(std::size_t a_size, std::int32_t a_alignment, bool a_alignmentRequired)
		{
			using func_t = decltype(&MemoryManager::Allocate);
			REL::Relocation<func_t> func{ RELOCATION_ID(66859, 68115) };
			return func(this, a_size, a_alignment, a_alignmentRequired);
		}

		void Deallocate(void* a_mem, bool a_alignmentRequired)
		{
			using func_t = decltype(&MemoryManager::Deallocate);
			REL::Relocation<func_t> func{ RELOCATION_ID(66861, 68117) };
			return func(this, a_mem, a_alignmentRequired);
		}

		[[nodiscard]] ScrapHeap* GetThreadScrapHeap()
		{
			using func_t = decltype(&MemoryManager::GetThreadScrapHeap);
			REL::Relocation<func_t> func{ RELOCATION_ID(66841, 68088) };
			return func(this);
		}

		[[nodiscard]] void* Reallocate(void* a_oldMem, std::size_t a_newSize, std::int32_t a_alignment, bool a_aligned)
		{
			using func_t = decltype(&MemoryManager::Reallocate);
			REL::Relocation<func_t> func{ RELOCATION_ID(66860, 68116) };
			return func(this, a_oldMem, a_newSize, a_alignment, a_aligned);
		}

		void RegisterMemoryManager()
		{
			using func_t = decltype(&MemoryManager::RegisterMemoryManager);
			REL::Relocation<func_t> func{ RELOCATION_ID(35199, 36091) };
			return func(this);
		}

		// members
		bool                    initialized{ false };                    // 000
		std::uint16_t           numHeaps{ 0 };                           // 002
		std::uint16_t           numPhysicalHeaps{ 0 };                   // 004
		IMemoryHeap**           heaps{ nullptr };                        // 008
		bool*                   allowOtherContextAllocs{ nullptr };      // 010
		IMemoryHeap*            heapsByContext[127]{ nullptr };          // 018
		ThreadScrapHeap*        threadScrapHeap{ nullptr };              // 410
		IMemoryHeap**           physicalHeaps{ nullptr };                // 418
		IMemoryHeap*            bigAllocHeap{ nullptr };                 // 420
		IMemoryHeap*            emergencyHeap{ nullptr };                // 428
		BSSmallBlockAllocator*  smallBlockAllocator{ nullptr };          // 430
		CompactingStore::Store* compactingStore{ nullptr };              // 438
		IMemoryHeap*            externalHavokAllocator{ nullptr };       // 440
		bool                    specialHeaps{ false };                   // 448
		bool                    allowPoolUse{ true };                    // 449
		std::uint32_t           sysAllocBytes{ 0 };                      // 44C
		std::uint32_t           mallocBytes{ 0 };                        // 450
		std::uint32_t           alignmentForPools{ 4 };                  // 450
		std::uint32_t           mainThreadMemoryProblemPassSignal{ 0 };  // 458
		std::size_t             failedAllocationSize{ 0 };               // 460
		std::uint32_t           numMemoryProblemPassesRun{ 0 };          // 468
		std::size_t             timeOfLastMemoryProblemPass{ 0 };        // 470
		IMemoryHeap*            defaultHeap{ nullptr };                  // 478
	};
	static_assert(sizeof(MemoryManager) == 0x480);

	inline void* malloc(std::size_t a_size)
	{
		auto heap = MemoryManager::GetSingleton();
		return heap ?
                   heap->Allocate(a_size, 0, false) :
                   nullptr;
	}

	template <class T>
	inline T* malloc(std::size_t a_size)
	{
		return static_cast<T*>(malloc(a_size));
	}

	template <class T>
	inline T* malloc()
	{
		return malloc<T>(sizeof(T));
	}

	inline void* aligned_alloc(std::size_t a_alignment, std::size_t a_size)
	{
		auto heap = MemoryManager::GetSingleton();
		return heap ?
                   heap->Allocate(a_size, static_cast<std::int32_t>(a_alignment), true) :
                   nullptr;
	}

	template <class T>
	inline T* aligned_alloc(std::size_t a_alignment, std::size_t a_size)
	{
		return static_cast<T*>(aligned_alloc(a_alignment, a_size));
	}

	template <class T>
	inline T* aligned_alloc()
	{
		return aligned_alloc<T>(alignof(T), sizeof(T));
	}

	inline void* calloc(std::size_t a_num, std::size_t a_size)
	{
		const auto ret = malloc(a_num * a_size);
		if (ret) {
			std::memset(ret, 0, a_num * a_size);
		}
		return ret;
	}

	template <class T>
	inline T* calloc(std::size_t a_num, std::size_t a_size)
	{
		return static_cast<T*>(calloc(a_num, a_size));
	}

	template <class T>
	inline T* calloc(std::size_t a_num)
	{
		return calloc<T>(a_num, sizeof(T));
	}

	inline void* realloc(void* a_ptr, std::size_t a_newSize)
	{
		auto heap = MemoryManager::GetSingleton();
		return heap ?
                   heap->Reallocate(a_ptr, a_newSize, 0, false) :
                   nullptr;
	}

	template <class T>
	inline T* realloc(void* a_ptr, std::size_t a_newSize)
	{
		return static_cast<T*>(realloc(a_ptr, a_newSize));
	}

	inline void* aligned_realloc(void* a_ptr, std::size_t a_newSize, std::size_t a_alignment)
	{
		auto heap = MemoryManager::GetSingleton();
		return heap ?
                   heap->Reallocate(a_ptr, a_newSize, static_cast<std::int32_t>(a_alignment), true) :
                   nullptr;
	}

	template <class T>
	inline T* aligned_realloc(void* a_ptr, std::size_t a_newSize, std::size_t a_alignment)
	{
		return static_cast<T*>(aligned_realloc(a_ptr, a_newSize, a_alignment));
	}

	inline void free(void* a_ptr)
	{
		auto heap = MemoryManager::GetSingleton();
		if (heap) {
			heap->Deallocate(a_ptr, false);
		}
	}

	inline void aligned_free(void* a_ptr)
	{
		auto heap = MemoryManager::GetSingleton();
		if (heap) {
			heap->Deallocate(a_ptr, true);
		}
	}
}

#define TES_HEAP_REDEFINE_NEW()                                                                                         \
	[[nodiscard]] inline void* operator new(std::size_t a_count)                                                        \
	{                                                                                                                   \
		const auto mem = RE::malloc(a_count);                                                                           \
		if (mem) {                                                                                                      \
			return mem;                                                                                                 \
		} else {                                                                                                        \
			stl::report_and_fail("out of memory"sv);                                                                    \
		}                                                                                                               \
	}                                                                                                                   \
                                                                                                                        \
	[[nodiscard]] inline void* operator new[](std::size_t a_count)                                                      \
	{                                                                                                                   \
		const auto mem = RE::malloc(a_count);                                                                           \
		if (mem) {                                                                                                      \
			return mem;                                                                                                 \
		} else {                                                                                                        \
			stl::report_and_fail("out of memory"sv);                                                                    \
		}                                                                                                               \
	}                                                                                                                   \
                                                                                                                        \
	[[nodiscard]] constexpr void* operator new(std::size_t, void* a_ptr) noexcept { return a_ptr; }                     \
	[[nodiscard]] constexpr void* operator new[](std::size_t, void* a_ptr) noexcept { return a_ptr; }                   \
	[[nodiscard]] constexpr void* operator new(std::size_t, std::align_val_t, void* a_ptr) noexcept { return a_ptr; }   \
	[[nodiscard]] constexpr void* operator new[](std::size_t, std::align_val_t, void* a_ptr) noexcept { return a_ptr; } \
                                                                                                                        \
	inline void operator delete(void* a_ptr) { RE::free(a_ptr); }                                                       \
	inline void operator delete[](void* a_ptr) { RE::free(a_ptr); }                                                     \
	inline void operator delete(void* a_ptr, std::align_val_t) { RE::aligned_free(a_ptr); }                             \
	inline void operator delete[](void* a_ptr, std::align_val_t) { RE::aligned_free(a_ptr); }                           \
	inline void operator delete(void* a_ptr, std::size_t) { RE::free(a_ptr); }                                          \
	inline void operator delete[](void* a_ptr, std::size_t) { RE::free(a_ptr); }                                        \
	inline void operator delete(void* a_ptr, std::size_t, std::align_val_t) { RE::aligned_free(a_ptr); }                \
	inline void operator delete[](void* a_ptr, std::size_t, std::align_val_t) { RE::aligned_free(a_ptr); }

namespace RE
{
	// this class is an implementation detail of operator new[]/delete[]
	template <class T>
	class SimpleArray
	{
	public:
		using value_type = T;
		using size_type = std::size_t;
		using difference_type = std::ptrdiff_t;
		using reference = value_type&;
		using const_reference = const value_type&;
		using pointer = value_type*;
		using const_pointer = const value_type*;
		using iterator = value_type*;
		using const_iterator = const value_type*;

		constexpr SimpleArray() noexcept = default;

		explicit SimpleArray(size_type a_count) { resize(a_count); }

		~SimpleArray()
		{
			static_assert(!std::is_trivially_destructible_v<value_type>, "there's no allocation overhead for trivially destructible types");
			clear();
		}

		TES_HEAP_REDEFINE_NEW();

		[[nodiscard]] reference operator[](size_type a_pos) noexcept
		{
			assert(a_pos < size());
			return _data[a_pos];
		}

		[[nodiscard]] const_reference operator[](size_type a_pos) const noexcept
		{
			assert(a_pos < size());
			return _data[a_pos];
		}

		[[nodiscard]] reference       front() noexcept { return operator[](0); }
		[[nodiscard]] const_reference front() const noexcept { return operator[](0); }

		[[nodiscard]] reference       back() noexcept { return operator[](size() - 1); }
		[[nodiscard]] const_reference back() const noexcept { return operator[](size() - 1); }

		[[nodiscard]] pointer       data() noexcept { return _data; }
		[[nodiscard]] const_pointer data() const noexcept { return _data; }

		[[nodiscard]] iterator       begin() noexcept { return _data; }
		[[nodiscard]] const_iterator begin() const noexcept { return _data; }
		[[nodiscard]] const_iterator cbegin() const noexcept { return begin(); }

		[[nodiscard]] iterator       end() noexcept { return _data ? _data + size() : nullptr; }
		[[nodiscard]] const_iterator end() const noexcept { return _data ? _data + size() : nullptr; }
		[[nodiscard]] const_iterator cend() const noexcept { return end(); }

		[[nodiscard]] bool empty() const noexcept { return size() == 0; }

		[[nodiscard]] size_type size() const noexcept { return _data ? *static_cast<const std::size_t*>(get_head()) : 0; }

		void clear()
		{
			if (_data) {
				std::destroy_n(data(), size());
				free(get_head());
				_data = nullptr;
			}
		}

		void resize(size_type a_count)
		{
			const auto oldSize = size();
			if (oldSize == a_count) {
				return;
			}

			const auto newData = [=]() {
				auto bytes = sizeof(value_type) * a_count;
				if constexpr (alignof(value_type) > alignof(std::size_t)) {
					bytes += sizeof(value_type);
				} else {
					bytes += sizeof(std::size_t);
				}

				const auto data = malloc<std::size_t>(bytes);
				*data = a_count;

				if constexpr (alignof(value_type) > alignof(std::size_t)) {
					return reinterpret_cast<pointer>(data) + 1;
				} else {
					return reinterpret_cast<pointer>(data + 1);
				}
			}();

			if (a_count < oldSize) {  // shrink
				std::uninitialized_move_n(data(), a_count, newData);
			} else {  // grow
				std::uninitialized_move_n(data(), oldSize, newData);
				std::uninitialized_default_construct_n(newData + oldSize, a_count - oldSize);
			}

			clear();
			_data = newData;
		}

	protected:
		[[nodiscard]] void* get_head() noexcept
		{
			assert(_data != nullptr);
			if constexpr (alignof(value_type) > alignof(std::size_t)) {
				return _data - 1;
			} else {
				return reinterpret_cast<std::size_t*>(_data) - 1;
			}
		}

		[[nodiscard]] const void* get_head() const noexcept
		{
			assert(_data != nullptr);
			if constexpr (alignof(value_type) > alignof(std::size_t)) {
				return _data - 1;
			} else {
				return reinterpret_cast<const std::size_t*>(_data) - 1;
			}
		}

		// members
		pointer _data{ nullptr };  // 0
	};
}


===============================================
File: include/RE/M/MemoryPage.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	namespace BSScript
	{
		// All stack frame pointers are offset by 4
		// The actual stack frame is kept here
		struct MemoryPage
		{
			TES_HEAP_REDEFINE_NEW();

			template <class T>
			T* GetData()
			{
				return reinterpret_cast<T*>(buf);
			}

			void* GetHead();
			void* GetTail();
			bool  IsInRange(const void* a_ptr);

			// members
			std::uint32_t pageSize;  // 00
			char          buf[0];    // 04
		};
		static_assert(sizeof(MemoryPage) == 0x4);  // pages can be larger
	}
}


===============================================
File: include/RE/M/MenuControls.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTSmartPointer.h"

namespace RE
{
	class InputEvent;
	class MenuEventHandler;
	class MenuModeChangeEvent;
	struct ClickHandler;
	struct ConsoleOpenHandler;
	struct DirectionHandler;
	struct FavoritesHandler;
	struct MenuOpenHandler;
	struct QuickSaveLoadHandler;
	struct ScreenshotHandler;

	class MenuControls :
		public BSTEventSink<InputEvent*>,         // 00
		public BSTSingletonSDM<MenuControls>,     // 10
		public BSTEventSink<MenuModeChangeEvent>  // 08
	{
	public:
		struct QueuedReg
		{
		public:
			QueuedReg(MenuEventHandler* a_handler, bool a_add);
			~QueuedReg() = default;

			// members
			MenuEventHandler* handler;  // 00
			bool              add;      // 08
			std::uint8_t      pad08;    // 09
			std::uint16_t     pad09;    // 0A
			std::uint32_t     pad0A;    // 0C
		};
		static_assert(sizeof(QueuedReg) == 0x10);

		~MenuControls() override;  // 00

		// override (BSTEventSink<InputEvent*>)
		BSEventNotifyControl ProcessEvent(InputEvent* const* a_event, BSTEventSource<InputEvent*>* a_eventSource) override;  // 01

		// override (BSTEventSink<MenuModeChangeEvent>)
		BSEventNotifyControl ProcessEvent(const MenuModeChangeEvent* a_event, BSTEventSource<MenuModeChangeEvent>* a_eventSource) override;  // 01

		static MenuControls* GetSingleton();

		void                         AddHandler(MenuEventHandler* a_handler);
		[[nodiscard]] constexpr bool InBeastForm() const noexcept { return beastForm; }
		void                         RegisterHandler(MenuEventHandler* a_handler);
		void                         RemoveHandler(MenuEventHandler* a_handler);
		bool                         QueueScreenshot();
		void                         UnregisterHandler(MenuEventHandler* a_handler);

		// members
		std::uint8_t                          pad11;                 // 11
		std::uint16_t                         pad12;                 // 12
		std::uint32_t                         pad14;                 // 14
		BSTArray<MenuEventHandler*>           handlers;              // 18
		BSTArray<QueuedReg>                   regBuffer;             // 30
		BSTSmartPointer<ClickHandler>         clickHandler;          // 48
		BSTSmartPointer<DirectionHandler>     directionHandler;      // 50
		BSTSmartPointer<ConsoleOpenHandler>   consoleOpenHandler;    // 58
		BSTSmartPointer<QuickSaveLoadHandler> quickSaveLoadHandler;  // 60
		BSTSmartPointer<MenuOpenHandler>      menuOpenHandler;       // 68
		BSTSmartPointer<FavoritesHandler>     favoritesHandler;      // 70
		BSTSmartPointer<ScreenshotHandler>    screenshotHandler;     // 78
		bool                                  isProcessing;          // 80
		bool                                  beastForm;             // 81
		bool                                  remapMode;             // 82
		std::uint8_t                          unk83;                 // 83
		std::uint32_t                         unk84;                 // 84
	};
	static_assert(offsetof(MenuControls, handlers) == 0x18);
	static_assert(offsetof(MenuControls, remapMode) == 0x82);
	static_assert(sizeof(MenuControls) == 0x88);
}


===============================================
File: include/RE/M/MenuCursor.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"

namespace RE
{
	class MenuCursor : public BSTSingletonSDM<MenuCursor>
	{
	public:
		static MenuCursor* GetSingleton();

		void SetCursorVisibility(bool a_visible);

		// members
		std::uint8_t  pad01;              // 01
		std::uint16_t pad02;              // 02
		float         cursorPosX;         // 04
		float         cursorPosY;         // 08
		float         safeZoneX;          // 0C
		float         safeZoneY;          // 10
		float         screenWidthX;       // 14
		float         screenWidthY;       // 18
		float         cursorSensitivity;  // 1C
		float         unk20;              // 20
		float         unk24;              // 24
		float         defaultMouseSpeed;  // 28
		std::int32_t  showCursorCount;    // 2C
	};
	static_assert(sizeof(MenuCursor) == 0x30);
}


===============================================
File: include/RE/M/MenuEventHandler.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"

namespace RE
{
	class ButtonEvent;
	class InputEvent;
	class KinectEvent;
	class MouseMoveEvent;
	class ThumbstickEvent;

	class MenuEventHandler : public BSIntrusiveRefCounted
	{
	public:
		inline static constexpr auto RTTI = RTTI_MenuEventHandler;

		MenuEventHandler() = default;
		virtual ~MenuEventHandler() = default;  // 00

		virtual bool CanProcess(InputEvent* a_event) = 0;          // 01
		virtual bool ProcessKinect(KinectEvent* a_event);          // 02 - { return false; }
		virtual bool ProcessThumbstick(ThumbstickEvent* a_event);  // 03 - { return false; }
		virtual bool ProcessMouseMove(MouseMoveEvent* a_event);    // 04 - { return false; }
		virtual bool ProcessButton(ButtonEvent* a_event);          // 05 - { return false; }

		// members
		bool          registered;  // 0C
		std::uint8_t  unk0D;       // 0D
		std::uint16_t pad0E;       // 0E
	};
	static_assert(sizeof(MenuEventHandler) == 0x10);
}


===============================================
File: include/RE/M/MenuModeChangeEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	class MenuModeChangeEvent
	{
		enum class Mode
		{
			kNone = static_cast<std::underlying_type_t<Mode>>(-1),
			kHidden = 0,
			kDisplayed = 1
		};

		BSFixedString                        menu;  // 00
		stl::enumeration<Mode, std::uint8_t> mode;  // 08
	};
}


===============================================
File: include/RE/M/MenuOpenCloseEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	class MenuOpenCloseEvent
	{
	public:
		// members
		BSFixedString menuName;  // 00
		bool          opening;   // 08
		std::uint8_t  pad09;     // 09
		std::uint16_t pad0A;     // 0A
		std::uint32_t pad0C;     // 0C
	};
	static_assert(sizeof(MenuOpenCloseEvent) == 0x10);
}


===============================================
File: include/RE/M/MenuOpenHandler.h
===============================================
#pragma once

#include "RE/M/MenuEventHandler.h"

namespace RE
{
	struct MenuOpenHandler : public MenuEventHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_MenuOpenHandler;

		~MenuOpenHandler() override;  // 00

		// override (MenuEventHandler)
		bool CanProcess(InputEvent* a_event) override;      // 01
		bool ProcessKinect(KinectEvent* a_event) override;  // 02
		bool ProcessButton(ButtonEvent* a_event) override;  // 05

		// members
		bool          unk10;  // 10
		std::uint8_t  unk11;  // 11
		std::uint16_t unk12;  // 12
		std::uint32_t unk14;  // 14
	};
	static_assert(sizeof(MenuOpenHandler) == 0x18);
}


===============================================
File: include/RE/M/MenuTopicManager.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSString.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	class BGSDialogueBranch;
	class MenuOpenCloseEvent;
	class TESQuest;
	class TESTopic;
	class TESTopicInfo;
	struct PositionPlayerEvent;

	class MenuTopicManager :
		public BSTSingletonSDM<MenuTopicManager>,  // 0x10
		public BSTEventSink<MenuOpenCloseEvent>,   // 0x00
		public BSTEventSink<PositionPlayerEvent>   // 0x08
	{
	public:
		inline static constexpr auto RTTI = RTTI_MenuTopicManager;

		struct Dialogue
		{
		public:
			// members
			BSString                         topicText;        // 00
			bool                             unk10;            // 10
			bool                             unk11;            // 11
			bool                             unk12;            // 12 - data.topic->formID == 0xFD || data.topic->formID == 0x118
			std::uint8_t                     unk13;            // 13
			std::uint32_t                    unk14;            // 14
			BSSimpleList<DialogueResponse*>  responses;        // 18
			TESQuest*                        parentQuest;      // 28
			TESTopicInfo*                    parentTopicInfo;  // 30
			TESTopic*                        parentTopic;      // 38
			BSSimpleList<DialogueResponse*>* unk40;            // 40
			std::uint8_t                     unk48;            // 48
			bool                             neverSaid;        // 49
			std::uint16_t                    unk4A;            // 4A
			std::uint32_t                    unk4C;            // 4C
			TESTopic*                        unk50;            // 50
		};
		static_assert(sizeof(Dialogue) == 0x58);

		~MenuTopicManager() override;  // 00

		// override (BSTEventSink<MenuOpenCloseEvent>)
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<PositionPlayerEvent>)
		BSEventNotifyControl ProcessEvent(const PositionPlayerEvent* a_event, BSTEventSource<PositionPlayerEvent>* a_eventSource) override;  // 01

		static MenuTopicManager* GetSingleton()
		{
			REL::Relocation<MenuTopicManager**> singleton{ RELOCATION_ID(514959, 401099) };
			return *singleton;
		}

		// members
		BSSimpleList<Dialogue*>*     selectedResponseNode;  // 18
		BSSimpleList<Dialogue*>*     dialogueList;          // 20
		std::uint64_t                unk28;                 // 28
		TESTopicInfo*                rootTopicInfo;         // 30
		Dialogue*                    lastSelectedDialogue;  // 38
		WinAPI::CRITICAL_SECTION     criticalSection;       // 40
		ObjectRefHandle              speaker;               // 68
		ObjectRefHandle              lastSpeaker;           // 6C - used if the dialogue menu was closed but the NPC is still talking
		TESTopicInfo*                currentTopicInfo;      // 70 - only valid when the NPC is talking
		TESTopicInfo*                lastTopicInfo;         // 78 - used if the dialogue menu was closed but the NPC is still talking
		BSTArray<BGSDialogueBranch*> blockingBranches;      // 80
		BSTArray<BGSDialogueBranch*> topLevelBranches;      // 98
		bool                         isGreetingPlayer;      // B0
		bool                         unkB1;                 // B1
		bool                         isSayingGoodbye;       // B2
		bool                         unkB3;                 // B3
		bool                         unkB4;                 // B4
		bool                         unkB5;                 // B5
		bool                         unkB6;                 // B6
		bool                         unkB7;                 // B7
		bool                         unkB8;                 // B8
		bool                         unkB9;                 // B9
		bool                         unkBA;                 // BA
		bool                         unkBB;                 // BB
		std::uint16_t                padBC;                 // BC
		BSTArray<TESTopic*>          unkC0;                 // C0
	};
	static_assert(sizeof(MenuTopicManager) == 0xD8);
}


===============================================
File: include/RE/M/MessageBoxData.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/I/IUIMessageData.h"

namespace RE
{
	class IMessageBoxCallback;

	class MessageBoxData : public IUIMessageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_MessageBoxData;

		~MessageBoxData() override;  // 00

		void QueueMessage()
		{
			using func_t = decltype(&MessageBoxData::QueueMessage);
			REL::Relocation<func_t> func{ RELOCATION_ID(51422, 52271) };
			return func(this);
		}

		// members
		BSString                             bodyText;    // 10
		BSTArray<BSString>                   buttonText;  // 20
		std::uint32_t                        unk38;       // 38
		std::int32_t                         unk3C;       // 3C
		BSTSmartPointer<IMessageBoxCallback> callback;    // 40
		std::uint32_t                        unk48;       // 48
		std::uint8_t                         unk4C;       // 4C
		std::uint8_t                         unk4D;       // 4D
		std::uint8_t                         unk4E;       // 4E
		std::uint8_t                         unk4F;       // 4F
	};
	static_assert(sizeof(MessageBoxData) == 0x50);
}


===============================================
File: include/RE/M/MessageBoxMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 10
	// flags = kPausesGame | kAlwaysOpen | kUsesCursor | kModal
	// context = kMenuMode
	class MessageBoxMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_MessageBoxMenu;
		constexpr static std::string_view MENU_NAME = "MessageBoxMenu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT      \
	std::uint8_t  unk30; /* 00 */ \
	std::uint8_t  pad31; /* 01 */ \
	std::uint16_t pad32; /* 02 */ \
	std::uint32_t pad34; /* 04 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x8);

		~MessageBoxMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(MessageBoxMenu) == 0x38);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(MessageBoxMenu) == 0x48);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/M/MiddleHighProcessData.h
===============================================
#pragma once

#include "RE/A/ActorPackage.h"
#include "RE/B/BGSPerkEntry.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSResponse.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/F/FormTypes.h"
#include "RE/H/HitData.h"
#include "RE/M/MagicSystem.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class ActiveEffect;
	class BGSAttackData;
	class BGSPerkEntry;
	class bhkCharacterController;
	class bhkRagdollPenetrationUtil;
	class BSAnimationGraphManager;
	class BSFaceGenAnimationData;
	class BSFaceGenNiNode;
	class BSLightingShaderProperty;
	class ExtraDataList;
	class InventoryEntryData;
	class MagicItem;
	class NiAVObject;
	class NiNode;
	class QueuedFile;
	class TESBoundObject;
	struct AnimationVariableData;
	struct BSAnimationGraphVariableCache;

	enum class RESET_3D_FLAGS
	{
		kNone = 0,
		kModel = 1 << 0,
		kSkin = 1 << 1,
		kHead = 1 << 2,
		kFace = 1 << 3,
		kScale = 1 << 4,
		kSkeleton = 1 << 5,
		kInitDefault = 1 << 6,
		kSkyCellSkin = 1 << 7
	};

	struct CommandedActorData
	{
	public:
		// members
		ActorHandle   commandedActor;  // 00
		std::uint32_t pad04;           // 04
		ActiveEffect* activeEffect;    // 10
	};
	static_assert(sizeof(CommandedActorData) == 0x10);

	struct ObjectEquipParams
	{
	public:
		// members
		ExtraDataList*      extraDataList;    // 00
		std::int32_t        count;            // 08
		std::uint32_t       pad0C;            // 0C
		const BGSEquipSlot* equipSlot;        // 10
		void*               unk18;            // 18
		bool                playEquipSounds;  // 20
		bool                forceEquip;       // 21
		bool                showMessage;      // 22
		bool                unk23;            // 23
		bool                unk24;            // 24
		std::uint8_t        pad25;            // 25
		std::uint16_t       pad26;            // 26
	};
	static_assert(sizeof(ObjectEquipParams) == 0x28);

	class QueuedItem
	{
	public:
		// members
		QueuedItem*           next;         // 00
		TESBoundObject*       object;       // 08
		ObjectEquipParams     equipParams;  // 10
		NiPointer<QueuedFile> queuedFiles;  // 38
		bool                  equip;        // 40
		std::uint8_t          pad41;        // 41
		std::uint16_t         pad42;        // 42
		std::uint32_t         pad44;        // 44
	};
	static_assert(sizeof(QueuedItem) == 0x48);

	struct DeferredHideLimb
	{
	public:
		// members
		float             dismemberTimer;       // 00
		std::uint32_t     limbIndex;            // 04
		NiPointer<NiNode> dismemberedLimbRoot;  // 08
		NiPointer<NiNode> replacementLimb;      // 10
		DeferredHideLimb* next;                 // 18
		bool              explosion;            // 20
		std::uint8_t      pad21;                // 21
		std::uint16_t     pad22;                // 22
		std::uint32_t     pad24;                // 24
	};
	static_assert(sizeof(DeferredHideLimb) == 0x28);

	struct AIPerkData
	{
	public:
		BSTArray<BGSPerkEntry*>& at(BGSEntryPoint::ENTRY_POINT a_pos)
		{
			return operator[](a_pos);
		}

		BSTArray<BGSPerkEntry*>& operator[](BGSEntryPoint::ENTRY_POINT a_pos)
		{
			assert(a_pos < BGSEntryPoint::ENTRY_POINT::kTotal);
			return perkEntryArrays[stl::to_underlying(a_pos)];
		}

		// members
		BSTArray<BGSPerkEntry*> perkEntryArrays[BGSEntryPoint::ENTRY_POINTS::kTotal];  // 000
	};
	static_assert(sizeof(AIPerkData) == 0x8A0);

	struct MiddleHighProcessData
	{
	public:
		BSTEventSource<void*>                          unk000;                      // 000
		ActorPackage                                   runOncePackage;              // 058
		BSTArray<ActorHandle>                          deadDetectList;              // 088
		BSSimpleList<TESObjectREFR*>                   refListChairBed;             // 0A0
		NiPoint3                                       rotation;                    // 0B0
		NiPoint3                                       rotationSpeed;               // 0BC
		NiPoint3                                       actorMountPosition;          // 0C8
		NiPoint3                                       furniturePathPoint;          // 0D4
		NiPoint3                                       lastSeenPosition;            // 0E0
		std::uint32_t                                  bleedoutAttacker;            // 0EC
		MagicSystem::WardState                         wardState;                   // 0F0
		std::uint32_t                                  pad0F4;                      // 0F4
		BSTSmartPointer<AnimResponse>                  animResponse;                // 0F8
		BSTArray<CommandedActorData>                   commandedActors;             // 100
		NiNode*                                        damageRootNode[6];           // 118
		NiAVObject*                                    unk148;                      // 148
		NiNode*                                        weaponBone;                  // 150
		NiAVObject*                                    headNode;                    // 158
		NiAVObject*                                    torsoNode;                   // 160
		NiAVObject*                                    faceTargetSourceNode;        // 168
		BSFaceGenNiNode*                               faceNodeSkinned;             // 170
		NiPointer<BSLightingShaderProperty>            lightingProperty;            // 178
		std::uint64_t                                  unk180;                      // 180
		QueuedItem*                                    itemstoEquipUnequip;         // 188
		HitData*                                       lastHitData;                 // 190
		DeferredHideLimb*                              headDeferredHideLimb;        // 198
		BSSimpleList<ActiveEffect*>*                   activeEffects;               // 1A0
		BSTSmartPointer<BSAnimationGraphManager>       animationGraphManager;       // 1A8
		BSAnimationGraphVariableCache*                 animationVariableCache;      // 1B0
		BSTArray<void*>                                unk1B8;                      // 1B8
		BSTArray<void*>                                unk1D0;                      // 1D0
		mutable BSSpinLock                             unk1E8;                      // 1E8
		void*                                          unk1F0;                      // 1F0 - smart ptr
		std::uint16_t                                  unk1F8;                      // 1F8
		std::uint16_t                                  unk1FA;                      // 1FA
		std::uint32_t                                  unk1FC;                      // 1FC
		std::uint32_t                                  unk200;                      // 200
		float                                          headHeightOffset;            // 204
		ObjectRefHandle                                occupiedFurniture;           // 208
		std::uint32_t                                  unk20C;                      // 20C
		std::uint64_t                                  unk210;                      // 210
		ActorHandle                                    commandingActor;             // 218
		std::uint32_t                                  pad21C;                      // 21C
		InventoryEntryData*                            leftHand;                    // 220
		TESIdleForm*                                   furnitureIdle;               // 228
		void*                                          unk230;                      // 230 - smart ptr
		BSFaceGenAnimationData*                        faceAnimationData;           // 238
		MagicItem*                                     currentPackageSpell;         // 240
		std::uint64_t                                  unk248;                      // 248
		NiPointer<bhkCharacterController>              charController;              // 250
		BSTSmartPointer<bhkRagdollPenetrationUtil>     penetrationDetectUtil;       // 258
		InventoryEntryData*                            rightHand;                   // 260
		InventoryEntryData*                            bothHands;                   // 268
		NiPointer<QueuedFile>                          bodyPartPreload;             // 270
		void*                                          unk278;                      // 278
		TESIdleForm*                                   lastIdlePlayed;              // 280
		AIPerkData*                                    perkData;                    // 288
		std::uint32_t                                  unk290;                      // 290
		std::uint32_t                                  currentFurnitureSubgraphID;  // 294
		float                                          unk298;                      // 298
		float                                          unk29C;                      // 29C
		float                                          unk2A0;                      // 2A0
		float                                          unk2A4;                      // 2A4
		float                                          unk2A8;                      // 2A8
		float                                          unk2AC;                      // 2AC
		float                                          unk2B0;                      // 2B0
		float                                          bleedoutRate;                // 2B4
		float                                          unk2B8;                      // 2B8
		float                                          unk2BC;                      // 2BC
		float                                          unk2C0;                      // 2C0
		float                                          torchEvaluationTimer;        // 2C4
		float                                          alphaMult;                   // 2C8
		float                                          scriptRefractPower;          // 2CC
		float                                          unk2D0;                      // 2D0
		float                                          deferredKillTimer;           // 2D4
		float                                          killMoveTimer;               // 2D8
		float                                          unk2DC;                      // 2DC
		std::uint32_t                                  unk2E0;                      // 2E0
		std::uint32_t                                  unk2E4;                      // 2E4
		std::uint32_t                                  currentFurnitureMarkerID;    // 2E8
		std::uint32_t                                  unk2EC;                      // 2EC
		std::uint64_t                                  unk2F0;                      // 2F0
		std::uint32_t                                  unk2F8;                      // 2F8
		std::uint32_t                                  unk2FC;                      // 2FC
		std::uint32_t                                  unk300;                      // 300
		std::uint16_t                                  unk304;                      // 304
		std::uint16_t                                  unk306;                      // 306
		std::uint64_t                                  unk308;                      // 308
		std::uint8_t                                   unk310;                      // 310
		stl::enumeration<RESET_3D_FLAGS, std::uint8_t> update3DModel;               // 311
		std::uint16_t                                  unk312;                      // 312
		std::uint16_t                                  unk314;                      // 314
		bool                                           unk316;                      // 316
		bool                                           unk317;                      // 317
		bool                                           unk318;                      // 318
		bool                                           unk319;                      // 319
		bool                                           unk31A;                      // 31A
		bool                                           pickPocketed;                // 31B
		bool                                           summonedCreature;            // 31C
		bool                                           forceNextUpdate;             // 31D
		bool                                           unk31E;                      // 31E
		bool                                           unk31F;                      // 31F
		bool                                           unk320;                      // 320
		bool                                           unk321;                      // 321
		bool                                           beenAttacked;                // 322
		bool                                           alwaysHit;                   // 323
		bool                                           doNoDamage;                  // 324
		bool                                           soulTrapped;                 // 325
		bool                                           unk326;                      // 326
		bool                                           unk327;                      // 327
		bool                                           unk328;                      // 328
		bool                                           preventCombat;               // 329
		bool                                           unk32A;                      // 32A
		bool                                           isFleeing;                   // 32B
		bool                                           unk32C;                      // 32C
		bool                                           hostileGuard;                // 32D
		bool                                           unk32E;                      // 32E
		bool                                           unk32F;                      // 32F
		bool                                           unk330;                      // 330
		bool                                           killQueued;                  // 331
		bool                                           inDeferredKill;              // 332
		bool                                           pad333;                      // 333
		std::uint32_t                                  pad334;                      // 334
	};
	static_assert(sizeof(MiddleHighProcessData) == 0x338);
}


===============================================
File: include/RE/M/Misc.h
===============================================
#pragma once

#include "RE/N/NiPoint3.h"

namespace RE
{
	class Actor;
	class IMessageBoxCallback;
	template <class T>
	class NiPointer;
	class Setting;
	class TESObjectREFR;
	class TESForm;
	class InventoryEntryData;

	void          CreateMessage(const char* a_message, IMessageBoxCallback* a_callback, std::uint32_t a_arg3, std::uint32_t a_arg4, std::uint32_t a_arg5, const char* a_buttonText, const char* a_secondaryButtonText);
	void          CreateRefHandle(RefHandle& a_handleOut, TESObjectREFR* a_refTo);
	void          DebugNotification(const char* a_notification, const char* a_soundToPlay = 0, bool a_cancelIfAlreadyQueued = true);
	void          DebugMessageBox(const char* a_message);
	float         GetArmorFinalRating(InventoryEntryData* a_armorEntryData, float a_armorPerks, float a_skillMultiplier);
	std::uint32_t GetDurationOfApplicationRunTime();
	Setting*      GetINISetting(const char* a_name);
	float         GetSecondsSinceLastFrame();
	bool          LookupReferenceByHandle(const RefHandle& a_handle, NiPointer<Actor>& a_refrOut);
	bool          LookupReferenceByHandle(const RefHandle& a_handle, NiPointer<TESObjectREFR>& a_refrOut);
	void          PlaySound(const char* a_editorID);
	void          ShakeCamera(float a_strength, const NiPoint3& a_position, float a_duration);
}


===============================================
File: include/RE/M/MissileProjectile.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/I/ImpactResults.h"
#include "RE/P/Projectile.h"

namespace RE
{
	class MissileProjectile : public Projectile
	{
	public:
		inline static constexpr auto RTTI = RTTI_MissileProjectile;
		inline static constexpr auto VTABLE = VTABLE_MissileProjectile;
		inline static constexpr auto FORMTYPE = FormType::ProjectileMissile;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~MissileProjectile() override;  // 00

		// override (Projectile)
		void SaveGame(BGSSaveFormBuffer* a_buf) override;        // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;        // 0F
		void InitLoadGame(BGSLoadFormBuffer* a_buf) override;    // 10
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;  // 11
		void Revert(BGSLoadFormBuffer* a_buf) override;          // 12
#ifndef SKYRIM_CROSS_VR
		bool IsMissileProjectile() override;               // A2 - { return 1; }
		void Process3D() override;               // A9
		void UpdateImpl(float a_delta) override;  // AB
		bool ProcessImpacts() override;               // AC
		bool GetKillOnCollision() override;               // B8 - { return unk1D8 == 1; }
		void AddImpact(TESObjectREFR* a_ref, const NiPoint3& a_targetLoc, const NiPoint3& a_velocity, hkpCollidable* a_collidable, std::int32_t a_arg6, std::uint32_t a_arg7) override;               // BD
		void Handle3DLoaded() override;           // C0
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void Unk_C2(void);  // C2 - { return 0; }
		SKYRIM_REL_VR_VIRTUAL void Unk_C3(void);  // C3 - { return 0; }

		struct MISSILE_RUNTIME_DATA
		{
#define MISSILE_RUNTIME_DATA_CONTENT               \
	ImpactResult  impactResult;          /* 1D8, 1E0 */ \
	bool          waitingToInitialize3D; /* 1DC */ \
	std::uint8_t  unk1DD;                /* 1DD */ \
	std::uint16_t unk1DE;                /* 1DE */

			MISSILE_RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline MISSILE_RUNTIME_DATA& GetMissileRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<MISSILE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		[[nodiscard]] inline const MISSILE_RUNTIME_DATA& GetMissileRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<MISSILE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x1D8, 0x1E0);
		}

		// members
#ifndef ENABLE_SKYRIM_AE
		MISSILE_RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(MissileProjectile) == 0x1E0);
#endif
}
#undef MISSILE_RUNTIME_DATA_CONTENT


===============================================
File: include/RE/M/MistMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"
#include "RE/M/MenuEventHandler.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiMatrix3.h"
#include "RE/S/SimpleAnimationGraphManagerHolder.h"

namespace RE
{
	class BSLightingShaderProperty;
	class NiAVObject;
	class NiControllerManager;
	class NiControllerSequence;

	struct ImageSpaceBaseData;

	// menuDepth = 8
	// flags = kDisablePauseMenu | kAllowSaving | kDontHideCursorWhenTopmost
	// context = kNone
	class MistMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                              // 00
		public SimpleAnimationGraphManagerHolder,  // 30, 40
		public MenuEventHandler                    // 48, 58
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_MistMenu;
		inline static constexpr auto      VTABLE = VTABLE_MistMenu;
		constexpr static std::string_view MENU_NAME = "Mist Menu";

		struct Colors
		{
			enum Color
			{
				kXNeg,
				kXPos,
				kYNeg,
				kYPos,
				kZNeg,
				kZPos,

				kTotal
			};
		};

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                           \
	NiColor                         ambientColors[Colors::kTotal];  /* 058 */ \
			std::uint32_t                   unk0A0;                         /* 0A0 */ \
			std::uint32_t                   unk0A4;                         /* 0A4 */ \
			std::uint64_t                   unk0A8;                         /* 0A8 */ \
			NiPointer<NiNode>               mistModel;                      /* 0B0 - smart ptr */ \
			void*                           mistModelDBHandle;              /* 0B8 */ \
			void*                           loadScreenDBHandle;             /* 0C0 */ \
			NiPointer<BSFadeNode>           cameraPath;                     /* 0C8 - parent of cameraPathNode */ \
			NiPointer<NiNode>               cameraPathNode;                 /* 0D0 - smart ptr */ \
			NiPointer<NiControllerSequence> cameraPathSequence;             /* 0D8 - smart ptr */ \
			NiPointer<NiControllerManager>  cameraPathController;           /* 0E0 - smart ptr */ \
			BSLightingShaderProperty*       logoShaderProperty;             /* 0E8 - default logo only */ \
			NiPointer<BSFadeNode>           loadScreenModel;                /* 0F0 */ \
			ImageSpaceBaseData*             originalImageSpace;             /* 0F8 - imagespacedata? */ \
			float                           cameraFOV;                      /* 100 */ \
			float                           angleZ;                         /* 104 */ \
			float                           unk108;                         /* 108 */ \
			float                           unk10C;                         /* 10C */ \
			NiMatrix3                       cameraRotate;                   /* 110 */ \
			bool                            showMist;                       /* 134 */ \
			bool                            showLoadScreen;                 /* 135 */ \
			std::uint8_t                    unk136;                         /* 136 */ \
			std::uint8_t                    unk137;                         /* 137 */ \
			std::uint8_t                    unk138;                         /* 138 - initCameraPath? */ \
			std::uint8_t                    unk139;                         /* 139 - cameraPath related */ \
			bool                            leftButtonHeldDown;             /* 13A */ \
			bool                            rightButtonHeldDown;            /* 13B */ \
			std::uint32_t                   pad13C;                         /* 13C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0xE8);

		~MistMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05
		void               PostDisplay() override;                                                // 06

		// override (MenuEventHandler)
#ifndef SKYRIM_CROSS_VR
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03
		bool ProcessMouseMove(MouseMoveEvent* a_event) override;    // 04
		bool ProcessButton(ButtonEvent* a_event) override;          // 05
#endif

		[[nodiscard]] SimpleAnimationGraphManagerHolder* AsSimpleAnimationGraphManagerHolder() noexcept
		{
			return &REL::RelocateMember<SimpleAnimationGraphManagerHolder>(this, 0x30, 0x40);
		}

		[[nodiscard]] const SimpleAnimationGraphManagerHolder* AsSimpleAnimationGraphManagerHolder() const noexcept
		{
			return const_cast<MistMenu*>(this)->AsSimpleAnimationGraphManagerHolder();
		}

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x48, 0x58);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<MistMenu*>(this)->AsMenuEventHandler();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x58, 0x68);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x58, 0x68);
		}

		[[nodiscard]] static MistMenu* GetSingleton()
		{
			REL::Relocation<MistMenu**> singleton{ RELOCATION_ID(519827, 406370) };
			return *singleton;
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 58, 68
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(MistMenu) == 0x140);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(MistMenu) == 0x150);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/M/ModManagerMenu.h
===============================================
#pragma once

#include "RE/G/GFxFunctionHandler.h"
#include "RE/I/IMenu.h"
#include "RE/M/MenuEventHandler.h"

namespace RE
{
	// menuDepth = 9
	// flags = kPausesGame | kUsesMenuContext | kModal | kDisablePauseMenu | kRequiresUpdate | kTopmostRenderedMenu | kUpdateUsesCursor
	// context = kMenuMode
	class ModManagerMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,              // 00
		public MenuEventHandler,   // 30
		public GFxFunctionHandler  // 40
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_ModManagerMenu;
		constexpr static std::string_view MENU_NAME = "Mod Manager Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT      \
	std::uint8_t  unk50; /* 50 */ \
	std::uint8_t  pad51; /* 51 */ \
	std::uint16_t pad52; /* 52 */ \
	std::uint32_t pad54; /* 54 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x8);

		~ModManagerMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;                         // 04
		void               AdvanceMovie(float a_interval, std::uint32_t a_currentTime) override;  // 05

#ifndef SKYRIM_CROSS_VR
		// override (MenuEventHandler)
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03

		// override (GFxFunctionHandler)
		void Call(Params& a_params) override;  // 01
#endif

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<ModManagerMenu*>(this)->AsMenuEventHandler();
		}

		[[nodiscard]] GFxFunctionHandler* AsGFxFunctionHandler() noexcept
		{
			return &REL::RelocateMember<GFxFunctionHandler>(this, 0x40, 0x50);
		}

		[[nodiscard]] const GFxFunctionHandler* AsGFxFunctionHandler() const noexcept
		{
			return const_cast<ModManagerMenu*>(this)->AsGFxFunctionHandler();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x50, 0x60);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x50, 0x60);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 50, 60
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(ModManagerMenu) == 0x58);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(ModManagerMenu) == 0x68);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/M/ModelProcessor.h
===============================================
#pragma once

#include "RE/B/BSTSingleton.h"
#include "RE/D/DBTraits.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiNode;

	namespace BSModelDB
	{
		class BSModelProcessor : public BSTSingletonExplicit<BSModelProcessor>
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSModelDB__BSModelProcessor;
			inline static constexpr auto VTABLE = VTABLE_BSModelDB__BSModelProcessor;

			virtual ~BSModelProcessor();

			// add
			virtual void PostCreate(const DBTraits::ArgsType& a_args, const char* modelName, NiPointer<NiNode>& a_root, std::uint32_t& a_typeOut);
		};
	}

	namespace TESModelDB
	{
		class TESProcessor : public BSModelDB::BSModelProcessor
		{
		public:
			inline static constexpr auto RTTI = RTTI_TESModelDB____TESProcessor;
			inline static constexpr auto VTABLE = VTABLE_TESModelDB____TESProcessor;

			~TESProcessor() override;

			// override (BSModelDM::BSModelProcessor)
			void PostCreate(const BSModelDB::DBTraits::ArgsType& a_args, const char* modelName, NiPointer<NiNode>& a_root, std::uint32_t& a_typeOut) override;
		};
	}
}


===============================================
File: include/RE/M/ModelReferenceEffect.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTEvent.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/R/RefAttachTechniqueInput.h"
#include "RE/R/ReferenceEffect.h"
#include "RE/S/SimpleAnimationGraphManagerHolder.h"

namespace RE
{
	class NiAVObject;
	struct BSAnimationGraphEvent;
	class BGSArtObjectCloneTask;

	class ModelReferenceEffect :
		public ReferenceEffect,                     // 00
		public SimpleAnimationGraphManagerHolder,   // 48
		public BSTEventSink<BSAnimationGraphEvent>  // 60
	{
	public:
		inline static constexpr auto RTTI = RTTI_ModelReferenceEffect;
		inline static auto           Ni_RTTI = NiRTTI_ModelReferenceEffect;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kRefModel;

		enum class Flags
		{
			kNone = 0,
			kAttached = 1 << 0,
			k3rdPersonVisible = 1 << 1
		};

		~ModelReferenceEffect() override;  // 00

		// override (ReferenceEffect)
		const NiRTTI*    GetRTTI() const override;                         // 02
		bool             Update(float a_arg1) override;                    // 28
		NiAVObject*      Get3D() const override;                           // 29 - { return artObject3D; }
		TEMP_EFFECT_TYPE GetType() const override;                         // 2C - { return 9; }
		void             SaveGame(BGSSaveGameBuffer* a_buf) override;      // 2D
		void             LoadGame(BGSLoadGameBuffer* a_buf) override;      // 2E
		void             Init() override;                                  // 36
		void             UpdateParentCell(NiAVObject* a_object) override;  // 3A
		void             UpdatePosition() override;                        // 3B
		NiAVObject*      GetAttachRoot() override;                         // 3C
		bool             GetAttached() override;                           // 3D - { return flags & 1; }
		void             DetachImpl() override;                            // 3E

		// override (SimpleAnimationGraphManagerHolder)
		bool SetupAnimEventSinks(const BSTSmartPointer<BShkbAnimationGraph>& a_animGraph) override;                                                        // 08
		bool CreateAnimationChannels(BSScrapArray<BSTSmartPointer<BSAnimationGraphChannel>>& animGraphChannels) override;                                  // 0A
		void PostChangeAnimationManager(const BSTSmartPointer<BShkbAnimationGraph>& a_arg1, const BSTSmartPointer<BShkbAnimationGraph>& a_arg2) override;  // 0D

		// override (BSTEventSink<BSAnimationGraphEvent>)
		BSEventNotifyControl ProcessEvent(const BSAnimationGraphEvent* a_event, BSTEventSource<BSAnimationGraphEvent>* a_eventSource) override;  // 01

		// members
		RefAttachTechniqueInput                hitEffectArtData;  // 68
		std::uint64_t                          unkB0;             // B0
		BGSArtObject*                          artObject;         // B8
		BSTSmartPointer<BGSArtObjectCloneTask> cloneTask;         // C0
		NiPointer<NiAVObject>                  artObject3D;       // C8
		stl::enumeration<Flags, std::uint32_t> flags;             // D0
		std::uint32_t                          padD4;             // D4
	};
	static_assert(sizeof(ModelReferenceEffect) == 0xD8);
}


===============================================
File: include/RE/M/Moon.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/S/SkyObject.h"

namespace RE
{
	class BSTriShape;
	class NiNode;

	class Moon : public SkyObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_Moon;
		inline static constexpr auto VTABLE = VTABLE_Moon;

		enum class UpdateStatus
		{
			kNotRequired = 0,
			kWhenCulled,
			kInitialize
		};

		struct Phases
		{
			enum Phase
			{
				kFull = 0,
				kWaningGibbous,
				kWaningQuarter,
				kWaningCrescent,
				kNewMoon,
				kWaxingCrescent,
				kWaxingQuarter,
				kWaxingGibbous,

				kTotal
			};
		};
		using Phase = Phases::Phase;

		~Moon() override;  // 00

		// override (SkyObject)
		void Init(NiNode* a_root) override;              // 02
		void Update(Sky* a_sky, float a_arg2) override;  // 03

		// members
		NiPointer<NiNode>                             moonNode;                      // 10
		NiPointer<NiNode>                             shadowNode;                    // 18
		NiPointer<BSTriShape>                         moonMesh;                      // 20
		NiPointer<BSTriShape>                         shadowMesh;                    // 28
		BSString                                      stateTextures[Phase::kTotal];  // 30
		float                                         angleFadeStart;                // B0
		float                                         angleFadeEnd;                  // B4
		float                                         angleShadowEarlyFade;          // B8
		float                                         speed;                         // BC
		float                                         zOffset;                       // C0
		std::uint32_t                                 size;                          // C4
		stl::enumeration<UpdateStatus, std::uint32_t> updateMoonTexture;             // C8
		float                                         unkCC;                         // CC
		float                                         unkD0;                         // D0
		std::uint32_t                                 padD4;                         // D4
	};
	static_assert(sizeof(Moon) == 0xD8);
}


===============================================
File: include/RE/M/MouseMoveEvent.h
===============================================
#pragma once

#include "RE/I/IDEvent.h"

namespace RE
{
	class MouseMoveEvent : public IDEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_MouseMoveEvent;

		~MouseMoveEvent() override;  // 00

		// members
		std::int32_t mouseInputX;  // 28
		std::int32_t mouseInputY;  // 2C
	};
	static_assert(sizeof(MouseMoveEvent) == 0x30);
}


===============================================
File: include/RE/M/MoveToFunctor.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/D/DelayFunctor.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
	}

	namespace SkyrimScript
	{
		class MoveToFunctor : public DelayFunctor
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript____MoveToFunctor;

			~MoveToFunctor() override;  // 00

			// override (DelayFunctor)
			RE::BSScript::Variable operator()() override;                                                              // 01
			bool                   IsLatent() const override;                                                          // 02 - { return true; }
			bool                   SaveImpl(BSStorage& a_storage) const override;                                      // 04
			FunctorType            GetType() const override;                                                           // 05 - { return 0; }
			bool                   LoadImpl(const BSStorage& a_storage, std::uint32_t a_arg2, bool& a_arg3) override;  // 06

			// members
			ObjectRefHandle                            source;          // 10
			ObjectRefHandle                            destination;     // 14
			NiPoint3                                   offset;          // 18
			NiPoint3                                   rotationOffset;  // 24
			bool                                       matchRotation;   // 30
			bool                                       exactTranslate;  // 31
			std::uint16_t                              pad32;           // 32
			std::uint32_t                              pad34;           // 34
			BSTSmartPointer<BSScript::IVirtualMachine> vm;              // 38
		};
		static_assert(sizeof(MoveToFunctor) == 0x40);
	}
}


===============================================
File: include/RE/M/Movement.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	namespace Movement
	{
		struct SPEED_DIRECTIONS
		{
			enum SPEED_DIRECTION : std::uint32_t
			{
				kLeft,
				kRight,
				kForward,
				kBack,
				kRotations,

				kTotal
			};
		};
		using SPEED_DIRECTION = SPEED_DIRECTIONS::SPEED_DIRECTION;

		struct MaxSpeeds
		{
		public:
			enum
			{
				kWalk,
				kRun,

				kTotal
			};

			// members
			float speeds[SPEED_DIRECTIONS::kTotal][kTotal];  // 00
			float rotateWhileMovingRun;                      // 28
		};
		static_assert(sizeof(MaxSpeeds) == 0x2C);

		struct TypeData
		{
		public:
			// members
			BSFixedString typeName;       // 00 - MNAM
			MaxSpeeds     defaultData;    // 08 - SPED
			float         directional;    // 34 - INAM~
			float         movementSpeed;  // 38
			float         rotationSpeed;  // 3C - ~INAM
		};
		static_assert(sizeof(TypeData) == 0x40);
	}
}


===============================================
File: include/RE/M/MovementControllerAI.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/I/IMovementControllerRegisterInterface.h"

namespace RE
{
	class MovementControllerAI :
		public BSIntrusiveRefCounted,                // 008
		public IMovementControllerRegisterInterface  // 000
	{
	public:
		inline static constexpr auto RTTI = RTTI_MovementControllerAI;

		~MovementControllerAI() override;  // 00

		// add
		virtual void Unk_05(void);  // 05
		virtual void Unk_06(void);  // 06 - { return; }
		virtual void Unk_07(void);  // 07
		virtual void Unk_08(void);  // 08
		virtual void Unk_09(void);  // 09 - { return 1; }

		// members
		std::uint32_t unk00C;  // 00C
		std::uint64_t unk010;  // 010
		std::uint64_t unk018;  // 018
		std::uint64_t unk020;  // 020
		std::uint64_t unk028;  // 028
		std::uint64_t unk030;  // 030
		std::uint64_t unk038;  // 038
		std::uint64_t unk040;  // 040
		std::uint64_t unk048;  // 048
		std::uint64_t unk050;  // 050
		std::uint64_t unk058;  // 058
		std::uint64_t unk060;  // 060
		std::uint64_t unk068;  // 068
		std::uint64_t unk070;  // 070
		std::uint64_t unk078;  // 078
		std::uint64_t unk080;  // 080
		std::uint64_t unk088;  // 088
		std::uint64_t unk090;  // 090
		std::uint64_t unk098;  // 098
		std::uint64_t unk0A0;  // 0A0
		std::uint64_t unk0A8;  // 0A8
		std::uint64_t unk0B0;  // 0B0
		std::uint64_t unk0B8;  // 0B8
		std::uint64_t unk0C0;  // 0C0
		std::uint64_t unk0C8;  // 0C8
		std::uint64_t unk0D0;  // 0D0
		std::uint64_t unk0D8;  // 0D8
		std::uint64_t unk0E0;  // 0E0
		std::uint64_t unk0E8;  // 0E8
		std::uint64_t unk0F0;  // 0F0
		std::uint64_t unk0F8;  // 0F8
		std::uint64_t unk100;  // 100
		std::uint64_t unk108;  // 108
		std::uint64_t unk110;  // 110
		std::uint64_t unk118;  // 118
	};
	static_assert(sizeof(MovementControllerAI) == 0x120);
}


===============================================
File: include/RE/M/MovementControllerNPC.h
===============================================
#pragma once

#include "RE/I/IAnimationSetCallbackFunctor.h"
#include "RE/I/IMovementDirectControl.h"
#include "RE/I/IMovementMessageInterface.h"
#include "RE/I/IMovementMotionDrivenControl.h"
#include "RE/I/IMovementPlannerDirectControl.h"
#include "RE/I/IMovementSelectIdle.h"
#include "RE/M/MovementControllerAI.h"

namespace RE
{
	class MovementControllerNPC :
		public MovementControllerAI,           // 000
		public IMovementMessageInterface,      // 120
		public IMovementMotionDrivenControl,   // 128
		public IMovementSelectIdle,            // 130
		public IMovementDirectControl,         // 138
		public IMovementPlannerDirectControl,  // 140
		public IAnimationSetCallbackFunctor    // 148
	{
	public:
		inline static constexpr auto RTTI = RTTI_MovementControllerNPC;

		~MovementControllerNPC() override;  // 00

		// add
		virtual void Unk_0A(void);  // 0A
		virtual void Unk_0B(void);  // 0B
		virtual void Unk_0C(void);  // 0C
		virtual void Unk_0D(void);  // 0D
		virtual void Unk_0E(void);  // 0E - { return unk1C5 == 0; }
		virtual void Unk_0F(void);  // 0F - { return unk1C5; }
		virtual void Unk_10(void);  // 10
		virtual void Unk_11(void);  // 11
		virtual void Unk_12(void);  // 12
		virtual void Unk_13(void);  // 13
		virtual void Unk_14(void);  // 14

		// members
		std::uint64_t unk150;  // 150
		std::uint64_t unk158;  // 158
		std::uint64_t unk160;  // 160
		std::uint64_t unk168;  // 168
		std::uint64_t unk170;  // 170
		std::uint64_t unk178;  // 178
		std::uint64_t unk180;  // 180
		std::uint64_t unk188;  // 188
		std::uint64_t unk190;  // 190
		std::uint64_t unk198;  // 198
		std::uint64_t unk1A0;  // 1A0
		std::uint64_t unk1A8;  // 1A8
		std::uint64_t unk1B0;  // 1B0
		std::uint64_t unk1B8;  // 1B8
		std::uint32_t unk1C0;  // 1C0
		std::uint8_t  unk1C4;  // 1C4
		std::uint8_t  unk1C5;  // 1C5
		std::uint16_t unk1C6;  // 1C6
		std::uint64_t unk1C8;  // 1C8
	};
	static_assert(sizeof(MovementControllerNPC) == 0x1D0);
}


===============================================
File: include/RE/M/MovementHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	struct MovementHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_MovementHandler;

		~MovementHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                          // 01
		void ProcessThumbstick(ThumbstickEvent* a_event, PlayerControlsData* a_data) override;  // 02
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;          // 04
	};
	static_assert(sizeof(MovementHandler) == 0x10);
}


===============================================
File: include/RE/M/MoviePlayer.h
===============================================
#pragma once

namespace RE
{
	class MoviePlayer
	{
	public:
		inline static constexpr auto RTTI = RTTI_MoviePlayer;

		virtual ~MoviePlayer();  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01
		virtual void Unk_02(void) = 0;  // 02
		virtual void Unk_03(void) = 0;  // 03
		virtual void Unk_04(void) = 0;  // 04
		virtual void Unk_05(void) = 0;  // 05
		virtual void Unk_06(void) = 0;  // 06
		virtual void Unk_07(void) = 0;  // 07
		virtual void Unk_08(void) = 0;  // 08
		virtual void Unk_09(void) = 0;  // 09
		virtual void Unk_0A(void) = 0;  // 0A
		virtual void Unk_0B(void) = 0;  // 0B
		virtual void Unk_0C(void) = 0;  // 0C
		virtual void Unk_0D(void);      // 0D

		// members
		std::uint64_t unk08;  // 08
		std::uint64_t unk10;  // 10
		std::uint64_t unk18;  // 18
		std::uint64_t unk20;  // 20
		std::uint64_t unk28;  // 28
		std::uint64_t unk30;  // 30
		std::uint64_t unk38;  // 38
		std::uint64_t unk40;  // 40
		std::uint64_t unk48;  // 48
		std::uint64_t unk50;  // 50
	};
	static_assert(sizeof(MoviePlayer) == 0x58);
}


===============================================
File: include/RE/M/MultiBoundMarkerData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class MultiBoundMarkerData : public BSExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_MultiBoundMarkerData;
		inline static constexpr auto EXTRADATATYPE = ExtraDataType::kMultiBoundMarkerData;

		~MultiBoundMarkerData() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;                             // 01 - { reutrn kMultiBoundMarkerData; }
		bool          IsNotEqual(const BSExtraData* a_rhs) const override;  // 02

		// members
		NiPoint3      halfExtents;  // 10
		std::uint32_t pad1C;        // 1C
	};
	static_assert(sizeof(MultiBoundMarkerData) == 0x20);
}


===============================================
File: include/RE/N/NativeFunction.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/I/IObjectHandlePolicy.h"
#include "RE/N/NativeFunctionBase.h"
#include "RE/P/PackUnpack.h"
#include "RE/S/Stack.h"
#include "RE/S/StackFrame.h"
#include "RE/T/TypeTraits.h"
#include "RE/V/Variable.h"
#include "RE/V/VirtualMachine.h"

namespace RE
{
	namespace BSScript
	{
		namespace Impl
		{
			template <class F, class Tuple, std::size_t... I, class... Args>
			inline constexpr decltype(auto) CallbackImpl(F&& a_func, Tuple&& a_tuple, std::index_sequence<I...>, Args&&... a_args)
			{
				return std::invoke(
					std::forward<F>(a_func),
					std::forward<Args>(a_args)...,
					std::get<I>(std::forward<Tuple>(a_tuple))...);
			}

			template <class F, class Tuple, class... Args>
			inline constexpr decltype(auto) CallBack(F&& a_func, Tuple&& a_tuple, Args&&... a_args)
			{
				return CallbackImpl(
					std::forward<F>(a_func),
					std::forward<Tuple>(a_tuple),
					index_sequence_for_tuple<Tuple>{},
					std::forward<Args>(a_args)...);
			}

			template <class... Args, std::size_t... I>
			std::tuple<Args...> MakeTupleImpl(const StackFrame& a_frame, std::uint32_t a_page, std::index_sequence<I...>)
			{
				return std::forward_as_tuple(
					a_frame.GetStackFrameVariable(I, a_page).Unpack<Args>()...);
			}

			// tuple element construction order isn't guaranteed, so we need to wrap it
			template <class... Args>
			std::tuple<Args...> MakeTuple(const StackFrame& a_frame, std::uint32_t a_page)
			{
				return MakeTupleImpl<Args...>(a_frame, a_page, std::index_sequence_for<Args...>{});
			}
		}

		template <bool IS_LONG, class F, class R, class Base, class... Args>
		class NativeFunction : public NF_util::NativeFunctionBase
		{
		public:
			using result_type = R;
			using base_type = Base;
			using function_type = F;

			NativeFunction() = delete;
			NativeFunction(const NativeFunction&) = delete;
			NativeFunction(NativeFunction&&) = delete;

			NativeFunction(std::string_view a_fnName, std::string_view a_className, function_type a_callback) :
				NF_util::NativeFunctionBase(a_fnName, a_className, is_static_base_v<base_type>, sizeof...(Args)),
				_stub(a_callback)
			{
				std::size_t i = 0;
				((_descTable.entries[i++].second.SetType(GetRawType<Args>{}())), ...);
				_retType = GetRawType<result_type>{}();
			}

			~NativeFunction() override = default;  // 00

			bool HasStub() const override  // 15
			{
				return static_cast<bool>(_stub);
			}

			bool MarshallAndDispatch(Variable& a_baseValue, [[maybe_unused]] Internal::VirtualMachine& a_vm, [[maybe_unused]] VMStackID a_stackID, Variable& a_resultValue, const StackFrame& a_frame) const override  // 16
			{
				base_type base{};
				if constexpr (std::negation_v<is_static_base<base_type>>) {
					base = a_baseValue.Unpack<base_type>();
					if (!base) {
						return false;
					}
				}

				auto page = a_frame.GetPageForFrame();
				auto args = Impl::MakeTuple<Args...>(a_frame, page);
				if constexpr (std::is_void_v<result_type>) {
					if constexpr (IS_LONG) {
						Impl::CallBack(_stub, std::move(args), std::addressof(a_vm), a_stackID, std::move(base));
						a_resultValue.SetNone();
					} else {
						Impl::CallBack(_stub, std::move(args), std::move(base));
						a_resultValue.SetNone();
					}
				} else {
					if constexpr (IS_LONG) {
						auto result = Impl::CallBack(_stub, std::move(args), std::addressof(a_vm), a_stackID, std::move(base));
						a_resultValue.Pack<result_type>(std::move(result));
					} else {
						auto result = Impl::CallBack(_stub, std::move(args), std::move(base));
						a_resultValue.Pack<result_type>(std::move(result));
					}
				}

				return true;
			}

		protected:
			// members
			std::function<function_type> _stub;  // 50
		};
	}

	template <class F, class = void>
	class NativeFunction;

	template <class R, class Cls, class... Args>
	class NativeFunction<R(Cls, Args...), std::enable_if_t<BSScript::is_valid_short_sig_v<R, Cls, Args...>>> :
		public BSScript::NativeFunction<false, R(Cls, Args...), R, Cls, Args...>
	{
	private:
		using super = BSScript::NativeFunction<false, R(Cls, Args...), R, Cls, Args...>;

	public:
		using result_type = typename super::result_type;
		using base_type = typename super::base_type;
		using function_type = typename super::function_type;

		using super::super;
	};

	template <class Int, class R, class Cls, class... Args>
	class NativeFunction<R(BSScript::Internal::VirtualMachine*, Int, Cls, Args...), std::enable_if_t<BSScript::is_valid_long_sig_v<Int, R, Cls, Args...>>> :
		public BSScript::NativeFunction<true, R(BSScript::Internal::VirtualMachine*, Int, Cls, Args...), R, Cls, Args...>
	{
	private:
		using super = BSScript::NativeFunction<true, R(BSScript::Internal::VirtualMachine*, Int, Cls, Args...), R, Cls, Args...>;

	public:
		using result_type = typename super::result_type;
		using base_type = typename super::base_type;
		using function_type = typename super::function_type;

		using super::super;
	};

	template <class Int, class R, class Cls, class... Args>
	class NativeFunction<R(BSScript::IVirtualMachine*, Int, Cls, Args...), std::enable_if_t<BSScript::is_valid_long_sig_v<Int, R, Cls, Args...>>> :
		public BSScript::NativeFunction<true, R(BSScript::IVirtualMachine*, Int, Cls, Args...), R, Cls, Args...>
	{
	private:
		using super = BSScript::NativeFunction<true, R(BSScript::IVirtualMachine*, Int, Cls, Args...), R, Cls, Args...>;

	public:
		using result_type = typename super::result_type;
		using base_type = typename super::base_type;
		using function_type = typename super::function_type;

		using super::super;
	};

	template <class F>
	NativeFunction(std::string_view, std::string_view, F) -> NativeFunction<std::remove_pointer_t<F>>;

	namespace BSScript
	{
		template <class F>
		void IVirtualMachine::RegisterFunction(std::string_view a_fnName, std::string_view a_className, F a_callback, bool a_callableFromTasklets)
		{
			BindNativeMethod(new RE::NativeFunction(a_fnName, a_className, a_callback));
			if (a_callableFromTasklets) {
				SetCallableFromTasklets(a_className.data(), a_fnName.data(), a_callableFromTasklets);
			}
		}
	}
}


===============================================
File: include/RE/N/NativeFunctionBase.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/I/IFunction.h"
#include "RE/T/TypeInfo.h"
#include "RE/V/VDescTable.h"

namespace RE
{
	namespace BSScript
	{
		namespace Internal
		{
			class VirtualMachine;
		}

		class StackFrame;
		class Variable;

		namespace NF_util
		{
			class NativeFunctionBase : public IFunction
			{
			public:
				inline static constexpr auto RTTI = RTTI_BSScript__NF_util__NativeFunctionBase;
				inline static constexpr auto VTABLE = VTABLE_BSScript__NF_util__NativeFunctionBase;

				NativeFunctionBase() = delete;
				explicit NativeFunctionBase(std::string_view a_fnName, std::string_view a_className, bool a_isStatic, std::uint16_t a_numParams);
				~NativeFunctionBase() override = default;  // 00

				// override (IFunction)
				const BSFixedString& GetName() const override;                                                                                                  // 01
				const BSFixedString& GetObjectTypeName() const override;                                                                                        // 02
				const BSFixedString& GetStateName() const override;                                                                                             // 03
				TypeInfo             GetReturnType() const override;                                                                                            // 04
				std::uint32_t        GetParamCount() const override;                                                                                            // 05
				void                 GetParam(std::uint32_t a_idx, BSFixedString& a_nameOut, TypeInfo& a_typeOut) const override;                               // 06
				std::uint32_t        GetStackFrameSize() const override;                                                                                        // 07
				bool                 GetIsNative() const override;                                                                                              // 08
				bool                 GetIsStatic() const override;                                                                                              // 09
				bool                 GetIsEmpty() const override;                                                                                               // 0A
				FunctionType         GetFunctionType() const override;                                                                                          // 0B
				std::uint32_t        GetUserFlags() const override;                                                                                             // 0C
				const BSFixedString& GetDocString() const override;                                                                                             // 0D
				void                 InsertLocals(StackFrame* a_frame) override;                                                                                // 0E
				CallResult           Call(const BSTSmartPointer<Stack>& a_stack, ErrorLogger* a_logger, Internal::VirtualMachine* a_vm, bool a_arg4) override;  // 0F
				const BSFixedString& GetSourceFilename() const override;                                                                                        // 10
				bool                 TranslateIPToLineNumber(std::uint32_t a_taskletExecutionOffset, std::uint32_t& a_lineNumberOut) const override;            // 11
				bool                 GetVarNameForStackIndex(std::uint32_t a_idx, BSFixedString& a_nameOut) const override;                                     // 12
				bool                 CanBeCalledFromTasklets() const override;                                                                                  // 13
				void                 SetCallableFromTasklets(bool a_callable) override;                                                                         // 14

				// add
				virtual bool HasStub() const = 0;                                                                                                                                            // 15
				virtual bool MarshallAndDispatch(Variable& a_baseValue, Internal::VirtualMachine& a_vm, VMStackID a_stackID, Variable& a_resultValue, const StackFrame& a_frame) const = 0;  // 16

				bool GetIsLatent() const;

			protected:
				// members
				BSFixedString        _name;                            // 10
				BSFixedString        _objName;                         // 18
				BSFixedString        _stateName{ "" };                 // 20
				TypeInfo             _retType;                         // 28
				Internal::VDescTable _descTable;                       // 30
				bool                 _isStatic;                        // 40
				bool                 _isCallableFromTasklet{ false };  // 41
				bool                 _isLatent{ false };               // 42
				std::uint8_t         _pad43{ 0 };                      // 43
				std::uint32_t        _userFlags{ 0 };                  // 44
				BSFixedString        _docString;                       // 48
			};
			static_assert(sizeof(NativeFunctionBase) == 0x50);
		}
	}
}


===============================================
File: include/RE/N/NativeLatentFunction.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/I/IObjectHandlePolicy.h"
#include "RE/I/IVirtualMachine.h"
#include "RE/N/NativeFunction.h"
#include "RE/P/PackUnpack.h"
#include "RE/T/TypeTraits.h"
#include "RE/V/Variable.h"
#include "RE/V/VirtualMachine.h"

namespace RE
{
	namespace BSScript
	{
		template <bool IS_LONG, class F, class callbackR, class latentR, class Base, class... Args>
		class NativeLatentFunction : public NativeFunction<IS_LONG, F, std::underlying_type_t<callbackR>, Base, Args...>
		{
		public:
			using result_type = callbackR;
			using base_type = Base;
			using function_type = F;

			NativeLatentFunction() = delete;
			NativeLatentFunction(const NativeLatentFunction&) = delete;
			NativeLatentFunction(NativeLatentFunction&&) = delete;

			NativeLatentFunction(std::string_view a_fnName, std::string_view a_className, function_type a_callback) :
				NativeFunction<IS_LONG, F, std::underlying_type_t<callbackR>, Base, Args...>(a_fnName, a_className, a_callback)
			{
				this->_retType = GetRawType<latentR>();
				this->_isLatent = true;
			}

			~NativeLatentFunction() override = default;  // 00
		};
	}

	template <class R, class F, class = void>
	class NativeLatentFunction;

	template <class R, class Int, class F, class Cls, class... Args>
	class NativeLatentFunction<R, F(BSScript::Internal::VirtualMachine*, Int, Cls, Args...), std::enable_if_t<BSScript::is_valid_latent_long_sig_v<R, Int, F, Cls, Args...>>> :
		public BSScript::NativeLatentFunction<true, F(BSScript::Internal::VirtualMachine*, Int, Cls, Args...), F, R, Cls, Args...>
	{
	private:
		using super = BSScript::NativeLatentFunction<true, F(BSScript::Internal::VirtualMachine*, Int, Cls, Args...), F, R, Cls, Args...>;

	public:
		using result_type = typename super::result_type;
		using base_type = typename super::base_type;
		using function_type = typename super::function_type;

		using super::super;
	};

	namespace BSScript
	{
		enum LatentStatus : bool
		{
			kFailed,   // Failed to start latent funciton, return NONE and log error
			kStarted,  // Latent function started, script will pause until latent function finishes
		};

		/**
		@brief Registers a latent function. Unlike normal native functions, latent functions do not return a result to the script immediately.
		
		@details A latent function is intended for any native functions that take significant amount of time to execute (Utility.Wait(X) as an example). A latent function will block a script event until the latent function finishes
		Setup: A latent function is setup with three pieces: 
		1. The initial callback. This will setup the necessary logic for the latent execution, and returns a BSScript::LatentStatus for if the setup is successful. Note this callback must return as soon as possible to unblock the game.
		2. The latent logic. This can be a timer waiting X amount of time, a wait for some event, some crazy number crunching or anything inbetween. It is very important this logic is not executed in the callback
		3. The return. This will be any code that returns the result back to the script. It is important to store the stackID from the callback somewhere to identify which script event to return the result to.

		Notes:
		1. Since latent functions do not execute their logic while blocking the game, the player can save during a latent function execution. 
		Care must be taken to store the stackID as well as necessary relevant data for the latent function in the cosave, to resume execution when loading up the save. Otherwise, the script event will be permanently blocked without a call to return a result to it
		2. When returning a value, the value type must exactly match the result type specified here. As an example, if the result type in the registration is TESForm*, and the actual value is Actor* (which inherits TESForm), the actor MUST be casted to TESForm with myActor->As<TESForm>() before being returned;

		@tparam R The result type to return with IVirtualMachine::ReturnLatentResult
		@param a_fnName name of the latent function
		@param a_className name of the class holding the latent function
		@param a_callback initial callback. This must be setup as BSScript::LatentStatus callback(BSScript::Internal::VirtualMachine*, VMStackID, Cls, Args...)
		@param a_callableFromTasklets Whether the function can be invoked immediately from a script (not thread safe!) or wait for the next frame to invoke (thread safe!)
		@see IVirtualMachine::ReturnLatentResult
		@see https://www.creationkit.com/index.php?title=Category:Latent_Functions
		*/
		template <class R, class F>
		void IVirtualMachine::RegisterLatentFunction(std::string_view a_fnName, std::string_view a_className, F a_callback, bool a_callableFromTasklets)
		{
			BindNativeMethod(new RE::NativeLatentFunction<R, std::remove_pointer_t<F>>(a_fnName, a_className, a_callback));
			if (a_callableFromTasklets) {
				SetCallableFromTasklets(a_className.data(), a_fnName.data(), true);
			}
		}

		/**
		@brief Returns a result to the stack if it is waiting for a latent function to return. This is a wrapper over ReturnFromLatent.
		
		@param a_stackID ID of the stack waiting for the latent result
		@param a_result result to return to the stack

		*/
		template <class V>
		requires is_return_convertible_v<V>
		void IVirtualMachine::ReturnLatentResult(VMStackID a_stackID, V a_result)
		{
			RE::BSScript::Variable var;
			var.Pack(a_result);
			ReturnFromLatent(a_stackID, var);
		}
	}
}


===============================================
File: include/RE/N/NavMesh.h
===============================================
#pragma once

#include "RE/B/BSNavmesh.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESChildCell.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class NavMesh :
		public TESForm,       // 000
		public TESChildCell,  // 020
		public BSNavmesh      // 028
	{
	public:
		inline static constexpr auto RTTI = RTTI_NavMesh;
		inline static constexpr auto VTABLE = VTABLE_NavMesh;
		inline static constexpr auto FORMTYPE = FormType::NavMesh;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kCompressed = 1 << 18,
				kAutoGen = 1 << 26,
				kNavMeshGenCell = (std::uint32_t)1 << 31
			};
		};

		~NavMesh() override;  // 00

		// override (TESForm)
		bool Load(TESFile* a_mod) override;                                                        // 06
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;                                    // 11
		void InitItemImpl() override;                                                              // 13
		void GetFormDetailedString(char* a_buf, std::uint32_t a_bufLen) override;                  // 16
		void SetDelete(bool a_set) override;                                                       // 23
		void SetAltered(bool a_set) override;                                                      // 24
		bool BelongsInGroup(FORM* a_form, bool a_allowParentGroups, bool a_currentOnly) override;  // 30
		void CreateGroupData(FORM* a_form, FORM_GROUP* a_group) override;                          // 31

		// add
		virtual void               Save();                        // 3B - { return; }
		[[nodiscard]] virtual bool SavesBefore(FORM* a_form);     // 3C - { return fa;se; }
		[[nodiscard]] virtual bool SavesBefore(TESForm* a_form);  // 3D - { return false; }
		[[nodiscard]] virtual bool ProcessBeforeSave();           // 3E - { return false; }
	};
	static_assert(sizeof(NavMesh) == 0x140);
}


===============================================
File: include/RE/N/NavMeshInfoMap.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSNavmeshInfoMap.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/F/FormTypes.h"
#include "RE/P/PrecomputedNavmeshInfoPathMap.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct NavMeshInfo;

	class NavMeshInfoMap :
		public TESForm,                       // 00
		public BSNavmeshInfoMap,              // 20
		public PrecomputedNavmeshInfoPathMap  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_NavMeshInfoMap;
		inline static constexpr auto VTABLE = VTABLE_NavMeshInfoMap;
		inline static constexpr auto FORMTYPE = FormType::Navigation;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~NavMeshInfoMap() override;  // 00

		// override (TESForm)
		bool Load(TESFile* a_mod) override;    // 06
		void InitItemImpl() override;          // 13
		void SetAltered(bool a_set) override;  // 24

		// override (BSNavmeshInfoMap)

		BSNavmeshInfo* GetNavMeshInfoFixID(std::uint32_t a_id) override;                                                      // 01
		BSNavmeshInfo* GetNavmeshInfo(std::uint32_t a_id) override;                                                           // 02
		void           GetAllNavMeshInfo(BSTArray<BSNavmeshInfo*>& a_results) override;                                       // 03
		void           BuildListOfConnectedInfos(const BSNavmeshInfo* a_info, BSTArray<BSNavmeshInfo*>& a_results) override;  // 04
		void           ForEach(IVisitor* a_visitor) override;                                                                 // 05

		// members
		bool                                                 updateAll;         // 78
		std::uint8_t                                         pad79;             // 79
		std::uint16_t                                        pad7A;             // 7A
		std::uint32_t                                        pad7C;             // 7C
		BSTHashMap<std::uint32_t, NavMeshInfo*>              infoMap;           // 80
		BSTHashMap<std::uint64_t, BSTArray<BSNavmeshInfo*>*> ckNavMeshInfoMap;  // B0
		mutable BSReadWriteLock                              mapLock;           // E0
		bool                                                 init;              // E8
		std::uint8_t                                         padE9;             // E9
		std::uint16_t                                        padEA;             // EA
		std::uint32_t                                        padEC;             // EC
	};
	static_assert(sizeof(NavMeshInfoMap) == 0xF0);
}


===============================================
File: include/RE/N/NiAVObject.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSShaderMaterial.h"
#include "RE/C/CollisionLayers.h"
#include "RE/N/NiBound.h"
#include "RE/N/NiObjectNET.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTransform.h"

namespace RE
{
	class bhkCollisionObject;
	class NiAlphaProperty;
	class NiAVObject;
	class NiCollisionObject;
	class NiColor;
	class NiColorA;
	class NiCullingProcess;
	class NiNode;
	class NiPoint3;
	class TESObjectREFR;

	class NiUpdateData
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kDirty = 1 << 0,
			kDisableCollision = 1 << 13
		};

		float                                 time;   // 0
		stl::enumeration<Flag, std::uint32_t> flags;  // 4
	};
	static_assert(sizeof(NiUpdateData) == 0x8);

	class PerformOpFunc
	{
	public:
		virtual ~PerformOpFunc();  // 00

		// add
		virtual bool operator()(NiAVObject* a_object);  // 01
	};
	static_assert(sizeof(PerformOpFunc) == 0x8);

	class NiAVObject : public NiObjectNET
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiAVObject;
		inline static auto           Ni_RTTI = NiRTTI_NiAVObject;

		enum class Flag
		{
			kNone = 0,
			kHidden = 1 << 0,
			kSelectiveUpdate = 1 << 1,
			kSelectiveUpdateTransforms = 1 << 2,
			kSelectiveUpdateController = 1 << 3,
			kSelectiveUpdateRigid = 1 << 4,
			kDisplayObject = 1 << 5,
			kDisableSorting = 1 << 6,
			kSelectiveUpdateTransformsOverride = 1 << 7,
			kSaveExternalGeometryData = 1 << 9,
			kNoDecals = 1 << 10,
			kAlwaysDraw = 1 << 11,
			kMeshLOD = 1 << 12,
			kFixedBound = 1 << 13,
			kTopFadeNode = 1 << 14,
			kIgnoreFade = 1 << 15,
			kNoAnimSyncX = 1 << 16,
			kNoAnimSyncY = 1 << 17,
			kNoAnimSyncZ = 1 << 18,
			kNoAnimSyncS = 1 << 19,
			kNoDismember = 1 << 20,
			kNoDismemberValidity = 1 << 21,
			kRenderUse = 1 << 22,
			kMaterialsApplied = 1 << 23,
			kHighDetail = 1 << 24,
			kForceUpdate = 1 << 25,
			kPreProcessedNode = 1 << 26
		};

		~NiAVObject() override;  // 00

		// override (NiObjectNET)
		const NiRTTI* GetRTTI() const override;                            // 02
		void          LoadBinary(NiStream& a_stream) override;             // 18
		void          LinkObject(NiStream& a_stream) override;             // 19
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A
		void          SaveBinary(NiStream& a_stream) override;             // 1B
		bool          IsEqual(NiObject* a_object) override;                // 1C
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D

		// add
		virtual void UpdateControllers(NiUpdateData& a_data);  // 25
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		virtual void Unk_VRFunc(void);
#endif
		SKYRIM_REL_VR_VIRTUAL void PerformOp(PerformOpFunc& a_func);                                                                          // 26
		SKYRIM_REL_VR_VIRTUAL void AttachProperty(NiAlphaProperty* a_property);                                                               // 27 - { return; }
		SKYRIM_REL_VR_VIRTUAL void SetMaterialNeedsUpdate(bool a_needsUpdate);                                                                // 28 - { return; }
		SKYRIM_REL_VR_VIRTUAL void SetDefaultMaterialNeedsUpdateFlag(bool a_flag);                                                            // 29 - { return; }
		SKYRIM_REL_VR_VIRTUAL NiAVObject* GetObjectByName(const BSFixedString& a_name);                                                       // 2A
		SKYRIM_REL_VR_VIRTUAL void        SetSelectiveUpdateFlags(bool& a_selectiveUpdate, bool a_selectiveUpdateTransforms, bool& a_rigid);  // 2B
		SKYRIM_REL_VR_VIRTUAL void        UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2);                                     // 2C
		SKYRIM_REL_VR_VIRTUAL void        UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2);                             // 2D
		SKYRIM_REL_VR_VIRTUAL void        UpdateRigidDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2);                                // 2E
		SKYRIM_REL_VR_VIRTUAL void        UpdateWorldBound();                                                                                 // 2F - { return; }
		SKYRIM_REL_VR_VIRTUAL void        UpdateWorldData(NiUpdateData* a_data);                                                              // 30
		SKYRIM_REL_VR_VIRTUAL void        UpdateTransformAndBounds(NiUpdateData& a_data);                                                     // 31
		SKYRIM_REL_VR_VIRTUAL void        PreAttachUpdate(NiNode* a_parent, NiUpdateData& a_data);                                            // 32
		SKYRIM_REL_VR_VIRTUAL void        PostAttachUpdate();                                                                                 // 33
		SKYRIM_REL_VR_VIRTUAL void        OnVisible(NiCullingProcess& a_process);                                                             // 34 - { return; }

		[[nodiscard]] NiAVObject*         Clone();
		void                              CullGeometry(bool a_cull);
		void                              CullNode(bool a_cull);
		[[nodiscard]] bool                GetAppCulled() const;
		[[nodiscard]] bhkCollisionObject* GetCollisionObject() const;
		[[nodiscard]] COL_LAYER           GetCollisionLayer() const;
		[[nodiscard]] BSGeometry*         GetFirstGeometryOfShaderType(BSShaderMaterial::Feature a_type);
		[[nodiscard]] TESObjectREFR*      GetUserData() const;
		void                              SetUserData(TESObjectREFR* a_ref) noexcept;
		[[nodiscard]] bool                HasAnimation() const;
		[[nodiscard]] bool                HasShaderType(BSShaderMaterial::Feature a_type);
		void                              RemoveDecals();
		void                              SetAppCulled(bool a_cull);
		void                              SetCollisionLayer(COL_LAYER a_collisionLayer);
		void                              SetCollisionLayerAndGroup(COL_LAYER a_collisionLayer, std::uint32_t a_group);
		bool                              SetMotionType(std::uint32_t a_motionType, bool a_arg2 = true, bool a_arg3 = false, bool a_allowActivate = true);
		bool                              SetProjectedUVData(const NiColorA& a_projectedUVParams, const NiColor& a_projectedUVColor, bool a_isSnow);
		void                              TintScenegraph(const NiColorA& a_color);
		void                              Update(NiUpdateData& a_data);
		void                              UpdateBodyTint(const NiColor& a_color);
		void                              UpdateHairColor(const NiColor& a_color);
		void                              UpdateMaterialAlpha(float a_alpha, bool a_doOnlySkin);
		void                              UpdateRigidConstraints(bool a_enable, std::uint8_t a_arg2 = 1, std::uint32_t a_arg3 = 1);

		[[nodiscard]] inline stl::enumeration<Flag, std::uint32_t>& GetFlags() noexcept
		{
			return REL::RelocateMember<stl::enumeration<Flag, std::uint32_t>>(this, 0x0F4, 0x10C);
		}

		[[nodiscard]] inline const stl::enumeration<Flag, std::uint32_t>& GetFlags() const noexcept
		{
			return REL::RelocateMember<stl::enumeration<Flag, std::uint32_t>>(this, 0x0F4, 0x10C);
		}

		// members
		NiNode*                      parent;           // 030
		std::uint32_t                parentIndex;      // 038
		std::uint32_t                unk03C;           // 03C
		NiPointer<NiCollisionObject> collisionObject;  // 040
		NiTransform                  local;            // 048
		NiTransform                  world;            // 07C
		NiTransform                  previousWorld;    // 0B0
		NiBound                      worldBound;       // 0E4
#ifndef ENABLE_SKYRIM_VR
		stl::enumeration<Flag, std::uint32_t> flags;                    // 0F4
		TESObjectREFR*                        userData;                 // 0F8
		float                                 fadeAmount;               // 100
		std::uint32_t                         lastUpdatedFrameCounter;  // 104
		std::uint8_t                          unk108;                   // 108
		std::uint8_t                          flags02;                  // 109
		std::uint16_t                         unk10A;                   // 10A
		std::uint32_t                         pad10C;                   // 10C
	};
	static_assert(sizeof(NiAVObject) == 0x110);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		float                                 unkF4;                    // 0F4
		float                                 unkF8;                    // 0F8
		float                                 unkFC;                    // 0FC
		float                                 fadeAmount;               // 100
		std::uint32_t                         lastUpdatedFrameCounter;  // 104
		float                                 unk108;                   // 108
		stl::enumeration<Flag, std::uint32_t> flags;                    // 10C
		TESObjectREFR*                        userData;                 // 110
		std::uint32_t                         unk11C;                   // 11C
		std::uint8_t                          unk120[8];                // 120 - bitfield
		std::uint64_t                         unk128;                   // 128
		std::uint32_t                         unk130;                   // 130
		std::uint32_t                         unk134;                   // 134
	};
	static_assert(sizeof(NiAVObject) == 0x138);
#else
		uint32_t      unkF4;                    // 0F4
		uint64_t*     unkF8;                    // 0F8
		float         fadeAmount;               // 100
		std::uint32_t lastUpdatedFrameCounter;  // 104
		uint64_t      unk104;                   // 108
	};
#endif
}


===============================================
File: include/RE/N/NiAllocator.h
===============================================
#pragma once

namespace RE
{
	enum class NiMemEventType
	{
		kUnknown = 0,
		kOperNew = 1,
		kOperNewArray = 2,
		kOperDelete = 3,
		kOperDeleteArray = 4,
		kMalloc = 5,
		kRealloc = 6,
		kAlignedMalloc = 7,
		kAlignedRealloc = 8,
		kFree = 9,
		kAlignedFree = 10,
		kExternalAlloc = 11,
		kExternalFree = 12
	};

	class NiAllocator
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiAllocator;

		virtual ~NiAllocator();  // 00

		// add
		virtual void* Allocate(std::size_t& a_sizeInBytes, std::size_t& a_alignment, NiMemEventType a_eventType, bool a_provideAccurateSizeOnDeallocate, const char* a_file, std::int32_t a_line, const char* a_function) = 0;                                          // 01
		virtual void  Deallocate(void* a_memory, NiMemEventType a_eventType, std::size_t a_sizeInBytes) = 0;                                                                                                                                                            // 02
		virtual void* Reallocate(void* a_memory, size_t& a_sizeInBytes, std::size_t& a_alignment, NiMemEventType a_eventType, bool a_provideAccurateSizeOnDeallocate, std::size_t a_sizeCurrent, const char* a_file, std::int32_t a_line, const char* a_function) = 0;  // 03
		virtual bool  TrackAllocate(const void* const a_memory, std::size_t a_sizeInBytes, NiMemEventType a_eventType, const char* a_file, std::int32_t a_line, const char* a_function) = 0;                                                                            // 04
		virtual bool  TrackDeallocate(const void* const a_memory, NiMemEventType a_eventType) = 0;                                                                                                                                                                      // 05
		virtual void  Unk_06(void) = 0;                                                                                                                                                                                                                                 // 06
		virtual void  Initialize() = 0;                                                                                                                                                                                                                                 // 07
		virtual void  Shutdown() = 0;                                                                                                                                                                                                                                   // 08
		virtual bool  VerifyAddress(const void* a_memory) = 0;                                                                                                                                                                                                          // 09
	};
	static_assert(sizeof(NiAllocator) == 0x8);
}


===============================================
File: include/RE/N/NiAlphaProperty.h
===============================================
#pragma once

#include "RE/N/NiProperty.h"

namespace RE
{
	class NiAlphaProperty : public NiProperty
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiAlphaProperty;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiAlphaProperty;
		inline static constexpr auto VTABLE = VTABLE_NiAlphaProperty;

		enum class AlphaFunction
		{
			kOne,
			kZero,
			kSrcColor,
			kInvSrcColor,
			kDestColor,
			kInvDestColor,
			kSrcAlpha,
			kInvSrcAlpha,
			kDestAlpha,
			kInvDestAlpha,
			kSrcAlphaSat
		};

		enum class TestFunction
		{
			kAlways,
			kLess,
			kEqual,
			kLessEqual,
			kGreater,
			kNotEqual,
			kGreaterEqual,
			kNever
		};

		~NiAlphaProperty() override;  // 00

		// override (NiProperty)
		const NiRTTI*      GetRTTI() const override;                           // 02
		NiObject*          CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void               LoadBinary(NiStream& a_stream) override;            // 18
		void               LinkObject(NiStream& a_stream) override;            // 19 - { NiProperty::LinkObject(a_stream); }
		bool               RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiProperty::RegisterStreamables(a_stream); }
		void               SaveBinary(NiStream& a_stream) override;            // 1B
		bool               IsEqual(NiObject* a_object) override;               // 1C
		[[nodiscard]] Type GetType() const override;                           // 25 - { return Type::kAlpha; }

		[[nodiscard]] bool          GetAlphaBlending() const;
		[[nodiscard]] bool          GetAlphaTesting() const;
		[[nodiscard]] AlphaFunction GetDestBlendMode() const;
		[[nodiscard]] AlphaFunction GetSrcBlendMode() const;
		void                        SetAlphaBlending(bool a_enable);
		void                        SetAlphaTesting(bool a_enable);
		void                        SetDestBlendMode(AlphaFunction a_mode);
		void                        SetSrcBlendMode(AlphaFunction a_mode);

		// members
		std::uint16_t alphaFlags;      // 30
		std::uint8_t  alphaThreshold;  // 32
		std::uint8_t  pad33;           // 33
		std::uint32_t pad34;           // 34
	};
	static_assert(sizeof(NiAlphaProperty) == 0x38);
}


===============================================
File: include/RE/N/NiAnimationKey.h
===============================================
#pragma once

namespace RE
{
	class NiAnimationKey
	{
	public:
		enum class KeyContent
		{
			kFloat,
			kPos,
			kRot,
			kColor,
			kText,
			kBool,

			kTotal
		};

		enum class KeyType
		{
			kNoInterp,
			kLink,
			kBez,
			kTCB,
			kEuler,
			kStrip,

			kTotal
		};

		NiAnimationKey();
		NiAnimationKey(float a_time);
		~NiAnimationKey();

		[[nodiscard]] float           GetTime() const;
		void                          SetTime(float a_time);
		[[nodiscard]] NiAnimationKey* GetKeyAt(std::uint32_t a_index, std::uint8_t a_keySize) const;

	protected:
		// members
		float _time;  // 00
	};
	static_assert(sizeof(NiAnimationKey) == 0x4);
}


===============================================
File: include/RE/N/NiBinaryStream.h
===============================================
#pragma once

namespace RE
{
	class NiBinaryStream
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiBinaryStream;

		using int_type = std::int32_t;
		using pos_type = std::uint32_t;
		using off_type = std::int32_t;

		struct BufferInfo
		{
		public:
			// members
			void*         buffer;           // 00
			std::uint32_t totalSize;        // 08
			std::uint32_t bufferAllocSize;  // 0C
			std::uint32_t bufferReadSize;   // 10
			std::uint32_t bufferPos;        // 14
			std::uint32_t streamPos;        // 18
			std::uint32_t pad1C;            // 1C
		};
		static_assert(sizeof(BufferInfo) == 0x20);

		NiBinaryStream();
		virtual ~NiBinaryStream();  // 00

		// add
		[[nodiscard]] virtual bool          good() const = 0;                    // 01
		virtual void                        seek(std::int32_t a_numBytes) = 0;   // 02
		[[nodiscard]] virtual std::uint32_t tell() const;                        // 03 - { return _absoluteCurrentPos; }
		virtual void                        get_info(BufferInfo& a_buf);         // 04
		virtual void                        set_endian_swap(bool a_doSwap) = 0;  // 05

		template <class CharT>
		bool get(CharT& a_ch);
		template <class CharT>
		bool read(CharT* a_str, std::uint32_t a_count);
		template <class CharT>
		bool put(CharT a_ch);
		template <class CharT>
		bool write(const CharT* a_str, std::uint32_t a_count);

	protected:
		using ReadFn = std::uint32_t(NiBinaryStream* a_this, void* a_buffer, std::uint32_t a_bytes, std::uint32_t* a_componentSizes, std::uint32_t a_numComponents);
		using WriteFn = std::uint32_t(NiBinaryStream* a_this, const void* a_buffer, std::uint32_t a_bytes, std::uint32_t* a_componentSizes, std::uint32_t a_numComponents);

		std::uint32_t binary_read(void* a_buffer, std::uint32_t a_totalBytes, std::uint32_t* a_componentSizes, std::uint32_t a_numComponents = 1);
		std::uint32_t binary_write(const void* a_buffer, std::uint32_t a_totalBytes, std::uint32_t* a_componentSizes, std::uint32_t a_numComponents = 1);

		// members
		std::uint32_t _absoluteCurrentPos;  // 08
		std::uint32_t _pad0C;               // 0C
		ReadFn*       _readFn;              // 10
		WriteFn*      _writeFn;             // 18
	};
	static_assert(sizeof(NiBinaryStream) == 0x20);

	template <class CharT>
	inline bool NiBinaryStream::get(CharT& a_ch)
	{
		return read(&a_ch, 1);
	}

	template <class CharT>
	inline bool NiBinaryStream::read(CharT* a_str, std::uint32_t a_count)
	{
		std::uint32_t size = sizeof(CharT);
		std::uint32_t toRead = a_count * size;
		std::uint32_t bytesRead = binary_read(a_str, toRead, &size);
		return bytesRead == toRead;
	}

	template <class CharT>
	inline bool NiBinaryStream::put(CharT a_ch)
	{
		return write(&a_ch, 1);
	}

	template <class CharT>
	inline bool NiBinaryStream::write(const CharT* a_str, std::uint32_t a_count)
	{
		std::uint32_t size = sizeof(CharT);
		std::uint32_t toWrite = a_count * size;
		std::uint32_t bytesWritten = binary_write(a_str, toWrite, &size);
		return bytesWritten == toWrite;
	}
}

namespace std
{
	template <class CharT, class Traits, class Allocator>
	inline bool getline(RE::NiBinaryStream& a_input, std::basic_string<CharT, Traits, Allocator>& a_str)
	{
		CharT delim = std::use_facet<std::ctype<CharT>>(std::locale()).widen('\n');
		return getline(a_input, a_str, delim);
	}

	template <class CharT, class Traits, class Allocator>
	inline bool getline(RE::NiBinaryStream& a_input, std::basic_string<CharT, Traits, Allocator>& a_str, CharT a_delim)
	{
		a_str.erase();
		CharT c;
		auto  notEOF = a_input.get(c);
		if (notEOF) {
			do {
				if (!std::char_traits<CharT>::eq(c, a_delim)) {
					a_str.push_back(c);
				} else {
					break;
				}

				if (a_str.size() != a_str.max_size()) {
					notEOF = a_input.get(c);
				} else {
					break;
				}
			} while (notEOF);
			return true;
		} else {
			return false;
		}
	}
}


===============================================
File: include/RE/N/NiBoneMatrixSetterI.h
===============================================
#pragma once

namespace RE
{
	class NiBoneMatrixSetterI
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiBoneMatrixSetterI;

		virtual ~NiBoneMatrixSetterI();  // 00

		// add
		virtual void Unk_01(void);  // 01
	};
	static_assert(sizeof(NiBoneMatrixSetterI) == 0x8);
}


===============================================
File: include/RE/N/NiBooleanExtraData.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"

namespace RE
{
	class NiBooleanExtraData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiBooleanExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiBooleanExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiBooleanExtraData;

		~NiBooleanExtraData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		static NiBooleanExtraData* Create(const BSFixedString& a_name, bool a_value);

		// members
		bool data;  // 18
	};
	static_assert(sizeof(NiBooleanExtraData) == 0x20);
}


===============================================
File: include/RE/N/NiBound.h
===============================================
#pragma once

#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiBound
	{
	public:
		// members
		NiPoint3 center;  // 00
		float    radius;  // 0C
	};
	static_assert(sizeof(NiBound) == 0x10);
}


===============================================
File: include/RE/N/NiCamera.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiAVObject.h"
#include "RE/N/NiFrustum.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiRect.h"

namespace RE
{
	class NiCamera : public NiAVObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiCamera;
		inline static auto           Ni_RTTI = NiRTTI_NiCamera;

		struct RUNTIME_DATA
		{
#ifndef ENABLE_SKYRIM_VR
#	define RUNTIME_DATA_CONTENT float worldToCam[4][4]; /* 0 */
			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x40);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
#	define RUNTIME_DATA_CONTENT                   \
		float           worldToCam[4][4]; /* 0 */  \
		NiFrustum*      viewFrustumPtr;   /* 40 */ \
		BSTArray<void*> unk180;           /* 48 */ \
		BSTArray<void*> unk198;           /* 60 */ \
		BSTArray<void*> unk1B0;           /* 78 */ \
		std::uint32_t   unk1C8;           /* 90 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x98);
#else
#	define RUNTIME_DATA_CONTENT float worldToCam[4][4]; /* 0 */
			RUNTIME_DATA_CONTENT
		};
#endif

		struct RUNTIME_DATA2
		{
#define RUNTIME_DATA2_CONTENT                \
	NiFrustum     viewFrustum;      /* 00 */ \
	float         minNearPlaneDist; /* 1C */ \
	float         maxFarNearRatio;  /* 20 */ \
	NiRect<float> port;             /* 24 */ \
	float         lodAdjust;        /* 34 */

			RUNTIME_DATA2_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA2) == 0x38);

		~NiCamera() override;  // 00

		// override (NiAVObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17 - { return this; }
		void          LoadBinary(NiStream& a_stream) override;            // 18 - { return; }
		void          LinkObject(NiStream& a_stream) override;            // 19 - { return; }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B - { return; }
		bool          IsEqual(NiObject* a_object) override;               // 1C
#if !defined(ENABLE_SKYRIM_VR) || (!defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_VR))
		// The following are virtual functions past the point where VR compatibility breaks.
		void UpdateWorldBound() override;                     // 2F - { return; }
		void UpdateWorldData(NiUpdateData* a_data) override;  // 30
#endif

		static bool BoundInFrustum(const NiBound& a_bound, NiCamera* a_camera);
		static bool NodeInFrustum(NiAVObject* a_node, NiCamera* a_camera);
		static bool PointInFrustum(const NiPoint3& a_point, NiCamera* a_camera, float a_radius);

		static bool WorldPtToScreenPt3(const float a_matrix[4][4], const NiRect<float>& a_port, const NiPoint3& a_point, float& a_xOut, float& a_yOut, float& a_zOut, float a_zeroTolerance);

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x110, 0x138);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x110, 0x138);
		}

		[[nodiscard]] inline RUNTIME_DATA2& GetRuntimeData2() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA2>(this, 0x150, 0x1CC);
		}

		[[nodiscard]] inline const RUNTIME_DATA2& GetRuntimeData2() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA2>(this, 0x150, 0x1CC);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT;   // 110, 138
		RUNTIME_DATA2_CONTENT;  // 150, 1CC
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(NiCamera) == 0x188);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(NiCamera) == 0x208);
#endif
}
#undef RUNTIME_DATA_CONTENT
#undef RUNTIME_DATA2_CONTENT


===============================================
File: include/RE/N/NiCloningProcess.h
===============================================
#pragma once

#include "RE/B/BSTHashMap.h"
#include "RE/N/NiObject.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiCloningProcess
	{
	public:
		// members
		BSTHashMap<NiObject*, NiObject*> cloneMap;    // 00
		BSTHashMap<NiObject*, bool>      processMap;  // 30
		std::uint32_t                    copyType;    // 60
		char                             appendChar;  // 64
		std::uint16_t                    unk65;       // 65
		NiPoint3                         unk68;       // 68
	};
	static_assert(sizeof(NiCloningProcess) == 0x78);
}


===============================================
File: include/RE/N/NiCollisionObject.h
===============================================
#pragma once

#include "RE/N/NiObject.h"

namespace RE
{
	class NiAVObject;

	class NiCollisionObject : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiCollisionObject;
		inline static auto           Ni_RTTI = NiRTTI_NiCollisionObject;

		~NiCollisionObject() override = 0;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C

		// add
		virtual void Unk_25(void);      // 25
		virtual void Unk_26(void) = 0;  // 26
		virtual void Unk_27(void) = 0;  // 27
		virtual void Unk_28(void);      // 28 - { return; }
		virtual void Unk_29(void);      // 29 - { return; }

		// members
		NiAVObject* sceneObject;  // 10
	};
	static_assert(sizeof(NiCollisionObject) == 0x18);
}


===============================================
File: include/RE/N/NiColor.h
===============================================
#pragma once

namespace RE
{
	class NiColor;
	class NiColorA;

	struct Color;

	class NiColor
	{
	public:
		enum : std::size_t
		{
			kRed,
			kGreen,
			kBlue,

			kTotal
		};

		constexpr NiColor() noexcept :
			red(0.0),
			green(0.0),
			blue(0.0)
		{}

		constexpr NiColor(const NiColor& a_rhs) noexcept :
			red(a_rhs.red),
			green(a_rhs.green),
			blue(a_rhs.blue)
		{}

		constexpr NiColor(NiColor&& a_rhs) noexcept :
			red(std::move(a_rhs.red)),
			green(std::move(a_rhs.green)),
			blue(std::move(a_rhs.blue))
		{}

		constexpr NiColor(float a_red, float a_green, float a_blue) noexcept :
			red(a_red),
			green(a_green),
			blue(a_blue)
		{}

		constexpr NiColor(std::uint32_t a_hexValue) noexcept :
			red(((a_hexValue >> 16) & 0xFF) / 255.0f),
			green(((a_hexValue >> 8) & 0xFF) / 255.0f),
			blue(((a_hexValue)&0xFF) / 255.0f)
		{
		}

		NiColor(const Color& a_rhs);
		~NiColor() noexcept = default;

		constexpr NiColor& operator=(const NiColor& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				red = a_rhs.red;
				green = a_rhs.green;
				blue = a_rhs.blue;
			}
			return *this;
		}

		constexpr NiColor& operator=(NiColor&& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				red = std::move(a_rhs.red);
				green = std::move(a_rhs.green);
				blue = std::move(a_rhs.blue);
			}
			return *this;
		}

		constexpr NiColor& operator=(const NiColorA& a_rhs) noexcept;

		[[nodiscard]] friend constexpr bool operator==(const NiColor& a_lhs, const NiColor& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				if (a_lhs[i] != a_rhs[i]) {
					return false;
				}
			}
			return true;
		}

		[[nodiscard]] friend constexpr bool operator!=(const NiColor& a_lhs, const NiColor& a_rhs) noexcept
		{
			return !(a_lhs == a_rhs);
		}

		[[nodiscard]] constexpr float& operator[](std::size_t a_idx) noexcept
		{
			assert(a_idx < kTotal);
			return std::addressof(red)[a_idx];
		}

		[[nodiscard]] constexpr const float& operator[](std::size_t a_idx) const noexcept
		{
			assert(a_idx < kTotal);
			return std::addressof(red)[a_idx];
		}

		[[nodiscard]] NiColor operator+(const NiColor& a_rhs) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] += a_rhs[i];
			}
			return tmp;
		}

		NiColor& operator+=(const NiColor& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) += a_rhs[i];
			}
			return *this;
		}

		[[nodiscard]] NiColor operator-(const NiColor& a_rhs) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] -= a_rhs[i];
			}
			return tmp;
		}

		NiColor& operator-=(const NiColor& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) -= a_rhs[i];
			}
			return *this;
		}

		friend NiColor operator-(float a_lhs, const NiColor& a_rhs)
		{
			return NiColor(
				a_lhs - a_rhs.red,
				a_lhs - a_rhs.green,
				a_lhs - a_rhs.blue);
		}

		[[nodiscard]] NiColor operator*(const NiColor& a_rhs) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] *= a_rhs[i];
			}
			return tmp;
		}

		NiColor& operator*=(const NiColor& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) *= a_rhs[i];
			}
			return *this;
		}

		friend NiColor operator*(float a_lhs, const NiColor& a_rhs)
		{
			return NiColor(
				a_lhs * a_rhs.red,
				a_lhs * a_rhs.green,
				a_lhs * a_rhs.blue);
		}

		[[nodiscard]] NiColor operator/(const NiColor& a_rhs) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] /= a_rhs[i];
			}
			return tmp;
		}

		NiColor& operator/=(const NiColor& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) /= a_rhs[i];
			}
			return *this;
		}

		friend NiColor operator/(float a_lhs, const NiColor& a_rhs)
		{
			return NiColor(
				a_lhs / a_rhs.red,
				a_lhs / a_rhs.green,
				a_lhs / a_rhs.blue);
		}

		[[nodiscard]] NiColor operator+(float a_value) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] += a_value;
			}
			return tmp;
		}

		NiColor& operator+=(float a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) += a_value;
			}
			return *this;
		}

		[[nodiscard]] NiColor operator-(float a_value) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] -= a_value;
			}
			return tmp;
		}

		NiColor& operator-=(float a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) -= a_value;
			}
			return *this;
		}

		[[nodiscard]] NiColor operator*(float a_value) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] *= a_value;
			}
			return tmp;
		}

		NiColor& operator*=(float a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) *= a_value;
			}
			return *this;
		}

		[[nodiscard]] NiColor operator/(float a_value) const noexcept
		{
			NiColor tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] /= a_value;
			}
			return tmp;
		}

		NiColor& operator/=(float a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) /= a_value;
			}
			return *this;
		}

		[[nodiscard]] std::uint32_t ToInt() const;
		[[nodiscard]] std::string   ToHex() const;

		// members
		float red;    // 0
		float green;  // 4
		float blue;   // 8
	};
	static_assert(sizeof(NiColor) == 0xC);

	class NiColorA
	{
	public:
		enum : std::size_t
		{
			kRed,
			kGreen,
			kBlue,
			kAlpha,

			kTotal
		};

		constexpr NiColorA() noexcept :
			red(0.0),
			green(0.0),
			blue(0.0),
			alpha(0.0)
		{}

		constexpr NiColorA(const NiColorA& a_rhs) noexcept :
			red(a_rhs.red),
			green(a_rhs.green),
			blue(a_rhs.blue),
			alpha(a_rhs.alpha)
		{}

		constexpr NiColorA(NiColorA&& a_rhs) noexcept :
			red(std::move(a_rhs.red)),
			green(std::move(a_rhs.green)),
			blue(std::move(a_rhs.blue)),
			alpha(std::move(a_rhs.alpha))
		{}

		constexpr NiColorA(float a_red, float a_green, float a_blue, float a_alpha) noexcept :
			red(a_red),
			green(a_green),
			blue(a_blue),
			alpha(a_alpha)
		{}

		NiColorA(const Color& a_rhs);
		~NiColorA() noexcept = default;

		constexpr NiColorA& operator=(const NiColorA& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				red = a_rhs.red;
				green = a_rhs.green;
				blue = a_rhs.blue;
				alpha = a_rhs.alpha;
			}
			return *this;
		}

		constexpr NiColorA& operator=(NiColorA&& a_rhs) noexcept
		{
			if (this != std::addressof(a_rhs)) {
				red = std::move(a_rhs.red);
				green = std::move(a_rhs.green);
				blue = std::move(a_rhs.blue);
				alpha = std::move(a_rhs.alpha);
			}
			return *this;
		}

		constexpr NiColorA& operator=(const NiColor& a_rhs) noexcept;

		[[nodiscard]] friend constexpr bool operator==(const NiColorA& a_lhs, const NiColorA& a_rhs) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				if (a_lhs[i] != a_rhs[i]) {
					return false;
				}
			}
			return true;
		}

		[[nodiscard]] friend constexpr bool operator!=(const NiColorA& a_lhs, const NiColorA& a_rhs) noexcept
		{
			return !(a_lhs == a_rhs);
		}

		[[nodiscard]] constexpr float& operator[](std::size_t a_idx) noexcept
		{
			assert(a_idx < kTotal);
			return std::addressof(red)[a_idx];
		}

		[[nodiscard]] constexpr const float& operator[](std::size_t a_idx) const noexcept
		{
			assert(a_idx < kTotal);
			return std::addressof(red)[a_idx];
		}

		[[nodiscard]] NiColorA operator*(float a_value) const noexcept
		{
			NiColorA tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] *= a_value;
			}
			return tmp;
		}

		NiColorA& operator*=(float a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) *= a_value;
			}
			return *this;
		}

		[[nodiscard]] NiColorA operator/(float a_value) const noexcept
		{
			NiColorA tmp = *this;
			for (std::size_t i = 0; i < kTotal; ++i) {
				tmp[i] /= a_value;
			}
			return tmp;
		}

		NiColorA& operator/=(float a_value) noexcept
		{
			for (std::size_t i = 0; i < kTotal; ++i) {
				operator[](i) /= a_value;
			}
			return *this;
		}

		// members
		float red;    // 00
		float green;  // 04
		float blue;   // 08
		float alpha;  // 0C
	};
	static_assert(sizeof(NiColorA) == 0x10);

	constexpr NiColor& NiColor::operator=(const NiColorA& a_rhs) noexcept
	{
		red = a_rhs.red;
		green = a_rhs.green;
		blue = a_rhs.blue;
		return *this;
	}

	constexpr NiColorA& NiColorA::operator=(const NiColor& a_rhs) noexcept
	{
		red = a_rhs.red;
		green = a_rhs.green;
		blue = a_rhs.blue;
		alpha = 0.0;
		return *this;
	}
}


===============================================
File: include/RE/N/NiColorData.h
===============================================
#pragma once

#include "RE/N/NiColorKey.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class NiColorData : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiColorData;
		inline static auto           Ni_RTTI = NiRTTI_NiColorData;

		using KeyType = NiColorKey::KeyType;

		NiColorData();
		~NiColorData() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                 // 02
		void          LoadBinary(NiStream& a_stream) override;  // 18
		void          SaveBinary(NiStream& a_stream) override;  // 1B
		bool          IsEqual(NiObject* a_object) override;     // 1C

		[[nodiscard]] std::uint32_t GetNumKeys() const;
		NiColorKey*                 GetAnim(std::uint32_t& a_numKeys, NiColorKey::KeyType& a_type, std::uint8_t& a_size) const;

		// members
		std::uint32_t numKeys;  // 10
		std::uint32_t pad14;    // 14
		NiColorKey*   keys;     // 18
		KeyType       type;     // 20
		std::uint8_t  keySize;  // 24
		std::uint8_t  pad25;    // 25
		std::uint16_t pad26;    // 26
	};
	static_assert(sizeof(NiColorData) == 0x28);
}


===============================================
File: include/RE/N/NiColorInterpolator.h
===============================================
#pragma once

#include "RE/N/NiColor.h"
#include "RE/N/NiKeyBasedInterpolator.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiColorData;

	class NiColorInterpolator : public NiKeyBasedInterpolator
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiColorInterpolator;
		inline static auto           Ni_RTTI = NiRTTI_NiColorInterpolator;

		~NiColorInterpolator() override;  // 00

		// override (NiKeyBasedInterpolator)
		const NiRTTI*      GetRTTI() const override;                                                               // 02
		NiObject*          CreateClone(NiCloningProcess& a_cloning) override;                                      // 17
		void               LoadBinary(NiStream& a_stream) override;                                                // 18
		void               LinkObject(NiStream& a_stream) override;                                                // 19 - { NiKeyBasedInterpolator::LinkObject(a_stream); }
		bool               RegisterStreamables(NiStream& a_stream) override;                                       // 1A
		void               SaveBinary(NiStream& a_stream) override;                                                // 1B
		bool               IsEqual(NiObject* a_object) override;                                                   // 1C
		bool               Update1(float a_time, NiObjectNET* a_interpTarget, NiQuatTransform& a_value) override;  // 25 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update2(float a_time, NiObjectNET* a_target, NiColorA& a_value) override;               // 26
		bool               Update3(float a_time, NiObjectNET* a_interpTarget, NiPoint3& a_value) override;         // 27 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update4(float a_time, NiObjectNET* a_interpTarget, NiQuaternion& a_value) override;     // 28 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update5(float a_time, NiObjectNET* a_interpTarget, float& a_value) override;            // 29 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update6(float a_time, NiObjectNET* a_interpTarget, bool& a_value) override;             // 2A - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               IsColorAValueSupported() const override;                                                // 2F - { return true; }
		void               Collapse() override;                                                                    // 31
		void               GuaranteeTimeRange(float a_start, float a_end) override;                                // 33
		NiInterpolator*    GetSequenceInterpolator(float a_start, float a_end) override;                           // 34
		std::uint16_t      GetKeyChannelCount() const override;                                                    // 39 - { return 1; }
		std::uint32_t      GetKeyCount(std::uint16_t a_channel) const override;                                    // 3A - { return colorData ? colorData->numKeys : 0; }
		KeyContent         GetKeyContent(std::uint16_t a_channel) const override;                                  // 3B - { KeyContent::kColor; }
		KeyType            GetKeyType(std::uint16_t a_channel) const override;                                     // 3C - { return colorData ? colorData->type : 0; }
		void*              GetKeyArray(std::uint16_t a_channel) const override;                                    // 3D - { return colorData ? colorData->keys : 0; }
		std::uint8_t       GetKeyStride(std::uint16_t a_channel) const override;                                   // 3E - { return colorData ? colorData->keySize : 0; }
		[[nodiscard]] bool GetChannelPosed(std::uint16_t a_channel) const override;                                // 3F

		// members
		NiColorA               colorValue;  // 18
		NiPointer<NiColorData> colorData;   // 28
		std::uint32_t          lastIndex;   // 30
		std::uint32_t          pad34;       // 34
	};
	static_assert(sizeof(NiColorInterpolator) == 0x38);
}


===============================================
File: include/RE/N/NiColorKey.h
===============================================
#pragma once

#include "RE/N/NiAnimationKey.h"
#include "RE/N/NiColor.h"

namespace RE
{
	class NiColorKey : public NiAnimationKey
	{
	public:
		NiColorKey();
		NiColorKey(float a_time, const NiColorA& a_color);
		~NiColorKey();

		void                          SetColor(const NiColorA& a_color);
		[[nodiscard]] const NiColorA& GetColor() const;
		NiColorKey*                   GetKeyAt(std::uint32_t a_index, std::uint8_t a_keySize);

	protected:
		// members
		NiColorA _color;  // 04
	};
	static_assert(sizeof(NiColorKey) == 0x14);
}


===============================================
File: include/RE/N/NiControllerManager.h
===============================================
#pragma once

#include "RE/B/BSAnimNoteListener.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTArray.h"
#include "RE/N/NiTSet.h"
#include "RE/N/NiTimeController.h"

namespace RE
{
	class NiAVObjectPalette;
	class NiControllerSequence;

	class NiControllerManager : public NiTimeController
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiControllerManager;
		inline static auto           Ni_RTTI = NiRTTI_NiControllerManager;

		~NiControllerManager() override;  // 00

		// override (NiTimeController)
		const NiRTTI*        GetRTTI() const override;                            // 02
		NiObject*            CreateClone(NiCloningProcess& a_cloning) override;   // 17
		void                 LoadBinary(NiStream& a_stream) override;             // 18
		void                 LinkObject(NiStream& a_stream) override;             // 19
		bool                 RegisterStreamables(NiStream& a_stream) override;    // 1A
		void                 SaveBinary(NiStream& a_stream) override;             // 1B
		bool                 IsEqual(NiObject* a_object) override;                // 1C
		void                 ProcessClone(NiCloningProcess& a_cloning) override;  // 1D
		void                 PostLinkObject(NiStream& a_stream) override;         // 1E
		NiControllerManager* AsNiControllerManager() override;                    // 24 - { return this; }
		void                 Start(float a_time) override;                        // 25
		void                 Stop() override;                                     // 26
		void                 Update(float a_time) override;                       // 27
		void                 SetTarget(NiObjectNET* a_target) override;           // 28
		[[nodiscard]] bool   TargetIsRequiredType() const override;               // 2E

		// add
		virtual void Start();  // 2F - { return; }

		NiControllerSequence* GetSequenceByName(std::string_view a_name);

		// members
		NiTObjectArray<NiPointer<NiControllerSequence>>  sequenceArray;    // 48
		NiTPrimitiveSet<NiControllerSequence*>           activeSequences;  // 60
		BSTHashMap<BSFixedString, NiControllerSequence*> stringMap;        // 70
		BSAnimNoteListener*                              listener;         // A0
		bool                                             cumulative;       // A8
		std::uint8_t                                     padA9;            // A9
		std::uint16_t                                    padAA;            // AA
		std::uint32_t                                    padAC;            // AC
		NiTObjectSet<NiPointer<NiControllerSequence>>    tempBlendSeqs;    // B0
		NiPointer<NiAVObjectPalette>                     objectPalette;    // C0
	};
	static_assert(sizeof(NiControllerManager) == 0xC8);
}


===============================================
File: include/RE/N/NiControllerSequence.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/M/MemoryManager.h"
#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTimeController.h"

namespace RE
{
	class BSAnimNote;
	class NiAVObject;
	class NiBlendInterpolator;
	class NiControllerManager;
	class NiInterpController;
	class NiInterpolator;
	class NiStringPalette;
	class NiTextKeyExtraData;

	NiSmartPointer(NiControllerSequence);

	class NiControllerSequence : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiControllerSequence;
		inline static auto           Ni_RTTI = NiRTTI_NiControllerSequence;

		enum class AnimState
		{
			kInactive,
			kAnimating,
			kEaseIn,
			kEaseOut,
			kTransSource,
			kTransDest,
			kMorphSource
		};

		struct InterpArrayItem
		{
		public:
			// members
			NiPointer<NiInterpolator>     interpolator;  // 00
			NiPointer<NiInterpController> interpCtlr;    // 08
			NiBlendInterpolator*          blendInterp;   // 10
			std::uint8_t                  blendIdx;      // 18
			std::uint8_t                  pad19;         // 19
			std::uint16_t                 pad1A;         // 1A
			std::uint32_t                 pad1C;         // 1C
		};
		static_assert(sizeof(InterpArrayItem) == 0x20);

		struct IDTag
		{
		public:
			// members
			BSFixedString avObjectName;    // 00
			BSFixedString propertyType;    // 08
			BSFixedString ctlrType;        // 10
			BSFixedString ctlrID;          // 18
			BSFixedString interpolatorID;  // 20
		};
		static_assert(sizeof(IDTag) == 0x28);

		~NiControllerSequence() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                            // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;   // 17
		void          LoadBinary(NiStream& a_stream) override;             // 18
		void          LinkObject(NiStream& a_stream) override;             // 19
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A
		void          SaveBinary(NiStream& a_stream) override;             // 1B
		bool          IsEqual(NiObject* a_object) override;                // 1C
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D
		void          PostLinkObject(NiStream& a_stream) override;         // 1E

		// add
		virtual bool Deactivate(float a_easeOutTime, bool a_transition);  // 25

		bool                         Activate(std::uint8_t a_interpIndex, bool a_maxOffset, float a_seqWeight, float a_easeInTime, NiControllerSequence* a_partnerSequence, bool a_transition);
		[[nodiscard]] constexpr bool Animating() const noexcept { return state == AnimState::kAnimating; }
		[[nodiscard]] constexpr bool Inactive() const noexcept { return state == AnimState::kInactive; }
		void                         SetPhase(float a_phase, bool a_arg2);

		// members
		BSFixedString                                                name;                     // 10
		std::uint32_t                                                arraySize;                // 18
		std::uint32_t                                                arrayGrowBy;              // 1C
		SimpleArray<InterpArrayItem>                                 interpArray;              // 20
		SimpleArray<IDTag>                                           idTagArray;               // 28
		float                                                        seqWeight;                // 30
		std::uint32_t                                                pad34;                    // 30
		NiPointer<NiTextKeyExtraData>                                textKeys;                 // 38
		stl::enumeration<NiTimeController::CycleType, std::uint32_t> cycleType;                // 40
		float                                                        frequency;                // 44
		float                                                        beginKeyTime;             // 48
		float                                                        endKeyTime;               // 4C
		float                                                        lastTime;                 // 50
		float                                                        weightedLastTime;         // 54
		float                                                        lastScaledTime;           // 58
		std::uint32_t                                                pad5C;                    // 5C
		NiControllerManager*                                         owner;                    // 60
		stl::enumeration<AnimState, std::uint32_t>                   state;                    // 68
		float                                                        offset;                   // 6C
		float                                                        startTime;                // 70
		float                                                        endTime;                  // 74
		float                                                        destFrame;                // 78
		std::uint32_t                                                pad7C;                    // 7C
		NiControllerSequence*                                        partnerSequence;          // 80
		BSFixedString                                                accumRootName;            // 88
		NiAVObject*                                                  accumRoot;                // 90
		NiPointer<NiStringPalette>                                   deprecatedStringPalette;  // 98
		std::int16_t                                                 curAnimNIdx;              // A0
		std::uint16_t                                                unkA2;                    // A2
		std::uint32_t                                                unkA4;                    // A4
		SimpleArray<NiPointer<BSAnimNote>>                           animNotes;                // A8
		std::uint16_t                                                numNotes;                 // B0
		bool                                                         removableObjects;         // B2
		std::uint8_t                                                 unkB3;                    // B3
		std::uint32_t                                                unkB4;                    // B4
	};
	static_assert(sizeof(NiControllerSequence) == 0xB8);
}


===============================================
File: include/RE/N/NiCullingProcess.h
===============================================
#pragma once

#include "RE/N/NiFrustum.h"
#include "RE/N/NiFrustumPlanes.h"

namespace RE
{
	class BSDynamicTriShape;
	class BSFadeNode;
	class BSGeometry;
	class bhkAttachmentCollisionObject;
	class bhkBlendCollisionObject;
	class bhkLimitedHingeConstraint;
	class bhkNiCollisionObject;
	class bhkRigidBody;
	class BSLines;
	class BSMultiBoundNode;
	class BSSegmentedTriShape;
	class BSSubIndexTriShape;
	class BSTriShape;
	class NiAVObject;
	class NiCamera;
	class NiGeometry;
	class NiNode;
	class NiParticles;
	class NiSwitchNode;
	class NiRTTI;
	class NiTriBasedGeom;
	class NiTriShape;
	class NiTriStrips;
	class NiVisibleArray;

	class NiCullingProcess
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiCullingProcess;
		inline static auto           Ni_RTTI = NiRTTI_NiCullingProcess;

		// add
		[[nodiscard]] virtual const NiRTTI*   GetRTTI() const;                      // 00
		virtual NiNode*                       GetAsNiNode();                        // 01 - { return 0; }
		virtual NiSwitchNode*                 GetAsNiSwitchNode();                  // 02 - { return 0; }
		virtual BSFadeNode*                   GetAsBSFadeNode();                    // 03 - { return 0; }
		virtual BSMultiBoundNode*             GetAsBSMultiBoundNode();              // 04 - { return 0; }
		virtual BSGeometry*                   GetAsBSGeometry();                    // 05 - { return 0; }
		virtual NiTriStrips*                  GetAsNiTriStrips();                   // 06 - { return 0; }
		virtual BSTriShape*                   GetAsBSTriShape();                    // 07 - { return 0; }
		virtual BSSegmentedTriShape*          GetAsBSSegmentedTriShape();           // 08 - { return 0; }
		virtual BSSubIndexTriShape*           GetAsBSSubIndexTriShape();            // 09 - { return 0; }
		virtual BSDynamicTriShape*            GetAsBSDynamicTriShape();             // 0A - { return 0; }
		virtual NiGeometry*                   GetAsNiGeometry();                    // 0B - { return 0; }
		virtual NiTriBasedGeom*               GetAsNiTriBasedGeom();                // 0C - { return 0; }
		virtual NiTriShape*                   GetAsNiTriShape();                    // 0D - { return 0; }
		virtual NiParticles*                  GetAsNiParticles();                   // 0E - { return 0; }
		virtual BSLines*                      GetAsBSLines();                       // 0F - { return 0; }
		virtual bhkNiCollisionObject*         GetAsBhkNiCollisionObject();          // 10 - { return 0; }
		virtual bhkBlendCollisionObject*      GetAsBhkBlendCollisionObject();       // 11 - { return 0; }
		virtual bhkAttachmentCollisionObject* GetAsBhkAttachmentCollisionObject();  // 12 - { return 0; }
		virtual bhkRigidBody*                 GetAsBhkRigidBody();                  // 13 - { return 0; }
		virtual bhkLimitedHingeConstraint*    GetAsBhkLimitedHingeConstraint();     // 14 - { return 0; }

		virtual ~NiCullingProcess();  // 15

		virtual void Process1(NiAVObject* a_object, std::uint32_t a_arg2);                                   // 16
		virtual void Process2(const NiCamera* a_camera, NiAVObject* a_scene, NiVisibleArray* a_visibleSet);  // 17 - { return; }
		virtual void AppendVirtual(BSGeometry& a_visible, std::uint32_t a_arg2);                             // 18

		// members
		const bool      useVirtualAppend{ false };  // 008
		std::uint8_t    pad009;                     // 009
		std::uint16_t   pad00A;                     // 00A
		std::uint32_t   pad00C;                     // 00C
		NiVisibleArray* visibleSet;                 // 010
		const NiCamera* camera;                     // 018
		NiFrustum       frustum;                    // 020
		NiFrustumPlanes planes;                     // 03C
		NiFrustumPlanes customCullPlanes;           // 0AC
		bool            cameraRelatedUpdates;       // 11C
		bool            updateAccumulateFlag;       // 11D
		bool            ignorePreprocess;           // 11E
		bool            doCustomCullPlanes;         // 11F
		std::uint8_t    unk120;                     // 120
		std::uint8_t    unk121;                     // 121
		std::uint16_t   pad122;                     // 122
		std::uint32_t   pad124;                     // 124
	};
	static_assert(sizeof(NiCullingProcess) == 0x128);
}


===============================================
File: include/RE/N/NiExtraData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class NiExtraData : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiExtraData;

		~NiExtraData() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19 - { return; }
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C

		// add
		[[nodiscard]] virtual bool IsStreamable() const;  // 25 - { return true; }
		[[nodiscard]] virtual bool IsCloneable() const;   // 26 - { return true; }

		static NiExtraData* Create(std::size_t a_size, std::uintptr_t a_vtbl);
		template <class T>
		static T* Create();

		[[nodiscard]] const BSFixedString& GetName() const;
		void                               SetName(const BSFixedString& a_name);

		// members
		BSFixedString name;  // 10
	};
	static_assert(sizeof(NiExtraData) == 0x18);

	template <class T>
	T* NiExtraData::Create()
	{
		return static_cast<T*>(Create(sizeof(T), T::VTABLE[0].address()));
	}
}


===============================================
File: include/RE/N/NiFile.h
===============================================
#pragma once

#include "RE/N/NiBinaryStream.h"

namespace RE
{
	class NiFile : public NiBinaryStream
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiFile;

		enum class OpenMode
		{
			kReadOnly = 0,
			kWriteOnly = 1,
			kAppendOnly = 2
		};

		~NiFile() override;  // 00

		// override (NiBinaryStream)
		bool good() const override;                    // 01 - { return isGood; }
		void seek(std::int32_t a_numBytes) override;   // 02
		void get_info(BufferInfo& a_buf) override;     // 04
		void set_endian_swap(bool a_doSwap) override;  // 05

		// add
		virtual void                        seek(std::int32_t a_offset, std::int32_t a_from);  // 06
		[[nodiscard]] virtual std::uint32_t size() const;                                      // 07

		// members
		std::uint32_t                             bufferAllocSize;  // 20
		std::uint32_t                             bufferReadSize;   // 24
		std::uint32_t                             pos;              // 28
		std::uint32_t                             pad2C;            // 2C
		char*                                     buffer;           // 30
		std::FILE*                                file;             // 38
		stl::enumeration<OpenMode, std::uint32_t> mode;             // 40
		bool                                      isGood;           // 44
		std::uint8_t                              pad45;            // 45
		std::uint16_t                             pad46;            // 46
	};
	static_assert(sizeof(NiFile) == 0x48);
}


===============================================
File: include/RE/N/NiFloatData.h
===============================================
#pragma once

#include "RE/N/NiFloatKey.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class NiFloatData : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiFloatData;
		inline static auto           Ni_RTTI = NiRTTI_NiFloatData;

		using KeyType = NiFloatKey::KeyType;

		NiFloatData();
		~NiFloatData() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                 // 02
		void          LoadBinary(NiStream& a_stream) override;  // 18
		void          SaveBinary(NiStream& a_stream) override;  // 1B
		bool          IsEqual(NiObject* a_object) override;     // 1C

		[[nodiscard]] std::uint32_t GetNumKeys() const;
		NiFloatKey*                 GetAnim(std::uint32_t& a_numKeys, KeyType& a_type, std::uint8_t& a_size) const;

		// members
		std::uint32_t numKeys;  // 10
		std::uint32_t pad14;    // 14
		NiFloatKey*   keys;     // 18
		KeyType       type;     // 20
		std::uint8_t  keySize;  // 24
		std::uint8_t  pad25;    // 25
		std::uint16_t pad26;    // 26
	};
	static_assert(sizeof(NiFloatData) == 0x28);
}


===============================================
File: include/RE/N/NiFloatExtraData.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"

namespace RE
{
	class NiFloatExtraData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiFloatExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiFloatExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiFloatExtraData;

		~NiFloatExtraData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		static NiFloatExtraData* Create(const BSFixedString& a_name, float a_value);

		// members
		float value;  // 18
	};
	static_assert(sizeof(NiFloatExtraData) == 0x20);
}


===============================================
File: include/RE/N/NiFloatInterpolator.h
===============================================
#pragma once

#include "RE/N/NiKeyBasedInterpolator.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiFloatData;

	class NiFloatInterpolator : public NiKeyBasedInterpolator
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiFloatInterpolator;
		inline static auto           Ni_RTTI = NiRTTI_NiFloatInterpolator;

		~NiFloatInterpolator() override;  // 00

		// override (NiKeyBasedInterpolator)
		const NiRTTI*      GetRTTI() const override;                                                               // 02
		NiObject*          CreateClone(NiCloningProcess& a_cloning) override;                                      // 17
		void               LoadBinary(NiStream& a_stream) override;                                                // 18
		void               LinkObject(NiStream& a_stream) override;                                                // 19 - { NiKeyBasedInterpolator::LinkObject(a_stream); }
		bool               RegisterStreamables(NiStream& a_stream) override;                                       // 1A
		void               SaveBinary(NiStream& a_stream) override;                                                // 1B
		bool               IsEqual(NiObject* a_object) override;                                                   // 1C
		bool               Update1(float a_time, NiObjectNET* a_interpTarget, NiQuatTransform& a_value) override;  // 25 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update2(float a_time, NiObjectNET* a_target, NiColorA& a_value) override;               // 26 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update3(float a_time, NiObjectNET* a_interpTarget, NiPoint3& a_value) override;         // 27 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update4(float a_time, NiObjectNET* a_interpTarget, NiQuaternion& a_value) override;     // 28 - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               Update5(float a_time, NiObjectNET* a_interpTarget, float& a_value) override;            // 29
		bool               Update6(float a_time, NiObjectNET* a_interpTarget, bool& a_value) override;             // 2A - { return NiInterpolator::UpdateTransform(a_time, a_interpTarget, a_value); }
		bool               IsFloatValueSupported() const override;                                                 // 2C - { return true; }
		void               Collapse() override;                                                                    // 31
		void               GuaranteeTimeRange(float a_start, float a_end) override;                                // 33
		NiInterpolator*    GetSequenceInterpolator(float a_start, float a_end) override;                           // 34
		std::uint16_t      GetKeyChannelCount() const override;                                                    // 39 - { return 1; }
		std::uint32_t      GetKeyCount(std::uint16_t a_channel) const override;                                    // 3A - { return floatData ? floatData->numKeys : 0; }
		KeyContent         GetKeyContent(std::uint16_t a_channel) const override;                                  // 3B - { KeyContent::kFloat; }
		KeyType            GetKeyType(std::uint16_t a_channel) const override;                                     // 3C - { return floatData ? floatData->type : 0; }
		void*              GetKeyArray(std::uint16_t a_channel) const override;                                    // 3D - { return floatData ? floatData->keys : 0; }
		std::uint8_t       GetKeyStride(std::uint16_t a_channel) const override;                                   // 3E - { return floatData ? floatData->keySize : 0; }
		[[nodiscard]] bool GetChannelPosed(std::uint16_t a_channel) const override;                                // 3F - { return !floatData && floatValue != -3.4028235e38; }

		// members
		float                  floatValue;  // 18
		std::uint32_t          pad1C;       // 1C
		NiPointer<NiFloatData> floatData;   // 20
		std::uint32_t          lastIndex;   // 28
		std::uint32_t          pad2C;       // 2C
	};
	static_assert(sizeof(NiFloatInterpolator) == 0x30);
}


===============================================
File: include/RE/N/NiFloatKey.h
===============================================
#pragma once

#include "RE/N/NiAnimationKey.h"

namespace RE
{
	class NiFloatKey : public NiAnimationKey
	{
	public:
		NiFloatKey();
		NiFloatKey(float a_time, float a_value);
		~NiFloatKey();

		[[nodiscard]] float GetValue() const;
		void                SetValue(float a_value);
		NiFloatKey*         GetKeyAt(std::uint32_t a_index, std::uint8_t a_keySize);

	protected:
		float _value;  // 04
	};
	static_assert(sizeof(NiFloatKey) == 0x8);
}


===============================================
File: include/RE/N/NiFloatsExtraData.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"

namespace RE
{
	class NiFloatsExtraData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiFloatsExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiFloatsExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiFloatsExtraData;

		~NiFloatsExtraData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		static NiFloatsExtraData* Create(const BSFixedString& a_name, const std::vector<float>& a_Floats);

		[[nodiscard]] std::optional<std::uint32_t> GetIndex(float a_element) const;
		bool                                       Insert(float a_element);
		bool                                       Remove(float a_element);

		// members
		std::uint32_t size;   // 18
		std::uint32_t pad;    // 1C
		float*        value;  // 20
	};
	static_assert(sizeof(NiFloatsExtraData) == 0x28);
}


===============================================
File: include/RE/N/NiFrustum.h
===============================================
#pragma once

namespace RE
{
	class NiFrustum
	{
	public:
		// members
		float fLeft;    // 00
		float fRight;   // 04
		float fTop;     // 08
		float fBottom;  // 0C
		float fNear;    // 10
		float fFar;     // 14
		bool  bOrtho;   // 18
	};
	static_assert(sizeof(NiFrustum) == 0x1C);
}


===============================================
File: include/RE/N/NiFrustumPlanes.h
===============================================
#pragma once

#include "RE/N/NiPlane.h"

namespace RE
{
	class NiFrustumPlanes
	{
	public:
		struct Planes
		{
			enum Plane
			{
				kNear,
				kFar,
				kLeft,
				kRight,
				kTop,
				kBottom,

				kTotal
			};
		};

		enum class ActivePlane
		{
			kNear = 1 << 0,
			kFar = 1 << 1,
			kLeft = 1 << 2,
			kRight = 1 << 3,
			kTop = 1 << 4,
			kBottom = 1 << 5
		};

		// members
		NiPlane                                      cullingPlanes[Planes::kTotal];  // 00
		stl::enumeration<ActivePlane, std::uint32_t> activePlanes;                   // 60
		std::uint32_t                                basePlaneStates;                // 64
		std::uint32_t                                unk68;                          // 68
		std::uint32_t                                unk6C;                          // 6C
	};
	static_assert(sizeof(NiFrustumPlanes) == 0x70);
}


===============================================
File: include/RE/N/NiGeometry.h
===============================================
#pragma once

#include "RE/N/NiAVObject.h"
#include "RE/N/NiGeometryData.h"
#include "RE/N/NiProperty.h"
#include "RE/N/NiSkinInstance.h"

namespace RE
{
	class NiGeometry : public NiAVObject
	{
	public:
		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                               \
	NiPointer<NiProperty>     m_spPropertyState; /* 110 */ \
	NiPointer<NiProperty>     m_spEffectState;   /* 118 */ \
	NiPointer<NiSkinInstance> m_spSkinInstance;  /* 120 */ \
	NiPointer<NiGeometryData> m_spModelData;     /* 128 */ \
	std::uint64_t             unk130;            /* 130 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x28);

		// add
		SKYRIM_REL_VR_VIRTUAL void  Unk_35(void);                           // 35, 36 - call controller vtbl+0xA0?
		SKYRIM_REL_VR_VIRTUAL void  Unk_36(void);                           // 36, 37 - ret 0
		SKYRIM_REL_VR_VIRTUAL void  Unk_37(void);                           // 37, 38 - same as Unk_33
		SKYRIM_REL_VR_VIRTUAL void* Unk_38(void);                           // 38, 39 - ret call m_spModelData vtbl+0x9C
		SKYRIM_REL_VR_VIRTUAL void  SetGeometryData(NiGeometryData* unk1);  // 39, 3A - set and AddRef geometry data
		SKYRIM_REL_VR_VIRTUAL void* Unk_3A(void);                           // 3A, 3B - ret call m_spModelData vtbl+0x94
		SKYRIM_REL_VR_VIRTUAL std::uint16_t Unk_3B(bool unk1);              // 3B, 3C ??

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x110, 0x138);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x110, 0x138);
		}

		RUNTIME_DATA_CONTENT  // 110, 138
	};
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(NiGeometry) == 0x160);
#else
	static_assert(sizeof(NiGeometry) == 0x138);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/N/NiGeometryData.h
===============================================
#pragma once

#include "RE/N/NiBound.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class NiAdditionalGeometryData;
	class NiColorA;
	class NiPoint2;
	class NiPoint3;
	class NiTriShapeData;
	class NiTriStripsData;

	class NiGeometryData : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiGeometryData;
		inline static auto           Ni_RTTI = NiRTTI_NiGeometryData;

		enum class DataFlag
		{
			kNone = 0x0000,
			kNDL = 1 << 12,
			kMax = 1 << 13,
			kATI = kNDL | kMax,
		};

		enum class DirtyFlag
		{
			kVertex = 1 << 0,
			kNormal = 1 << 1,
			kColor = 1 << 2,
			kTexture = 1 << 3,

			kMutable = 0,
			kStatic = 1 << 14,
			kVolatile = 1 << 15
		};

		enum class KeepFlag
		{
			kXYZ = 1 << 0,
			kNorm = 1 << 1,
			kColor = 1 << 2,
			kUV = 1 << 3,
			kIndices = 1 << 4,
			kBonedata = 1 << 5,

			kAll = kXYZ | kNorm | kColor | kUV | kIndices | kBonedata
		};

		enum class CompressFlag
		{
			kNorm = 1 << 0,
			kColor = 1 << 1,
			kUV = 1 << 2,
			kWeight = 1 << 3,
			kPosition = 1 << 4,

			kAll = kNorm | kColor | kUV | kWeight | kPosition
		};

		~NiGeometryData() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C

		// add
		virtual void                        SetActiveVertexCount(std::uint16_t a_count);  // 25 - { return; }
		[[nodiscard]] virtual std::uint16_t GetActiveVertexCount() const;                 // 26 - { return vertices; }
		virtual NiTriStripsData*            AsTriStripsData();                            // 27 - { return 0; }
		virtual NiTriShapeData*             AsTriShapeData();                             // 28 - { return 0; }
		virtual void                        Unk_29(void) = 0;                             // 29

		// members
		std::uint16_t                                vertices;            // 10
		std::uint16_t                                id;                  // 12
		stl::enumeration<DirtyFlag, std::uint16_t>   dirtyFlags;          // 14
		stl::enumeration<DataFlag, std::uint16_t>    dataFlags;           // 16
		NiBound                                      bound;               // 18
		NiPoint3*                                    vertex;              // 28
		NiPoint3*                                    normal;              // 30
		NiColorA*                                    color;               // 38
		NiPoint2*                                    texture;             // 40
		std::uint32_t                                unk48;               // 48
		std::uint32_t                                unk4C;               // 4C
		std::uint32_t                                unk50;               // 50
		std::uint32_t                                unk54;               // 54
		NiPointer<NiAdditionalGeometryData>          additionalGeomData;  // 58
		stl::enumeration<KeepFlag, std::uint8_t>     keepFlags;           // 60
		stl::enumeration<CompressFlag, std::uint8_t> compressFlags;       // 61
		std::uint8_t                                 unk62;               // 62
		std::uint8_t                                 unk63;               // 63
		std::uint8_t                                 unk64;               // 64
		std::uint8_t                                 unk65;               // 65
		bool                                         hasGeoData;          // 66
		std::uint8_t                                 unk67;               // 67
	};
	static_assert(sizeof(NiGeometryData) == 0x68);
}


===============================================
File: include/RE/N/NiIntegerExtraData.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"

namespace RE
{
	class NiIntegerExtraData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiIntegerExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiIntegerExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiIntegerExtraData;

		~NiIntegerExtraData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C - { return object ? value == a_object->value : false; }

		static NiIntegerExtraData* Create(const BSFixedString& a_name, std::int32_t a_value);

		// members
		std::int32_t  value;  // 18
		std::uint32_t pad1C;  // 1C
	};
	static_assert(sizeof(NiIntegerExtraData) == 0x20);
}


===============================================
File: include/RE/N/NiIntegersExtraData.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"

namespace RE
{
	class NiIntegersExtraData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiIntegersExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiIntegersExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiIntegersExtraData;

		~NiIntegersExtraData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		static NiIntegersExtraData* Create(const BSFixedString& a_name, const std::vector<std::int32_t>& a_integers);

		[[nodiscard]] std::optional<std::uint32_t> GetIndex(std::int32_t a_element) const;
		bool                                       Insert(std::int32_t a_element);
		bool                                       Remove(std::int32_t a_element);

		// members
		std::uint32_t size;   // 18
		std::uint32_t pad;    // 1C
		std::int32_t* value;  // 20
	};
	static_assert(sizeof(NiIntegersExtraData) == 0x28);
}


===============================================
File: include/RE/N/NiInterpController.h
===============================================
#pragma once

#include "RE/N/NiTimeController.h"

namespace RE
{
	class NiBlendInterpolator;
	class NiInterpolator;

	class NiInterpController : public NiTimeController
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiInterpController;
		inline static auto           Ni_RTTI = NiRTTI_NiInterpController;

		~NiInterpController() override;  // 00

		// override (NiTimeController)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18 - { NiTimeController::LoadBinary(a_stream); }
		void          LinkObject(NiStream& a_stream) override;           // 19 - { NiTimeController::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A - { return NiTimeController::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;           // 1B - { NiTimeController::SaveBinary(a_stream); }
		bool          IsEqual(NiObject* a_object) override;              // 1C - { NiTimeController::IsEqual(a_object); }

		// add
		[[nodiscard]] virtual std::uint16_t        GetInterpolatorCount() const = 0;                                                                                                                                                                  // 2F
		virtual const char*                        GetInterpolatorID(std::uint16_t a_index = 0) = 0;                                                                                                                                                  // 30
		virtual std::uint16_t                      GetInterpolatorIndex(const char* a_id) const = 0;                                                                                                                                                  // 31
		[[nodiscard]] virtual std::uint16_t        GetInterpolatorIndexFx(const BSFixedString& a_id) const = 0;                                                                                                                                       // 32
		[[nodiscard]] virtual NiInterpolator*      GetInterpolator(std::uint16_t a_index = 0) const = 0;                                                                                                                                              // 33
		virtual void                               SetInterpolator(NiInterpolator* a_interpolator, std::uint16_t a_index = 0) = 0;                                                                                                                    // 34
		virtual void                               ResetTimeExtrema();                                                                                                                                                                                // 35
		virtual const char*                        GetCtlrID();                                                                                                                                                                                       // 36 - { return 0; }
		virtual NiInterpolator*                    CreatePoseInterpolator(std::uint16_t a_index) = 0;                                                                                                                                                 // 37
		virtual void                               SynchronizePoseInterpolator(NiInterpolator* a_interp, std::uint16_t a_index = 0) = 0;                                                                                                              // 38
		[[nodiscard]] virtual NiBlendInterpolator* CreateBlendInterpolator(std::uint16_t a_index = 0, bool a_managerControlled = false, bool a_accumulateAnimations = false, float a_weightThreshold = 0.0, std::uint8_t a_arraySize = 2) const = 0;  // 39
		virtual void                               GuaranteeTimeRange(float a_startTime, float a_endTime) = 0;                                                                                                                                        // 3A
		virtual bool                               InterpolatorIsCorrectType(NiInterpolator* a_interpolator, std::uint16_t a_index) const = 0;                                                                                                        // 3B
	};
	static_assert(sizeof(NiInterpController) == 0x48);
}


===============================================
File: include/RE/N/NiInterpolator.h
===============================================
#pragma once

#include "RE/N/NiObject.h"

namespace RE
{
	class NiAVObjectPalette;
	class NiBoolInterpolator;
	class NiColorA;
	class NiObjectNET;
	class NiPoint3;
	class NiQuaternion;
	class NiQuatTransform;

	class NiInterpolator : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiInterpolator;
		inline static auto           Ni_RTTI = NiRTTI_NiInterpolator;

		~NiInterpolator() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18 - { NiObject::LoadBinary(a_stream); }
		void          LinkObject(NiStream& a_stream) override;           // 19 - { NiObject::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A - { return NiObject::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;           // 1B - { NiObject::SaveBinary(a_stream); }
		bool          IsEqual(NiObject* a_object) override;              // 1C - { return NiObject::IsEqual(a_stream); }

		// add
		virtual bool                Update1(float a_time, NiObjectNET* a_interpTarget, NiQuatTransform& a_value);  // 25 - { return false; }
		virtual bool                Update2(float a_time, NiObjectNET* a_interpTarget, NiColorA& a_value);         // 26 - { return false; }
		virtual bool                Update3(float a_time, NiObjectNET* a_interpTarget, NiPoint3& a_value);         // 27 - { return false; }
		virtual bool                Update4(float a_time, NiObjectNET* a_interpTarget, NiQuaternion& a_value);     // 28 - { return false; }
		virtual bool                Update5(float a_time, NiObjectNET* a_interpTarget, float& a_value);            // 29 - { return false; }
		virtual bool                Update6(float a_time, NiObjectNET* a_interpTarget, bool& a_value);             // 2A - { return false; }
		[[nodiscard]] virtual bool  IsBoolValueSupported() const;                                                  // 2B - { return false; }
		[[nodiscard]] virtual bool  IsFloatValueSupported() const;                                                 // 2C - { return false; }
		[[nodiscard]] virtual bool  IsQuaternionValueSupported() const;                                            // 2D - { return false; }
		[[nodiscard]] virtual bool  IsPoint3ValueSupported() const;                                                // 2E - { return false; }
		[[nodiscard]] virtual bool  IsColorAValueSupported() const;                                                // 2F - { return false; }
		[[nodiscard]] virtual bool  IsTransformValueSupported() const;                                             // 30 - { return false; }
		virtual void                Collapse();                                                                    // 31 - { return; }
		virtual void                GetActiveTimeRange(float& a_beginKeyTime, float& a_endKeyTime) const;          // 32 - { a_beginKeyTime = 0.0; a_endKeyTime = 0.0; }
		virtual void                GuaranteeTimeRange(float a_startTime, float a_endTime);                        // 33 - { return; }
		virtual NiInterpolator*     GetSequenceInterpolator(float a_startTime, float a_endTime);                   // 34
		virtual bool                ResolveDependencies(NiAVObjectPalette* a_palette);                             // 35 - { return true; }
		virtual bool                SetUpDependencies();                                                           // 36 - { return true; }
		[[nodiscard]] virtual bool  AlwaysUpdate() const;                                                          // 37 - { return false; }
		virtual NiBoolInterpolator* AsNiBoolInterpolator();                                                        // 38 - { return 0; }

		bool Update(float a_time, NiObjectNET* a_interpTarget, NiQuatTransform& a_value);
		bool Update(float a_time, NiObjectNET* a_interpTarget, NiColorA& a_value);
		bool Update(float a_time, NiObjectNET* a_interpTarget, NiPoint3& a_value);
		bool Update(float a_time, NiObjectNET* a_interpTarget, NiQuaternion& a_value);
		bool Update(float a_time, NiObjectNET* a_interpTarget, float& a_value);
		bool Update(float a_time, NiObjectNET* a_interpTarget, bool& a_value);

		// members
		float         lastTime;  // 10
		std::uint32_t pad14;     // 14
	};
	static_assert(sizeof(NiInterpolator) == 0x18);
}


===============================================
File: include/RE/N/NiKeyBasedInterpolator.h
===============================================
#pragma once

#include "RE/N/NiAnimationKey.h"
#include "RE/N/NiInterpolator.h"

namespace RE
{
	class NiKeyBasedInterpolator : public NiInterpolator
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiKeyBasedInterpolator;
		inline static auto           Ni_RTTI = NiRTTI_NiKeyBasedInterpolator;

		using KeyType = NiAnimationKey::KeyType;
		using KeyContent = NiAnimationKey::KeyContent;

		~NiKeyBasedInterpolator() override;  // 00

		// override (NiInterpolator)
		const NiRTTI* GetRTTI() const override;                                         // 02
		void          LoadBinary(NiStream& a_stream) override;                          // 18 - { NiInterpolator::LoadBinary(a_stream); }
		void          LinkObject(NiStream& a_stream) override;                          // 19 - { NiInterpolator::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;                 // 1A - { return NiInterpolator::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;                          // 1B - { NiInterpolator::SaveBinary(a_stream); }
		bool          IsEqual(NiObject* a_object) override;                             // 1C - { return NiInterpolator::IsEqual(a_stream); }
		void          GetActiveTimeRange(float& a_start, float& a_end) const override;  // 32

		// add
		[[nodiscard]] virtual std::uint16_t GetKeyChannelCount() const = 0;                      // 39
		[[nodiscard]] virtual std::uint32_t GetKeyCount(std::uint16_t a_channel) const = 0;      // 3A
		[[nodiscard]] virtual KeyType       GetKeyType(std::uint16_t a_channel) const = 0;       // 3C
		[[nodiscard]] virtual KeyContent    GetKeyContent(std::uint16_t a_channel) const = 0;    // 3B
		[[nodiscard]] virtual void*         GetKeyArray(std::uint16_t a_channel) const = 0;      // 3D
		[[nodiscard]] virtual std::uint8_t  GetKeyStride(std::uint16_t a_channel) const = 0;     // 3E
		[[nodiscard]] virtual bool          GetChannelPosed(std::uint16_t a_channel) const = 0;  // 3F
	};
	static_assert(sizeof(NiKeyBasedInterpolator) == 0x18);
}


===============================================
File: include/RE/N/NiLight.h
===============================================
#pragma once

#include "RE/N/NiAVObject.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiLight : public NiAVObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiLight;
		inline static auto           Ni_RTTI = NiRTTI_NiLight;

		struct LIGHT_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT         \
	NiColor       ambient; /* 00 */  \
	NiColor       diffuse; /* 0C */  \
	NiPoint3      radius;  /* 018 */ \
	float         fade;    /* 024 */ \
	std::uint32_t unk138;  /* 028 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(LIGHT_RUNTIME_DATA) == 0x2C);

		~NiLight() override;  // 00

		// override (NiAVObject)
		const NiRTTI* GetRTTI() const override;                 // 02
		void          LoadBinary(NiStream& a_stream) override;  // 18
		void          SaveBinary(NiStream& a_stream) override;  // 1B
		bool          IsEqual(NiObject* a_object) override;     // 1C

		[[nodiscard]] inline LIGHT_RUNTIME_DATA& GetLightRuntimeData() noexcept
		{
			return REL::RelocateMember<LIGHT_RUNTIME_DATA>(this, 0x110, 0x138);
		}

		[[nodiscard]] inline const LIGHT_RUNTIME_DATA& GetLightRuntimeData() const noexcept
		{
			return REL::RelocateMember<LIGHT_RUNTIME_DATA>(this, 0x110, 0x138);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 110, 138
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(NiLight) == 0x140);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(NiLight) == 0x168);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/N/NiMath.h
===============================================
#pragma once

namespace RE
{
	constexpr float NI_INFINITY = FLT_MAX;
	constexpr float NI_PI = static_cast<float>(3.1415926535897932);
	constexpr float NI_HALF_PI = 0.5F * NI_PI;
	constexpr float NI_TWO_PI = 2.0F * NI_PI;

	inline float deg_to_rad(float a_degrees)
	{
		return a_degrees * (NI_PI / 180.0f);
	}

	inline float rad_to_deg(float a_radians)
	{
		return a_radians * (180.0f / NI_PI);
	}

	inline float normalize_angle(float a_radians)
	{
		float a = std::fmodf(a_radians + NI_PI, 2 * NI_PI);
		return a >= 0.0f ? (a - NI_PI) : (a + NI_PI);
	}

	float NiAbs(float a_value);
	float NiASin(float a_value);
	float NiFastATan2(float a_y, float a_x);
}


===============================================
File: include/RE/N/NiMatrix3.h
===============================================
#pragma once

namespace RE
{
	class NiPoint3;

	class NiMatrix3
	{
	public:
		constexpr NiMatrix3() noexcept
		{
			entry[0][0] = 1.0f;
			entry[0][1] = 0.0f;
			entry[0][2] = 0.0f;
			entry[1][0] = 0.0f;
			entry[1][1] = 1.0f;
			entry[1][2] = 0.0f;
			entry[2][0] = 0.0f;
			entry[2][1] = 0.0f;
			entry[2][2] = 1.0f;
		}

		NiMatrix3(const NiPoint3& a_point);
		NiMatrix3(float a_x, float a_y, float a_z);
		NiMatrix3(const NiPoint3& a_x, const NiPoint3& a_y, const NiPoint3& a_z);

		bool      ToEulerAnglesXYZ(NiPoint3& a_angle) const;
		bool      ToEulerAnglesXYZ(float& a_xAngle, float& a_yAngle, float& a_zAngle) const;
		void      EulerAnglesToAxesZXY(const NiPoint3& a_angle);
		void      EulerAnglesToAxesZXY(float a_xAngle, float a_yAngle, float a_zAngle);
		void      SetEulerAnglesXYZ(const NiPoint3& a_point);
		void      SetEulerAnglesXYZ(float a_x, float a_y, float a_z);
		NiMatrix3 Transpose() const;

		bool      operator==(const NiMatrix3& a_rhs) const;
		bool      operator!=(const NiMatrix3& a_rhs) const;
		NiMatrix3 operator*(const NiMatrix3& a_rhs) const;
		NiPoint3  operator*(const NiPoint3& a_point) const;
		NiMatrix3 operator*(float a_scalar) const;

		// members
		float entry[3][3];  // 00
	};
	static_assert(sizeof(NiMatrix3) == 0x24);
}


===============================================
File: include/RE/N/NiMemManager.h
===============================================
#pragma once

#include "RE/N/NiAllocator.h"

namespace RE
{
	class NiMemManager
	{
	public:
		static NiMemManager* GetSingleton();

		void* Allocate(std::size_t a_sizeInBytes, std::size_t a_alignment, NiMemEventType a_eventType, bool a_provideAccurateSizeOnDeallocate = false, const char* a_sourceFile = nullptr, std::int32_t a_sourceLine = -1, const char* a_function = nullptr);
		void  Deallocate(void* a_mem, NiMemEventType a_eventType, std::size_t a_sizeinBytes = static_cast<std::size_t>(-1));
		void* Reallocate(void* a_mem, std::size_t a_sizeInBytes, std::size_t a_alignment, NiMemEventType a_eventType, bool a_provideAccurateSizeOnDeallocate = false, std::size_t a_sizeCurrent = static_cast<std::size_t>(-1), const char* a_sourceFile = nullptr, std::int32_t a_sourceLine = -1, const char* a_function = nullptr);
		bool  TrackAllocate(const void* const a_mem, std::size_t a_sizeInBytes, NiMemEventType a_eventType, const char* a_sourceFile = nullptr, std::int32_t a_sourceLine = -1, const char* a_function = nullptr);
		bool  TrackDeallocate(const void* const a_mem, NiMemEventType a_eventType);

		// members
		NiAllocator* allocator;  // 00
	};
	static_assert(sizeof(NiMemManager) == 0x8);
}


===============================================
File: include/RE/N/NiMeshParticleSystem.h
===============================================
#pragma once

#include "RE/N/NiParticleSystem.h"

namespace RE
{
	class NiMeshParticleSystem : public NiParticleSystem
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiMeshParticleSystem;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiMeshParticleSystem;
		inline static constexpr auto VTABLE = VTABLE_NiMeshParticleSystem;

		~NiMeshParticleSystem() override;  // 00

		// override (NiParticles)
		const NiRTTI* GetRTTI() const override;                                                                                    // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;                                                           // 17
		void          LoadBinary(NiStream& a_stream) override;                                                                     // 18
		void          LinkObject(NiStream& a_stream) override;                                                                     // 19 - { BSGeometry::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;                                                            // 1A - { return BSGeometry::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;                                                                     // 1B
		bool          IsEqual(NiObject* a_object) override;                                                                        // 1C - { return BSGeometry::IsEqual(); }
#ifndef SKYRIM_CROSS_VR
		void          SetSelectiveUpdateFlags(bool& a_selectiveUpdate, bool a_selectiveUpdateTransforms, bool& a_rigid) override;  // 2B
		void          UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                                     // 2C
		void          UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                             // 2D
		void          UpdateRigidDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                                // 2E
		void          UpdateWorldBound() override;                                                                                 // 2F
		void          UpdateWorldData(NiUpdateData* a_data) override;                                                              // 30
		void          OnVisible(NiCullingProcess& a_process) override;                                                             // 34
#endif

		struct MESH_PARTICLE_SYSTEM_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                      \
	float         time;               /* 198 */ \
			bool          updateControllers;  /* 19C */ \
			std::uint8_t  pad19D;             /* 19D */ \
			std::uint16_t pad19E;             /* 19E */
		};

		[[nodiscard]] inline MESH_PARTICLE_SYSTEM_RUNTIME_DATA& GetMeshParticleSystemRuntimeData() noexcept
		{
			return REL::RelocateMember<MESH_PARTICLE_SYSTEM_RUNTIME_DATA>(this, 0x198, 0x1C0);
		}

		[[nodiscard]] inline const MESH_PARTICLE_SYSTEM_RUNTIME_DATA& GetMeshParticleSystemRuntimeData() const noexcept
		{
			return REL::RelocateMember<MESH_PARTICLE_SYSTEM_RUNTIME_DATA>(this, 0x198, 0x1C0);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 198, 1C0
#endif
	};
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/N/NiMultiTargetTransformController.h
===============================================
#pragma once

#include "RE/N/NiInterpController.h"

namespace RE
{
	class NiAVObject;
	class NiBlendTransformInterpolator;

	class NiMultiTargetTransformController : public NiInterpController
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiMultiTargetTransformController;
		inline static auto           Ni_RTTI = NiRTTI_NiMultiTargetTransformController;

		~NiMultiTargetTransformController() override;  // 00

		// override (NiInterpController)
		const NiRTTI*        GetRTTI() const override;                                                                                                                                                                               // 02
		NiObject*            CreateClone(NiCloningProcess& a_cloning) override;                                                                                                                                                      // 17
		void                 LoadBinary(NiStream& a_stream) override;                                                                                                                                                                // 18
		void                 LinkObject(NiStream& a_stream) override;                                                                                                                                                                // 19
		bool                 RegisterStreamables(NiStream& a_stream) override;                                                                                                                                                       // 1A
		void                 SaveBinary(NiStream& a_stream) override;                                                                                                                                                                // 1B
		bool                 IsEqual(NiObject* a_object) override;                                                                                                                                                                   // 1C
		void                 ProcessClone(NiCloningProcess& a_cloning) override;                                                                                                                                                     // 1D
		void                 Update(float a_time) override;                                                                                                                                                                          // 27
		bool                 TargetIsRequiredType() const override;                                                                                                                                                                  // 2E
		std::uint16_t        GetInterpolatorCount() const override;                                                                                                                                                                  // 2F - { return numInterps; }
		const char*          GetInterpolatorID(std::uint16_t a_index = 0) override;                                                                                                                                                  // 30 - { return targets[a_index]->name.c_str(); }
		std::uint16_t        GetInterpolatorIndex(const char* a_id) const override;                                                                                                                                                  // 31
		std::uint16_t        GetInterpolatorIndexFx(const BSFixedString& a_id) const override;                                                                                                                                       // 32
		NiInterpolator*      GetInterpolator(std::uint16_t a_index = 0) const override;                                                                                                                                              // 33
		void                 SetInterpolator(NiInterpolator* a_interpolator, std::uint16_t a_index = 0) override;                                                                                                                    // 34 - { return; }
		void                 ResetTimeExtrema() override;                                                                                                                                                                            // 35
		NiInterpolator*      CreatePoseInterpolator(std::uint16_t a_index) override;                                                                                                                                                 // 37
		void                 SynchronizePoseInterpolator(NiInterpolator* a_interp, std::uint16_t a_index = 0) override;                                                                                                              // 38 - { return; }
		NiBlendInterpolator* CreateBlendInterpolator(std::uint16_t a_index = 0, bool a_managerControlled = false, bool a_accumulateAnimations = false, float a_weightThreshold = 0.0, std::uint8_t a_arraySize = 2) const override;  // 39
		void                 GuaranteeTimeRange(float a_startTime, float a_endTime) override;                                                                                                                                        // 3A
		bool                 InterpolatorIsCorrectType(NiInterpolator* a_interpolator, std::uint16_t a_index) const override;                                                                                                        // 3B

		// members
		NiBlendTransformInterpolator* blendInterps;  // 48
		NiAVObject**                  targets;       // 50
		std::uint16_t                 numInterps;    // 58
		std::uint16_t                 pad5A;         // 58
		std::uint32_t                 pad5C;         // 5C
	};
	static_assert(sizeof(NiMultiTargetTransformController) == 0x60);
}


===============================================
File: include/RE/N/NiNode.h
===============================================
#pragma once

#include "RE/N/NiAVObject.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTArray.h"

namespace RE
{
	class NiUpdateData;

	class NiNode : public NiAVObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiNode;
		inline static auto           Ni_RTTI = NiRTTI_NiNode;

		~NiNode() override;  // 00

		// override (NiAVObject)
		const NiRTTI* GetRTTI() const override;                            // 02
		NiNode*       AsNode() override;                                   // 03 - { return this; }
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;   // 17
		void          LoadBinary(NiStream& a_stream) override;             // 18
		void          LinkObject(NiStream& a_stream) override;             // 19
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A
		void          SaveBinary(NiStream& a_stream) override;             // 1B
		bool          IsEqual(NiObject* a_object) override;                // 1C
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D
		void          UpdateControllers(NiUpdateData& a_data) override;    // 25
#ifndef SKYRIM_CROSS_VR
		// The following are virtual functions past the point where VR compatibility breaks.
		void        PerformOp(PerformOpFunc& a_func) override;                                                                   // 26
		void        AttachProperty(NiAlphaProperty* a_property) override;                                                        // 27
		NiAVObject* GetObjectByName(const BSFixedString& a_name) override;                                                       // 2A
		void        SetSelectiveUpdateFlags(bool& a_selectiveUpdate, bool a_selectiveUpdateTransforms, bool& a_rigid) override;  // 2B
		void        UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                                     // 2C
		void        UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                             // 2D
		void        UpdateRigidDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2) override;                                // 2E
		void        UpdateWorldBound() override;                                                                                 // 2F
		void        UpdateTransformAndBounds(NiUpdateData& a_data) override;                                                     // 31
		void        OnVisible(NiCullingProcess& a_process) override;                                                             // 34
#endif

		// add
		SKYRIM_REL_VR_VIRTUAL void AttachChild(NiAVObject* a_child, bool a_firstAvail = false);                          // 35
		SKYRIM_REL_VR_VIRTUAL void InsertChildAt(std::uint32_t a_idx, NiAVObject* a_child);                              // 36
		SKYRIM_REL_VR_VIRTUAL void DetachChild1(NiAVObject* a_child, NiPointer<NiAVObject>& a_childOut);                 // 37
		SKYRIM_REL_VR_VIRTUAL void DetachChild2(NiAVObject* a_child);                                                    // 38
		SKYRIM_REL_VR_VIRTUAL void DetachChildAt1(std::uint32_t a_idx, NiPointer<NiAVObject>& a_childOut);               // 39
		SKYRIM_REL_VR_VIRTUAL void DetachChildAt2(std::uint32_t a_idx);                                                  // 3A
		SKYRIM_REL_VR_VIRTUAL void SetAt1(std::uint32_t a_idx, NiAVObject* a_child, NiPointer<NiAVObject>& a_childOut);  // 3B
		SKYRIM_REL_VR_VIRTUAL void SetAt2(std::uint32_t a_idx, NiAVObject* a_child);                                     // 3C
		SKYRIM_REL_VR_VIRTUAL void UpdateUpwardPass(NiUpdateData& a_data);                                               // 3D

		static NiNode* Create(std::uint16_t a_arrBufLen = 0);

		[[nodiscard]] inline NiTObjectArray<NiPointer<NiAVObject>>& GetChildren() noexcept
		{
			return REL::RelocateMember<NiTObjectArray<NiPointer<NiAVObject>>>(this, 0x110, 0x138);
		}

		[[nodiscard]] inline const NiTObjectArray<NiPointer<NiAVObject>>& GetChildren() const noexcept
		{
			return REL::RelocateMember<NiTObjectArray<NiPointer<NiAVObject>>>(this, 0x110, 0x138);
		}

		void DetachChild(NiAVObject* a_child);
		void DetachChild(NiAVObject* a_child, NiPointer<NiAVObject>& a_childOut);
		void DetachChildAt(std::uint32_t a_idx);
		void DetachChildAt(std::uint32_t a_idx, NiPointer<NiAVObject>& a_childOut);
		void SetAt(std::uint32_t a_idx, NiAVObject* a_child);
		void SetAt(std::uint32_t a_idx, NiAVObject* a_child, NiPointer<NiAVObject>& a_childOut);

		// members
#ifndef SKYRIM_CROSS_VR
		NiTObjectArray<NiPointer<NiAVObject>> children;  // 110, 138
#endif

	protected:
		NiNode* Ctor(std::uint16_t a_arrBufLen);
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(NiNode) == 0x128);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(NiNode) == 0x150);
#endif
}


===============================================
File: include/RE/N/NiObject.h
===============================================
#pragma once

#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSDynamicTriShape;
	class BSFadeNode;
	class BSGeometry;
	class bhkAttachmentCollisionObject;
	class bhkBlendCollisionObject;
	class bhkLimitedHingeConstraint;
	class bhkNiCollisionObject;
	class bhkRigidBody;
	class BSLines;
	class BSMultiBoundNode;
	class BSSegmentedTriShape;
	class BSSubIndexTriShape;
	class BSTriShape;
	class NiCloningProcess;
	class NiControllerManager;
	class NiGeometry;
	class NiNode;
	class NiObjectGroup;
	class NiParticles;
	class NiRTTI;
	class NiStream;
	class NiSwitchNode;
	class NiTriBasedGeom;
	class NiTriShape;
	class NiTriStrips;

	NiSmartPointer(NiObject);

	class NiObject : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiObject;
		inline static auto           Ni_RTTI = NiRTTI_NiObject;

		~NiObject() override = default;  // 00

		// add
		[[nodiscard]] virtual const NiRTTI*   GetRTTI() const;                                                            // 02
		virtual NiNode*                       AsNode() { return nullptr; }                                                // 03
		virtual NiSwitchNode*                 AsSwitchNode() { return nullptr; }                                          // 04
		virtual BSFadeNode*                   AsFadeNode() { return nullptr; }                                            // 05
		virtual BSMultiBoundNode*             AsMultiBoundNode() { return nullptr; }                                      // 06
		virtual BSGeometry*                   AsGeometry() { return nullptr; }                                            // 07
		virtual NiTriStrips*                  AsTriStrips() { return nullptr; }                                           // 08
		virtual BSTriShape*                   AsTriShape() { return nullptr; }                                            // 09
		virtual BSSegmentedTriShape*          AsSegmentedTriShape() { return nullptr; }                                   // 0A
		virtual BSSubIndexTriShape*           AsSubIndexTriShape() { return nullptr; }                                    // 0B
		virtual BSDynamicTriShape*            AsDynamicTriShape() { return nullptr; }                                     // 0C
		virtual NiGeometry*                   AsNiGeometry() { return nullptr; }                                          // 0D
		virtual NiTriBasedGeom*               AsNiTriBasedGeom() { return nullptr; }                                      // 0E
		virtual NiTriShape*                   AsNiTriShape() { return nullptr; }                                          // 0F
		virtual NiParticles*                  AsParticlesGeom() { return nullptr; }                                       // 10
		virtual BSLines*                      AsLinesGeom() { return nullptr; }                                           // 11
		virtual bhkNiCollisionObject*         AsBhkNiCollisionObject() { return nullptr; }                                // 12
		virtual bhkBlendCollisionObject*      AsBhkBlendCollisionObject() { return nullptr; }                             // 13
		virtual bhkAttachmentCollisionObject* AsBhkAttachmentCollisionObject() { return nullptr; }                        // 14
		virtual bhkRigidBody*                 AsBhkRigidBody() { return nullptr; }                                        // 15
		virtual bhkLimitedHingeConstraint*    AsBhkLimitedHingeConstraint() { return nullptr; }                           // 16
		virtual NiObject*                     CreateClone([[maybe_unused]] NiCloningProcess& a_cloning) { return this; }  // 17
		virtual void                          LoadBinary([[maybe_unused]] NiStream& a_stream) { return; }                 // 18
		virtual void                          LinkObject([[maybe_unused]] NiStream& a_stream) { return; }                 // 19
		virtual bool                          RegisterStreamables(NiStream& a_stream);                                    // 1A
		virtual void                          SaveBinary([[maybe_unused]] NiStream& a_stream) { return; }                 // 1B
		virtual bool                          IsEqual(NiObject* a_object);                                                // 1C
		virtual void                          ProcessClone(NiCloningProcess& a_cloning);                                  // 1D
		virtual void                          PostLinkObject([[maybe_unused]] NiStream& a_stream) { return; }             // 1E
		virtual bool                          StreamCanSkip() { return false; }                                           // 1F
		[[nodiscard]] virtual const NiRTTI*   GetStreamableRTTI() const { return GetRTTI(); }                             // 20
		[[nodiscard]] virtual std::uint32_t   GetBlockAllocationSize() const { return 0; }                                // 21
		[[nodiscard]] virtual NiObjectGroup*  GetGroup() const { return nullptr; }                                        // 22
		virtual void                          SetGroup([[maybe_unused]] NiObjectGroup* a_group) { return; }               // 23
		virtual NiControllerManager*          AsNiControllerManager() { return nullptr; }                                 // 24

		void CreateDeepCopy(NiPointer<NiObject>& a_object);
	};
	static_assert(sizeof(NiObject) == 0x10);
}


===============================================
File: include/RE/N/NiObjectGroup.h
===============================================
#pragma once

namespace RE
{
	class NiObjectGroup
	{
	public:
		// members
		std::uint32_t size;   // 00
		std::uint32_t pad04;  // 04
		std::uint64_t unk08;  // 08
		std::uint64_t unk10;  // 10
		std::uint32_t unk18;  // 18
		std::uint32_t pad1C;  // 1C
	};
	static_assert(sizeof(NiObjectGroup) == 0x20);
}


===============================================
File: include/RE/N/NiObjectNET.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiExtraData;
	class NiTimeController;

	class NiObjectNET : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiObjectNET;
		inline static auto           Ni_RTTI = NiRTTI_NiObjectNET;

		~NiObjectNET() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                            // 02
		void          LoadBinary(NiStream& a_stream) override;             // 18
		void          LinkObject(NiStream& a_stream) override;             // 19
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A
		void          SaveBinary(NiStream& a_stream) override;             // 1B
		bool          IsEqual(NiObject* a_object) override;                // 1C
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D
		void          PostLinkObject(NiStream& a_stream) override;         // 1E

		bool                            AddExtraData(const BSFixedString& a_key, NiExtraData* a_extra);
		bool                            AddExtraData(NiExtraData* a_extra);
		void                            DeleteExtraData(std::uint16_t a_extraDataIndex);
		[[nodiscard]] NiTimeController* GetControllers() const;
		NiTimeController*               GetController(const NiRTTI* a_rtti) const;

		template <class T>
		[[nodiscard]] T* GetController() const;

		[[nodiscard]] NiExtraData* GetExtraData(const BSFixedString& a_key) const;
		template <class T>
		[[nodiscard]] T* GetExtraData(const BSFixedString& a_key) const;

		[[nodiscard]] NiExtraData*  GetExtraDataAt(std::uint16_t a_extraDataIndex) const;
		[[nodiscard]] std::uint16_t GetExtraDataSize() const;
		[[nodiscard]] bool          HasExtraData(const BSFixedString& a_key) const;
		bool                        InsertExtraData(NiExtraData* a_extra);
		void                        RemoveAllExtraData();
		bool                        RemoveExtraData(const BSFixedString& a_key);
		bool                        RemoveExtraDataAt(std::uint16_t a_extraDataIndex);
		bool                        SetExtraDataSize(std::uint16_t a_size);

		// members
		BSFixedString               name;           // 10
		NiPointer<NiTimeController> controllers;    // 18
		NiExtraData**               extra;          // 20
		std::uint16_t               extraDataSize;  // 28
		std::uint16_t               maxSize;        // 2A
		std::uint32_t               pad2C;          // 2C
	};
	static_assert(sizeof(NiObjectNET) == 0x30);

	template <class T>
	T* NiObjectNET::GetController() const
	{
		const REL::Relocation<const NiRTTI*> rtti{ T::Ni_RTTI };
		return static_cast<T*>(GetController(rtti.get()));
	}

	template <class T>
	T* NiObjectNET::GetExtraData(const BSFixedString& a_key) const
	{
		return static_cast<T*>(GetExtraData(a_key));
	}
}


===============================================
File: include/RE/N/NiPSysData.h
===============================================
#pragma once

#include "RE/N/NiParticlesData.h"

namespace RE
{
	class NiParticleInfo
	{
	public:
		// members
		NiPoint3      velocity;    // 00
		float         age;         // 0C
		float         lifespan;    // 10
		float         lastUpdate;  // 14
		std::uint16_t unk18;       // 18
		std::uint16_t unk1A;       // 1A
		std::uint32_t pad1C;       // 1C
	};
	static_assert(sizeof(NiParticleInfo) == 0x20);

	class NiPSysData : public NiParticlesData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiPSysData;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiPSysData;

		~NiPSysData() override;  // 00

		// override (NiParticlesData)
		const NiRTTI* GetRTTI() const override;                                // 02
		void          LoadBinary(NiStream& a_stream) override;                 // 18
		void          LinkObject(NiStream& a_stream) override;                 // 19
		bool          RegisterStreamables(NiStream& a_stream) override;        // 1A
		void          SaveBinary(NiStream& a_stream) override;                 // 1B
		bool          IsEqual(NiObject* a_object) override;                    // 1C - { return false; }
		void          RemoveParticle(std::uint16_t a_particleCount) override;  // 28

		// add
		virtual std::uint16_t AddParticle();            // 2A
		virtual void          ResolveAddedParticles();  // 2B

		// members
		NiParticleInfo* particleInfo;        // 90
		float*          rotationSpeeds;      // 98
		std::uint16_t   addedParticleCount;  // A0
		std::uint16_t   addedParticlesBase;  // A0
		std::uint32_t   padA4;               // A4
	};
	static_assert(sizeof(NiPSysData) == 0xA8);
}


===============================================
File: include/RE/N/NiPSysGravityModifier.h
===============================================
#pragma once

#include "RE/N/NiPSysModifier.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiPSysGravityModifier : public NiPSysModifier
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiPSysGravityModifier;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiPSysGravityModifier;

		enum class ForceType
		{
			kPlanar = 0,
			kSpherical
		};

		~NiPSysGravityModifier() override;  // 00

		// override (NiPSysModifier)
		const NiRTTI* GetRTTI() const override;                                                                                                  // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;                                                                         // 17
		void          LoadBinary(NiStream& a_stream) override;                                                                                   // 18
		void          LinkObject(NiStream& a_stream) override;                                                                                   // 19
		bool          RegisterStreamables(NiStream& a_stream) override;                                                                          // 1A
		void          SaveBinary(NiStream& a_stream) override;                                                                                   // 1B
		bool          IsEqual(NiObject* a_object) override;                                                                                      // 1C - { return false; }
		void          ProcessClone(NiCloningProcess& a_cloning) override;                                                                        // 1D
		bool          Update(float a_time, NiPSysData* a_particleData, NiPoint3* a_position, NiPoint3* a_radii, NiColorA* a_rotation) override;  // 25

		// members
		NiAVObject*                                gravityObj;    // 30
		NiPoint3                                   gravityAxis;   // 38
		float                                      decay;         // 44
		float                                      strength;      // 48
		stl::enumeration<ForceType, std::uint32_t> forceType;     // 4C
		float                                      turbulence;    // 50
		float                                      scale;         // 54
		bool                                       worldAligned;  // 58
		std::uint8_t                               pad59;         // 59
		std::uint16_t                              pad5A;         // 5A
		std::uint32_t                              pad5C;         // 5C
	};
	static_assert(sizeof(NiPSysGravityModifier) == 0x60);
}


===============================================
File: include/RE/N/NiPSysModifier.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class NiColorA;
	class NiParticleSystem;
	class NiPoint3;
	class NiPSysData;

	class NiPSysModifier : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiPSysModifier;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiPSysModifier;

		enum class ORDER
		{
			kKillOldParticles = 0,
			kBSLOD = 1,
			kEmitter = 1000,
			kSpawn = 2000,
			kGeneral = 3000,
			kForce = 4000,
			kCollider = 5000,
			kPosUpdate = 6000,
			kPostPosUpdate = 6500,
			kBoundUpdate = 7000,
			kBSStripUpdate = 8000
		};

		~NiPSysModifier() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                            // 02
		void          LoadBinary(NiStream& a_stream) override;             // 18
		void          LinkObject(NiStream& a_stream) override;             // 19
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A
		void          SaveBinary(NiStream& a_stream) override;             // 1B
		bool          IsEqual(NiObject* a_object) override;                // 1C - { return false; }
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D

		// add
		virtual bool Update(float a_time, NiPSysData* a_particleData, NiPoint3* a_position, NiPoint3* a_radii, NiColorA* a_rotation) = 0;  // 25
		virtual void Initialize(NiPSysData* a_particleData, std::uint16_t, NiPoint3*);                                                     // 26
		virtual void HandleReset();                                                                                                        // 27
		virtual void SetActive(bool a_active);                                                                                             // 28
		virtual void SetSystemPointer(NiParticleSystem* a_target);                                                                         // 29

		// members
		BSFixedString                          name;    // 10
		stl::enumeration<ORDER, std::uint32_t> order;   // 18
		std::uint32_t                          pad1C;   // 1C
		NiParticleSystem*                      target;  // 20
		bool                                   active;  // 28
		std::uint8_t                           pad29;   // 29
		std::uint16_t                          pad2A;   // 29
		std::uint32_t                          pad2C;   // 29
	};
	static_assert(sizeof(NiPSysModifier) == 0x30);
}


===============================================
File: include/RE/N/NiParticleSystem.h
===============================================
#pragma once

#include "RE/N/NiParticles.h"
#include "RE/N/NiTPointerList.h"

namespace RE
{
	class NiPSysModifier;

	class NiParticleSystem : public NiParticles
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiParticleSystem;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiParticleSystem;
		inline static constexpr auto VTABLE = VTABLE_NiParticleSystem;

		~NiParticleSystem() override;  // 00

		// override (NiParticles)
		const NiRTTI* GetRTTI() const override;                                                                                    // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;                                                           // 17
		void          LoadBinary(NiStream& a_stream) override;                                                                     // 18
		void          LinkObject(NiStream& a_stream) override;                                                                     // 19 - { BSGeometry::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;                                                            // 1A - { return BSGeometry::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;                                                                     // 1B
		bool          IsEqual(NiObject* a_object) override;                                                                        // 1C - { return BSGeometry::IsEqual(); }
		void          ProcessClone(NiCloningProcess& a_cloning) override;                                                          // 1D
		void          SetSelectiveUpdateFlags(bool& a_selectiveUpdate, bool a_selectiveUpdateTransforms, bool& a_rigid);  // 2B
		void          UpdateDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2);                                     // 2C
		void          UpdateSelectedDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2);                             // 2D
		void          UpdateRigidDownwardPass(NiUpdateData& a_data, std::uint32_t a_arg2);                                // 2E
		void          UpdateWorldData(NiUpdateData* a_data);                                                              // 30

		// add
		virtual void UpdateSystem(float a_time);     // 38 - { return NiParticleSystem::Do_UpdateSystem(a_time); }
		virtual void Do_UpdateSystem(float a_time);  // 39

		void AddModifier(NiPSysModifier* a_modifier)
		{
			using func_t = decltype(&NiParticleSystem::AddModifier);
			REL::Relocation<func_t> func{ RELOCATION_ID(72799, 74499) };
			return func(this, a_modifier);
		}

		// members
		NiTPointerList<NiPointer<NiPSysModifier>> modifierList;   // 168
		float                                     unk180;         // 180
		float                                     unk184;         // 184
		float                                     unk188;         // 188
		float                                     lastUpdate;     // 18C
		bool                                      resetSystem;    // 190
		bool                                      dynamicBounds;  // 191
		bool                                      isWorldspace;   // 192
		std::uint8_t                              pad193;         // 192
		std::uint32_t                             pad194;         // 194
	};
}


===============================================
File: include/RE/N/NiParticles.h
===============================================
#pragma once

#include "RE/B/BSGeometry.h"

namespace RE
{
	class NiParticlesData;

	class NiParticles : public BSGeometry
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiParticles;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiParticles;

		~NiParticles() override;  // 00

		// override (BSGeometry)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiParticles*  AsParticlesGeom() override;                         // 10
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { BSGeometry::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return BSGeometry::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C - { return BSGeometry::IsEqual(); }

		// members
		NiPointer<NiParticlesData> particleData;  // 158
		std::uint64_t              unk160;        // 160
	};
}


===============================================
File: include/RE/N/NiParticlesData.h
===============================================
#pragma once

#include "RE/N/NiBound.h"
#include "RE/N/NiObject.h"

namespace RE
{
	class NiParticlesData : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiParticlesData;
		inline static constexpr auto Ni_RTTI = NiRTTI_NiParticlesData;

		~NiParticlesData() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C - { return false; }

		// add
		virtual void          SetActiveVertexCount(std::uint16_t a_vertexCount);  // 25
		virtual std::uint16_t GetActiveVertexCount();                             // 26
		virtual void          RemoveParticle(std::uint16_t a_particleCount);      // 28
		virtual void          CalculateNormals();                                 // 29 - { return; }

		// members
		bool          hasRotations;            // 10
		std::uint8_t  unk11;                   // 11
		std::uint16_t maxNumVertices;          // 12
		NiBound       bound;                   // 14
		std::uint32_t pad24;                   // 24
		NiQuaternion* rotations;               // 28
		NiPoint3*     positions;               // 30
		NiColorA*     color;                   // 38
		float*        radii;                   // 40
		float*        sizes;                   // 48
		float*        rotationAngles;          // 50
		NiPoint3*     rotationAxes;            // 58
		NiColorA*     subtextureOffsets;       // 60
		std::uint32_t subTextureOffsetsCount;  // 68 - max 256
		float         aspectRatio;             // 6C
		float         speedToAspectAspect2;    // 70
		float         speedToAspectAspect1;    // 74
		float         speedToAspectSpeed2;     // 78
		std::uint16_t numVertices;             // 7C
		std::uint16_t pad7E;                   // 7E
		std::uint8_t* textureIndices;          // 80
		std::uint8_t  unk88;                   // 88 - aspect flags?
		std::uint8_t  unk89;                   // 89
		std::uint16_t pad8A;                   // 8A
		std::uint32_t pad8C;                   // 8C
	};
	static_assert(sizeof(NiParticlesData) == 0x90);
}


===============================================
File: include/RE/N/NiPlane.h
===============================================
#pragma once

#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiPlane
	{
	public:
		// members
		NiPoint3 normal;    // 00
		float    constant;  // 0C
	};
	static_assert(sizeof(NiPlane) == 0x10);
}


===============================================
File: include/RE/N/NiPoint2.h
===============================================
#pragma once

namespace RE
{
	class NiPoint2
	{
	public:
		constexpr NiPoint2() noexcept = default;

		constexpr NiPoint2(float a_x, float a_y) noexcept :
			x(a_x),
			y(a_y){};

		float&       operator[](std::size_t a_idx);
		const float& operator[](std::size_t a_idx) const;
		bool         operator==(const NiPoint2& a_rhs) const;
		bool         operator!=(const NiPoint2& a_rhs) const;
		NiPoint2     operator+(const NiPoint2& a_rhs) const;
		NiPoint2     operator-(const NiPoint2& a_rhs) const;
		float        operator*(const NiPoint2& a_rhs) const;
		NiPoint2     operator*(float a_scalar) const;
		NiPoint2     operator/(float a_scalar) const;
		NiPoint2     operator-() const;
		NiPoint2&    operator+=(const NiPoint2& a_rhs);
		NiPoint2&    operator-=(const NiPoint2& a_rhs);
		NiPoint2&    operator*=(float a_scalar);
		NiPoint2&    operator/=(float a_scalar);

		[[nodiscard]] float Cross(const NiPoint2& a_pt) const;
		[[nodiscard]] float Dot(const NiPoint2& a_pt) const;
		[[nodiscard]] float GetDistance(const NiPoint2& a_pt) const noexcept;
		[[nodiscard]] float GetSquaredDistance(const NiPoint2& a_pt) const noexcept;
		[[nodiscard]] float Length() const;
		[[nodiscard]] float SqrLength() const;
		float               Unitize();

		// members
		float x{ 0.0F };  // 0
		float y{ 0.0F };  // 4
	};
	static_assert(sizeof(NiPoint2) == 0x8);
}


===============================================
File: include/RE/N/NiPoint3.h
===============================================
#pragma once

namespace RE
{
	class NiPoint3
	{
	public:
		constexpr NiPoint3() noexcept = default;

		constexpr NiPoint3(float a_x, float a_y, float a_z) noexcept :
			x(a_x),
			y(a_y),
			z(a_z){};

		float&       operator[](std::size_t a_idx);
		const float& operator[](std::size_t a_idx) const;
		bool         operator==(const NiPoint3& a_rhs) const;
		bool         operator!=(const NiPoint3& a_rhs) const;
		NiPoint3     operator+(const NiPoint3& a_rhs) const;
		NiPoint3     operator-(const NiPoint3& a_rhs) const;
		float        operator*(const NiPoint3& a_rhs) const;
		NiPoint3     operator*(float a_scalar) const;
		NiPoint3     operator/(float a_scalar) const;
		NiPoint3     operator-() const;
		NiPoint3&    operator+=(const NiPoint3& a_rhs);
		NiPoint3&    operator-=(const NiPoint3& a_rhs);
		NiPoint3&    operator*=(const NiPoint3& a_rhs);
		NiPoint3&    operator/=(const NiPoint3& a_rhs);
		NiPoint3&    operator*=(float a_scalar);
		NiPoint3&    operator/=(float a_scalar);

		[[nodiscard]] NiPoint3 Cross(const NiPoint3& pt) const;
		[[nodiscard]] float    Dot(const NiPoint3& pt) const;
		[[nodiscard]] float    GetDistance(const NiPoint3& a_pt) const noexcept;
		[[nodiscard]] float    GetSquaredDistance(const NiPoint3& a_pt) const noexcept;
		[[nodiscard]] float    Length() const;
		[[nodiscard]] float    SqrLength() const;
		[[nodiscard]] NiPoint3 UnitCross(const NiPoint3& a_pt) const;
		float                  Unitize();

		static const NiPoint3& Zero();

		// members
		float x{ 0.0F };  // 0
		float y{ 0.0F };  // 4
		float z{ 0.0F };  // 8
	};
	static_assert(sizeof(NiPoint3) == 0xC);
}


===============================================
File: include/RE/N/NiPointLight.h
===============================================
#pragma once

#include "RE/N/NiLight.h"

namespace RE
{
	class NiPointLight : public NiLight
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiPointLight;
		inline static auto           Ni_RTTI = NiRTTI_NiPointLight;

		struct POINT_LIGHT_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT             \
	float constAttenuation;     /* 00 */ \
	float linearAttenuation;    /* 04 */ \
	float quadraticAttenuation; /* 08 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(POINT_LIGHT_RUNTIME_DATA) == 0x0C);

		~NiPointLight() override;  // 00

		// override (NiLight)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		[[nodiscard]] inline POINT_LIGHT_RUNTIME_DATA& GetPointLightRuntimeData() noexcept
		{
			return REL::RelocateMember<POINT_LIGHT_RUNTIME_DATA>(this, 0x140, 0x168);
		}

		[[nodiscard]] inline const POINT_LIGHT_RUNTIME_DATA& GetPointLightRuntimeData() const noexcept
		{
			return REL::RelocateMember<POINT_LIGHT_RUNTIME_DATA>(this, 0x140, 0x168);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 140, 168
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(NiPointLight) == 0x150);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(NiPointLight) == 0x178);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/N/NiProperty.h
===============================================
#pragma once

#include "RE/N/NiObjectNET.h"

namespace RE
{
	class NiProperty : public NiObjectNET
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiProperty;
		inline static auto           Ni_RTTI = NiRTTI_NiProperty;

		enum class Type
		{
			kAlpha = 0,
			kShade = 1
		};

		~NiProperty() override;  // 00

		// override (NiObjectNET)
		const NiRTTI* GetRTTI() const override;                            // 02
		void          LoadBinary(NiStream& a_stream) override;             // 18 - { NiObjectNET::LoadBinary(a_stream); }
		void          LinkObject(NiStream& a_stream) override;             // 19 - { NiObjectNET::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A - { return NiObjectNET::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;             // 1B - { NiObjectNET::SaveBinary(a_stream); }
		bool          IsEqual(NiObject* a_object) override;                // 1C - { return NiObjectNET::IsEqual(a_object); }
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D

		// add
		[[nodiscard]] virtual Type GetType() const = 0;   // 25
		virtual void               Update(float a_time);  // 26
	};
	static_assert(sizeof(NiProperty) == 0x30);
}


===============================================
File: include/RE/N/NiQuaternion.h
===============================================
#pragma once

namespace RE
{
	class NiQuaternion
	{
	public:
		// members
		float w;  // 00
		float x;  // 04
		float y;  // 08
		float z;  // 0C
	};
	static_assert(sizeof(NiQuaternion) == 0x10);
}


===============================================
File: include/RE/N/NiRTTI.h
===============================================
#pragma once

namespace RE
{
	class NiRTTI
	{
	public:
		[[nodiscard]] constexpr const char*   GetName() const noexcept { return name; }
		[[nodiscard]] constexpr const NiRTTI* GetBaseRTTI() const noexcept { return baseRTTI; }

		[[nodiscard]] constexpr bool IsKindOf(const NiRTTI* a_rtti) const noexcept
		{
			for (auto iter = this; iter; iter = iter->GetBaseRTTI()) {
				if (iter == a_rtti) {
					return true;
				}
			}
			return false;
		}

		// members
		const char*   name;      // 00
		const NiRTTI* baseRTTI;  // 08
	};
	static_assert(sizeof(NiRTTI) == 0x10);

	namespace Ni_Impl
	{
		template <class T>
		using remove_cvpr_t =
			std::remove_pointer_t<
				std::remove_reference_t<
					std::remove_cv_t<T>>>;

		template <class To, class From>
		struct types_are_compat :
			std::false_type
		{};

		template <class To, class From>
		struct types_are_compat<To&, From> :
			std::is_lvalue_reference<
				std::remove_cv_t<From>>
		{};

		template <class To, class From>
		struct types_are_compat<To*, From> :
			std::is_pointer<
				std::remove_cv_t<From>>
		{};

		template <class Base, class Derived>
		struct is_base_of_no_cvpr :
			std::is_base_of<
				remove_cvpr_t<Base>,
				remove_cvpr_t<Derived>>
		{};

		template <class T, class Enable = void>
		struct _has_rtti :
			std::false_type
		{};

		template <class T>
		struct _has_rtti<T, std::void_t<decltype(T::Ni_RTTI)>> :
			std::true_type
		{};

		template <class T>
		struct has_rtti :
			_has_rtti<remove_cvpr_t<T>>
		{};

		template <class To, class From>
		struct cast_is_valid :
			std::conjunction<
				types_are_compat<To, From>,
				is_base_of_no_cvpr<From, To>,
				has_rtti<To>,
				has_rtti<From>>
		{};

		template <class To, class From>
		inline constexpr bool cast_is_valid_v = cast_is_valid<To, From>::value;
	}
}

// downcast
template <
	class To,
	class From,
	std::enable_if_t<
		RE::Ni_Impl::cast_is_valid_v<
			To,
			const From*>,
		int> = 0>
To netimmerse_cast(const From* a_from)
{
	if (!a_from) {
		return nullptr;
	}

	REL::Relocation<const RE::NiRTTI*> to{ RE::Ni_Impl::remove_cvpr_t<To>::Ni_RTTI };

	const RE::NiRTTI* toRTTI = to.get();
	const RE::NiRTTI* fromRTTI = a_from->GetRTTI();
	while (fromRTTI) {
		if (fromRTTI == toRTTI) {
			return static_cast<To>(const_cast<From*>(a_from));
		}
		fromRTTI = fromRTTI->GetBaseRTTI();
	}

	return nullptr;
}

// upcast
template <
	class To,
	class From,
	std::enable_if_t<
		RE::Ni_Impl::cast_is_valid_v<
			const From*,
			To>,
		int> = 0>
To netimmerse_cast(const From* a_from)
{
	return static_cast<To>(const_cast<From*>(a_from));
}


===============================================
File: include/RE/N/NiRect.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class NiRect
	{
	public:
		NiRect(T a_left = T(0), T a_right = T(0), T a_top = T(0), T a_bottom = T(0)) :
			left(a_left),
			right(a_right),
			top(a_top),
			bottom(a_bottom)
		{}

		[[nodiscard]] T GetWidth() const
		{
			return right > left ? (right - left) : (left - right);
		}

		[[nodiscard]] T GetHeight() const
		{
			return top > bottom ? (top - bottom) : (bottom - top);
		}

	protected:
		// members
		T left;    // 00
		T right;   // ??
		T top;     // ??
		T bottom;  // ??
	};
	static_assert(sizeof(NiRect<float>) == 0x10);
}


===============================================
File: include/RE/N/NiRefObject.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	class NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiRefObject;

		NiRefObject();
		virtual ~NiRefObject();  // 00

		// add
		virtual void DeleteThis();  // 01

		void                                  IncRefCount();
		void                                  DecRefCount();
		[[nodiscard]] constexpr std::uint32_t GetRefCount() const noexcept { return _refCount; }

		[[nodiscard]] static volatile std::uint32_t* GetTotalObjectCount();

		TES_HEAP_REDEFINE_NEW();

		// members
		volatile std::uint32_t _refCount{ 0 };  // 08
		std::uint32_t          _pad0C{ 0 };     // 0C
	};
	static_assert(sizeof(NiRefObject) == 0x10);
}


===============================================
File: include/RE/N/NiShadeProperty.h
===============================================
#pragma once

#include "RE/N/NiProperty.h"

namespace RE
{
	class NiShadeProperty : public NiProperty
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiShadeProperty;
		inline static auto           Ni_RTTI = NiRTTI_NiShadeProperty;

		~NiShadeProperty() override;  // 00

		// override (NiProperty)
		const NiRTTI*      GetRTTI() const override;                           // 02
		NiObject*          CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void               LoadBinary(NiStream& a_stream) override;            // 18 - { NiProperty::LoadBinary(a_stream); }
		void               LinkObject(NiStream& a_stream) override;            // 19 - { NiProperty::LinkObject(a_stream); }
		bool               RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiProperty::RegisterStreamables(a_stream); }
		void               SaveBinary(NiStream& a_stream) override;            // 1B - { NiProperty::SaveBinary(a_stream); }
		bool               IsEqual(NiObject* a_object) override;               // 1C - { return NiProperty::IsEqual(a_object); }
		[[nodiscard]] Type GetType() const override;                           // 25 - { return Type::kShade; }

		// add
		virtual bool SetupGeometry(BSGeometry* a_geometry);        // 27 - { return 1; }
		virtual bool FinishSetupGeometry(BSGeometry* a_geometry);  // 28 - { return 1; }
		virtual void Unk_29(void);                                 // 29 - { return; }
	};
	static_assert(sizeof(NiShadeProperty) == 0x30);
}


===============================================
File: include/RE/N/NiSkinData.h
===============================================
#pragma once

#include "RE/N/NiBound.h"
#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTransform.h"

namespace RE
{
	class NiSkinPartition;

	class NiSkinData : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiSkinData;
		inline static auto           Ni_RTTI = NiRTTI_NiSkinData;

		class BoneVertData
		{
		public:
			// members
			std::uint16_t vert;    // 0
			std::uint16_t pad2;    // 2
			float         weight;  // 4
		};
		static_assert(sizeof(BoneVertData) == 0x8);

		class BoneData
		{
		public:
			// members
			NiTransform   skinToBone;    // 00
			NiBound       bound;         // 34
			std::uint32_t pad44;         // 44
			BoneVertData* boneVertData;  // 48
			std::uint16_t verts;         // 50
			std::uint16_t pad52;         // 52
			std::uint32_t pad54;         // 54
		};
		static_assert(sizeof(BoneData) == 0x58);

		~NiSkinData() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19 - { NiObject::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A - { NiObject::RegisterStreamables(a_stream) != false; }
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C

		// members
		NiPointer<NiSkinPartition> skinPartition;     // 10
		NiTransform                rootParentToSkin;  // 18
		BoneData*                  boneData;          // 50
		std::uint32_t              bones;             // 58
		std::uint32_t              pad5C;             // 5C
	};
	static_assert(sizeof(NiSkinData) == 0x60);
}


===============================================
File: include/RE/N/NiSkinInstance.h
===============================================
#pragma once

#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiAVObject;
	class NiTransform;
	class NiSkinData;
	class NiSkinPartition;

	class NiSkinInstance : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiSkinInstance;
		inline static auto           Ni_RTTI = NiRTTI_NiSkinInstance;

		~NiSkinInstance() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C
		void          PostLinkObject(NiStream& a_stream) override;        // 1E - { return; }

		// add
		virtual void Unk_25(void);  // 25

		static NiSkinInstance* Create();

		// members
		NiPointer<NiSkinData>      skinData;                      // 10
		NiPointer<NiSkinPartition> skinPartition;                 // 18
		NiAVObject*                rootParent;                    // 20
		NiAVObject**               bones;                         // 28
		const NiTransform**        boneWorldTransforms;           // 30
		std::uint32_t              frameID;                       // 38
		std::uint32_t              numMatrices;                   // 3C
		std::uint32_t              numRegisters;                  // 40
		std::uint32_t              allocatedSize;                 // 44
		void*                      boneMatrices;                  // 48
		void*                      prevBoneMatrices;              // 50
		void*                      skinToWorldWorldToSkinMatrix;  // 58
#ifndef ENABLE_SKYRIM_VR
		WinAPI::CRITICAL_SECTION lock;  // 60
	};
	static_assert(sizeof(NiSkinInstance) == 0x88);
#else
		std::uint64_t unk60;  // 60 - no lock in VR
	};
	static_assert(sizeof(NiSkinInstance) == 0x68);
#endif
}


===============================================
File: include/RE/N/NiSkinPartition.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"
#include "RE/N/NiGeometryData.h"
#include "RE/N/NiObject.h"
#include "RE/V/VertexDesc.h"

namespace RE
{
	struct ID3D11Buffer;

	namespace BSGraphics
	{
		struct TriShape
		{
			ID3D11Buffer*          vertexBuffer;   // 00
			ID3D11Buffer*          indexBuffer;    // 08
			BSGraphics::VertexDesc vertexDesc;     // 10
			volatile std::uint32_t refCount;       // 18
			std::uint32_t          pad1C;          // 1C
			std::uint8_t*          rawVertexData;  // 20
			std::uint16_t*         rawIndexData;   // 28
		};
		static_assert(sizeof(TriShape) == 0x30);
	}

	class NiSkinPartition : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiSkinPartition;
		inline static auto           Ni_RTTI = NiRTTI_NiSkinPartition;

		class Partition
		{
		public:
			BSGraphics::VertexDesc vertexDesc;      // 00
			std::uint16_t*         bones;           // 08
			float*                 weights;         // 10
			std::uint16_t*         vertexMap;       // 18
			std::uint8_t*          bonePalette;     // 20
			std::uint16_t*         triList;         // 28
			std::uint16_t*         stripLengths;    // 30
			std::uint16_t          vertices;        // 38
			std::uint16_t          triangles;       // 3A
			std::uint16_t          numBones;        // 3C
			std::uint16_t          strips;          // 3E
			std::uint16_t          bonesPerVertex;  // 40
			std::uint16_t          pad42;           // 42
			float                  unk44;           // 44
			BSGraphics::TriShape*  buffData;        // 48
		};
		static_assert(sizeof(Partition) == 0x50);

		~NiSkinPartition() override;  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                          // 02
		void          LoadBinary(NiStream& a_stream) override;           // 18
		void          LinkObject(NiStream& a_stream) override;           // 19 - { NiObject::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;  // 1A - { return NiObject::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;           // 1B
		bool          IsEqual(NiObject* a_object) override;              // 1C

		// add
		virtual void Unk_25(void);  // 25

		// members
		std::uint32_t          numPartitions;  // 10
		std::uint32_t          pad14;          // 14
		SimpleArray<Partition> partitions;     // 18
		std::uint32_t          vertexCount;    // 20
		std::uint32_t          unk24;          // 24
	};
	static_assert(sizeof(NiSkinPartition) == 0x28);
}


===============================================
File: include/RE/N/NiSmartPointer.h
===============================================
#pragma once

#include "RE/C/CRC.h"

namespace RE
{
	template <class T>
	class NiPointer
	{
	public:
		using element_type = T;

		// 1
		constexpr NiPointer() noexcept = default;

		// 2
		constexpr NiPointer(std::nullptr_t) noexcept {}

		// 3
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		explicit NiPointer(Y* a_rhs) :
			_ptr(a_rhs)
		{
			TryAttach();
		}

		// 9a
		NiPointer(const NiPointer& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 9b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		NiPointer(const NiPointer<Y>& a_rhs) :
			_ptr(a_rhs._ptr)
		{
			TryAttach();
		}

		// 10a
		NiPointer(NiPointer&& a_rhs) noexcept :
			_ptr(a_rhs._ptr)
		{
			a_rhs._ptr = nullptr;
		}

		// 10b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		NiPointer(NiPointer<Y>&& a_rhs) noexcept :
			_ptr(a_rhs._ptr)
		{
			a_rhs._ptr = nullptr;
		}

		~NiPointer() { TryDetach(); }

		// 1a
		NiPointer& operator=(const NiPointer& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = a_rhs._ptr;
				TryAttach();
			}
			return *this;
		}

		// 1b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		NiPointer& operator=(const NiPointer<Y>& a_rhs)
		{
			TryDetach();
			_ptr = a_rhs._ptr;
			TryAttach();
			return *this;
		}

		// 2a
		NiPointer& operator=(NiPointer&& a_rhs)
		{
			if (this != std::addressof(a_rhs)) {
				TryDetach();
				_ptr = a_rhs._ptr;
				a_rhs._ptr = nullptr;
			}
			return *this;
		}

		// 2b
		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		NiPointer& operator=(NiPointer<Y>&& a_rhs)
		{
			TryDetach();
			_ptr = a_rhs._ptr;
			a_rhs._ptr = nullptr;
			return *this;
		}

		void reset() { TryDetach(); }

		template <
			class Y,
			std::enable_if_t<
				std::is_convertible_v<
					Y*,
					element_type*>,
				int> = 0>
		void reset(Y* a_ptr)
		{
			if (_ptr != a_ptr) {
				TryDetach();
				_ptr = a_ptr;
				TryAttach();
			}
		}

		[[nodiscard]] constexpr element_type* get() const noexcept
		{
			return _ptr;
		}

		[[nodiscard]] explicit constexpr operator bool() const noexcept
		{
			return static_cast<bool>(_ptr);
		}

		[[nodiscard]] constexpr element_type& operator*() const noexcept
		{
			assert(static_cast<bool>(*this));
			return *_ptr;
		}

		[[nodiscard]] constexpr element_type* operator->() const noexcept
		{
			assert(static_cast<bool>(*this));
			return _ptr;
		}

	protected:
		template <class>
		friend class NiPointer;

		void TryAttach()
		{
			if (_ptr) {
				_ptr->IncRefCount();
			}
		}

		void TryDetach()
		{
			if (_ptr) {
				_ptr->DecRefCount();
				_ptr = nullptr;
			}
		}

		// members
		element_type* _ptr{ nullptr };  // 0
	};
	//static_assert(sizeof(NiPointer<void*>) == 0x8);

	template <class T, class... Args>
	[[nodiscard]] NiPointer<T> make_nismart(Args&&... a_args)
	{
		return NiPointer<T>{ new T(std::forward<Args>(a_args)...) };
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator==(const NiPointer<T1>& a_lhs, const NiPointer<T2>& a_rhs)
	{
		return a_lhs.get() == a_rhs.get();
	}

	template <class T1, class T2>
	[[nodiscard]] constexpr bool operator!=(const NiPointer<T1>& a_lhs, const NiPointer<T2>& a_rhs)
	{
		return !(a_lhs == a_rhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(const NiPointer<T>& a_lhs, std::nullptr_t) noexcept
	{
		return !a_lhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator==(std::nullptr_t, const NiPointer<T>& a_rhs) noexcept
	{
		return !a_rhs;
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(const NiPointer<T>& a_lhs, std::nullptr_t) noexcept
	{
		return static_cast<bool>(a_lhs);
	}

	template <class T>
	[[nodiscard]] constexpr bool operator!=(std::nullptr_t, const NiPointer<T>& a_rhs) noexcept
	{
		return static_cast<bool>(a_rhs);
	}

	template <class T>
	NiPointer(T*) -> NiPointer<T>;

	template <class T>
	struct BSCRC32_<NiPointer<T>>
	{
	public:
		[[nodiscard]] inline std::uint32_t operator()(const NiPointer<T>& a_key) const noexcept
		{
			return BSCRC32_<T*>()(a_key.get());
		}
	};
}

#define NiSmartPointer(className) \
	class className;              \
	using className##Ptr = RE::NiPointer<className>


===============================================
File: include/RE/N/NiSourceTexture.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTexture.h"

namespace RE
{
	namespace BSGraphics
	{
		class Texture;
	}

	namespace BSResource
	{
		class Stream;
	}

	NiSmartPointer(NiSourceTexture);

	class NiSourceTexture : public NiTexture
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiSourceTexture;
		inline static auto           Ni_RTTI = NiRTTI_NiSourceTexture;

		~NiSourceTexture() override;  // 00

		// override (NiTexture)
		const NiRTTI* GetRTTI() const override;  // 02
		void          Unk_25(void) override;     // 25 - { return 0; }
		void          Unk_26(void) override;     // 26 - { return 0; }
		void          Unk_27(void) override;     // 27
		void          Unk_28(void) override;     // 28
		void          Unk_29(void) override;     // 29 - { return; }
		void          Unk_2A(void) override;     // 2A - { return; }

		// members
		BSResource::Stream*  unk40;            // 40
		BSGraphics::Texture* rendererTexture;  // 48
		std::uint8_t         flags;            // 50
		std::uint8_t         pad51;            // 51
		std::uint16_t        pad52;            // 52
		std::uint32_t        pad54;            // 54
	};
	static_assert(sizeof(NiSourceTexture) == 0x58);
}


===============================================
File: include/RE/N/NiStream.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiObjectGroup.h"
#include "RE/N/NiTArray.h"
#include "RE/N/NiTPointerMap.h"

namespace RE
{
	class NiBinaryStream;
	class NiObjectGroup;

	struct BSStreamHeader
	{
	public:
		// members
		std::uint32_t version;            // 00
		char          author[64];         // 04
		char          processScript[64];  // 44
		char          exportScript[64];   // 84
		std::uint32_t padC4;              // C4
	};
	static_assert(sizeof(BSStreamHeader) == 0xC8);

	class NiStream
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiStream;
		inline static constexpr auto VTABLE = VTABLE_NiStream;

		virtual ~NiStream();  // 00

		// add
		virtual bool          Load1(NiBinaryStream* a_stream);                          // 01
		virtual bool          Load2(char* a_buffer, std::uint64_t a_len);               // 02
		virtual bool          Load3(const char* a_path);                                // 03
		virtual bool          Save1(NiBinaryStream* a_stream);                          // 04
		virtual bool          Save2(char*& a_path, std::uint64_t& a_len);               // 05
		virtual bool          Save3(const char* a_path);                                // 06
		virtual void          Unk_07(void);                                             // 07 - { return 0; }
		virtual bool          RegisterFixedString(const BSFixedString& a_fixedString);  // 08
		virtual bool          RegisterSaveObject(NiObject* a_object);                   // 09
		virtual bool          ChangeObject(NiObject* a_object);                         // 0A
		virtual std::uint32_t GetLinkIDFromObject(const NiObject* a_object);            // 0B
		virtual void          SaveLinkID(const NiObject* a_object);                     // 0C
		virtual bool          LoadHeader();                                             // 0D
		virtual void          SaveHeader();                                             // 0E
		virtual bool          LoadStream();                                             // 0F
		virtual void          SaveStream();                                             // 10
		virtual void          RegisterObjects();                                        // 11
		virtual void          LoadTopLevelObjects();                                    // 12
		virtual void          SaveTopLevelObjects();                                    // 13
		virtual bool          LoadObject();                                             // 14
		virtual std::uint64_t PreSaveObjectSizeTable();                                 // 15
		virtual bool          SaveObjectSizeTable(std::uint64_t a_size);                // 16
		virtual bool          LoadObjectSizeTable();                                    // 17

		// members
		BSStreamHeader                                header;                      // 008
		BSTSmallArray<NiObjectGroup>                  groups;                      // 0D0
		std::uint32_t                                 nifMaxVersion;               // 100
		std::uint32_t                                 nifMaxUserDefinedVersion;    // 104
		char                                          inputFilePath[MAX_PATH];     // 108
		std::uint16_t                                 unk20C;                      // 20C
		std::uint16_t                                 unk20E;                      // 20E
		std::uint64_t                                 unk210;                      // 210
		NiTLargeObjectArray<NiPointer<NiObject>>      objects;                     // 218
		NiTLargePrimitiveArray<std::uint32_t>         objectSizes;                 // 238
		NiTLargeObjectArray<NiPointer<NiObject>>      topObjects;                  // 258
		NiTLargeObjectArray<BSFixedString>            fixedStrings;                // 278
		NiBinaryStream*                               iStr;                        // 298
		NiBinaryStream*                               oStr;                        // 2A0
		std::uint32_t                                 linkIndex;                   // 2A8
		std::uint32_t                                 linkBlockIndex;              // 2AC
		NiTPointerMap<NiObject const*, std::uint32_t> registerMap;                 // 2B0
		std::uint16_t                                 niAVObjectFlags;             // 2D0
		std::uint16_t                                 niTimeControllerFlags;       // 2D2
		std::uint16_t                                 niPropertyFlags;             // 2D4
		std::uint32_t                                 unk2D8;                      // 2D8
		bool                                          unk2DC;                      // 2DC
		std::uint32_t                                 load;                        // 2E0
		std::uint32_t                                 link;                        // 2E4
		std::uint32_t                                 postLink;                    // 2E8
		std::uint64_t                                 unk2F0;                      // 2F0
		std::uint64_t                                 unk2F8;                      // 2F8
		std::uint32_t                                 unk300;                      // 300
		std::uint32_t                                 unk304;                      // 304
		std::int32_t                                  unk308;                      // 308
		char                                          lastLoadedRTTI[MAX_PATH];    // 30C
		std::uint32_t                                 lastError;                   // 410
		char                                          lastErrorMessage[MAX_PATH];  // 414
		char                                          filePath[MAX_PATH];          // 518
	};
	static_assert(sizeof(NiStream) == 0x620);
}


===============================================
File: include/RE/N/NiStringExtraData.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"

namespace RE
{
	class NiStringExtraData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiStringExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiStringExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiStringExtraData;

		~NiStringExtraData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		// members
		char* value;  // 18
	};
	static_assert(sizeof(NiStringExtraData) == 0x20);
}


===============================================
File: include/RE/N/NiStringsExtraData.h
===============================================
#pragma once

#include "RE/N/NiExtraData.h"

namespace RE
{
	class NiStringsExtraData : public NiExtraData
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiStringsExtraData;
		inline static auto           Ni_RTTI = NiRTTI_NiStringsExtraData;
		inline static constexpr auto VTABLE = VTABLE_NiStringsExtraData;

		~NiStringsExtraData() override;  // 00

		// override (NiExtraData)
		const NiRTTI* GetRTTI() const override;                           // 02
		NiObject*     CreateClone(NiCloningProcess& a_cloning) override;  // 17
		void          LoadBinary(NiStream& a_stream) override;            // 18
		void          LinkObject(NiStream& a_stream) override;            // 19 - { NiExtraData::LinkObject(a_stream); }
		bool          RegisterStreamables(NiStream& a_stream) override;   // 1A - { return NiExtraData::RegisterStreamables(a_stream); }
		void          SaveBinary(NiStream& a_stream) override;            // 1B
		bool          IsEqual(NiObject* a_object) override;               // 1C

		static NiStringsExtraData*                 Create(const BSFixedString& a_name, const std::vector<BSFixedString>& a_strings);
		[[nodiscard]] std::optional<std::uint32_t> GetIndex(const BSFixedString& a_element) const;
		bool                                       Insert(const BSFixedString& a_element);
		bool                                       Remove(const BSFixedString& a_element);
		bool                                       Replace(const BSFixedString& a_from, const BSFixedString& a_to);

		// members
		std::uint32_t size;   // 18
		std::uint32_t pad1C;  // 1C
		char**        value;  // 20

	private:
		static void copy_string(char*& a_value, const BSFixedString& a_string);
		static void copy_string(char*& a_value, char* a_copyValue);
	};
	static_assert(sizeof(NiStringsExtraData) == 0x28);
}


===============================================
File: include/RE/N/NiSystem.h
===============================================
#pragma once

namespace RE
{
	constexpr auto NI_TRUNCATE = static_cast<std::size_t>(-1);

	int   NiMemcpy(void* a_dest, std::size_t a_destSize, const void* a_src, std::size_t a_count);
	int   NiSprintf(char* a_dest, std::size_t a_destSize, const char* a_format, ...);
	char* NiStrcat(char* a_dest, std::size_t a_destSize, const char* a_src);
	char* NiStrncpy(char* a_dest, std::size_t a_destSize, const char* a_src, std::size_t a_count);
	int   NiVsnprintf(char* a_dest, std::size_t a_destSize, std::size_t a_count, const char* a_format, std::va_list a_args);
	int   NiVsprintf(char* a_dest, std::size_t a_destSize, const char* a_format, std::va_list a_args);
}


===============================================
File: include/RE/N/NiTArray.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"
#include "RE/N/NiTCollection.h"

namespace RE
{
	template <class T, class Allocator>
	class NiTArray
	{
	public:
		using value_type = T;
		using allocator_type = Allocator;
		using size_type = std::uint16_t;
		using reference = value_type&;
		using const_reference = const value_type&;
		using iterator = T*;
		using const_iterator = const T*;

		NiTArray(std::uint32_t a_maxSize = 0, std::uint32_t a_growBy = 1) :
			_data(0),
			_capacity(static_cast<std::uint16_t>(a_maxSize)),
			_freeIdx(0),
			_size(0),
			_growthSize(static_cast<std::uint16_t>(a_growBy))
		{
			if (_capacity > 0) {
				_data = allocator_type::Allocate(_capacity);
			}
		}

		virtual ~NiTArray()  // 00
		{
			allocator_type::Deallocate(_data);
		}

		reference operator[](size_type a_pos)
		{
			assert(a_pos < capacity());
			return _data[a_pos];
		}

		const_reference operator[](size_type a_pos) const
		{
			assert(a_pos < capacity());
			return _data[a_pos];
		}

		reference front()
		{
			return operator[](0);
		}

		[[nodiscard]] const_reference front() const
		{
			return operator[](0);
		}

		reference back()
		{
			return operator[](capacity() - 1);
		}

		[[nodiscard]] const_reference back() const
		{
			return operator[](capacity() - 1);
		}

		iterator begin()
		{
			return _data;
		}

		[[nodiscard]] const_iterator begin() const
		{
			return _data;
		}

		[[nodiscard]] const_iterator cbegin() const
		{
			return _data;
		}

		iterator end()
		{
			return _data + _capacity;
		}

		[[nodiscard]] const_iterator end() const
		{
			return _data + _capacity;
		}

		[[nodiscard]] const_iterator cend() const
		{
			return _data + _capacity;
		}

		[[nodiscard]] bool empty() const
		{
			return _capacity == 0;
		}

		[[nodiscard]] size_type size() const
		{
			return _size;
		}

		[[nodiscard]] size_type capacity() const
		{
			return _capacity;
		}

	private:
		// members
		T*            _data;        // 08
		std::uint16_t _capacity;    // 10
		std::uint16_t _freeIdx;     // 12
		std::uint16_t _size;        // 14
		std::uint16_t _growthSize;  // 16
	};
	static_assert(sizeof(NiTArray<void*, NiTMallocInterface<void*>>) == 0x18);

	template <class T>
	class NiTObjectArray : public NiTArray<T, NiTNewInterface<T>>
	{
	public:
		NiTObjectArray(std::uint32_t a_maxSize = 0, std::uint32_t a_growBy = 1) :
			NiTArray<T, NiTNewInterface<T>>(a_maxSize, a_growBy)
		{}
	};
	static_assert(sizeof(NiTObjectArray<void*>) == 0x18);

	template <class T>
	class NiTPrimitiveArray : public NiTArray<T, NiTMallocInterface<T>>
	{
	public:
		NiTPrimitiveArray(std::uint32_t a_maxSize = 0, std::uint32_t a_growBy = 1) :
			NiTArray<T, NiTMallocInterface<T>>(a_maxSize, a_growBy)
		{}
	};
	static_assert(sizeof(NiTPrimitiveArray<void*>) == 0x18);

	template <class T, class Allocator>
	class NiTLargeArray
	{
	public:
		using value_type = T;
		using allocator_type = Allocator;
		using size_type = std::uint32_t;
		using reference = value_type&;
		using const_reference = const value_type&;
		using iterator = T*;
		using const_iterator = const T*;

		NiTLargeArray(std::uint32_t a_maxSize = 0, std::uint32_t a_growBy = 1) :
			_data(0),
			_capacity(a_maxSize),
			_freeIdx(0),
			_size(0),
			_growthSize(a_growBy)
		{
			if (_capacity > 0) {
				_data = allocator_type::Allocate(_capacity);
			}
		}

		virtual ~NiTLargeArray()  // 00
		{
			allocator_type::Deallocate(_data);
		}

		reference operator[](size_type a_pos)
		{
			assert(a_pos < size());
			return _data[a_pos];
		}

		const_reference operator[](size_type a_pos) const
		{
			assert(a_pos < size());
			return _data[a_pos];
		}

		reference front()
		{
			return operator[](0);
		}

		[[nodiscard]] const_reference front() const
		{
			return operator[](0);
		}

		reference back()
		{
			return operator[](size() - 1);
		}

		[[nodiscard]] const_reference back() const
		{
			return operator[](size() - 1);
		}

		iterator begin()
		{
			return _data;
		}

		[[nodiscard]] const_iterator begin() const
		{
			return _data;
		}

		[[nodiscard]] const_iterator cbegin() const
		{
			return _data;
		}

		iterator end()
		{
			return _data + _size;
		}

		[[nodiscard]] const_iterator end() const
		{
			return _data + _size;
		}

		[[nodiscard]] const_iterator cend() const
		{
			return _data + _size;
		}

		[[nodiscard]] bool empty() const
		{
			return _capacity == 0;
		}

		[[nodiscard]] size_type size() const
		{
			return _size;
		}

		[[nodiscard]] size_type capacity() const
		{
			return _capacity;
		}

	private:
		// members
		T*            _data;        // 08
		std::uint32_t _capacity;    // 10
		std::uint32_t _freeIdx;     // 14
		std::uint32_t _size;        // 18
		std::uint32_t _growthSize;  // 1C
	};
	static_assert(sizeof(NiTLargeArray<void*, NiTMallocInterface<void*>>) == 0x20);

	template <class T>
	class NiTLargeObjectArray : public NiTLargeArray<T, NiTNewInterface<T>>
	{
	public:
		NiTLargeObjectArray(std::uint32_t a_maxSize = 0, std::uint32_t a_growBy = 1) :
			NiTLargeArray<T, NiTNewInterface<T>>(a_maxSize, a_growBy)
		{}
	};
	static_assert(sizeof(NiTLargeObjectArray<void*>) == 0x20);

	template <class T>
	class NiTLargePrimitiveArray : public NiTLargeArray<T, NiTMallocInterface<T>>
	{
	public:
		NiTLargePrimitiveArray(std::uint32_t a_maxSize = 0, std::uint32_t a_growBy = 1) :
			NiTLargeArray<T, NiTMallocInterface<T>>(a_maxSize, a_growBy)
		{}
	};
	static_assert(sizeof(NiTLargePrimitiveArray<void*>) == 0x20);

	class TESForm;
	class NiFormArray : public NiTLargePrimitiveArray<TESForm*>
	{
	public:
	};
	static_assert(sizeof(NiFormArray) == 0x20);
}


===============================================
File: include/RE/N/NiTCollection.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	void*          NiMalloc(std::size_t a_sizeInBytes);
	void*          NiAlignedMalloc(std::size_t a_sizeInBytes, std::size_t a_alignment);
	void*          NiRealloc(void* a_mem, std::size_t a_sizeInBytes);
	void*          NiAlignedRealloc(void* a_mem, std::size_t a_sizeInBytes, std::size_t a_alignment);
	void           NiFree(void* a_mem);
	void           NiAlignedFree(void* a_mem);
	constexpr bool NiTrackAlloc([[maybe_unused]] void* a_mem, [[maybe_unused]] std::size_t a_sizeInBytes) { return false; }
	constexpr bool NiTrackFree([[maybe_unused]] void* a_mem) { return false; }

	// calloc
	template <class T>
	T* NiAlloc(std::size_t a_count)
	{
		return static_cast<T*>(NiMalloc(sizeof(T) * a_count));
	}

	// aligned calloc
	template <class T>
	T* NiAlignedAlloc(std::size_t a_count, std::size_t a_alignment)
	{
		return static_cast<T*>(NiAlignedMalloc(sizeof(T) * a_count, a_alignment));
	}

	template <class T>
	class NiTMallocInterface
	{
	public:
		inline static T* Allocate(std::size_t a_numElements)
		{
			return static_cast<T*>(NiMalloc(sizeof(T) * a_numElements));
		};

		inline static void Deallocate(T* a_array)
		{
			NiFree(a_array);
		};
	};

	template <class T>
	class NiTNewInterface
	{
	public:
		inline static T* Allocate(std::size_t a_numElements)
		{
			auto mem = malloc(sizeof(std::size_t) + sizeof(T) * a_numElements);
			auto head = static_cast<std::size_t*>(mem);
			*head = a_numElements;
			mem = head + 1;
			return static_cast<T*>(mem);
		};

		inline static void Deallocate(T* a_array)
		{
			if (a_array) {
				auto head = stl::adjust_pointer<std::size_t>(a_array, -stl::ssizeof_v<std::uintptr_t>);
				for (std::size_t i = 0; i < *head; ++i) {
					a_array[i].~T();
				}
				free(head);
			}
		};
	};
}


===============================================
File: include/RE/N/NiTDefaultAllocator.h
===============================================
#pragma once

#include "RE/N/NiTCollection.h"

#define NiTDefaultAllocator DFALL

namespace RE
{
	template <class T>
	class NiTDefaultAllocator
	{
	public:
		void* Allocate()
		{
			return NiMalloc(sizeof(T));
		}

		void Deallocate(void* a_ptr)
		{
			return NiFree(a_ptr);
		}
	};
}


===============================================
File: include/RE/N/NiTList.h
===============================================
#pragma once

#include "RE/N/NiTDefaultAllocator.h"
#include "RE/N/NiTPointerListBase.h"

namespace RE
{
	template <class T>
	class NiTList : public NiTPointerListBase<NiTDefaultAllocator<T>, T>
	{
	public:
	};
	static_assert(sizeof(NiTList<void*>) == 0x18);
}


===============================================
File: include/RE/N/NiTListBase.h
===============================================
#pragma once

namespace RE
{
	template <class T>
	class NiTListItem
	{
	public:
		NiTListItem* next;     // 00
		NiTListItem* prev;     // 08
		T            element;  // 10
	};
	static_assert(sizeof(NiTListItem<void*>) == 0x18);

	template <class Allocator, class T>
	class NiTListBase
	{
	public:
		struct AntiBloatAllocator : public Allocator
		{
			// members
			std::uint32_t size;  // ??
		};

		// members
		NiTListItem<T>*    head;       // 00
		NiTListItem<T>*    tail;       // 08
		AntiBloatAllocator allocator;  // 10
	};
}


===============================================
File: include/RE/N/NiTMap.h
===============================================
#pragma once

#include "RE/N/NiTDefaultAllocator.h"
#include "RE/N/NiTMapBase.h"

namespace RE
{
	template <class Key, class T>
	class NiTMap : public NiTMapBase<NiTDefaultAllocator<NiTMapItem<Key, T>>, Key, T>
	{
	private:
		using Base = NiTMapBase<NiTDefaultAllocator<NiTMapItem<Key, T>>, Key, T>;

	public:
		using key_type = typename Base::key_type;
		using mapped_type = typename Base::mapped_type;
		using value_type = typename Base::value_type;
		using size_type = typename Base::size_type;

		NiTMap(std::uint32_t a_hashSize = 37) :
			Base(a_hashSize)
		{}

		~NiTMap() override  // 00
		{}

	protected:
		using Base::_allocator;

		// override (NiTMapBase)
		value_type* malloc_value() override  // 05
		{
			return static_cast<value_type*>(_allocator.Allocate());
		}

		void free_value(value_type* a_value) override  // 06
		{
			if (a_value) {
				a_value->~value_type();
				_allocator.Deallocate(a_value);
			}
		}
	};
	static_assert(sizeof(NiTMap<void*, void*>) == 0x20);
}


===============================================
File: include/RE/N/NiTMapBase.h
===============================================
#pragma once

#include "RE/M/MemoryManager.h"

namespace RE
{
	template <class Key, class T>
	class NiTMapItem
	{
	public:
		using key_type = Key;
		using mapped_type = T;

		// members
		NiTMapItem* next;    // 00
		key_type    first;   // 08
		mapped_type second;  // ??
	};
	static_assert(sizeof(NiTMapItem<std::uint32_t, std::uint64_t>) == 0x18);

	// hash table with separate chaining
	template <class Allocator, class Key, class T>
	class NiTMapBase
	{
	private:
		template <class U>
		friend class iterator_base;

	public:
		using key_type = Key;
		using mapped_type = T;
		using value_type = NiTMapItem<Key, T>;
		using size_type = std::uint32_t;

		template <class U>
		struct iterator_base
		{
		public:
			using difference_type = std::ptrdiff_t;
			using value_type = U;
			using pointer = U*;
			using reference = U&;
			using iterator_category = std::forward_iterator_tag;

			iterator_base() :
				_proxy(0),
				_iter(0),
				_idx(0)
			{}

			iterator_base(const iterator_base& a_rhs) :
				_proxy(a_rhs._proxy),
				_iter(a_rhs._iter),
				_idx(a_rhs._idx)
			{}

			iterator_base(iterator_base&& a_rhs) :
				_proxy(a_rhs._proxy),
				_iter(std::move(a_rhs._iter)),
				_idx(std::move(a_rhs._idx))
			{
				assert(_proxy);
				a_rhs._iter = nullptr;
				a_rhs._idx = a_rhs._proxy->_capacity;
			}

			iterator_base(NiTMapBase* a_proxy, std::uint32_t a_idx) :
				_proxy(a_proxy),
				_iter(nullptr),
				_idx(a_idx)
			{
				assert(_proxy);
				_iter = _proxy->_data[_idx];
				while (!_iter && _idx < _proxy->_capacity) {
					++_idx;
					_iter = _proxy->_data[_idx];
				}
			}

			iterator_base(NiTMapBase* a_proxy, value_type* a_iter, std::uint32_t a_idx) :
				_proxy(a_proxy),
				_iter(a_iter),
				_idx(a_idx)
			{
				assert(_proxy);
				assert(_iter);
			}

			~iterator_base()
			{}

			iterator_base& operator=(const iterator_base& a_rhs)
			{
				assert(_proxy == a_rhs._proxy);
				_iter = a_rhs._iter;
				_idx = a_rhs._idx;
			}

			iterator_base& operator=(iterator_base&& a_rhs)
			{
				assert(_proxy == a_rhs._proxy);

				_iter = std::move(a_rhs._iter);
				a_rhs._iter = 0;

				_idx = std::move(a_rhs._idx);
				a_rhs._idx = a_rhs._proxy->_capacity;
			}

			void swap(iterator_base& a_rhs)
			{
				assert(_proxy == a_rhs._proxy);
				std::swap(_iter, a_rhs._iter);
				std::swap(_idx, a_rhs._idx);
			}

			[[nodiscard]] reference operator*() const
			{
				assert(_iter);
				assert(_idx < _proxy->_capacity);
				return *_iter;
			}

			[[nodiscard]] pointer operator->() const
			{
				assert(_iter);
				assert(_idx < _proxy->_capacity);
				return _iter;
			}

			[[nodiscard]] bool operator==(const iterator_base& a_rhs) const
			{
				assert(_proxy == a_rhs._proxy);

				if (_idx != a_rhs._idx) {
					return false;
				}

				if (_idx < _proxy->_capacity) {
					return _iter == a_rhs._iter;
				}

				return true;
			}

			[[nodiscard]] bool operator!=(const iterator_base& a_rhs) const
			{
				return !operator==(a_rhs);
			}

			// prefix
			iterator_base& operator++()
			{
				assert(_proxy);
				assert(_iter);
				assert(_idx < _proxy->_capacity);

				if (_iter->next) {
					_iter = _iter->next;
				} else {
					do {
						++_idx;
						_iter = _proxy->_data[_idx];
					} while (!_iter && _idx < _proxy->_capacity);
				}

				return *this;
			}

			// postfix
			iterator_base operator++(int)
			{
				iterator_base tmp(*this);
							  operator++();
				return tmp;
			}

		private:
			NiTMapBase*   _proxy;
			value_type*   _iter;
			std::uint32_t _idx;
		};

		using iterator = iterator_base<value_type>;
		using const_iterator = iterator_base<const value_type>;

		struct AntiBloatAllocator : public Allocator
		{
			AntiBloatAllocator() :
				Allocator(),
				size(0)
			{}

			// members
			size_type size;  // ??
		};

		NiTMapBase(size_type a_capacity = 37) :
			_capacity(a_capacity),
			_pad0C(0),
			_data(0),
			_allocator()
		{
			std::size_t memSize = sizeof(value_type*) * _capacity;
			_data = malloc<value_type*>(memSize);
			std::memset(_data, 0, memSize);
		}

		virtual ~NiTMapBase()  // 00
		{
			clear();
			if (_data) {
				free(_data);
				_data = nullptr;
			}
			_capacity = 0;
		}

	protected:
		virtual std::uint32_t hash_function(key_type a_key) const;                                      // 01 - { return a_key % _capacity; }
		virtual bool          key_eq(key_type a_lhs, key_type a_rhs) const;                             // 02 - { return stricmp(a_lhs == a_rhs); }
		virtual void          assign_value(value_type* a_value, key_type a_key, mapped_type a_mapped);  // 03 - { a_value->key = a_key; a_value->mapped = a_mapped; }
		virtual void          clear_value(value_type* a_value);                                         // 04 - { return; }
		virtual value_type*   malloc_value() = 0;                                                       // 05
		virtual void          free_value(value_type* a_value) = 0;                                      // 06

	public:
		iterator begin()
		{
			return iterator(this, 0);
		}

		const_iterator begin() const
		{
			return const_iterator(this, 0);
		}

		const_iterator cbegin() const
		{
			return const_iterator(this, 0);
		}

		iterator end()
		{
			return iterator(this, _capacity);
		}

		const_iterator end() const
		{
			return const_iterator(this, _capacity);
		}

		const_iterator cend() const
		{
			return const_iterator(this, _capacity);
		}

		[[nodiscard]] bool empty() const noexcept
		{
			return _allocator.size == 0;
		}

		[[nodiscard]] size_type size() const noexcept
		{
			return _allocator.size;
		}

		void clear()
		{
			for (std::uint32_t i = 0; i < _capacity; i++) {
				while (_data[i]) {
					auto elem = _data[i];
					_data[i] = _data[i]->next;
					clear_value(elem);
					free_value(elem);
				}
			}

			_allocator.size = 0;
		}

		template <class M>
		bool insert_or_assign(key_type&& a_key, M&& a_obj)
		{
			// look up hash table location for key
			auto index = hash_function(a_key);
			auto item = _data[index];

			// search list at hash table location for key
			while (item) {
				if (key_eq(a_key, item->key)) {
					// item already in hash table, set its new value
					item->val = std::forward<M>(a_obj);
					return false;
				}
				item = item->next;
			}

			// add object to beginning of list for this hash table index
			item = malloc_value();

			assert(item != 0);
			assign_value(item, std::move(a_key), std::forward<M>(a_obj));
			item->next = _data[index];
			_data[index] = item;
			++_allocator.size;
			return true;
		}

		size_type erase(const key_type& a_key)
		{
			// look up hash table location for key
			auto index = hash_function(a_key);
			auto item = _data[index];

			value_type* prev = 0;
			while (item) {
				if (key_eq(a_key, item->key)) {
					if (prev) {
						prev->next = item->next;
					} else {
						_data[index] = item->next;
					}
					remove_value(item);
					return 1;
				}
				prev = item;
				item = item->next;
			}
			return 0;
		}

		iterator find(const Key& a_key)
		{
			auto result = do_find(a_key);
			return result ? iterator(this, result->first, result->second) : end();
		}

		const_iterator find(const Key& a_key) const
		{
			auto result = do_find(a_key);
			return result ? const_iterator(this, result->first, result->second) : end();
		}

	private:
		inline void remove_value(value_type* a_value)
		{
			clear_value(a_value);
			free_value(a_value);
			--_allocator.size;
		}

		std::optional<std::pair<value_type*, std::uint32_t>> do_find(const Key& a_key) const
		{
			size_type idx = hash_function(a_key);
			for (auto iter = _data[idx]; iter; iter = iter->next) {
				if (key_eq(a_key, iter->first)) {
					return std::make_optional(std::make_pair(iter, idx));
				}
			}

			return std::nullopt;
		}

	protected:
		// members
		std::uint32_t      _capacity;   // 08
		std::uint32_t      _pad0C;      // 0C
		value_type**       _data;       // 10
		AntiBloatAllocator _allocator;  // 18
	};
}


===============================================
File: include/RE/N/NiTPointerAllocator.h
===============================================
#pragma once

#include "RE/N/NiTCollection.h"

namespace RE
{
	template <class T>
	class NiTPointerAllocator
	{
	public:
		class AllocNode
		{
		public:
			AllocNode* next;     // 00
			void*      data;     // 08
			T          element;  // 10
		};

		void* Allocate()
		{
			return NiMalloc(sizeof(AllocNode));
		}

		void Deallocate(void* a_ptr)
		{
			return NiFree(a_ptr);
		}
	};
}


===============================================
File: include/RE/N/NiTPointerList.h
===============================================
#pragma once

#include "RE/N/NiTPointerAllocator.h"
#include "RE/N/NiTPointerListBase.h"

namespace RE
{
	template <class T>
	class NiTPointerList : public NiTPointerListBase<NiTPointerAllocator<std::uintptr_t>, T>
	{
	public:
	};
	static_assert(sizeof(NiTPointerList<void*>) == 0x18);
}


===============================================
File: include/RE/N/NiTPointerListBase.h
===============================================
#pragma once

#include "RE/N/NiTListBase.h"

namespace RE
{
	template <class Allocator, class T>
	class NiTPointerListBase : public NiTListBase<Allocator, T>
	{
	public:
	};
}


===============================================
File: include/RE/N/NiTPointerMap.h
===============================================
#pragma once

#include "RE/N/NiTMapBase.h"
#include "RE/N/NiTPointerAllocator.h"

namespace RE
{
	template <class Key, class T>
	class NiTPointerMap : public NiTMapBase<NiTPointerAllocator<std::uintptr_t>, Key, T>
	{
	private:
		using Base = NiTMapBase<NiTPointerAllocator<std::uintptr_t>, Key, T>;

	public:
		using key_type = typename Base::key_type;
		using mapped_type = typename Base::mapped_type;
		using value_type = typename Base::value_type;
		using size_type = typename Base::size_type;

		NiTPointerMap(std::uint32_t a_hashSize = 37) :
			Base(a_hashSize)
		{}

		~NiTPointerMap() override  // 00
		{}

	protected:
		using Base::_allocator;

		// override (NiTMapBase)
		value_type* malloc_value() override  // 05
		{
			return static_cast<value_type*>(_allocator.Allocate());
		}

		void free_value(value_type* a_value) override  // 06
		{
			a_value->~value_type();
			_allocator.Deallocate(a_value);
		}
	};
	static_assert(sizeof(NiTPointerMap<std::uint32_t, std::uint64_t>) == 0x20);
}


===============================================
File: include/RE/N/NiTSet.h
===============================================
#pragma once

#include "RE/N/NiTCollection.h"

namespace RE
{
	template <class T, class Allocator>
	class NiTSet
	{
	public:
		using value_type = T;
		using allocator_type = Allocator;
		using size_type = std::uint32_t;
		using reference = value_type&;
		using const_reference = const value_type&;
		using iterator = T*;
		using const_iterator = const T*;

		NiTSet(std::uint32_t a_initialSize = 0) :
			_data(0),
			_capacity(a_initialSize),
			_size(0)
		{
			if (_capacity > 0) {
				_data = allocator_type::Allocate(_capacity);
			}
		}

		~NiTSet()
		{
			allocator_type::Deallocate(_data);
		}

		reference operator[](size_type a_pos)
		{
			assert(a_pos < size());
			return _data[a_pos];
		}

		const_reference operator[](size_type a_pos) const
		{
			assert(a_pos < size());
			return _data[a_pos];
		}

		reference front()
		{
			return operator[](0);
		}

		[[nodiscard]] const_reference front() const
		{
			return operator[](0);
		}

		reference back()
		{
			return operator[](size() - 1);
		}

		[[nodiscard]] const_reference back() const
		{
			return operator[](size() - 1);
		}

		iterator begin()
		{
			return _data;
		}

		[[nodiscard]] const_iterator begin() const
		{
			return _data;
		}

		[[nodiscard]] const_iterator cbegin() const
		{
			return _data;
		}

		iterator end()
		{
			return _data + _size;
		}

		[[nodiscard]] const_iterator end() const
		{
			return _data + _size;
		}

		[[nodiscard]] const_iterator cend() const
		{
			return _data + _size;
		}

		[[nodiscard]] bool empty() const
		{
			return _capacity == 0;
		}

		[[nodiscard]] size_type size() const
		{
			return _size;
		}

		[[nodiscard]] size_type capacity() const
		{
			return _capacity;
		}

	private:
		T*            _data;      // 00
		std::uint32_t _capacity;  // 08
		std::uint32_t _size;      // 0C
	};
	static_assert(sizeof(NiTSet<void*, NiTMallocInterface<void*>>) == 0x10);

	template <class T>
	class NiTObjectSet : public NiTSet<T, NiTNewInterface<T>>
	{
	public:
		NiTObjectSet(std::uint32_t a_initialSize = 0) :
			NiTSet<T, NiTNewInterface<T>>(a_initialSize)
		{}
	};
	static_assert(sizeof(NiTObjectSet<void*>) == 0x10);

	template <class T>
	class NiTPrimitiveSet : public NiTSet<T, NiTMallocInterface<T>>
	{
	public:
		NiTPrimitiveSet(std::uint32_t a_initialSize = 0) :
			NiTSet<T, NiTMallocInterface<T>>(a_initialSize)
		{}
	};
	static_assert(sizeof(NiTPrimitiveSet<void*>) == 0x10);
}


===============================================
File: include/RE/N/NiTStringMap.h
===============================================
#pragma once

#include "RE/N/NiTMap.h"

namespace RE
{
	// 28
	template <class Parent, class T>
	class NiTStringTemplateMap : public Parent
	{
	private:
		using Base = Parent;

	public:
		using key_type = typename Base::key_type;
		using mapped_type = typename Base::mapped_type;
		using value_type = typename Base::value_type;
		using size_type = typename Base::size_type;

		NiTStringTemplateMap(std::uint32_t a_hashSize = 37, bool a_copy = true) :
			Base(a_hashSize),
			_copy(a_copy),
			_pad21(0),
			_pad22(0),
			_pad24(0)
		{}

		virtual ~NiTStringTemplateMap();  // 00

	protected:
		// override (Parent)
		std::uint32_t hash_function(key_type a_key) const override;                                      // 01
		bool          key_eq(key_type a_lhs, key_type a_rhs) const override;                             // 02
		void          assign_value(value_type* a_value, key_type a_key, mapped_type a_mapped) override;  // 03
		void          clear_value(value_type* a_value) override;                                         // 04

		// members
		bool          _copy;   // 20
		std::uint8_t  _pad21;  // 21
		std::uint16_t _pad22;  // 22
		std::uint32_t _pad24;  // 24
	};

	// 28
	template <class T>
	class NiTStringMap : public NiTStringTemplateMap<NiTMap<const char*, T>, T>
	{
	private:
		using Base = NiTStringTemplateMap<NiTMap<const char*, T>, T>;

	public:
		using key_type = typename Base::key_type;
		using mapped_type = typename Base::mapped_type;
		using value_type = typename Base::value_type;
		using size_type = typename Base::size_type;

		virtual ~NiTStringMap();  // 00
	};
}


===============================================
File: include/RE/N/NiTexture.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"

struct ID3D11Texture2D;
struct ID3D11ShaderResourceView;

namespace RE
{
	NiSmartPointer(NiTexture);

	class NiTexture : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiTexture;
		inline static auto           Ni_RTTI = NiRTTI_NiTexture;

		class FormatPrefs
		{
		public:
			enum class PixelLayout
			{
				kPalettized8,
				kHighColor16,
				kTrueColor32,
				kCompressed,
				kBumpmap,
				kPalettized4,
				kDefault,
				kSingleColor8,
				kSingleColor16,
				kSingleColor32,
				kDoubleColor32,
				kDoubleColor64,
				kFloatColor32,
				kFloatColor64,
				kFloatColor128
			};

			enum class AlphaFormat
			{
				kNone,
				kBinary,  // 1-bit
				kSmooth,  // multi-bit
				kDefault
			};

			enum class MipFlag
			{
				kNo = 0,
				kYes = 1,
				kDefault
			};

			FormatPrefs();

			// members
			stl::enumeration<PixelLayout, std::uint32_t> pixelLayout;  // 00
			stl::enumeration<AlphaFormat, std::uint32_t> alphaFormat;  // 04
			stl::enumeration<MipFlag, std::uint32_t>     mipMapped;    // 08
			std::uint32_t                                pad0C;        // 0C
		};
		static_assert(sizeof(FormatPrefs) == 0x10);

		class RendererData
		{
		public:
			RendererData(std::uint16_t width, std::uint16_t height) noexcept :
				width(width), height(height) {}

			ID3D11Texture2D*          texture{ nullptr };       // 00
			std::uint64_t             unk08{ 0 };               // 08
			ID3D11ShaderResourceView* resourceView{ nullptr };  // 10
			std::uint16_t             width;                    // 18
			std::uint16_t             height;                   // 1A
			std::uint8_t              unk1C{ 1 };               // 1C
			std::uint8_t              unk1D{ 0x1C };            // 1D
			std::uint16_t             unk1E{ 0 };               // 1E
			std::uint32_t             unk20{ 1 };               // 20
			std::uint32_t             unk24{ 0x130012 };        // 24

			TES_HEAP_REDEFINE_NEW();
		};
		static_assert(sizeof(RendererData) == 0x28);

		~NiTexture() override;

		// override (NiObject)
		[[nodiscard]] const NiRTTI* GetRTTI() const override;  // 02

		// add
		virtual void Unk_25(void);  // 25 - { return 0; }
		virtual void Unk_26(void);  // 26 - { return 0; }
		virtual void Unk_27(void);  // 27 - { return "n/a"; }
		virtual void Unk_28(void);  // 28
		virtual void Unk_29(void);  // 29 - { return 0; }
		virtual void Unk_2A(void);  // 2A - { return 0; }

		// members
		FormatPrefs   formatPrefs;  // 10
		BSFixedString name;         // 20
		std::uint32_t unk28;        // 28
		std::uint32_t unk2C;        // 2C
		NiTexture*    prev;         // 30
		NiTexture*    next;         // 38
	};
	static_assert(sizeof(NiTexture) == 0x40);
}


===============================================
File: include/RE/N/NiTimeController.h
===============================================
#pragma once

#include "RE/N/NiObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiObjectNET;

	NiSmartPointer(NiTimeController);

	class NiTimeController : public NiObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_NiTimeController;
		inline static auto           Ni_RTTI = NiRTTI_NiTimeController;

		enum class CycleType
		{
			kLoop,
			kReverse,
			kClamp,

			kTotal
		};

		enum class Flag
		{
			kAnimType_AppTime = 0 << 0,
			kAnimType_AppInit = 1 << 0,
			kAnimType_Mask = 1,

			kCycleType_Loop = 0 << 1,
			kCycleType_Reverse = 1 << 1,
			kCycleType_Clamp = 2 << 1,
			kCycleType_Mask = 6,

			kActive = 1 << 3,
			kPlayBackwards = 1 << 4,
			kManagerControlled = 1 << 5,
			kComputeScaledTime = 1 << 6,
			kForceUpdate = 1 << 7
		};

		inline NiTimeController() { ctor(); }
		~NiTimeController() override { dtor(); }  // 00

		// override (NiObject)
		const NiRTTI* GetRTTI() const override;                            // 02
		void          LoadBinary(NiStream& a_stream) override;             // 18
		void          LinkObject(NiStream& a_stream) override;             // 19
		bool          RegisterStreamables(NiStream& a_stream) override;    // 1A
		void          SaveBinary(NiStream& a_stream) override;             // 1B
		bool          IsEqual(NiObject* a_object) override;                // 1C
		void          ProcessClone(NiCloningProcess& a_cloning) override;  // 1D

		// add
		virtual void               Start(float a_time);                             // 25
		virtual void               Stop();                                          // 26
		virtual void               Update(float a_time) = 0;                        // 27
		virtual void               SetTarget(NiObjectNET* a_target);                // 28
		[[nodiscard]] virtual bool IsTransformController() const { return false; }  // 29
		[[nodiscard]] virtual bool IsVertexController() const { return false; }     // 2A
		virtual float              ComputeScaledTime(float a_time);                 // 2B
		virtual void               OnPreDisplay() { return; }                       // 2C
		[[nodiscard]] virtual bool IsStreamable() const { return true; }            // 2D
		[[nodiscard]] virtual bool TargetIsRequiredType() const = 0;                // 2E

		static void StartAnimations(NiObjectNET* a_target);

		[[nodiscard]] constexpr NiTimeController* GetNext() const noexcept { return next.get(); }

		// members
		stl::enumeration<Flag, std::uint16_t> flags;             // 10
		std::uint16_t                         pad12;             // 12
		float                                 frequency;         // 14
		float                                 phase;             // 18
		float                                 loKeyTime;         // 1C
		float                                 hiKeyTime;         // 20
		float                                 startTime;         // 24
		float                                 lastTime;          // 28
		float                                 weightedLastTime;  // 2C
		float                                 scaledTime;        // 30
		std::uint32_t                         pad34;             // 34
		NiObjectNET*                          target;            // 38
		NiPointer<NiTimeController>           next;              // 40 - singly-linked list

	private:
		NiTimeController* ctor();
		void              dtor();
	};
	static_assert(sizeof(NiTimeController) == 0x48);
}


===============================================
File: include/RE/N/NiTransform.h
===============================================
#pragma once

#include "RE/N/NiMatrix3.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class NiTransform
	{
	public:
		constexpr NiTransform() noexcept
		{
			translate = { 0.f, 0.f, 0.f };
			rotate = NiMatrix3();
			scale = 1.0f;
		}

		NiTransform Invert() const;

		bool        operator==(const NiTransform& a_rhs) const;
		bool        operator!=(const NiTransform& a_rhs) const;
		NiTransform operator*(const NiTransform& a_rhs) const;
		NiPoint3    operator*(const NiPoint3& a_point) const;

		NiMatrix3 rotate;     // 00
		NiPoint3  translate;  // 24
		float     scale;      // 30
	};
	static_assert(sizeof(NiTransform) == 0x34);
}


===============================================
File: include/RE/N/NightEyeEffect.h
===============================================
#pragma once

#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class NightEyeEffect :
		public ValueModifierEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_NightEyeEffect;
		inline static constexpr auto VTABLE = VTABLE_NightEyeEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;  // 04
		virtual ~NightEyeEffect();                    // 13
		virtual void Start() override;                // 14
		virtual void Finish() override;               // 15
	};
	static_assert(sizeof(NightEyeEffect) == 0x98);
}


===============================================
File: include/RE/N/NonActorMagicCaster.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/E/ExtraMagicCaster.h"

namespace RE
{
	class TESObjectREFR;

	class NonActorMagicCaster : public ExtraMagicCaster
	{
	public:
		inline static constexpr auto RTTI = RTTI_NonActorMagicCaster;
		inline static constexpr auto EXTRADATATYPE = ExtraDataType::kMagicCaster;

		~NonActorMagicCaster() override;  // 00

		// override (MagicCaster)
		void           CastSpellImmediate(MagicItem* a_spell, bool a_noHitEffectArt, TESObjectREFR* a_target, float a_effectiveness, bool a_hostileEffectivenessOnly, float a_magnitudeOverride, Actor* a_blameActor) override;  // 01
		void           FinishCastImpl() override;                                                                                                                                                                                // 07 - { return; }
		TESObjectREFR* GetCasterStatsObject() const override;                                                                                                                                                                    // 0B - { return 0; }
		Actor*         GetCasterAsActor() const override;                                                                                                                                                                        // 0C - { return 0; }
		TESObjectREFR* GetCasterObjectReference(Actor** a_outCaster) const override;                                                                                                                                             // 0D
		NiNode*        GetMagicNode() override;                                                                                                                                                                                  // 0E - { return 0; }
		void           SaveGame(BGSSaveGameBuffer* a_buf) override;                                                                                                                                                              // 18
		void           LoadGame(BGSLoadGameBuffer* a_buf) override;                                                                                                                                                              // 19

		// members
		TESObjectREFR* unk58;       // 58
		ActorHandle    blameActor;  // 60
		std::uint32_t  unk64;       // 64
	};
	static_assert(sizeof(NonActorMagicCaster) == 0x68);
}


===============================================
File: include/RE/N/NonActorMagicTarget.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/B/BSTList.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/M/MagicTarget.h"

namespace RE
{
	class ActiveEffect;
	class TESObjectREFR;

	class NonActorMagicTarget :
		public BSExtraData,  // 00
		public MagicTarget   // 10
	{
	public:
		inline static constexpr auto RTTI = RTTI_NonActorMagicTarget;
		inline static constexpr auto EXTRADATATYPE = ExtraDataType::kNonActorMagicTarget;

		~NonActorMagicTarget() override;  // 00

		// override (BSExtraData)
		ExtraDataType GetType() const override;  // 01 - { return kNonActorMagicTarget; }

		// override (MagicTarget)
		bool                         AddTarget(AddTargetData& a_targetData) override;  // 01
		TESObjectREFR*               GetTargetStatsObject() override;                  // 02 - { return targetObject; }
		bool                         CanAddActiveEffect() override;                    // 06 - { return true; }
		BSSimpleList<ActiveEffect*>* GetActiveEffectList() override;                   // 07 - { return &activeEffects; }

		// members
		TESObjectREFR*              targetObject;   // 28
		BSSimpleList<ActiveEffect*> activeEffects;  // 30
	};
	static_assert(sizeof(NonActorMagicTarget) == 0x40);
}


===============================================
File: include/RE/O/Object.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/M/MemoryManager.h"
#include "RE/V/Variable.h"

namespace RE
{
	namespace BSScript
	{
		class ObjectTypeInfo;

		class Object
		{
		public:
			~Object();

			[[nodiscard]] VMHandle              GetHandle() const;
			ObjectTypeInfo*                     GetTypeInfo();
			[[nodiscard]] const ObjectTypeInfo* GetTypeInfo() const;
			[[nodiscard]] constexpr bool        IsConstructed() const noexcept { return static_cast<bool>(constructed); }
			[[nodiscard]] constexpr bool        IsInitialized() const noexcept { return static_cast<bool>(initialized); }
			[[nodiscard]] constexpr bool        IsValid() const noexcept { return static_cast<bool>(valid); }

			[[nodiscard]] void* Resolve(VMTypeID a_typeID) const;

			void          IncRef();
			std::uint32_t DecRef();

			Variable*                     GetProperty(const BSFixedString& a_name);
			[[nodiscard]] const Variable* GetProperty(const BSFixedString& a_name) const;
			Variable*                     GetVariable(const BSFixedString& a_name);
			[[nodiscard]] const Variable* GetVariable(const BSFixedString& a_name) const;

			TES_HEAP_REDEFINE_NEW();

			// members
			std::uint32_t                   constructed: 1;            // 00 - 0
			std::uint32_t                   initialized: 1;            // 00 - 1
			std::uint32_t                   valid: 1;                  // 00 - 2
			std::uint32_t                   remainingPropsToInit: 29;  // 00 - 3
			BSTSmartPointer<ObjectTypeInfo> type;                      // 08
			BSFixedString                   currentState;              // 10
			void*                           lockStructure;             // 18 - first bit used as flag
			volatile VMHandle               handle;                    // 20
			volatile std::int32_t           refCountAndHandleLock;     // 28
			std::uint32_t                   pad2C;                     // 2C
			Variable                        variables[0];              // 30 - size == classPtr->GetTotalNumVariables() + 3

		private:
			void Dtor();
		};
		static_assert(sizeof(Object) == 0x30);
	}
}


===============================================
File: include/RE/O/ObjectTypeInfo.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/P/PropertyTypeInfo.h"
#include "RE/T/TypeInfo.h"
#include "RE/V/Variable.h"

namespace RE
{
	namespace BSScript
	{
		class IFunction;

		class ObjectTypeInfo : public BSIntrusiveRefCounted
		{
		public:
			enum class LinkValidState : std::uint32_t
			{
				kNotLinked,
				kCurrentlyLinking,
				kLinkedInvalid,
				kLinkedValid
			};

			struct UnlinkedNativeFunction
			{
			public:
				// members
				UnlinkedNativeFunction*    next;  // 00
				BSTSmartPointer<IFunction> func;  // 08
			};
			static_assert(sizeof(UnlinkedNativeFunction) == 0x10);

			struct UserFlagInfo
			{
			public:
				enum : std::uintptr_t
				{
					kSetOnObject = 1 << 0
				};

				[[nodiscard]] BSFixedString GetUserFlag() const;

				// members
				std::uintptr_t data;  // 0
			};
			static_assert(sizeof(UserFlagInfo) == 0x8);

			struct VariableInfo
			{
			public:
				// members
				BSFixedString name;  // 00
				TypeInfo      type;  // 08
			};
			static_assert(sizeof(VariableInfo) == 0x10);

			struct InitialValueInfo
			{
			public:
				// members
				std::uint32_t variableIndex;  // 00
				std::uint32_t pad04;          // 04
				Variable      initialValue;   // 08
			};
			static_assert(sizeof(InitialValueInfo) == 0x18);

			struct PropertyInfo
			{
			public:
				// members
				BSFixedString    name;  // 00
				PropertyTypeInfo info;  // 08
			};
			static_assert(sizeof(PropertyInfo) == 0x48);

			struct GlobalFuncInfo
			{
			public:
				// members
				BSTSmartPointer<IFunction> func;  // 00
			};
			static_assert(sizeof(GlobalFuncInfo) == 0x8);

			struct MemberFuncInfo
			{
			public:
				// members
				BSTSmartPointer<IFunction> func;  // 00
			};
			static_assert(sizeof(MemberFuncInfo) == 0x8);

			struct NamedStateInfo
			{
			public:
				enum : std::uint32_t
				{
					kFuncCountMask = 0x1FF,
					kFuncOffsetShift = 9
				};

				struct Func
				{
				public:
					// members
					BSTSmartPointer<IFunction> func;  // 00
				};
				static_assert(sizeof(Func) == 0x8);

				[[nodiscard]] constexpr std::uint32_t GetNumFuncs() const noexcept { return memberFunctionCount; }
				Func*                                 GetFuncIter();
				[[nodiscard]] const Func*             GetFuncIter() const;

				// members
				BSFixedString name;                     // 00
				std::uint32_t memberFunctionCount: 9;   // 08 - 0
				std::uint32_t memberFunctionOffset: 9;  // 09 - 1
				std::uint32_t pad0C;                    // 0C
			};
			static_assert(sizeof(NamedStateInfo) == 0x10);

			~ObjectTypeInfo();

			const char*           GetName() const;
			ObjectTypeInfo*       GetParent();
			const ObjectTypeInfo* GetParent() const;
			TypeInfo::RawType     GetRawType() const;

			[[nodiscard]] constexpr bool IsLinked() const noexcept
			{
				switch (linkedValid) {
				case LinkValidState::kLinkedInvalid:
				case LinkValidState::kLinkedValid:
					return true;
				default:
					return false;
				}
			}

			UnlinkedNativeFunction*       GetUnlinkedFunctionIter();
			const UnlinkedNativeFunction* GetUnlinkedFunctionIter() const;

			[[nodiscard]] constexpr std::uint32_t GetNumUserFlags() const noexcept { return userFlagCount; }
			UserFlagInfo*                         GetUserFlagIter();
			const UserFlagInfo*                   GetUserFlagIter() const;

			[[nodiscard]] constexpr std::uint32_t GetNumVariables() const noexcept { return variableCount; }
			std::uint32_t                         GetTotalNumVariables() const;
			VariableInfo*                         GetVariableIter();
			const VariableInfo*                   GetVariableIter() const;

			[[nodiscard]] constexpr std::uint32_t GetNumInitalValues() const noexcept { return initialValueCount; }
			InitialValueInfo*                     GetInitialValueIter();
			const InitialValueInfo*               GetInitialValueIter() const;

			[[nodiscard]] constexpr std::uint32_t GetNumProperties() const noexcept { return propertyCount; }
			PropertyInfo*                         GetPropertyIter();
			const PropertyInfo*                   GetPropertyIter() const;

			[[nodiscard]] constexpr std::uint32_t GetNumGlobalFuncs() const noexcept { return staticFunctionCount; }
			GlobalFuncInfo*                       GetGlobalFuncIter();
			const GlobalFuncInfo*                 GetGlobalFuncIter() const;

			[[nodiscard]] constexpr std::uint32_t GetNumMemberFuncs() const noexcept { return emptyStateMemberFunctionCount; }
			MemberFuncInfo*                       GetMemberFuncIter();
			const MemberFuncInfo*                 GetMemberFuncIter() const;

			[[nodiscard]] constexpr std::uint32_t GetNumNamedStates() const noexcept { return namedStateCount; }
			NamedStateInfo*                       GetNamedStateIter();
			const NamedStateInfo*                 GetNamedStateIter() const;

			std::uint32_t GetPropertyIndex(const BSFixedString& a_name) const;

			// members
			BSFixedString                   name;                               // 08
			BSTSmartPointer<ObjectTypeInfo> parentTypeInfo;                     // 10
			BSFixedString                   docString;                          // 18
			LinkValidState                  linkedValid: 2;                     // 20 - 00 - 0 or 1 -> data == UnlinkedNativeFunction*, 2 or 3 -> data == normal progression
			std::uint32_t                   userFlagCount: 6;                   // 20 - 02
			std::uint32_t                   variableCount: 10;                  // 20 - 08
			std::uint32_t                   variableUserFlagCount: 6;           // 20 - 18
			std::uint32_t                   pad20_24: 8;                        // 20 - 24
			std::uint32_t                   initialValueCount: 10;              // 24 - 0
			std::uint32_t                   propertyCount: 10;                  // 24 - 10
			std::uint32_t                   staticFunctionCount: 9;             // 24 - 20
			std::uint32_t                   pad24_29: 3;                        // 24 - 29
			std::uint32_t                   emptyStateMemberFunctionCount: 11;  // 28 - 0
			std::uint32_t                   namedStateCount: 7;                 // 28 - 11
			std::uint32_t                   pad28_18: 14;                       // 28 - 18
			void*                           data;                               // 30

		private:
			void ReleaseData();
		};
		static_assert(sizeof(ObjectTypeInfo) == 0x38);
	}
}


===============================================
File: include/RE/O/ObjectiveState.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/Q/QuestObjectiveStates.h"

namespace RE
{
	class BGSQuestObjective;

	struct ObjectiveState
	{
	public:
		struct Event
		{
		public:
			// members
			BGSQuestObjective*    objective;  // 00
			QUEST_OBJECTIVE_STATE oldState;   // 08
			QUEST_OBJECTIVE_STATE newState;   // 0C
		};

		static BSTEventSource<Event>* GetEventSource();
	};
}


===============================================
File: include/RE/O/OldMessageBoxCallback.h
===============================================
#pragma once

#include "RE/I/IMessageBoxCallback.h"

namespace RE
{
	class OldMessageBoxCallback : public IMessageBoxCallback
	{
	public:
		inline static constexpr auto RTTI = RTTI___OldMessageBoxCallback;

		using Callback = void(Message);

		~OldMessageBoxCallback() override;  // 00

		// override (IMessageBoxCallback)
		void Run(Message a_msg) override;  // 01

		// members
		Callback* callback;  // 10
	};
	static_assert(sizeof(OldMessageBoxCallback) == 0x18);
}


===============================================
File: include/RE/O/OpenEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class OpenEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_OpenEffect;
		inline static constexpr auto VTABLE = VTABLE_OpenEffect;

		// override (ActiveEffect)
		virtual ~OpenEffect();          // 13
		virtual void Start() override;  // 14
	};
	static_assert(sizeof(OpenEffect) == 0x90);
}


===============================================
File: include/RE/Offsets.h
===============================================
#pragma once

#include "REL/Relocation.h"

namespace RE::Offset
{
	namespace Actor
	{
		constexpr auto AddSpell = RELOCATION_ID(37771, 38716);
		constexpr auto DispelWornItemEnchantments = RELOCATION_ID(33828, 34620);
		constexpr auto DoReset3D = RELOCATION_ID(39181, 40255);
		constexpr auto GetGhost = RELOCATION_ID(36286, 37275);
		constexpr auto GetHostileToActor = RELOCATION_ID(36537, 37537);
		constexpr auto GetLevel = RELOCATION_ID(36344, 37334);
		constexpr auto HasPerk = RELOCATION_ID(36690, 37698);
		constexpr auto IsRunning = RELOCATION_ID(36252, 37234);
		constexpr auto RequestDetectionLevel = RELOCATION_ID(36748, 37764);
		constexpr auto SwitchRace = RELOCATION_ID(36901, 37925);
		constexpr auto UpdateArmorAbility = RELOCATION_ID(37802, 38751);
		constexpr auto UpdateWeaponAbility = RELOCATION_ID(37803, 38752);
	}

	namespace ActorEquipManager
	{
		constexpr auto EquipObject = RELOCATION_ID(37938, 38894);
		constexpr auto Singleton = RELOCATION_ID(514494, 400636);
		constexpr auto UnequipObject = RELOCATION_ID(37945, 38901);
	}

	namespace ActorValueOwner
	{
		constexpr auto GetClampedActorValue = RELOCATION_ID(26616, 27284);
	}

	namespace AIProcess
	{
		constexpr auto SetBaseScale = RELOCATION_ID(38568, 39588);
		constexpr auto Update3DModel = RELOCATION_ID(38404, 39395);
	}

	namespace BGSFootstepManager
	{
		constexpr auto Singleton = RELOCATION_ID(517045, 403553);
	}

	namespace BGSListForm
	{
		constexpr auto AddForm = RELOCATION_ID(20470, 20913);
	}

	namespace BGSSaveLoadManager
	{
		constexpr auto Save = RELOCATION_ID(34818, 35727);
		constexpr auto Singleton = RELOCATION_ID(516860, 403340);
		constexpr auto Load = RELOCATION_ID(34819, 35728);
	}

	namespace BGSSkillPerkTreeNode
	{
		constexpr auto Ctor = RELOCATION_ID(26592, 27263);
	}

	namespace BGSStoryEventManager
	{
		constexpr auto AddEvent = RELOCATION_ID(31576, 32359);
		constexpr auto GetSingleton = RELOCATION_ID(22317, 22790);
	}

	namespace BGSStoryTeller
	{
		constexpr auto BeginShutDownQuest = RELOCATION_ID(31718, 32486);
		constexpr auto BeginStartUpQuest = RELOCATION_ID(31717, 32485);
		constexpr auto Singleton = RELOCATION_ID(514316, 400476);
	}

	namespace BipedAnim
	{
		constexpr auto Dtor = RELOCATION_ID(15491, 15656);
		constexpr auto RemoveAllParts = RELOCATION_ID(15494, 15659);
	}

	namespace BSAudioManager
	{
		constexpr auto GetSingleton = RELOCATION_ID(66391, 67652);
		constexpr auto BuildSoundDataFromDescriptor = RELOCATION_ID(66404, 67666);
	}

	namespace BSInputDeviceManager
	{
		constexpr auto Singleton = RELOCATION_ID(516574, 402776);
	}

	namespace BSLightingShaderMaterialBase
	{
		constexpr auto CreateMaterial = RELOCATION_ID(100016, 106723);
	}

	namespace BSReadWriteLock
	{
		constexpr auto LockForRead = RELOCATION_ID(66976, 68233);
		constexpr auto LockForWrite = RELOCATION_ID(66977, 68234);
		constexpr auto UnlockForRead = RELOCATION_ID(66982, 68239);
		constexpr auto UnlockForWrite = RELOCATION_ID(66983, 68240);
	}

	namespace BSResourceNiBinaryStream
	{
		constexpr auto Ctor = RELOCATION_ID(69636, 71014);
		constexpr auto Dtor = RELOCATION_ID(69638, 71016);
		constexpr auto Seek = RELOCATION_ID(69640, 71018);
		constexpr auto SetEndianSwap = RELOCATION_ID(69643, 71021);
	}

	namespace BSScaleformTranslator
	{
		constexpr auto GetCachedString = RELOCATION_ID(67844, 69188);
	}

	namespace BSScript
	{
		namespace ObjectBindPolicy
		{
			constexpr auto BindObject = RELOCATION_ID(97379, 104184);
		}

		namespace NF_util
		{
			namespace NativeFunctionBase
			{
				constexpr auto Call = RELOCATION_ID(97923, 104651);
			}
		}

		namespace Stack
		{
			constexpr auto Dtor = RELOCATION_ID(97742, 104480);
		}
	}

	namespace BSSoundHandle
	{
		constexpr auto IsValid = RELOCATION_ID(66360, 67621);
		constexpr auto Play = RELOCATION_ID(66355, 67616);
		constexpr auto SetObjectToFollow = RELOCATION_ID(66375, 67636);
		constexpr auto SetPosition = RELOCATION_ID(66370, 67631);
		constexpr auto Stop = RELOCATION_ID(66358, 67619);
	}

	namespace BSString
	{
		constexpr auto Set_CStr = RELOCATION_ID(10979, 11044);
	}

	namespace BucketTable
	{
		constexpr auto GetSingleton = RELOCATION_ID(67855, 69200);
	}

	namespace BSWin32SaveDataSystemUtility
	{
		constexpr auto GetSingleton = RELOCATION_ID(101884, 109278);
	}

	namespace Calendar
	{
		constexpr auto Singleton = RELOCATION_ID(514287, 400447);
	}

	namespace Console
	{
		constexpr auto SelectedRef = RELOCATION_ID(519394, 405935);
		constexpr auto SetSelectedRef = RELOCATION_ID(50164, 51093);
	}

	namespace ConsoleLog
	{
		constexpr auto Singleton = RELOCATION_ID(515064, 401203);
		constexpr auto VPrint = RELOCATION_ID(50180, 51110);
	}

	namespace ControlMap
	{
		constexpr auto Singleton = RELOCATION_ID(514705, 400863);
	}

	namespace CraftingSubMenus
	{
		namespace EnchantConstructMenu
		{
			constexpr auto RenameItem = RELOCATION_ID(50530, 51415);
			constexpr auto UpdateInterface = RELOCATION_ID(50567, 51459);
		}
	}

	namespace CRC32Calculator
	{
		constexpr auto SizeOf32 = RELOCATION_ID(66963, 12141);
		constexpr auto SizeOf64 = RELOCATION_ID(66964, 68221);
		constexpr auto SizeOfSize = RELOCATION_ID(66962, 68219);
	}

	namespace ExtraDataList
	{
		constexpr auto Add = RELOCATION_ID(12176, 12315);
		constexpr auto SetCount = RELOCATION_ID(11471, 11617);
		constexpr auto SetExtraFlags = RELOCATION_ID(11903, 12042);
		constexpr auto SetInventoryChanges = RELOCATION_ID(11483, 11600);
	}

	namespace GameSettingCollection
	{
		constexpr auto Singleton = RELOCATION_ID(514622, 400782);
	}

#if !defined(ENABLE_SKYRIM_SE) && !defined(ENABLE_SKYRIM_VR)
	namespace GASActionBufferData
	{
		constexpr auto Vtbl = RELOCATION_ID(0, 242366);
	}

	namespace GASDoAction
	{
		constexpr auto Vtbl = RELOCATION_ID(0, 242413);
	}

	namespace GASDoInitAction
	{
		constexpr auto Vtbl = RELOCATION_ID(0, 242414);
	}

	namespace GFxInitImportActions
	{
		constexpr auto Vtbl = RELOCATION_ID(0, 244866);
	}
#endif

	namespace GFxLoader
	{
		constexpr auto CreateMovie = RELOCATION_ID(80620, 84640);
	}

	namespace GFxMovieView
	{
		constexpr auto InvokeNoReturn = RELOCATION_ID(80547, 82665);
	}

#if !defined(ENABLE_SKYRIM_SE) && !defined(ENABLE_SKYRIM_VR)
    namespace GFxPlaceObject2
    {
        constexpr auto Vtbl = RELOCATION_ID(0, 242592);
    }

    namespace GFxPlaceObject3
    {
        constexpr auto Vtbl = RELOCATION_ID(0, 242593);
    }

    namespace GFxRemoveObject
    {
        constexpr auto Vtbl = RELOCATION_ID(0, 244863);
    }

    namespace GFxRemoveObject2
    {
        constexpr auto Vtbl = RELOCATION_ID(0, 244864);
    }

    namespace GFxSetBackgroundColor
    {
        constexpr auto Vtbl = RELOCATION_ID(0, 244865);
    }
#endif

	namespace GFxValue
	{
		namespace ObjectInterface
		{
			constexpr auto AttachMovie = RELOCATION_ID(80197, 82219);
			constexpr auto DeleteMember = RELOCATION_ID(80207, 82230);
			constexpr auto GetArraySize = RELOCATION_ID(80214, 82237);
            constexpr auto GetCxform = RELOCATION_ID(80215, 82238);
			constexpr auto GetDisplayInfo = RELOCATION_ID(80216, 82239);
            constexpr auto GetDisplayMatrix = RELOCATION_ID(80217, 82240);
			constexpr auto GetElement = RELOCATION_ID(80218, 82241);
			constexpr auto GetMember = RELOCATION_ID(80222, 82245);
			constexpr auto GotoAndPlay = RELOCATION_ID(80230, 82253);
			constexpr auto HasMember = RELOCATION_ID(80231, 82254);
			constexpr auto Invoke = RELOCATION_ID(80233, 82256);
			constexpr auto ObjectAddRef = RELOCATION_ID(80244, 82269);
			constexpr auto ObjectRelease = RELOCATION_ID(80245, 82270);
			constexpr auto PushBack = RELOCATION_ID(80248, 82273);
			constexpr auto RemoveElements = RELOCATION_ID(80252, 82280);
			constexpr auto SetArraySize = RELOCATION_ID(80261, 82285);
            constexpr auto SetCxform = RELOCATION_ID(80262, 82286);
			constexpr auto SetDisplayInfo = RELOCATION_ID(80263, 82287);
            constexpr auto SetDisplayMatrix = RELOCATION_ID(80264, 82288);
			constexpr auto SetElement = RELOCATION_ID(80265, 82289);
			constexpr auto SetMember = RELOCATION_ID(80268, 82292);
			constexpr auto SetText = RELOCATION_ID(80270, 82293);
            constexpr auto VisitMembers = RELOCATION_ID(80279, 82302);
		}
	}

	namespace GMemory
	{
		constexpr auto GlobalHeap = RELOCATION_ID(525584, 412058);
	}

	namespace hkReferencedObject
	{
		constexpr auto AddReference = RELOCATION_ID(56606, 57010);
		constexpr auto RemoveReference = RELOCATION_ID(56607, 57011);
	}

	namespace INIPrefSettingCollection
	{
		constexpr auto Singleton = RELOCATION_ID(523673, 410219);
	}

	namespace INISettingCollection
	{
		constexpr auto Singleton = RELOCATION_ID(524557, 411155);
	}

	namespace InterfaceStrings
	{
		constexpr auto Singleton = RELOCATION_ID(514286, 400446);
	}

	namespace Inventory
	{
		constexpr auto GetEventSource = RELOCATION_ID(15980, 16225);
	}

	namespace InventoryChanges
	{
		constexpr auto GetNextUniqueID = RELOCATION_ID(15908, 16148);
		constexpr auto SendContainerChangedEvent = RELOCATION_ID(15909, 16149);
		constexpr auto SetUniqueID = RELOCATION_ID(15907, 16149);
		constexpr auto TransferItemUID = RELOCATION_ID(15909, 16149);
	}

	namespace ItemCrafted
	{
		constexpr auto GetEventSource = RELOCATION_ID(50515, 51403);
	}

	namespace ItemList
	{
		constexpr auto Update = RELOCATION_ID(50099, 51031);
	}

	namespace ItemsPickpocketed
	{
		constexpr auto GetEventSource = RELOCATION_ID(50258, 51183);
	}

	namespace LocalMapCamera
	{
		constexpr auto Ctor = RELOCATION_ID(16084, 16325);
		constexpr auto SetNorthRotation = RELOCATION_ID(16089, 16330);
	}

	namespace MagicFavorites
	{
		constexpr auto Singleton = RELOCATION_ID(516858, 403337);
	}

	namespace MagicItem
	{
		constexpr auto CalculateCost = RELOCATION_ID(11213, 11321);
		constexpr auto GetCostliestEffectItem = RELOCATION_ID(11216, 11335);
	}

	namespace MagicTarget
	{
		constexpr auto HasMagicEffect = RELOCATION_ID(33733, 34517);
	}

	namespace Main
	{
		constexpr auto Singleton = RELOCATION_ID(516943, 403449);
	}

	namespace MenuControls
	{
		constexpr auto Singleton = RELOCATION_ID(515124, 401263);
	}

	namespace MessageDataFactoryManager
	{
		constexpr auto GetSingleton = RELOCATION_ID(22843, 52875);
	}

	namespace NiAVObject
	{
		constexpr auto SetMotionType = RELOCATION_ID(76033, 77866);
		constexpr auto Update = RELOCATION_ID(68900, 70251);
	}

	namespace NiCamera
	{
		constexpr auto WorldPtToScreenPt3 = RELOCATION_ID(69270, 70640);
	}

	namespace NiMemManager
	{
		constexpr auto Singleton = RELOCATION_ID(523759, 410319);
	}

	namespace NiNode
	{
		constexpr auto Ctor = RELOCATION_ID(68936, 70287);
	}

	namespace NiPoint3
	{
		constexpr auto Zero = RELOCATION_ID(523887, 410468);
	}

	namespace NiRefObject
	{
		constexpr auto TotalObjectCount = RELOCATION_ID(523912, 410493);
	}

	namespace NiSkinInstance
	{
		constexpr auto Ctor = RELOCATION_ID(69804, 71227);
	}

	namespace PlayerCamera
	{
		constexpr auto Singleton = RELOCATION_ID(514642, 400802);
		constexpr auto UpdateThirdPerson = RELOCATION_ID(49908, 50841);
	}

	namespace PlayerCharacter
	{
		namespace PlayerSkills
		{
			constexpr auto AdvanceLevel = RELOCATION_ID(40560, 41567);
		}

		constexpr auto ActivatePickRef = RELOCATION_ID(39471, 40548);
		constexpr auto GetArmorValue = RELOCATION_ID(39175, 40249);
		constexpr auto GetDamage = RELOCATION_ID(39179, 40253);
		constexpr auto GetNumTints = RELOCATION_ID(39614, 40700);
		constexpr auto GetTintMask = RELOCATION_ID(39612, 40698);
		constexpr auto PlayPickupEvent = RELOCATION_ID(39384, 40456);
		constexpr auto Singleton = RELOCATION_ID(517014, 403521);
		constexpr auto StartGrabObject = RELOCATION_ID(39475, 40552);
	}

	namespace PlayerControls
	{
		constexpr auto Ctor = RELOCATION_ID(41257, 42336);
		constexpr auto Singleton = RELOCATION_ID(514706, 400864);
	}

	namespace RaceSexMenu
	{
		constexpr auto ChangeName = RELOCATION_ID(51540, 52415);
	}

	namespace ReferenceEffectController
	{
		constexpr auto Start = RELOCATION_ID(33961, 34761);
	}

	namespace Script
	{
		constexpr auto CompileAndRun = RELOCATION_ID(21416, 21890);
		constexpr auto GetProcessScripts = RELOCATION_ID(21436, 21921);
		constexpr auto SetProcessScripts = RELOCATION_ID(21435, 21920);
	}

	namespace SCRIPT_FUNCTION
	{
		constexpr auto FirstConsoleCommand = RELOCATION_ID(501797, 365650);
		constexpr auto FirstScriptCommand = RELOCATION_ID(501789, 361120);
	}

	namespace Sky
	{
		constexpr auto GetSingleton = RELOCATION_ID(13789, 13878);
		constexpr auto SetWeather = RELOCATION_ID(25694, 26241);
		constexpr auto ForceWeather = RELOCATION_ID(25696, 26243);
		constexpr auto ResetWeather = RELOCATION_ID(25695, 26242);
	}

	namespace SkyrimVM
	{
		constexpr auto QueuePostRenderCall = RELOCATION_ID(53144, 53955);
        constexpr auto RelayEvent = RELOCATION_ID(53221, 54033);
		constexpr auto Singleton = RELOCATION_ID(514315, 400475);
	}

	namespace TES
	{
		constexpr auto Singleton = RELOCATION_ID(516923, 403450);
	}

	namespace TESCamera
	{
		constexpr auto SetState = RELOCATION_ID(32290, 33026);
	}

	namespace TESDataHandler
	{
		constexpr auto LoadScripts = RELOCATION_ID(13657, 13766);
		constexpr auto Singleton = RELOCATION_ID(514141, 400269);
	}

	namespace TESDescription
	{
		constexpr auto GetDescription = RELOCATION_ID(14399, 14552);
	}

	namespace TESFile
	{
		constexpr auto Duplicate = RELOCATION_ID(13923, 14018);
		constexpr auto GetCurrentSubRecordType = RELOCATION_ID(13902, 13988);
		constexpr auto GetFormType = RELOCATION_ID(13897, 13982);
		constexpr auto ReadData = RELOCATION_ID(13904, 13991);
		constexpr auto Seek = RELOCATION_ID(13898, 13984);
		constexpr auto SeekNextSubrecord = RELOCATION_ID(13903, 13990);
	}

	namespace TESHavokUtilities
	{
		constexpr auto FindCollidableRef = RELOCATION_ID(25466, 26003);
	}

	namespace TESNPC
	{
		constexpr auto ChangeHeadPart = RELOCATION_ID(24246, 24750);
		constexpr auto GetBaseOverlays = RELOCATION_ID(24275, 24791);
		constexpr auto GetNumBaseOverlays = RELOCATION_ID(24276, 24792);
		constexpr auto HasOverlays = RELOCATION_ID(24274, 24790);
		constexpr auto SetSkinFromTint = RELOCATION_ID(24206, 24710);
		constexpr auto UpdateNeck = RELOCATION_ID(24207, 24711);
	}

	namespace TESObjectREFR
	{
		constexpr auto FindReferenceFor3D = RELOCATION_ID(19323, 19750);
		constexpr auto GetDisplayFullName = RELOCATION_ID(19354, 19781);
		constexpr auto GetLock = RELOCATION_ID(19818, 20223);
		constexpr auto GetOwner = RELOCATION_ID(19789, 20194);
		constexpr auto GetStealValue = RELOCATION_ID(15807, 16045);
		constexpr auto InitInventoryIfRequired = RELOCATION_ID(15800, 16038);
		constexpr auto MoveTo = RELOCATION_ID(56227, 56626);
		constexpr auto PlayAnimation = RELOCATION_ID(14189, 14297);
	}

	namespace TESQuest
	{
		constexpr auto EnsureQuestStarted = RELOCATION_ID(24481, 25003);
		constexpr auto ResetQuest = RELOCATION_ID(24486, 25014);
	}

	namespace UI
	{
		constexpr auto Singleton = RELOCATION_ID(514178, 400327);
	}

	namespace UIBlurManager
	{
		constexpr auto DecrementBlurCount = RELOCATION_ID(51900, 52777);
		constexpr auto IncrementBlurCount = RELOCATION_ID(51899, 52776);
		constexpr auto Singleton = RELOCATION_ID(516871, 403350);
	}

	namespace UIMessageQueue
	{
		constexpr auto AddMessage = RELOCATION_ID(13530, 13631);
		constexpr auto CreateUIMessageData = RELOCATION_ID(80061, 82169);
		constexpr auto ProcessCommands = RELOCATION_ID(80059, 82167);
		constexpr auto Singleton = RELOCATION_ID(514285, 400445);
	}

	namespace UserEvents
	{
		constexpr auto Singleton = RELOCATION_ID(516458, 402638);
	}

	constexpr auto CreateRefHandle = RELOCATION_ID(12193, 12326);
	constexpr auto DebugNotification = RELOCATION_ID(52050, 52933);
	constexpr auto LookupReferenceByHandle = RELOCATION_ID(12204, 12332);
	constexpr auto PlaySound = RELOCATION_ID(52054, 52939);
	constexpr auto TlsIndex = RELOCATION_ID(528600, 415542);
    constexpr auto GlobalStateCounter = RELOCATION_ID(514157, 400305);
}


===============================================
File: include/RE/Offsets_NiRTTI.h
===============================================
#pragma once

#include "REL/Relocation.h"

namespace RE
{
	constexpr REL::VariantID NiRTTI_BGSAddonNodeSoundHandleExtra(514633, 400793, 0x2f8a838);
	constexpr REL::VariantID NiRTTI_BGSDecalNode(514417, 400564, 0x1f891a0);
	constexpr REL::VariantID NiRTTI_BSAnimGroupSequence(514462, 400606, 0x1f89358);
	constexpr REL::VariantID NiRTTI_BSAnimInteractionMarker(524679, 411294, 0x317cbd8);
	constexpr REL::VariantID NiRTTI_BSAnimNote(524418, 410999, 0x316d6c0);
	constexpr REL::VariantID NiRTTI_BSAnimNotes(524419, 411000, 0x316d6d0);
	constexpr REL::VariantID NiRTTI_BSBehaviorGraphExtraData(524621, 411261, 0x317ca20);
	constexpr REL::VariantID NiRTTI_BSBlastNode(524598, 411238, 0x317c900);
	constexpr REL::VariantID NiRTTI_BSBlendTreadTransfInterpolator(524358, 410939, 0x316d3a0);
	constexpr REL::VariantID NiRTTI_BSBloodSplatterShaderProperty(527906, 414853, 0x34851a0);
	constexpr REL::VariantID NiRTTI_BSBodyMorphOffsetsExtraData(524620, 411260, 0x317ca10);
	constexpr REL::VariantID NiRTTI_BSBoneLODExtraData(524706, 411326, 0x317e668);
	constexpr REL::VariantID NiRTTI_BSBoneMap(524677, 411292, 0x317cbc0);
	constexpr REL::VariantID NiRTTI_BSBound(524648, 411288, 0x317cb20);
	constexpr REL::VariantID NiRTTI_BSClearZNode(528336, 415282, 0x36f1748);
	constexpr REL::VariantID NiRTTI_BSCubeMapCamera(528279, 415229, 0x34d6180);
	constexpr REL::VariantID NiRTTI_BSCullingProcess(524626, 411266, 0x317ca58);
	constexpr REL::VariantID NiRTTI_BSDamageStage(524600, 411240, 0x317c920);
	constexpr REL::VariantID NiRTTI_BSDebrisNode(524599, 411239, 0x317c910);
	constexpr REL::VariantID NiRTTI_BSDecalPlacementVectorExtraData(524710, 411330, 0x317e6a8);
	constexpr REL::VariantID NiRTTI_BSDismemberSkinInstance(523941, 410521, 0x316be60);
	constexpr REL::VariantID NiRTTI_BSDistantObjectLargeRefExtraData(524689, 411304, 0x317cc48);
	constexpr REL::VariantID NiRTTI_BSDistantTreeShaderProperty(528220, 415170, 0x34d5fa0);
	constexpr REL::VariantID NiRTTI_BSDoorHavokController(517601, 404129, 0x2fff478);
	constexpr REL::VariantID NiRTTI_BSDynamicLines(528362, 415308, 0x36f1a80);
	constexpr REL::VariantID NiRTTI_BSDynamicTriShape(523953, 410533, 0x316bee0);
	constexpr REL::VariantID NiRTTI_BSEffectShaderProperty(527834, 414781, 0x3424340);
	constexpr REL::VariantID NiRTTI_BSEffectShaderPropertyColorController(528413, 415359, 0x36f1bc0);
	constexpr REL::VariantID NiRTTI_BSEffectShaderPropertyFloatController(528411, 415357, 0x36f1ba8);
	constexpr REL::VariantID NiRTTI_BSFaceGenAnimationData(515540, 401677, 0x2fc6670);
	constexpr REL::VariantID NiRTTI_BSFaceGenBaseMorphExtraData(515562, 401737, 0x2fccbb8);
	constexpr REL::VariantID NiRTTI_BSFaceGenModelExtraData(515558, 401733, 0x2fccb90);
	constexpr REL::VariantID NiRTTI_BSFaceGenMorphData(515563, 401738, 0x2fccbc8);
	constexpr REL::VariantID NiRTTI_BSFaceGenMorphDataHair(515565, 401740, 0x2fccbe8);
	constexpr REL::VariantID NiRTTI_BSFaceGenMorphDataHead(515564, 401739, 0x2fccbd8);
	constexpr REL::VariantID NiRTTI_BSFaceGenNiNode(515572, 401747, 0x2fccc28);
	constexpr REL::VariantID NiRTTI_BSFadeNode(527630, 414559, 0x3422f38);
	constexpr REL::VariantID NiRTTI_BSFadeNodeCuller(528214, 415164, 0x34d5f70);
	constexpr REL::VariantID NiRTTI_BSFlattenedBoneTree(523940, 410520, 0x316be18);
	constexpr REL::VariantID NiRTTI_BSFogProperty(528312, 415262, 0x34d6238);
	constexpr REL::VariantID NiRTTI_BSFrustumFOVController(524424, 411005, 0x316d720);
	constexpr REL::VariantID NiRTTI_BSFurnitureMarkerNode(524633, 411273, 0x317caa0);
	constexpr REL::VariantID NiRTTI_BSGeometry(523951, 410531, 0x316bec8);
	constexpr REL::VariantID NiRTTI_BSGeometryListCullingProcess(524686, 411301, 0x317cc20);
	constexpr REL::VariantID NiRTTI_BSGrabIKNote(524420, 411001, 0x316d6e0);
	constexpr REL::VariantID NiRTTI_BSGrassShaderProperty(527760, 414683, 0x3423e58);
	constexpr REL::VariantID NiRTTI_BSInstanceTriShape(524722, 411342, 0x317e770);
	constexpr REL::VariantID NiRTTI_BSInvMarker(524704, 411324, 0x317e650);
	constexpr REL::VariantID NiRTTI_BSLODMultiIndexTriShape(528536, 415482, 0x36f1ec8);
	constexpr REL::VariantID NiRTTI_BSLODTriShape(524017, 410597, 0x316c2f0);
	constexpr REL::VariantID NiRTTI_BSLagBoneController(524718, 411338, 0x317e720);
	constexpr REL::VariantID NiRTTI_BSLeafAnimNode(527635, 414564, 0x3422f78);
	constexpr REL::VariantID NiRTTI_BSLightingShaderProperty(527752, 414675, 0x3423e20);
	constexpr REL::VariantID NiRTTI_BSLightingShaderPropertyColorController(528400, 415346, 0x36f1b70);
	constexpr REL::VariantID NiRTTI_BSLightingShaderPropertyFloatController(528394, 415340, 0x36f1b40);
	constexpr REL::VariantID NiRTTI_BSLightingShaderPropertyUShortController(528397, 415343, 0x36f1b58);
	constexpr REL::VariantID NiRTTI_BSLines(528361, 415307, 0x36f1a70);
	constexpr REL::VariantID NiRTTI_BSLookIKNote(524421, 411002, 0x316d6f0);
	constexpr REL::VariantID NiRTTI_BSMasterParticleSystem(524698, 411318, 0x317e618);
	constexpr REL::VariantID NiRTTI_BSMeshLODTriShape(528535, 415481, 0x317e750);
	constexpr REL::VariantID NiRTTI_BSMultiBound(524551, 411149, 0x3175f88);
	constexpr REL::VariantID NiRTTI_BSMultiBoundAABB(524554, 411152, 0x3175fb0);
	constexpr REL::VariantID NiRTTI_BSMultiBoundCapsule(524714, 411334, 0x317e6e0);
	constexpr REL::VariantID NiRTTI_BSMultiBoundNode(524676, 411291, 0x317cbb0);
	constexpr REL::VariantID NiRTTI_BSMultiBoundOBB(524556, 411154, 0x3175fc8);
	constexpr REL::VariantID NiRTTI_BSMultiBoundRoom(524552, 411150, 0x3175f98);
	constexpr REL::VariantID NiRTTI_BSMultiBoundShape(524611, 411251, 0x317c998);
	constexpr REL::VariantID NiRTTI_BSMultiBoundSphere(524612, 411252, 0x317c9a8);
	constexpr REL::VariantID NiRTTI_BSMultiIndexTriShape(528364, 415310, 0x36f1aa0);
	constexpr REL::VariantID NiRTTI_BSMultiStreamInstanceTriShape(524606, 411246, 0x317c968);
	constexpr REL::VariantID NiRTTI_BSMultiTargetTreadTransfController(524062, 410643, 0x316c4c8);
	constexpr REL::VariantID NiRTTI_BSNiAlphaPropertyTestRefController(528414, 415360, 0x36f1bd0);
	constexpr REL::VariantID NiRTTI_BSNiNode(524721, 411341, 0x317e760);
	constexpr REL::VariantID NiRTTI_BSNodeReferences(524709, 411329, 0x317e698);
	constexpr REL::VariantID NiRTTI_BSNonUniformScaleExtraData(524719, 411339, 0x317e730);
	constexpr REL::VariantID NiRTTI_BSOcclusionBox(524614, 411254, 0x317c9c0);
	constexpr REL::VariantID NiRTTI_BSOcclusionPlane(524616, 411256, 0x317c9d8);
	constexpr REL::VariantID NiRTTI_BSOcclusionShape(524577, 411194, 0x317c5d0);
	constexpr REL::VariantID NiRTTI_BSOrderedNode(528360, 415306, 0x36f1a60);
	constexpr REL::VariantID NiRTTI_BSPSysArrayEmitter(524601, 411241, 0x317c930);
	constexpr REL::VariantID NiRTTI_BSPSysHavokUpdateModifier(524468, 411049, 0x316d850);
	constexpr REL::VariantID NiRTTI_BSPSysInheritVelocityModifier(524534, 411113, 0x316dc08);
	constexpr REL::VariantID NiRTTI_BSPSysLODModifier(528416, 415362, 0x36f1bf0);
	constexpr REL::VariantID NiRTTI_BSPSysMultiTargetEmitterCtlr(524684, 411299, 0x317cc08);
	constexpr REL::VariantID NiRTTI_BSPSysRecycleBoundModifier(524533, 411112, 0x316dbf8);
	constexpr REL::VariantID NiRTTI_BSPSysScaleModifier(524717, 411337, 0x317e710);
	constexpr REL::VariantID NiRTTI_BSPSysSimpleColorModifier(528415, 415361, 0x36f1be0);
	constexpr REL::VariantID NiRTTI_BSPSysStripUpdateModifier(524715, 411335, 0x317e6f0);
	constexpr REL::VariantID NiRTTI_BSPSysSubTexModifier(524716, 411336, 0x317e700);
	constexpr REL::VariantID NiRTTI_BSParabolicCullingProcess(528534, 415480, 0x36f1eb8);
	constexpr REL::VariantID NiRTTI_BSParentVelocityModifier(524711, 411331, 0x317e6b8);
	constexpr REL::VariantID NiRTTI_BSParticleShaderProperty(527992, 414937, 0x3485758);
	constexpr REL::VariantID NiRTTI_BSParticleSystemManager(524629, 411269, 0x317ca78);
	constexpr REL::VariantID NiRTTI_BSPlayerDistanceCheckController(517602, 404130, 0x2fff488);
	constexpr REL::VariantID NiRTTI_BSPortal(524617, 411257, 0x317c9e8);
	constexpr REL::VariantID NiRTTI_BSPortalSharedNode(524618, 411258, 0x317c9f8);
	constexpr REL::VariantID NiRTTI_BSProceduralLightningController(524703, 411323, 0x317e640);
	constexpr REL::VariantID NiRTTI_BSRangeNode(524594, 411234, 0x317c6c8);
	constexpr REL::VariantID NiRTTI_BSReference(524708, 411328, 0x317e688);
	constexpr REL::VariantID NiRTTI_BSRotAccumTransfInterpolator(524422, 411003, 0x316d700);
	constexpr REL::VariantID NiRTTI_BSSceneGraph(524681, 411296, 0x317cbf0);
	constexpr REL::VariantID NiRTTI_BSSegmentedTriShape(524019, 410599, 0x316c318);
	constexpr REL::VariantID NiRTTI_BSShaderAccumulator(527798, 414751, 0x3424080);
	constexpr REL::VariantID NiRTTI_BSShaderProperty(527634, 414563, 0x3422f68);
	constexpr REL::VariantID NiRTTI_BSShaderTextureSet(528104, 415049, 0x3485b98);
	constexpr REL::VariantID NiRTTI_BSSimpleScaleController(517603, 404131, 0x2fff498);
	constexpr REL::VariantID NiRTTI_BSSkyShaderProperty(528205, 415149, 0x3485ea8);
	constexpr REL::VariantID NiRTTI_BSSplatterExtraData(514508, 400667, 0x2f8a3d0);
	constexpr REL::VariantID NiRTTI_BSStripPSysData(524531, 411110, 0x316dbe0);
	constexpr REL::VariantID NiRTTI_BSStripParticleSystem(524474, 411055, 0x316d890);
	constexpr REL::VariantID NiRTTI_BSSubIndexLandTriShape(528538, 415484, 0x36f1ee0);
	constexpr REL::VariantID NiRTTI_BSSubIndexTriShape(524688, 411303, 0x317cc38);
	constexpr REL::VariantID NiRTTI_BSTempEffect(515912, 402009, 0x2fd2318);
	constexpr REL::VariantID NiRTTI_BSTempEffectDebris(515921, 402018, 0x2fd2398);
	constexpr REL::VariantID NiRTTI_BSTempEffectGeometryDecal(515924, 402021, 0x2fd23b8);
	constexpr REL::VariantID NiRTTI_BSTempEffectParticle(515935, 402032, 0x2fd2468);
	constexpr REL::VariantID NiRTTI_BSTempEffectSPG(515940, 402037, 0x2fd24a8);
	constexpr REL::VariantID NiRTTI_BSTempEffectSimpleDecal(515938, 402035, 0x2fd2490);
	constexpr REL::VariantID NiRTTI_BSTempNode(524573, 411190, 0x317c5b0);
	constexpr REL::VariantID NiRTTI_BSTempNodeManager(524572, 411189, 0x317c5a0);
	constexpr REL::VariantID NiRTTI_BSTextureSet(528103, 415048, 0x3485b88);
	constexpr REL::VariantID NiRTTI_BSTreadTransfInterpolator(524423, 411004, 0x316d710);
	constexpr REL::VariantID NiRTTI_BSTreeNode(527636, 414565, 0x3422f88);
	constexpr REL::VariantID NiRTTI_BSTriShape(523928, 410508, 0x316adb0);
	constexpr REL::VariantID NiRTTI_BSValueNode(524560, 411158, 0x3176000);
	constexpr REL::VariantID NiRTTI_BSWArray(524712, 411332, 0x317e6c8);
	constexpr REL::VariantID NiRTTI_BSWaterShaderProperty(527905, 414852, 0x3485190);
	constexpr REL::VariantID NiRTTI_BSWindModifier(524568, 411185, 0x317c580);
	constexpr REL::VariantID NiRTTI_BSXFlags(524558, 411156, 0x3175fe8);
	constexpr REL::VariantID NiRTTI_DebugTextExtraData(525589, 412094, 0x318ce70);
	constexpr REL::VariantID NiRTTI_ModelReferenceEffect(516697, 402943, 0x2feac88);
	constexpr REL::VariantID NiRTTI_NiAVObject(523895, 410476, 0x316ab40);
	constexpr REL::VariantID NiRTTI_NiAVObjectPalette(523977, 410557, 0x316c0e0);
	constexpr REL::VariantID NiRTTI_NiAccumulator(524024, 410605, 0x316c350);
	constexpr REL::VariantID NiRTTI_NiAdditionalGeometryData(524018, 410598, 0x316c300);
	constexpr REL::VariantID NiRTTI_NiAlphaAccumulator(523989, 410569, 0x316c148);
	constexpr REL::VariantID NiRTTI_NiAlphaProperty(523931, 410511, 0x316add8);
	constexpr REL::VariantID NiRTTI_NiAmbientLight(523990, 410570, 0x316c158);
	constexpr REL::VariantID NiRTTI_NiBSBoneLODController(524623, 411263, 0x317ca38);
	constexpr REL::VariantID NiRTTI_NiBSPNode(523993, 410573, 0x316c188);
	constexpr REL::VariantID NiRTTI_NiBSplineBasisData(524386, 410967, 0x316d4c8);
	constexpr REL::VariantID NiRTTI_NiBSplineColorInterpolator(524388, 410969, 0x316d4e8);
	constexpr REL::VariantID NiRTTI_NiBSplineCompColorInterpolator(524389, 410970, 0x316d4f8);
	constexpr REL::VariantID NiRTTI_NiBSplineCompFloatInterpolator(524390, 410971, 0x316d508);
	constexpr REL::VariantID NiRTTI_NiBSplineCompPoint3Interpolator(524391, 410972, 0x316d518);
	constexpr REL::VariantID NiRTTI_NiBSplineCompTransformInterpolator(524392, 410973, 0x316d528);
	constexpr REL::VariantID NiRTTI_NiBSplineData(524387, 410968, 0x316d4d8);
	constexpr REL::VariantID NiRTTI_NiBSplineFloatInterpolator(524393, 410974, 0x316d538);
	constexpr REL::VariantID NiRTTI_NiBSplineInterpolator(524459, 411040, 0x316d7c8);
	constexpr REL::VariantID NiRTTI_NiBSplinePoint3Interpolator(524394, 410975, 0x316d548);
	constexpr REL::VariantID NiRTTI_NiBSplineTransformInterpolator(524395, 410976, 0x316d558);
	constexpr REL::VariantID NiRTTI_NiBackToFrontAccumulator(524025, 410604, 0x316c360);
	constexpr REL::VariantID NiRTTI_NiBillboardNode(523959, 410539, 0x316bf28);
	constexpr REL::VariantID NiRTTI_NiBinaryExtraData(523991, 410571, 0x316c168);
	constexpr REL::VariantID NiRTTI_NiBlendAccumTransformInterpolator(524352, 410933, 0x316d370);
	constexpr REL::VariantID NiRTTI_NiBlendBoolInterpolator(524379, 410960, 0x316d458);
	constexpr REL::VariantID NiRTTI_NiBlendColorInterpolator(524380, 410961, 0x316d468);
	constexpr REL::VariantID NiRTTI_NiBlendFloatInterpolator(524349, 410930, 0x316d338);
	constexpr REL::VariantID NiRTTI_NiBlendInterpolator(524060, 410641, 0x316c4a8);
	constexpr REL::VariantID NiRTTI_NiBlendPoint3Interpolator(524381, 410962, 0x316d478);
	constexpr REL::VariantID NiRTTI_NiBlendQuaternionInterpolator(524382, 410963, 0x316d488);
	constexpr REL::VariantID NiRTTI_NiBlendTransformInterpolator(524348, 410929, 0x316d328);
	constexpr REL::VariantID NiRTTI_NiBoolData(524383, 410964, 0x316d498);
	constexpr REL::VariantID NiRTTI_NiBoolInterpController(524463, 411044, 0x316d808);
	constexpr REL::VariantID NiRTTI_NiBoolInterpolator(524384, 410965, 0x316d4a8);
	constexpr REL::VariantID NiRTTI_NiBoolTimelineInterpolator(524385, 410966, 0x316d4b8);
	constexpr REL::VariantID NiRTTI_NiBooleanExtraData(523992, 410572, 0x316c178);
	constexpr REL::VariantID NiRTTI_NiCamera(523926, 410506, 0x316ad98);
	constexpr REL::VariantID NiRTTI_NiCollisionData(524035, 410614, 0x316c3c8);
	constexpr REL::VariantID NiRTTI_NiCollisionObject(528359, 415305, 0x36f1a50);
	constexpr REL::VariantID NiRTTI_NiColorData(524340, 410921, 0x316d2c8);
	constexpr REL::VariantID NiRTTI_NiColorExtraData(523994, 410574, 0x316c198);
	constexpr REL::VariantID NiRTTI_NiColorExtraDataController(524396, 410977, 0x316d568);
	constexpr REL::VariantID NiRTTI_NiColorInterpolator(524341, 410922, 0x316d2d8);
	constexpr REL::VariantID NiRTTI_NiControllerManager(524054, 410635, 0x316c458);
	constexpr REL::VariantID NiRTTI_NiControllerSequence(524057, 410638, 0x316c478);
	constexpr REL::VariantID NiRTTI_NiCullingProcess(523961, 410541, 0x316bf48);
	constexpr REL::VariantID NiRTTI_NiDefaultAVObjectPalette(523955, 410535, 0x316bf00);
	constexpr REL::VariantID NiRTTI_NiDirectionalLight(523960, 410540, 0x316bf38);
	constexpr REL::VariantID NiRTTI_NiExtraData(523948, 410528, 0x316bea0);
	constexpr REL::VariantID NiRTTI_NiExtraDataController(524458, 411039, 0x316d7b8);
	constexpr REL::VariantID NiRTTI_NiFloatController(524462, 411043, 0x316d7f8);
	constexpr REL::VariantID NiRTTI_NiFloatData(524338, 410919, 0x316d2a8);
	constexpr REL::VariantID NiRTTI_NiFloatExtraData(523995, 410575, 0x316c1a8);
	constexpr REL::VariantID NiRTTI_NiFloatExtraDataController(524350, 410931, 0x316d348);
	constexpr REL::VariantID NiRTTI_NiFloatInterpController(524461, 411042, 0x316d7e8);
	constexpr REL::VariantID NiRTTI_NiFloatInterpolator(524339, 410920, 0x316d2b8);
	constexpr REL::VariantID NiRTTI_NiFloatsExtraData(523996, 410576, 0x316c1b8);
	constexpr REL::VariantID NiRTTI_NiFloatsExtraDataController(524397, 410978, 0x316d578);
	constexpr REL::VariantID NiRTTI_NiFloatsExtraDataPoint3Controller(524398, 410979, 0x316d588);
	constexpr REL::VariantID NiRTTI_NiFogProperty(523997, 410577, 0x316c1c8);
	constexpr REL::VariantID NiRTTI_NiGeometry(523978, 410558, 0x316c0f0);
	constexpr REL::VariantID NiRTTI_NiGeometryData(523949, 410529, 0x316beb0);
	constexpr REL::VariantID NiRTTI_NiIntegerExtraData(523999, 410579, 0x316c1e0);
	constexpr REL::VariantID NiRTTI_NiIntegersExtraData(524000, 410580, 0x316c1f0);
	constexpr REL::VariantID NiRTTI_NiInterpController(524063, 410644, 0x316c4d8);
	constexpr REL::VariantID NiRTTI_NiInterpolator(524353, 410934, 0x316d380);
	constexpr REL::VariantID NiRTTI_NiKeyBasedInterpolator(524361, 410942, 0x316d3b8);
	constexpr REL::VariantID NiRTTI_NiKeyframeManager(524399, 410980, 0x316d5a0);
	constexpr REL::VariantID NiRTTI_NiLight(523923, 410503, 0x316ad68);
	constexpr REL::VariantID NiRTTI_NiLightColorController(524400, 410981, 0x316d5b0);
	constexpr REL::VariantID NiRTTI_NiLightDimmerController(524401, 410982, 0x316d5c0);
	constexpr REL::VariantID NiRTTI_NiLookAtController(524402, 410983, 0x316d5d0);
	constexpr REL::VariantID NiRTTI_NiLookAtInterpolator(524403, 410984, 0x316d5e0);
	constexpr REL::VariantID NiRTTI_NiMeshPSysData(524481, 411062, 0x316d8f8);
	constexpr REL::VariantID NiRTTI_NiMeshParticleSystem(524470, 411051, 0x316d868);
	constexpr REL::VariantID NiRTTI_NiMorphData(524404, 410985, 0x316d5f0);
	constexpr REL::VariantID NiRTTI_NiMultiTargetTransformController(524061, 410642, 0x316c4b8);
	constexpr REL::VariantID NiRTTI_NiNode(523900, 410481, 0x316ab78);
	constexpr REL::VariantID NiRTTI_NiObject(523891, 410472, 0x316ab08);
	constexpr REL::VariantID NiRTTI_NiObjectNET(523910, 410491, 0x316ad08);
	constexpr REL::VariantID NiRTTI_NiPSysAgeDeathModifier(524486, 411067, 0x316d948);
	constexpr REL::VariantID NiRTTI_NiPSysAirFieldAirFrictionCtlr(524482, 411063, 0x316d908);
	constexpr REL::VariantID NiRTTI_NiPSysAirFieldInheritVelocityCtlr(524483, 411064, 0x316d918);
	constexpr REL::VariantID NiRTTI_NiPSysAirFieldModifier(524484, 411065, 0x316d928);
	constexpr REL::VariantID NiRTTI_NiPSysAirFieldSpreadCtlr(524485, 411066, 0x316d938);
	constexpr REL::VariantID NiRTTI_NiPSysBombModifier(524487, 411068, 0x316d958);
	constexpr REL::VariantID NiRTTI_NiPSysBoundUpdateModifier(524488, 411069, 0x316d968);
	constexpr REL::VariantID NiRTTI_NiPSysBoxEmitter(524489, 411070, 0x316d978);
	constexpr REL::VariantID NiRTTI_NiPSysCollider(524539, 411118, 0x316dc58);
	constexpr REL::VariantID NiRTTI_NiPSysColliderManager(524490, 411071, 0x316d988);
	constexpr REL::VariantID NiRTTI_NiPSysColorModifier(524491, 411072, 0x316d998);
	constexpr REL::VariantID NiRTTI_NiPSysCylinderEmitter(524473, 411054, 0x316d880);
	constexpr REL::VariantID NiRTTI_NiPSysData(524492, 411073, 0x316d9a8);
	constexpr REL::VariantID NiRTTI_NiPSysDragFieldModifier(524493, 411074, 0x316d9b8);
	constexpr REL::VariantID NiRTTI_NiPSysDragModifier(524494, 411075, 0x316d9c8);
	constexpr REL::VariantID NiRTTI_NiPSysEmitter(524475, 411056, 0x316d8a0);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterCtlr(524466, 411047, 0x316d830);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterCtlrData(524495, 411076, 0x316d9d8);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterDeclinationCtlr(524496, 411077, 0x316d9e8);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterDeclinationVarCtlr(524497, 411078, 0x316d9f8);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterInitialRadiusCtlr(524498, 411079, 0x316da08);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterLifeSpanCtlr(524499, 411080, 0x316da18);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterPlanarAngleCtlr(524500, 411081, 0x316da28);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterPlanarAngleVarCtlr(524501, 411082, 0x316da38);
	constexpr REL::VariantID NiRTTI_NiPSysEmitterSpeedCtlr(524502, 411083, 0x316da48);
	constexpr REL::VariantID NiRTTI_NiPSysFieldAttenuationCtlr(524503, 411084, 0x316da58);
	constexpr REL::VariantID NiRTTI_NiPSysFieldMagnitudeCtlr(524504, 411085, 0x316da68);
	constexpr REL::VariantID NiRTTI_NiPSysFieldMaxDistanceCtlr(524505, 411086, 0x316da78);
	constexpr REL::VariantID NiRTTI_NiPSysFieldModifier(524537, 411116, 0x316dc38);
	constexpr REL::VariantID NiRTTI_NiPSysGravityFieldModifier(524506, 411087, 0x316da88);
	constexpr REL::VariantID NiRTTI_NiPSysGravityModifier(524467, 411048, 0x316d840);
	constexpr REL::VariantID NiRTTI_NiPSysGravityStrengthCtlr(524507, 411088, 0x316da98);
	constexpr REL::VariantID NiRTTI_NiPSysGrowFadeModifier(524508, 411089, 0x316daa8);
	constexpr REL::VariantID NiRTTI_NiPSysInitialRotAngleCtlr(524509, 411090, 0x316dab8);
	constexpr REL::VariantID NiRTTI_NiPSysInitialRotAngleVarCtlr(524510, 411091, 0x316dac8);
	constexpr REL::VariantID NiRTTI_NiPSysInitialRotSpeedCtlr(524511, 411092, 0x316dad8);
	constexpr REL::VariantID NiRTTI_NiPSysInitialRotSpeedVarCtlr(524512, 411093, 0x316dae8);
	constexpr REL::VariantID NiRTTI_NiPSysMeshEmitter(524513, 411094, 0x316daf8);
	constexpr REL::VariantID NiRTTI_NiPSysMeshUpdateModifier(524479, 411060, 0x316d8d8);
	constexpr REL::VariantID NiRTTI_NiPSysModifier(524478, 411059, 0x316d8c8);
	constexpr REL::VariantID NiRTTI_NiPSysModifierActiveCtlr(524518, 411099, 0x316db28);
	constexpr REL::VariantID NiRTTI_NiPSysModifierBoolCtlr(524538, 411117, 0x316dc48);
	constexpr REL::VariantID NiRTTI_NiPSysModifierCtlr(524477, 411057, 0x316d8b8);
	constexpr REL::VariantID NiRTTI_NiPSysModifierFloatCtlr(524536, 411115, 0x316dc28);
	constexpr REL::VariantID NiRTTI_NiPSysPlanarCollider(524519, 411100, 0x316db38);
	constexpr REL::VariantID NiRTTI_NiPSysPositionModifier(524522, 411101, 0x316db50);
	constexpr REL::VariantID NiRTTI_NiPSysRadialFieldModifier(524523, 411102, 0x316db60);
	constexpr REL::VariantID NiRTTI_NiPSysResetOnLoopCtlr(524524, 411103, 0x316db70);
	constexpr REL::VariantID NiRTTI_NiPSysRotationModifier(524525, 411104, 0x316db80);
	constexpr REL::VariantID NiRTTI_NiPSysSpawnModifier(524526, 411105, 0x316db90);
	constexpr REL::VariantID NiRTTI_NiPSysSphereEmitter(524527, 411106, 0x316dba0);
	constexpr REL::VariantID NiRTTI_NiPSysSphericalCollider(524528, 411107, 0x316dbb0);
	constexpr REL::VariantID NiRTTI_NiPSysTurbulenceFieldModifier(524529, 411108, 0x316dbc0);
	constexpr REL::VariantID NiRTTI_NiPSysUpdateCtlr(524480, 411061, 0x316d8e8);
	constexpr REL::VariantID NiRTTI_NiPSysVolumeEmitter(524535, 411114, 0x316dc18);
	constexpr REL::VariantID NiRTTI_NiPSysVortexFieldModifier(524530, 411109, 0x316dbd0);
	constexpr REL::VariantID NiRTTI_NiParticleMeshes(524006, 410586, 0x316c258);
	constexpr REL::VariantID NiRTTI_NiParticleMeshesData(524005, 410585, 0x316c248);
	constexpr REL::VariantID NiRTTI_NiParticleSystem(524465, 411046, 0x316d820);
	constexpr REL::VariantID NiRTTI_NiParticles(523963, 410543, 0x316bf60);
	constexpr REL::VariantID NiRTTI_NiParticlesData(524004, 410584, 0x316c238);
	constexpr REL::VariantID NiRTTI_NiPathController(524405, 410986, 0x316d600);
	constexpr REL::VariantID NiRTTI_NiPathInterpolator(524344, 410925, 0x316d308);
	constexpr REL::VariantID NiRTTI_NiPoint3InterpController(524460, 411041, 0x316d7d8);
	constexpr REL::VariantID NiRTTI_NiPoint3Interpolator(524406, 410987, 0x316d610);
	constexpr REL::VariantID NiRTTI_NiPointLight(523954, 410534, 0x316bef0);
	constexpr REL::VariantID NiRTTI_NiPosData(524378, 410959, 0x316d448);
	constexpr REL::VariantID NiRTTI_NiProperty(523929, 410509, 0x316adc0);
	constexpr REL::VariantID NiRTTI_NiQuaternionInterpolator(524407, 410988, 0x316d620);
	constexpr REL::VariantID NiRTTI_NiRollController(524408, 410989, 0x316d630);
	constexpr REL::VariantID NiRTTI_NiRotData(524409, 410990, 0x316d640);
	constexpr REL::VariantID NiRTTI_NiSequence(524410, 410991, 0x316d650);
	constexpr REL::VariantID NiRTTI_NiSequenceStreamHelper(524413, 410994, 0x316d670);
	constexpr REL::VariantID NiRTTI_NiShadeProperty(523987, 410567, 0x316c130);
	constexpr REL::VariantID NiRTTI_NiSingleInterpController(524342, 410923, 0x316d2e8);
	constexpr REL::VariantID NiRTTI_NiSkinData(523986, 410566, 0x316c120);
	constexpr REL::VariantID NiRTTI_NiSkinInstance(523976, 410556, 0x316c0d0);
	constexpr REL::VariantID NiRTTI_NiSkinPartition(523974, 410554, 0x316c0b0);
	constexpr REL::VariantID NiRTTI_NiSourceTexture(523939, 410519, 0x316be08);
	constexpr REL::VariantID NiRTTI_NiSpotLight(524007, 410587, 0x316c268);
	constexpr REL::VariantID NiRTTI_NiStringExtraData(523942, 410522, 0x316be70);
	constexpr REL::VariantID NiRTTI_NiStringPalette(524414, 410995, 0x316d680);
	constexpr REL::VariantID NiRTTI_NiStringsExtraData(523925, 410505, 0x316ad88);
	constexpr REL::VariantID NiRTTI_NiSwitchNode(523924, 410504, 0x316ad78);
	constexpr REL::VariantID NiRTTI_NiSwitchStringExtraData(524008, 410588, 0x316c278);
	constexpr REL::VariantID NiRTTI_NiTextKeyExtraData(524415, 410996, 0x316d690);
	constexpr REL::VariantID NiRTTI_NiTexture(523967, 410547, 0x316bfa0);
	constexpr REL::VariantID NiRTTI_NiTimeController(523943, 410523, 0x316be80);
	constexpr REL::VariantID NiRTTI_NiTransformController(524351, 410932, 0x316d358);
	constexpr REL::VariantID NiRTTI_NiTransformData(524377, 410958, 0x316d438);
	constexpr REL::VariantID NiRTTI_NiTransformInterpolator(524343, 410924, 0x316d2f8);
	constexpr REL::VariantID NiRTTI_NiTriBasedGeom(524027, 410607, 0x316c380);
	constexpr REL::VariantID NiRTTI_NiTriBasedGeomData(524026, 410606, 0x316c370);
	constexpr REL::VariantID NiRTTI_NiTriShape(524010, 410590, 0x316c298);
	constexpr REL::VariantID NiRTTI_NiTriShapeData(524009, 410589, 0x316c288);
	constexpr REL::VariantID NiRTTI_NiTriStrips(524012, 410592, 0x316c2b8);
	constexpr REL::VariantID NiRTTI_NiTriStripsData(524011, 410591, 0x316c2a8);
	constexpr REL::VariantID NiRTTI_NiUVData(524416, 410997, 0x316d6a0);
	constexpr REL::VariantID NiRTTI_NiVectorExtraData(524013, 410593, 0x316c2c8);
	constexpr REL::VariantID NiRTTI_NiVertWeightsExtraData(523975, 410555, 0x316c0c0);
	constexpr REL::VariantID NiRTTI_NiVisController(524417, 410998, 0x316d6b0);
	constexpr REL::VariantID NiRTTI_PArrayPoint(524602, 411242, 0x317c940);
	constexpr REL::VariantID NiRTTI_REFRSyncController(514966, 401106, 0x2fc48b0);
	constexpr REL::VariantID NiRTTI_ReferenceEffect(516706, 402952, 0x2feacc8);
	constexpr REL::VariantID NiRTTI_SceneGraph(517222, 403753, 0x2ffd750);
	constexpr REL::VariantID NiRTTI_ShaderReferenceEffect(516712, 402958, 0x2feacf8);
	constexpr REL::VariantID NiRTTI_ShadowSceneNode(527735, 414664, 0x3423520);
	constexpr REL::VariantID NiRTTI_SummonPlacementEffect(516720, 402966, 0x2fead28);
	constexpr REL::VariantID NiRTTI_WeaponObject(525102, 411577, 0x31880b0);
	constexpr REL::VariantID NiRTTI_bhkAabbPhantom(525121, 411596, 0x3188180);
	constexpr REL::VariantID NiRTTI_bhkAction(525160, 411637, 0x3188368);
	constexpr REL::VariantID NiRTTI_bhkAngularDashpotAction(525243, 411719, 0x3189318);
	constexpr REL::VariantID NiRTTI_bhkAttachmentCollisionObject(525101, 411576, 0x31880a0);
	constexpr REL::VariantID NiRTTI_bhkAutoWater(516226, 402390, 0x2fe9890);
	constexpr REL::VariantID NiRTTI_bhkAvoidBox(525150, 411625, 0x31882f0);
	constexpr REL::VariantID NiRTTI_bhkBallAndSocketConstraint(525223, 411699, 0x3189228);
	constexpr REL::VariantID NiRTTI_bhkBallSocketConstraintChain(525225, 411701, 0x3189240);
	constexpr REL::VariantID NiRTTI_bhkBinaryAction(525460, 411936, 0x318b608);
	constexpr REL::VariantID NiRTTI_bhkBlendCollisionObject(525147, 411622, 0x31882d0);
	constexpr REL::VariantID NiRTTI_bhkBlendController(525255, 411731, 0x31893a8);
	constexpr REL::VariantID NiRTTI_bhkBoxShape(525136, 411611, 0x3188230);
	constexpr REL::VariantID NiRTTI_bhkBreakableConstraint(525241, 411717, 0x3189300);
	constexpr REL::VariantID NiRTTI_bhkBvTreeShape(525140, 411615, 0x3188260);
	constexpr REL::VariantID NiRTTI_bhkCachingShapePhantom(525177, 411653, 0x3189008);
	constexpr REL::VariantID NiRTTI_bhkCapsuleShape(525134, 411609, 0x3188218);
	constexpr REL::VariantID NiRTTI_bhkCartTether(515427, 401566, 0x2fc6008);
	constexpr REL::VariantID NiRTTI_bhkCharControllerShape(525261, 411737, 0x31893f8);
	constexpr REL::VariantID NiRTTI_bhkCharacterProxy(525445, 411921, 0x318a2b8);
	constexpr REL::VariantID NiRTTI_bhkCharacterRigidBody(525447, 411923, 0x318a2d0);
	constexpr REL::VariantID NiRTTI_bhkCollisionBox(525263, 411739, 0x3189410);
	constexpr REL::VariantID NiRTTI_bhkCollisionObject(525071, 411547, 0x3187f70);
	constexpr REL::VariantID NiRTTI_bhkCompressedMeshShape(525198, 411674, 0x31890f8);
	constexpr REL::VariantID NiRTTI_bhkCompressedMeshShapeData(525199, 411675, 0x3189108);
	constexpr REL::VariantID NiRTTI_bhkConstraint(525156, 411633, 0x3188338);
	constexpr REL::VariantID NiRTTI_bhkConstraintChain(525458, 411934, 0x318b5f0);
	constexpr REL::VariantID NiRTTI_bhkConvexShape(525126, 411601, 0x31881b0);
	constexpr REL::VariantID NiRTTI_bhkConvexSweepShape(525201, 411677, 0x3189120);
	constexpr REL::VariantID NiRTTI_bhkConvexTransformShape(525203, 411679, 0x3189138);
	constexpr REL::VariantID NiRTTI_bhkConvexTranslateShape(525205, 411681, 0x3189150);
	constexpr REL::VariantID NiRTTI_bhkConvexVerticesShape(525207, 411683, 0x3189168);
	constexpr REL::VariantID NiRTTI_bhkCylinderShape(525209, 411685, 0x3189180);
	constexpr REL::VariantID NiRTTI_bhkDashpotAction(525245, 411721, 0x3189330);
	constexpr REL::VariantID NiRTTI_bhkEntity(525117, 411592, 0x3188150);
	constexpr REL::VariantID NiRTTI_bhkExtraData(525256, 411732, 0x31893b8);
	constexpr REL::VariantID NiRTTI_bhkFixedConstraint(525231, 411707, 0x3189288);
	constexpr REL::VariantID NiRTTI_bhkGenericConstraint(525260, 411736, 0x31893e8);
	constexpr REL::VariantID NiRTTI_bhkGroupConstraint(525227, 411703, 0x3189258);
	constexpr REL::VariantID NiRTTI_bhkHeightFieldShape(525456, 411932, 0x318b5d8);
	constexpr REL::VariantID NiRTTI_bhkHingeConstraint(525187, 411663, 0x3189080);
	constexpr REL::VariantID NiRTTI_bhkHingeLimitsConstraint(525229, 411705, 0x3189270);
	constexpr REL::VariantID NiRTTI_bhkLimitedHingeConstraint(525152, 411627, 0x3188308);
	constexpr REL::VariantID NiRTTI_bhkLiquidAction(525247, 411723, 0x3189348);
	constexpr REL::VariantID NiRTTI_bhkListShape(525221, 411697, 0x3189210);
	constexpr REL::VariantID NiRTTI_bhkMalleableConstraint(525154, 411629, 0x3188320);
	constexpr REL::VariantID NiRTTI_bhkMoppBvTreeShape(525217, 411693, 0x31891e0);
	constexpr REL::VariantID NiRTTI_bhkMotorAction(525250, 411726, 0x3189368);
	constexpr REL::VariantID NiRTTI_bhkMouseSpringAction(525185, 411661, 0x3189068);
	constexpr REL::VariantID NiRTTI_bhkMultiSphereShape(525211, 411687, 0x3189198);
	constexpr REL::VariantID NiRTTI_bhkNiCollisionObject(525089, 411565, 0x3188010);
	constexpr REL::VariantID NiRTTI_bhkNiTriStripsShape(525142, 411617, 0x3188278);
	constexpr REL::VariantID NiRTTI_bhkOrientHingedBodyAction(525252, 411728, 0x3189380);
	constexpr REL::VariantID NiRTTI_bhkPCollisionObject(525127, 411602, 0x31881c0);
	constexpr REL::VariantID NiRTTI_bhkPackedNiTriStripsShape(525145, 411620, 0x31882a0);
	constexpr REL::VariantID NiRTTI_bhkPhantom(525119, 411594, 0x3188168);
	constexpr REL::VariantID NiRTTI_bhkPlaneShape(525213, 411689, 0x31891b0);
	constexpr REL::VariantID NiRTTI_bhkPointToPathConstraint(525466, 411942, 0x318b640);
	constexpr REL::VariantID NiRTTI_bhkPoseArray(525257, 411733, 0x31893c8);
	constexpr REL::VariantID NiRTTI_bhkPositionConstraintMotor(525267, 411743, 0x3189490);
	constexpr REL::VariantID NiRTTI_bhkPrismaticConstraint(525158, 411635, 0x3188350);
	constexpr REL::VariantID NiRTTI_bhkRagdollConstraint(525233, 411709, 0x31892a0);
	constexpr REL::VariantID NiRTTI_bhkRagdollLimitsConstraint(525235, 411711, 0x31892b8);
	constexpr REL::VariantID NiRTTI_bhkRagdollTemplate(525182, 411658, 0x3189040);
	constexpr REL::VariantID NiRTTI_bhkRagdollTemplateData(525181, 411657, 0x3189030);
	constexpr REL::VariantID NiRTTI_bhkRefObject(525108, 411583, 0x31880f8);
	constexpr REL::VariantID NiRTTI_bhkRigidBody(525068, 411544, 0x3187f58);
	constexpr REL::VariantID NiRTTI_bhkRigidBodyT(525106, 411581, 0x31882b8);
	constexpr REL::VariantID NiRTTI_bhkSPCollisionObject(525183, 411659, 0x3189050);
	constexpr REL::VariantID NiRTTI_bhkSerializable(525109, 411584, 0x3188108);
	constexpr REL::VariantID NiRTTI_bhkShape(525115, 411590, 0x3188138);
	constexpr REL::VariantID NiRTTI_bhkShapeCollection(525265, 411741, 0x3189428);
	constexpr REL::VariantID NiRTTI_bhkShapePhantom(525130, 411605, 0x31881e8);
	constexpr REL::VariantID NiRTTI_bhkSimpleShapePhantom(525132, 411607, 0x3188200);
	constexpr REL::VariantID NiRTTI_bhkSphereRepShape(525123, 411598, 0x3188198);
	constexpr REL::VariantID NiRTTI_bhkSphereShape(525138, 411613, 0x3188248);
	constexpr REL::VariantID NiRTTI_bhkSpringAction(525254, 411730, 0x3189398);
	constexpr REL::VariantID NiRTTI_bhkSpringDamperConstraintMotor(525269, 411745, 0x31894b0);
	constexpr REL::VariantID NiRTTI_bhkStiffSpringConstraint(525237, 411713, 0x31892d0);
	constexpr REL::VariantID NiRTTI_bhkTiltPreventAction(515428, 401567, 0x2fc6018);
	constexpr REL::VariantID NiRTTI_bhkTransformShape(525219, 411695, 0x31891f8);
	constexpr REL::VariantID NiRTTI_bhkTriSampledHeightFieldBvTreeShape(525164, 411639, 0x3188398);
	constexpr REL::VariantID NiRTTI_bhkTriangleShape(525215, 411691, 0x31891c8);
	constexpr REL::VariantID NiRTTI_bhkUnaryAction(525162, 411631, 0x3188380);
	constexpr REL::VariantID NiRTTI_bhkVelocityConstraintMotor(525268, 411744, 0x31894a0);
	constexpr REL::VariantID NiRTTI_bhkWheelAction(515429, 401568, 0x2fc6028);
	constexpr REL::VariantID NiRTTI_bhkWheelConstraint(525239, 411715, 0x31892e8);
	constexpr REL::VariantID NiRTTI_bhkWorld(525051, 411527, 0x3186e18);
	constexpr REL::VariantID NiRTTI_bhkWorldM(525107, 411582, 0x31880d0);
	constexpr REL::VariantID NiRTTI_bhkWorldObject(525039, 411515, 0x3186dd8);
	constexpr REL::VariantID NiRTTI_hkPackedNiTriStripsData(525128, 411603, 0x31881d0);
}


