===============================================
File: include/RE/P/PCGamepadType.h
===============================================
#pragma once

namespace RE
{
	enum class PC_GAMEPAD_TYPE
	{
		kDirectX = 0,
		kOrbis = 1,

		kTotal
	};
}


===============================================
File: include/RE/S/SFTypes.h
===============================================
#pragma once

namespace RE
{
	using UPInt = std::size_t;
	constexpr UPInt UPINT_MAX = (std::numeric_limits<UPInt>::max)();

	using SPInt = std::ptrdiff_t;
}


===============================================
File: include/RE/S/SafeZoneMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 11
	// flags = kNone
	// context = kNone
	class SafeZoneMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_SafeZoneMenu;
		constexpr static std::string_view MENU_NAME = "SafeZoneMenu";

		~SafeZoneMenu() override;  // 00
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(SafeZoneMenu) == 0x30);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(SafeZoneMenu) == 0x40);
#endif
}


===============================================
File: include/RE/S/SaveFileHandleReaderWriter.h
===============================================
#pragma once

#include "RE/B/BaseHandleReaderWriter.h"

namespace RE::SkyrimScript
{
	class SaveFileHandleReaderWriter : public BaseHandleReaderWriter
	{
	public:
		inline static constexpr auto RTTI = RTTI_SkyrimScript__SaveFileHandleReaderWriter;
		inline static constexpr auto VTABLE = VTABLE_SkyrimScript__SaveFileHandleReaderWriter;

		~SaveFileHandleReaderWriter() override;  // 0

		// override BaseHandleReaderWriter
		void Unk_08() override;
		bool SaveHandle(SaveStorageWrapper* saveWrapper, VMHandle handle) override;
		bool LoadHandle(BSMemStorage* loadWrapper, VMHandle* out) override;
		bool SaveRefID(SaveStorageWrapper* saveWrapper, uint32_t handleLow) override;
		bool ParseScriptInstance(BSMemStorage* loadWrapper, uint32_t* scriptInstanceValues) override;
	};
	static_assert(sizeof(SaveFileHandleReaderWriter) == 0x8);
}


===============================================
File: include/RE/S/SavePatcher.h
===============================================
#pragma once

#include "RE/I/ISavePatcherInterface.h"

namespace RE
{
	namespace SkyrimScript
	{
		class SavePatcher : public BSScript::ISavePatcherInterface
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript__SavePatcher;

			~SavePatcher() override;  // 00

			// override (BSScript::ISavePatcherInterface)
			void PatchStackFrame(BSScript::StackFrame* a_stackFrame, BSScript::IVirtualMachine* a_vm) override;  // 01
		};
		static_assert(sizeof(SavePatcher) == 0x8);
	}
}


===============================================
File: include/RE/S/SaveStorageWrapper.h
===============================================
#pragma once

#include "RE/B/BSMemStorage.h"

namespace RE
{
	class SaveStorageWrapper : public BSMemStorage
	{
	public:
		inline static constexpr auto RTTI = RTTI_SaveStorageWrapper;
		inline static constexpr auto VTABLE = VTABLE_SaveStorageWrapper;

		~SaveStorageWrapper() override;  // 00

		// override BSMemStorage
		std::size_t              GetSize() const override;                                                       // 01
		std::size_t              GetPosition() const override;                                                   // 02
		BSStorageDefs::ErrorCode Seek(std::size_t a_offset, BSStorageDefs::SeekMode a_seekMode) const override;  // 03
		BSStorageDefs::ErrorCode Read(std::size_t a_numBytes, std::byte* a_bytes) const override;                // 04
		BSStorageDefs::ErrorCode Write(std::size_t a_numBytes, const std::byte* a_bytes) override;               // 05

		// members
		std::uint64_t unk30;  // 30
	};
	static_assert(sizeof(SaveStorageWrapper) == 0x38);
}


===============================================
File: include/RE/S/SceneGraph.h
===============================================
#pragma once

#include "RE/B/BSSceneGraph.h"

namespace RE
{
	class SceneGraph : public BSSceneGraph
	{
	public:
		inline static constexpr auto RTTI = RTTI_SceneGraph;
		inline static constexpr auto Ni_RTTI = NiRTTI_SceneGraph;

		~SceneGraph() override;  // 00

		// override (BSSceneGraph)
		const NiRTTI* GetRTTI() const override;    // 02
		float         GetFarDistance() override;   // 3E
		float         GetNearDistance() override;  // 3F

		struct SCENE_GRAPH_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT        \
	float         customNearDistance; /* 140 */ \
	float         customFarDistance;  /* 144 */ \
	bool          useCustomNear;      /* 148 */ \
	bool          useCustomFar;       /* 149 */ \
	std::uint16_t pad14A;             /* 14A */ \
	std::uint32_t pad14C;             /* 14C */

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline SCENE_GRAPH_RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<SCENE_GRAPH_RUNTIME_DATA>(this, 0x140, 0x168);
		}

		[[nodiscard]] inline const SCENE_GRAPH_RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<SCENE_GRAPH_RUNTIME_DATA>(this, 0x140, 0x168);
		}

#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT
#endif
	};
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/S/ScrapHeap.h
===============================================
#pragma once

#include "RE/I/IMemoryStore.h"

namespace RE
{
	class ScrapHeap : public IMemoryStore
	{
	public:
		inline static constexpr auto RTTI = RTTI_ScrapHeap;

		struct Block
		{
		public:
			// members
			std::size_t sizeFlags;  // 00
			Block*      prev;       // 08
		};
		static_assert(sizeof(Block) == 0x10);

		struct FreeBlock : public Block
		{
		public:
			// members
			FreeBlock* left;   // 10
			FreeBlock* right;  // 18
		};
		static_assert(sizeof(FreeBlock) == 0x20);

		struct FreeTreeNode : public Block
		{
		public:
			// members
			FreeTreeNode** root;            // 10
			FreeTreeNode*  leftNode;        // 18
			FreeTreeNode*  rightNode;       // 20
			std::size_t    parentAndBlack;  // 28
		};
		static_assert(sizeof(FreeTreeNode) == 0x30);

		~ScrapHeap() override { WinAPI::VirtualFree(baseAddress, 0, MEM_RELEASE); }  // 00

		// override (IMemoryStore)
		std::size_t Size(void const* a_mem) const override { return *static_cast<const std::size_t*>(a_mem) & ~(std::size_t{ 3 } << 62); }  // 01
		void        GetMemoryStats(MemoryStats*) override { return; }                                                                       // 02
		bool        ContainsBlockImpl(const void* a_block) const override { return baseAddress <= a_block && a_block <= endAddress; }       // 03
		void*       AllocateAlignImpl(std::size_t a_size, std::uint32_t a_alignment) override { return Allocate(a_size, a_alignment); }     // 04
		void        DeallocateAlignImpl(void*& a_block) override { Deallocate(a_block), a_block = nullptr; }                                // 05

		void* Allocate(std::size_t a_size, std::size_t a_alignment);
		void  Deallocate(void* a_mem);

		// members
		FreeBlock*    smallBlocks[6]{ nullptr };  // 08
		FreeTreeNode* freeList{ nullptr };        // 38
		Block*        lastBlock{ nullptr };       // 40
		void*         baseAddress{ nullptr };     // 48
		void*         endAddress{ nullptr };      // 50
		void*         commitEnd{ nullptr };       // 58
		std::size_t   reserveSize{ 1 << 26 };     // 60
		std::size_t   minCommit{ 1 << 17 };       // 68
		std::size_t   totalAllocated{ 0 };        // 70
		std::uint32_t keepPagesRequest{ 0 };      // 78
		std::uint32_t totalFreeBlocks{ 0 };       // 7C
		std::uint32_t freeSmallBlocks{ 0 };       // 80
		std::uint32_t totalAllocatedBlocks{ 0 };  // 84
		std::uint32_t pmpBarrier{ 0 };            // 88
	};
	static_assert(sizeof(ScrapHeap) == 0x90);
}


===============================================
File: include/RE/S/ScreenSplatter.h
===============================================
#pragma once

#include "RE/B/BSBloodSplatterShaderProperty.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiCamera;
	class NiNode;
	class NiSourceTexture;

	class ScreenSplatter : public BSTSingletonSDM<ScreenSplatter>
	{
	public:
		static ScreenSplatter* GetSingleton()
		{
			REL::Relocation<ScreenSplatter**> singleton{ RELOCATION_ID(514512, 400672) };
			return *singleton;
		}

		void Clear()
		{
			using func_t = decltype(&ScreenSplatter::Clear);
			REL::Relocation<func_t> func{ RELOCATION_ID(16175, 16407) };
			return func(this);
		}

		// members
		std::uint8_t               pad01;                                            // 01
		std::uint16_t              pad02;                                            // 02
		std::uint32_t              pad04;                                            // 04
		NiPointer<NiNode>          root;                                             // 08
		NiPointer<NiCamera>        camera;                                           // 10
		float                      wRadius;                                          // 18
		float                      hRadius;                                          // 1C
		bool                       enabled;                                          // 20
		bool                       pad21;                                            // 21
		std::uint16_t              pad22;                                            // 22
		std::uint32_t              uiCount;                                          // 24
		NiPointer<NiSourceTexture> textures[BSBloodSplatterShaderProperty::kTotal];  // 28
	};
	static_assert(sizeof(ScreenSplatter) == 0x40);
}


===============================================
File: include/RE/S/ScreenshotHandler.h
===============================================
#pragma once

#include "RE/M/MenuEventHandler.h"

namespace RE
{
	struct ScreenshotHandler : public MenuEventHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_ScreenshotHandler;
		inline static constexpr auto VTABLE = VTABLE_ScreenshotHandler;

		~ScreenshotHandler() override;  // 00

		// override (MenuEventHandler)
		bool CanProcess(InputEvent* a_event) override;      // 01
		bool ProcessButton(ButtonEvent* a_event) override;  // 05

		// members
		bool          screenshotQueued;       // 10
		bool          multiScreenshotQueued;  // 11
		std::uint16_t pad12;                  // 12
		std::uint32_t pad14;                  // 14
	};
	static_assert(sizeof(ScreenshotHandler) == 0x18);
}


===============================================
File: include/RE/S/Script.h
===============================================
#pragma once

#include "RE/C/CommandTable.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	enum class COMPILER_NAME
	{
		kDefaultCompiler,
		kSystemWindowCompiler,
		kDialogueCompiler
	};

	class ScriptCompiler
	{
	public:
	};
	static_assert(sizeof(ScriptCompiler) == 0x1);

	class Script : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_Script;
		inline static constexpr auto VTABLE = VTABLE_Script;
		inline static constexpr auto FORMTYPE = FormType::Script;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
			};
		};

		~Script() override;  // 00

		static bool GetProcessScripts();
		static void SetProcessScripts(bool a_ProcessScripts);

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		void                      ClearCommand();
		void                      CompileAndRun(TESObjectREFR* a_targetRef, COMPILER_NAME a_name = COMPILER_NAME::kSystemWindowCompiler);
		void                      CompileAndRun(ScriptCompiler* a_compiler, TESObjectREFR* a_targetRef, COMPILER_NAME a_name = COMPILER_NAME::kSystemWindowCompiler);
		[[nodiscard]] std::string GetCommand() const;
		void                      SetCommand(std::string_view a_command);

		template <class... Args>
		static bool ParseParameters(const SCRIPT_PARAMETER* a_paramInfo, SCRIPT_FUNCTION::ScriptData* a_scriptData, std::uint32_t& a_opcodeOffsetPtr, TESObjectREFR* a_thisObj, TESObjectREFR* a_containingObj, Script* a_scriptObj, ScriptLocals* a_locals, Args... a_args)
		{
			static_assert((std::is_pointer_v<Args> && ...), "arguments must all be pointers");
			using func_t = bool(const SCRIPT_PARAMETER*, SCRIPT_FUNCTION::ScriptData*, std::uint32_t&, TESObjectREFR*, TESObjectREFR*, Script*, ScriptLocals*, ...);
			REL::Relocation<func_t> func{ RELOCATION_ID(21425, 21910) };
			return func(a_paramInfo, a_scriptData, a_opcodeOffsetPtr, a_thisObj, a_containingObj, a_scriptObj, a_locals, a_args...);
		}

		// members
		SCRIPT_HEADER                           header;                       // 20
		std::uint32_t                           pad34;                        // 34
		char*                                   text;                         // 38
		SCRIPT_FUNCTION::ScriptData*            data;                         // 40
		float                                   profilerTimer;                // 48
		float                                   questScriptDelay;             // 4C
		float                                   questScriptGetSecondsBuffer;  // 50
		std::uint32_t                           pad54;                        // 54
		TESQuest*                               parentQuest;                  // 58
		BSSimpleList<SCRIPT_REFERENCED_OBJECT*> refObjects;                   // 60
		BSSimpleList<ScriptVariable*>           variables;                    // 70

	private:
		void CompileAndRun_Impl(ScriptCompiler* a_compiler, COMPILER_NAME a_type, TESObjectREFR* a_targetRef);
	};
	static_assert(sizeof(Script) == 0x80);
}


===============================================
File: include/RE/S/ScriptEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class Script;
	class ScriptLocals;

	class ScriptEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_ScriptEffect;
		inline static constexpr auto VTABLE = VTABLE_ScriptEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;               // 04
		virtual void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 08
		virtual void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 09
		virtual void ClearTargetImpl() override;                   // 12
		virtual ~ScriptEffect();                                   // 13
		virtual void Start() override;                             // 14
		virtual void Finish() override;                            // 15

		// members
		Script*       script;        // 90
		ScriptLocals* effectLocals;  // 98
	};
	static_assert(sizeof(ScriptEffect) == 0xA0);
}


===============================================
File: include/RE/S/ScriptEventSourceHolder.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;
	struct BGSEventProcessedEvent;
	struct TESActivateEvent;
	struct TESActiveEffectApplyRemoveEvent;
	struct TESActorLocationChangeEvent;
	struct TESBookReadEvent;
	struct TESCellAttachDetachEvent;
	struct TESCellFullyLoadedEvent;
	struct TESCellReadyToApplyDecalsEvent;
	struct TESCombatEvent;
	struct TESContainerChangedEvent;
	struct TESDeathEvent;
	struct TESDestructionStageChangedEvent;
	struct TESEnterBleedoutEvent;
	struct TESEquipEvent;
	struct TESFastTravelEndEvent;
	struct TESFormDeleteEvent;
	struct TESFurnitureEvent;
	struct TESGrabReleaseEvent;
	struct TESHitEvent;
	struct TESInitScriptEvent;
	struct TESLoadGameEvent;
	struct TESLockChangedEvent;
	struct TESMagicEffectApplyEvent;
	struct TESMagicWardHitEvent;
	struct TESMoveAttachDetachEvent;
	struct TESObjectLoadedEvent;
	struct TESObjectREFRTranslationEvent;
	struct TESOpenCloseEvent;
	struct TESPackageEvent;
	struct TESPerkEntryRunEvent;
	struct TESPlayerBowShotEvent;
	struct TESQuestInitEvent;
	struct TESQuestStageEvent;
	struct TESQuestStageItemDoneEvent;
	struct TESQuestStartStopEvent;
	struct TESResetEvent;
	struct TESResolveNPCTemplatesEvent;
	struct TESSceneActionEvent;
	struct TESSceneEvent;
	struct TESScenePhaseEvent;
	struct TESSellEvent;
	struct TESSleepStartEvent;
	struct TESSleepStopEvent;
	struct TESSpellCastEvent;
	struct TESSwitchRaceCompleteEvent;
	struct TESTopicInfoEvent;
	struct TESTrackedStatsEvent;
	struct TESTrapHitEvent;
	struct TESTriggerEnterEvent;
	struct TESTriggerEvent;
	struct TESTriggerLeaveEvent;
	struct TESUniqueIDChangeEvent;
	struct TESWaitStartEvent;
	struct TESWaitStopEvent;

	class ScriptEventSourceHolder :
		public BSTEventSource<BGSEventProcessedEvent>,           // 0000
		public BSTEventSource<TESActivateEvent>,                 // 0058
		public BSTEventSource<TESActiveEffectApplyRemoveEvent>,  // 00B0
		public BSTEventSource<TESActorLocationChangeEvent>,      // 0108
		public BSTEventSource<TESBookReadEvent>,                 // 0160
		public BSTEventSource<TESCellAttachDetachEvent>,         // 01B8
		public BSTEventSource<TESCellFullyLoadedEvent>,          // 0210
		public BSTEventSource<TESCellReadyToApplyDecalsEvent>,   // 0268
		public BSTEventSource<TESCombatEvent>,                   // 02C0
		public BSTEventSource<TESContainerChangedEvent>,         // 0318
		public BSTEventSource<TESDeathEvent>,                    // 0370
		public BSTEventSource<TESDestructionStageChangedEvent>,  // 03C8
		public BSTEventSource<TESEnterBleedoutEvent>,            // 0420
		public BSTEventSource<TESEquipEvent>,                    // 0478
		public BSTEventSource<TESFormDeleteEvent>,               // 04D0
		public BSTEventSource<TESFurnitureEvent>,                // 0528
		public BSTEventSource<TESGrabReleaseEvent>,              // 0580
		public BSTEventSource<TESHitEvent>,                      // 05D8
		public BSTEventSource<TESInitScriptEvent>,               // 0630
		public BSTEventSource<TESLoadGameEvent>,                 // 0688
		public BSTEventSource<TESLockChangedEvent>,              // 06E0
		public BSTEventSource<TESMagicEffectApplyEvent>,         // 0738
		public BSTEventSource<TESMagicWardHitEvent>,             // 0790
		public BSTEventSource<TESMoveAttachDetachEvent>,         // 07E8
		public BSTEventSource<TESObjectLoadedEvent>,             // 0840
		public BSTEventSource<TESObjectREFRTranslationEvent>,    // 0898
		public BSTEventSource<TESOpenCloseEvent>,                // 08F0
		public BSTEventSource<TESPackageEvent>,                  // 0948
		public BSTEventSource<TESPerkEntryRunEvent>,             // 09A0
		public BSTEventSource<TESQuestInitEvent>,                // 09F8
		public BSTEventSource<TESQuestStageEvent>,               // 0A50
		public BSTEventSource<TESQuestStageItemDoneEvent>,       // 0AA8
		public BSTEventSource<TESQuestStartStopEvent>,           // 0B00
		public BSTEventSource<TESResetEvent>,                    // 0B58
		public BSTEventSource<TESResolveNPCTemplatesEvent>,      // 0BB0
		public BSTEventSource<TESSceneEvent>,                    // 0C08
		public BSTEventSource<TESSceneActionEvent>,              // 0C60
		public BSTEventSource<TESScenePhaseEvent>,               // 0CB8
		public BSTEventSource<TESSellEvent>,                     // 0D10
		public BSTEventSource<TESSleepStartEvent>,               // 0D68
		public BSTEventSource<TESSleepStopEvent>,                // 0DC0
		public BSTEventSource<TESSpellCastEvent>,                // 0E18
		public BSTEventSource<TESPlayerBowShotEvent>,            // 0E70
		public BSTEventSource<TESTopicInfoEvent>,                // 0EC8
		public BSTEventSource<TESTrackedStatsEvent>,             // 0F20
		public BSTEventSource<TESTrapHitEvent>,                  // 0F78
		public BSTEventSource<TESTriggerEvent>,                  // 0FD0
		public BSTEventSource<TESTriggerEnterEvent>,             // 1028
		public BSTEventSource<TESTriggerLeaveEvent>,             // 1080
		public BSTEventSource<TESUniqueIDChangeEvent>,           // 10D8
		public BSTEventSource<TESWaitStartEvent>,                // 1130 - ?
		public BSTEventSource<TESWaitStopEvent>,                 // 1188 - ?
#ifndef ENABLE_SKYRIM_VR
		public BSTEventSource<TESSwitchRaceCompleteEvent>,       // 11E0
		public BSTEventSource<TESFastTravelEndEvent>             // 1238
#else
    public BSTEventSource<TESSwitchRaceCompleteEvent>       // 11E0
#endif
	{
	public:
		static ScriptEventSourceHolder* GetSingleton();

		void SendActivateEvent(const NiPointer<TESObjectREFR>& a_objectActivated, const NiPointer<TESObjectREFR>& a_actionRef);
		void SendOpenCloseEvent(const NiPointer<TESObjectREFR>& a_ref, const NiPointer<TESObjectREFR>& a_activeRef, bool a_isOpened);
		void SendSpellCastEvent(const NiPointer<TESObjectREFR>& a_object, FormID a_formID);

		template <class T>
		inline BSTEventSource<T>* GetEventSource() noexcept
		{
			return static_cast<BSTEventSource<T>*>(this);
		}

        template <>
        inline BSTEventSource<TESFastTravelEndEvent>* GetEventSource() noexcept
        {
            return AsTESFastTravelEndEventSource();
        }

        inline BSTEventSource<TESFastTravelEndEvent>* AsTESFastTravelEndEventSource() noexcept
        {
            if SKYRIM_REL_CONSTEXPR (REL::Module::IsVR()) {
                return nullptr;
            } else {
                return &REL::RelocateMember<BSTEventSource<TESFastTravelEndEvent>>(this, 0x1238, 0);
            }
        }

		template <class T>
		inline void AddEventSink(BSTEventSink<T>* a_sink)
		{
			GetEventSource<T>()->AddEventSink(a_sink);
		}

		template <class T>
		inline void RemoveEventSink(BSTEventSink<T>* a_sink)
		{
			GetEventSource<T>()->RemoveEventSink(a_sink);
		}

		template <class T>
		inline void SendEvent(const T* a_event)
		{
			GetEventSource<T>()->SendEvent(a_event);
		}
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(ScriptEventSourceHolder) == 0x1290);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
    static_assert(sizeof(ScriptEventSourceHolder) == 0x1238);
#endif
}


===============================================
File: include/RE/S/ScriptFunction.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/I/IFunction.h"
#include "RE/P/PackedInstructionStream.h"
#include "RE/T/TypeInfo.h"
#include "RE/V/VDescTable.h"

namespace RE
{
	namespace BSScript
	{
		namespace Internal
		{
			class ScriptFunction : public IFunction
			{
			public:
				inline static constexpr auto RTTI = RTTI_BSScript__Internal__ScriptFunction;

				~ScriptFunction() override;  // 00

				// override (IFunction)
				const BSFixedString& GetName() const override;                                                                                                  // 01 - { return functionName; }
				const BSFixedString& GetObjectTypeName() const override;                                                                                        // 02 - { return scriptName; }
				const BSFixedString& GetStateName() const override;                                                                                             // 03 - { return stateName; }
				TypeInfo             GetReturnType() const override;                                                                                            // 04 - { return returnType; }
				std::uint32_t        GetParamCount() const override;                                                                                            // 05 - { return varInfo.numParams; }
				void                 GetParam(std::uint32_t a_idx, BSFixedString& a_nameOut, TypeInfo& a_typeOut) const override;                               // 06
				std::uint32_t        GetStackFrameSize() const override;                                                                                        // 07 - { return (descTable.totalEntries - descTable.paramCount) + GetNumParams(); }
				bool                 GetIsNative() const override;                                                                                              // 08 - { return false; }
				bool                 GetIsStatic() const override;                                                                                              // 09 - { return isStatic; }
				bool                 GetIsEmpty() const override;                                                                                               // 0A - { return instructions.numInstructionBits == 0; }
				FunctionType         GetFunctionType() const override;                                                                                          // 0B - { return functionType; }
				std::uint32_t        GetUserFlags() const override;                                                                                             // 0C - { return userFlags; }
				const BSFixedString& GetDocString() const override;                                                                                             // 0D - { return docString; }
				void                 InsertLocals(StackFrame* a_frame) override;                                                                                // 0E
				CallResult           Call(const BSTSmartPointer<Stack>& a_stack, ErrorLogger* a_logger, Internal::VirtualMachine* a_vm, bool a_arg4) override;  // 0F
				const BSFixedString& GetSourceFilename() const override;                                                                                        // 10 - { return sourceFileName; }
				bool                 TranslateIPToLineNumber(std::uint32_t a_indexPtr, std::uint32_t& a_lineNumberOut) const override;                          // 11
				bool                 GetVarNameForStackIndex(std::uint32_t a_idx, BSFixedString& a_nameOut) const override;                                     // 12
				bool                 CanBeCalledFromTasklets() const override;                                                                                  // 13 - { return true; }
				void                 SetCallableFromTasklets(bool a_callable) override;                                                                         // 14 - { return; }

				// members
				BSFixedString                                 name;             // 10
				BSFixedString                                 objName;          // 18
				BSFixedString                                 stateName;        // 20
				TypeInfo                                      retType;          // 28
				VDescTable                                    descTable;        // 30
				std::uint32_t                                 userFlags;        // 40
				std::uint32_t                                 pad44;            // 44
				ByteCode::PackedInstructionStream             instructions;     // 48
				stl::enumeration<FunctionType, std::uint16_t> functionType;     // 58
				bool                                          isStatic;         // 5A
				std::uint8_t                                  pad5B;            // 5B
				std::uint32_t                                 pad5C;            // 5C
				BSFixedString                                 docString;        // 60
				BSFixedString                                 sourceFileName;   // 68
				std::uint32_t                                 lineNumberCount;  // 70
				std::uint32_t                                 pad74;            // 74
				std::uint16_t*                                lineNumbers;      // 78
			};
			static_assert(sizeof(ScriptFunction) == 0x80);
		}
	}
}


===============================================
File: include/RE/S/ScriptedRefEffect.h
===============================================
#pragma once

#include "RE/S/ScriptEffect.h"

namespace RE
{
	class ScriptedRefEffect :
		public ScriptEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_ScriptedRefEffect;
		inline static constexpr auto VTABLE = VTABLE_ScriptedRefEffect;

		// override (ActiveEffect)
		virtual ~ScriptedRefEffect();  // 13
	};
	static_assert(sizeof(ScriptedRefEffect) == 0xA0);
}


===============================================
File: include/RE/S/ScrollItem.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/S/SpellItem.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	class ScrollItem :
		public SpellItem,                  // 000
		public TESModelTextureSwap,        // 0E8
		public BGSDestructibleObjectForm,  // 120
		public BGSPickupPutdownSounds,     // 130
		public TESWeightForm,              // 148
		public TESValueForm                // 158
	{
	public:
		inline static constexpr auto RTTI = RTTI_ScrollItem;
		inline static constexpr auto VTABLE = VTABLE_ScrollItem;
		inline static constexpr auto FORMTYPE = FormType::Scroll;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~ScrollItem() override;  // 00

		// override (SpellItem)
		void                                   InitItemImpl() override;                                               // 13
		[[nodiscard]] MagicSystem::SpellType   GetSpellType() const override;                                         // 53 - { return MagicSystem::SpellType::kScroll; }
		[[nodiscard]] MagicSystem::CastingType GetCastingType() const override;                                       // 55 - { return MagicSystem::CastingType::kFireAndForget; }
		bool                                   GetSkillUsageData(SkillUsageData& a_data) const override;              // 60 - { return 0; }
		[[nodiscard]] ActorValue               GetAssociatedSkill() const override;                                   // 66 - { return ActorValue::kNone; }
		void                                   LoadMagicItemChunk(TESFile* a_mod, std::uint32_t a_chunkID) override;  // 6A
	};
	static_assert(sizeof(ScrollItem) == 0x168);
}


===============================================
File: include/RE/S/SendPlayerToJailFunctor.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/D/DelayFunctor.h"

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
	}

	namespace SkyrimScript
	{
		class SendPlayerToJailFunctor : public DelayFunctor
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript____SendPlayerToJailFunctor;

			enum class Flag
			{
				kNone = 0,
				kRemoveInventory = 1 << 0,
				kRealJail = 1 << 1
			};

			~SendPlayerToJailFunctor() override;  // 00

			// override (DelayFunctor)
			RE::BSScript::Variable operator()() override;                                                              // 01
			bool                   IsLatent() const override;                                                          // 02 - { return true; }
			bool                   SaveImpl(BSStorage& a_storage) const override;                                      // 04
			FunctorType            GetType() const override;                                                           // 05 - { return 19; }
			bool                   LoadImpl(const BSStorage& a_storage, std::uint32_t a_arg2, bool& a_arg3) override;  // 06

			// members
			FormID                                     faction;  // 10
			stl::enumeration<Flag, std::uint8_t>       flags;    // 14
			std::uint8_t                               pad15;    // 15
			std::uint16_t                              pad16;    // 16
			BSTSmartPointer<BSScript::IVirtualMachine> vm;       // 18
		};
		static_assert(sizeof(SendPlayerToJailFunctor) == 0x20);
	}
}


===============================================
File: include/RE/S/SetEventData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"

namespace RE
{
	struct SetEventData
	{
	public:
		// members
		BSFixedString                 eventName;  // 00
		BSTSmallArray<BSFixedString>* clipNames;  // 08
		bool                          unk10;      // 10
		std::uint8_t                  pad11;      // 11
		std::uint16_t                 pad12;      // 12
		std::uint32_t                 pad14;      // 14
	};
	static_assert(sizeof(SetEventData) == 0x18);
}


===============================================
File: include/RE/S/SetMotionTypeFunctor.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/D/DelayFunctor.h"

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
	}

	namespace SkyrimScript
	{
		class SetMotionTypeFunctor : public DelayFunctor
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript____SetMotionTypeFunctor;

			~SetMotionTypeFunctor() override;  // 00

			// override (DelayFunctor)
			RE::BSScript::Variable operator()() override;                                                              // 01
			bool                   IsLatent() const override;                                                          // 02 - { return true; }
			bool                   SaveImpl(BSStorage& a_storage) const override;                                      // 04
			FunctorType            GetType() const override;                                                           // 05 - { return 8; }
			bool                   LoadImpl(const BSStorage& a_storage, std::uint32_t a_arg2, bool& a_arg3) override;  // 06

			// members
			ObjectRefHandle                            objectToChange;  // 10
			std::uint32_t                              type;            // 14
			BSTSmartPointer<BSScript::IVirtualMachine> vm;              // 18
			bool                                       allowActivate;   // 20
			std::uint8_t                               pad21;           // 21
			std::uint16_t                              pad22;           // 22
			std::uint32_t                              pad24;           // 24
		};
		static_assert(sizeof(SetMotionTypeFunctor) == 0x28);
	}
}


===============================================
File: include/RE/S/SetPositionFunctor.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/D/DelayFunctor.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	namespace BSScript
	{
		class IVirtualMachine;
	}

	namespace SkyrimScript
	{
		class SetPositionFunctor : public DelayFunctor
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript____SetPositionFunctor;

			~SetPositionFunctor() override;  // 00

			// override (SkyrimScript::DelayFunctor)
			RE::BSScript::Variable operator()() override;                                                              // 01
			bool                   IsLatent() const override;                                                          // 02 - { return true; }
			bool                   SaveImpl(BSStorage& a_storage) const override;                                      // 04
			FunctorType            GetType() const override;                                                           // 05 - { return 6; }
			bool                   LoadImpl(const BSStorage& a_storage, std::uint32_t a_arg2, bool& a_arg3) override;  // 06

			// members
			ObjectRefHandle                            objectToMove;  // 10
			NiPoint3                                   newPosition;   // 14
			BSTSmartPointer<BSScript::IVirtualMachine> vm;            // 20
		};
		static_assert(sizeof(SetPositionFunctor) == 0x28);
	}
}


===============================================
File: include/RE/S/Setting.h
===============================================
#pragma once

#include "RE/C/Color.h"

namespace RE
{
	class Setting
	{
	public:
		inline static constexpr auto RTTI = RTTI_Setting;

		enum class Type
		{
			kUnknown = 0,
			kBool,
			kFloat,
			kSignedInteger,
			kColor,
			kString,
			kUnsignedInteger
		};

		union Data
		{
			bool          b;
			float         f;
			std::int32_t  i;
			Color         r;
			char*         s;
			std::uint32_t u;
		};
		static_assert(sizeof(Data) == 0x8);

		virtual ~Setting();  // 00

		// add
		virtual bool Unk_01(void);  // 01 - { return false; }

		[[nodiscard]] bool        IsManaged() const;
		[[nodiscard]] Type        GetType() const;
		[[nodiscard]] const char* GetName() const;

		[[nodiscard]] bool          GetBool() const;
		[[nodiscard]] float         GetFloat() const;
		[[nodiscard]] std::int32_t  GetSInt() const;
		[[nodiscard]] Color         GetColor() const;
		[[nodiscard]] const char*   GetString() const;
		[[nodiscard]] std::uint32_t GetUInt() const;

		// members
		Data  data;  // 08
		char* name;  // 10
	};
	static_assert(sizeof(Setting) == 0x18);
}


===============================================
File: include/RE/S/SettingCollection.h
===============================================
#pragma once

namespace RE
{
	class TESFile;

	template <class T>
	class SettingCollection
	{
	public:
		virtual ~SettingCollection();  // 00

		// add
		virtual void InsertSetting(T* a_setting) = 0;  // 01
		virtual void RemoveSetting(T* a_setting) = 0;  // 02
		virtual bool WriteSetting(T* a_setting) = 0;   // 03
		virtual bool ReadSetting(T* a_setting) = 0;    // 04
		virtual bool OpenHandle(bool a_create);        // 05 - { return false; }
		virtual bool CloseHandle();                    // 06 - { return true; }
		virtual void Unk_07(void);                     // 07 - { return 0; }
		virtual void WriteAllSettings();               // 08 - { return handle != 0; }
		virtual void ReadAllSettings();                // 09 - { return handle != 0; }

		// members
		char  subKey[0x104];  // 008
		void* handle;         // 110
	};
	static_assert(sizeof(SettingCollection<void*>) == 0x118);
}


===============================================
File: include/RE/S/SettingCollectionList.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/S/SettingCollection.h"

namespace RE
{
	template <class T>
	class SettingCollectionList : public SettingCollection<T>
	{
	public:
		~SettingCollectionList() override;  // 00

		// override (SettingCollection<T>)
		void InsertSetting(T* a_setting) override;  // 01
		void RemoveSetting(T* a_setting) override;  // 02
		void WriteAllSettings() override;           // 08
		void ReadAllSettings() override;            // 09

		// members
		BSSimpleList<T*> settings;  // 118
	};
	static_assert(sizeof(SettingCollectionList<void*>) == 0x128);
}


===============================================
File: include/RE/S/SettingCollectionMap.h
===============================================
#pragma once

#include "RE/B/BSTCaseInsensitiveStringMap.h"
#include "RE/S/Setting.h"
#include "RE/S/SettingCollection.h"

namespace RE
{
	template <class T>
	class SettingCollectionMap : public SettingCollection<T>
	{
	public:
		~SettingCollectionMap() override;  // 00

		// override (SettingCollection<T>)
		void InsertSetting(T* a_setting) override;  // 01
		void RemoveSetting(T* a_setting) override;  // 02
		void WriteAllSettings() override;           // 08
		void ReadAllSettings() override;            // 09

		// members
		BSTCaseInsensitiveStringMap<T*> settings;  // 118
	};
	static_assert(sizeof(SettingCollectionMap<Setting>) == 0x140);
}


===============================================
File: include/RE/S/SettingT.h
===============================================
#pragma once

#include "RE/S/Setting.h"

namespace RE
{
	// auto registers/unregisters with the templated collection
	template <class T>
	class SettingT : public Setting
	{
	public:
		~SettingT() override;  // 00
	};
	static_assert(sizeof(SettingT<void*>) == 0x18);
}


===============================================
File: include/RE/S/Sexes.h
===============================================
#pragma once

namespace RE
{
	struct SEXES
	{
		enum SEX : std::uint32_t
		{
			kNone = static_cast<std::underlying_type_t<SEX>>(-1),
			kMale = 0,
			kFemale = 1,

			kTotal = 2
		};
	};
	using SEX = SEXES::SEX;
}


===============================================
File: include/RE/S/ShaderReferenceEffect.h
===============================================
#pragma once

#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/R/ReferenceEffect.h"

namespace RE
{
	class BSEffectShaderData;
	class BSParticleShaderObjectEmitter;
	class BSParticleShaderProperty;
	class NiAVObject;
	class NiSourceTexture;
	class TESBoundObject;
	class TESEffectShader;
	class BSEffectShaderData;

	class ShaderReferenceEffect : public ReferenceEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_ShaderReferenceEffect;
		inline static auto           Ni_RTTI = NiRTTI_ShaderReferenceEffect;
		inline static constexpr auto VTABLE = VTABLE_ShaderReferenceEffect;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kRefShader;

		enum class Flag
		{
			kNone = 0,
			kVisible = 1 << 0,
			kInterfaceEffect = 1 << 1,
			kAllowTargetRoot = 1 << 7
		};

		struct TextureRequest
		{
			std::uint64_t              unk00;  // 00
			NiPointer<NiSourceTexture> unk08;  // 08
		};
		static_assert(sizeof(TextureRequest) == 0x10);

		struct ParticleShader
		{
			NiPointer<BSParticleShaderProperty>      particleShaderProp;  // 00 - smart ptr
			NiPointer<BSParticleShaderObjectEmitter> particleEmitter;     // 08 - smart ptr
		};
		static_assert(sizeof(ParticleShader) == 0x10);

		~ShaderReferenceEffect() override;  // 00

		// override (ReferenceEffect)
		const NiRTTI*    GetRTTI() const override;                                  // 02
		bool             Update(float a_arg1) override;                             // 28
		NiAVObject*      Get3D() const override;                                    // 29 - { return lastRootNode.get(); }
		TEMP_EFFECT_TYPE GetType() const override;                                  // 2C - { return 10; }
		void             SaveGame(BGSSaveGameBuffer* a_buf) override;               // 2D
		void             LoadGame(BGSLoadGameBuffer* a_buf) override;               // 2E
		void             FinishLoadGame(BGSLoadGameBuffer* a_buf) override;         // 2F - { return ReferenceEffect::Unk_2F(); }
		bool             IsInterfaceEffect() const override;                        // 30 - { return (unk130 >> 1) & 1; }
		void             SetInterfaceEffect(bool a_set) override;                   // 31
		bool             GetStackable() const override;                             // 32 - { return true; }
		bool             GetStackableMatch(BSTempEffect* a_effect) const override;  // 33
		void             Push() override;                                           // 34 - { if (effectShaderData) ++pushCount; }
		void             Pop() override;                                            // 35
		void             Init() override;                                           // 36
		void             Suspend() override;                                        // 37
		void             Resume() override;                                         // 38
		void             ClearTarget() override;                                    // 39
		void             UpdatePosition() override;                                 // 3B
		NiAVObject*      GetAttachRoot() override;                                  // 3C
		void             DetachImpl() override;                                     // 3E

		// members
		BSTArray<TextureRequest>              textureRequests;         // 048
		BSTArray<NiPointer<NiAVObject>>       addonModels;             // 060 - smart ptrs
		BSTArray<void*>                       unk078;                  // 078
		BSTArray<ParticleShader>              particleShaders;         // 090
		BSTArray<void*>                       unk0A8;                  // 0A8 - smart ptrs
		BSSoundHandle                         soundHandle;             // 0C0
		std::uint32_t                         pad0CC;                  // 0CC
		NiPointer<NiSourceTexture>            particleShaderTexture;   // 0D0 - smart ptr
		NiPointer<NiSourceTexture>            particlePaletteTexture;  // 0D8 - smart ptr
		NiPointer<NiSourceTexture>            fillTexture;             // 0E0
		NiPointer<NiSourceTexture>            holesTexture;            // 0E8
		NiPointer<NiSourceTexture>            paletteTexture;          // 0F0
		NiPointer<NiAVObject>                 lastRootNode;            // 0F8
		TESBoundObject*                       wornObject;              // 100
		TESEffectShader*                      effectData;              // 108
		BSEffectShaderData*                   effectShaderData;        // 110
		NiPointer<NiAVObject>                 targetRoot;              // 118 - smart ptr
		float                                 unk120;                  // 120
		float                                 unk124;                  // 124 - 1.0f
		float                                 addonModelsScaleStart;   // 128 - 1.0f
		std::uint32_t                         unk12C;                  // 12C
		stl::enumeration<Flag, std::uint32_t> flags;                   // 130
		std::uint32_t                         pushCount;               // 134
	};
	static_assert(sizeof(ShaderReferenceEffect) == 0x138);
}


===============================================
File: include/RE/S/ShadowSceneNode.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/N/NiNode.h"

namespace RE
{
	class BSLight;
	class BSFogProperty;
	class BSLensFlareRenderData;
	class BSPortalGraph;
	class BSShadowLight;
	class BSShadowDirectionalLight;

	class ShadowSceneNode : public NiNode
	{
	public:
		inline static constexpr auto RTTI = RTTI_ShadowSceneNode;
		inline static auto           Ni_RTTI = NiRTTI_ShadowSceneNode;

		struct LIGHT_CREATE_PARAMS
		{
		public:
			// members
			std::uint8_t           unk00;          // 00
			std::uint8_t           unk01;          // 01
			bool                   portalStrict;   // 02
			bool                   affectLand;     // 03
			std::uint8_t           unk04;          // 04
			bool                   neverFades;     // 05
			float                  fov;            // 08
			float                  falloff;        // 0C
			float                  nearDistance;   // 10
			float                  depthBias;      // 14
			std::uint32_t          unk18;          // 18
			NiAVObject*            objectNode;     // 20
			BSLensFlareRenderData* lensFlareData;  // 28
		};

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                         \
	std::uint64_t                      unk128;             /* 128 */ \
	BSTArray<NiPointer<BSLight>>       activeLights;       /* 130 */ \
	BSTArray<NiPointer<BSLight>>       unk148;             /* 148 */ \
	BSTArray<NiPointer<BSLight>>       unk160;             /* 160 */ \
	BSTArray<void*>                    unk178;             /* 178 */ \
	BSTArray<NiPointer<BSLight>>       unk190;             /* 190 */ \
	mutable BSSpinLock                 unk1A8;             /* 1A8 */ \
	BSTArray<NiPointer<NiAVObject>>    geometries;         /* 1B0 */ \
	BSTArray<NiPointer<NiAVObject>>    particleNodes;      /* 1C8 */ \
	BSTArray<NiPointer<NiAVObject>>    actorRootNodes;     /* 1E0 */ \
	mutable BSSpinLock                 unk1F8;             /* 1F8 */ \
	BSLight*                           sunLight;           /* 200 */ \
	BSLight*                           cloudLight;         /* 208 */ \
	BSShadowDirectionalLight*          shadowDirLight;     /* 210 */ \
	std::uint8_t                       unk218;             /* 218 */ \
	std::uint8_t                       unk219;             /* 219 */ \
	std::uint8_t                       unk21A;             /* 21A */ \
	std::uint8_t                       unk21B;             /* 21B */ \
	std::uint32_t                      pad21C;             /* 21C */ \
	NiPointer<BSFogProperty>           fogProperty;        /* 220 */ \
	BSPortalGraph*                     portalGraph;        /* 228 */ \
	BSTArray<BSShadowLight*> shadowCasterLights; /* 230 */ \
	std::uint64_t                      unk248;             /* 248 */ \
	std::uint64_t                      unk250;             /* 250 */ \
	std::uint64_t                      unk258;             /* 258 */ \
	std::uint64_t                      unk260;             /* 260 */ \
	std::uint64_t                      unk268;             /* 268 */ \
	std::uint64_t                      unk270;             /* 270 */ \
	std::uint64_t                      unk278;             /* 278 */ \
	std::uint64_t                      unk280;             /* 280 */ \
	std::uint64_t                      unk288;             /* 288 */ \
	std::uint64_t                      unk290;             /* 290 */ \
	std::uint64_t                      unk298;             /* 298 */ \
	std::uint64_t                      unk2A0;             /* 2A0 */ \
	std::uint64_t                      unk2A8;             /* 2A8 */ \
	std::uint64_t                      unk2B0;             /* 2B0 */ \
	std::uint64_t                      unk2B8;             /* 2B8 */ \
	std::uint64_t                      unk2C0;             /* 2C0 */ \
	std::uint64_t                      unk2C8;             /* 2C8 */ \
	std::uint64_t                      unk2D0;             /* 2D0 */ \
	std::uint64_t                      unk2D8;             /* 2D8 */ \
	std::uint64_t                      unk2E0;             /* 2E0 */ \
	NiPoint3                           unk2E8;             /* 2E8 */ \
	NiPoint3                           cameraPos;          /* 2F4 */ \
	std::uint8_t                       unk300;             /* 300 */ \
	std::uint8_t                       pad301;             /* 301 */ \
	std::uint16_t                      pad302;             /* 302 */ \
	float                              unk304;             /* 304 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x1E0);

		~ShadowSceneNode() override;  // 00

		// override (NiNode)
		const NiRTTI* GetRTTI() const override;  // 02
#if !defined(ENABLE_SKYRIM_VR) || (!defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_VR))
		// The following are virtual functions past the point where VR compatibility breaks.
		void OnVisible(NiCullingProcess& a_process) override;  // 34
#endif

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x128, 0x150);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 128, 150
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(ShadowSceneNode) == 0x308);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(ShadowSceneNode) == 0x330);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/S/ShoutAttack.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class TESShout;

	struct ShoutAttack
	{
	public:
		struct Event
		{
		public:
			// members
			TESShout* shout;  // 00
		};
		static_assert(sizeof(Event) == 0x08);

		static BSTEventSource<ShoutAttack::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/S/ShoutHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	struct ShoutHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_ShoutHandler;

		~ShoutHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04

		// members
		std::uint64_t unk10;  // 10
		std::uint64_t unk18;  // 18
	};
	static_assert(sizeof(ShoutHandler) == 0x20);
}


===============================================
File: include/RE/S/ShoutMeter.h
===============================================
#pragma once

#include "RE/H/HUDMeter.h"

namespace RE
{
	class ShoutMeter : public HUDMeter
	{
	public:
		inline static constexpr auto RTTI = RTTI_ShoutMeter;

		~ShoutMeter() override;  // 00

		// override (HUDMeter)
		bool  ProcessMessage(UIMessage* a_message) override;  // 02
		float GetFillPct() override;                          // 05

		// members
		float         cooldown;  // 48 - in seconds
		std::uint32_t unk4C;     // 4C
	};
	static_assert(sizeof(ShoutMeter) == 0x50);
}


===============================================
File: include/RE/S/SimpleAllocMemoryPagePolicy.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/I/IMemoryPagePolicy.h"

namespace RE
{
	namespace BSScript
	{
		class SimpleAllocMemoryPagePolicy : public IMemoryPagePolicy
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__SimpleAllocMemoryPagePolicy;
			inline static constexpr auto VTABLE = VTABLE_BSScript__SimpleAllocMemoryPagePolicy;

			~SimpleAllocMemoryPagePolicy() override;  // 00

			// override (IMemoryPagePolicy)
			std::uint32_t    MaximumPageSize() override;                                                                                         // 01 - { return maxPageSize; }
			AllocationStatus AllocatePage(std::uint32_t a_pageSize, NewPageStrategy a_stategy, BSTAutoPointer<MemoryPage>& a_newPage) override;  // 02
			AllocationStatus GetLargestAvailablePage(BSTAutoPointer<MemoryPage>& a_newPage) override;                                            // 03
			void             DisposePage(BSTAutoPointer<MemoryPage>& a_newPage) override;                                                        // 04

			// members
			const std::uint32_t minPageSize{ 0 };          // 08
			const std::uint32_t maxPageSize{ 0 };          // 0C
			const std::uint32_t maxAllocatedMemory{ 0 };   // 10
			const bool          ignoreMemoryLimit{ 0 };    // 14 - Set each update by overstress status
			BSSpinLock          dataLock;                  // 18
			std::uint32_t       currentMemorySize;         // 20
			std::uint32_t       maxAdditionalAllocations;  // 20
		};
		static_assert(sizeof(SimpleAllocMemoryPagePolicy) == 0x28);
	}
}


===============================================
File: include/RE/S/SimpleAnimationGraphManagerHolder.h
===============================================
#pragma once

#include "RE/I/IAnimationGraphManagerHolder.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class SimpleAnimationGraphManagerLoadingTask;

	class SimpleAnimationGraphManagerHolder : public IAnimationGraphManagerHolder
	{
	public:
		inline static constexpr auto RTTI = RTTI_SimpleAnimationGraphManagerHolder;

		// override (IAnimationGraphManagerHolder)
		bool GetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_out) const override;  // 02 - { a_out = animationGraphManager; return a_out; }
		bool SetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_in) override;         // 03 - { animationGraphManager = a_in; return true; }
		bool ConstructAnimationGraph(BSTSmartPointer<BShkbAnimationGraph>& a_out) override;                 // 05

		// add
		virtual void Unk_13(void);  // 13 - { return; }

		// members
		BSTSmartPointer<BSAnimationGraphManager>          animationGraphManager;  // 08
		NiPointer<SimpleAnimationGraphManagerLoadingTask> loadingTask;            // 10
	};
	static_assert(sizeof(SimpleAnimationGraphManagerHolder) == 0x18);
}


===============================================
File: include/RE/S/SkillIncrease.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BSTEvent.h"

namespace RE
{
	class PlayerCharacter;

	struct SkillIncrease
	{
	public:
		struct Event
		{
		public:
			// members
			PlayerCharacter* player;      // 00
			ActorValue       actorValue;  // 08
			std::uint32_t    pad0C;       // 0C
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<SkillIncrease::Event>* GetEventSource();
	};
}


===============================================
File: include/RE/S/Sky.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTextureSet.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/S/SkyEffectController.h"

namespace RE
{
	class Atmosphere;
	class BGSLightingTemplate;
	class BSMultiBoundNode;
	class Clouds;
	class ImageSpaceModifierInstanceForm;
	class Moon;
	class NiNode;
	class NiTexture;
	class Precipitation;
	class ReferenceEffect;
	class SkySound;
	class Stars;
	class Sun;
	class TESClimate;
	class TESRegion;
	class TESWeather;

	class Sky
	{
	public:
		inline static constexpr auto RTTI = RTTI_Sky;

		enum class Mode
		{
			kNone = 0,
			kInterior,
			kSkyDomeOnly,
			kFull,

			kTotal
		};

		struct SkyStaticRefData
		{
		public:
		};

		virtual ~Sky();  // 00

		static Sky* GetSingleton();

		[[nodiscard]] bool IsRaining() const;
		[[nodiscard]] bool IsSnowing() const;

		void SetWeather(RE::TESWeather* a_weather, bool a_override, bool a_accelerate);
		void ForceWeather(RE::TESWeather* a_weather, bool a_override);
		void ResetWeather();

		// members
		NiPointer<BSMultiBoundNode>           root;                            // 008
		NiPointer<NiNode>                     moonsRoot;                       // 010
		NiPointer<NiNode>                     auroraRoot;                      // 018
		std::uint64_t                         unk020;                          // 020
		BGSLightingTemplate*                  extLightingOverride;             // 028
		ObjectRefHandle                       currentRoom;                     // 030
		ObjectRefHandle                       previousRoom;                    // 034
		float                                 lightingTransition;              // 038
		float                                 lightingTransitionTimer;         // 03C
		TESClimate*                           currentClimate;                  // 040
		TESWeather*                           currentWeather;                  // 048
		TESWeather*                           lastWeather;                     // 050
		TESWeather*                           defaultWeather;                  // 058
		TESWeather*                           overrideWeather;                 // 060
		TESRegion*                            region;                          // 068
		Atmosphere*                           atmosphere;                      // 070
		Stars*                                stars;                           // 078
		Sun*                                  sun;                             // 080
		Clouds*                               clouds;                          // 088
		Moon*                                 masser;                          // 090
		Moon*                                 secunda;                         // 098
		Precipitation*                        precip;                          // 0A0
		NiColor                               skyColor[17];                    // 0A8
		std::uint32_t                         unk174;                          // 174
		std::uint64_t                         unk178;                          // 178
		std::uint64_t                         unk180;                          // 180
		std::uint32_t                         unk188;                          // 188
		float                                 windSpeed;                       // 18C
		float                                 windAngle;                       // 190
		std::uint32_t                         unk194;                          // 190
		std::uint64_t                         unk198;                          // 198
		std::uint32_t                         unk1A0;                          // 1A0
		std::uint32_t                         unk1A4;                          // 1A4
		float                                 unk1A8;                          // 1A8
		float                                 unk1AC;                          // 1AC
		float                                 currentGameHour;                 // 1B0
		float                                 lastWeatherUpdate;               // 1B4
		float                                 currentWeatherPct;               // 1B8
		stl::enumeration<Mode, std::uint32_t> mode;                            // 1BC
		BSSimpleList<SkySound*>*              skySoundList;                    // 1C0
		float                                 flash;                           // 1C8
		std::uint32_t                         pad1CC;                          // 1CC
		std::time_t                           flashTime;                       // 1D0
		std::uint32_t                         lastMoonPhaseUpdate;             // 1D8
		std::uint32_t                         flags;                           // 1DC
		ImageSpaceModifierInstanceForm*       currentWeatherImageSpaceMod;     // 1E0
		ImageSpaceModifierInstanceForm*       currentWeatherImageSpaceMod2;    // 1E8
		ImageSpaceModifierInstanceForm*       lastWeatherImageSpaceMod;        // 1F0
		ImageSpaceModifierInstanceForm*       lastWeatherImageSpaceMod2;       // 1F8
		NiColor                               directionalAmbientColors[3][2];  // 200
		NiColor                               ambientSpecularTint;             // 248
		float                                 ambientSpecularFresnel;          // 254
		float                                 auroraInStart;                   // 258
		float                                 auroraIn;                        // 25C
		float                                 auroraOutStart;                  // 260
		float                                 auroraOut;                       // 264
		NiPointer<ReferenceEffect>            currentReferenceEffect;          // 268
		NiPointer<ReferenceEffect>            lastReferenceEffect;             // 270
		SkyEffectController                   effectController;                // 278
		BSTArray<NiPointer<NiTexture>>        storedCloudTextures;             // 280
		BSTArray<NiPointer<NiTexture>>        storedWorldMapCloudTextures;     // 298
		BSTArray<SkyStaticRefData>            skyStaticRefData;                // 2B0
	};
	static_assert(sizeof(Sky) == 0x2C8);
}


===============================================
File: include/RE/S/SkyEffectController.h
===============================================
#pragma once

#include "RE/R/ReferenceEffectController.h"

namespace RE
{
	class SkyEffectController : public ReferenceEffectController
	{
	public:
		inline static constexpr auto RTTI = RTTI_SkyEffectController;

		~SkyEffectController() override;  // 00

		// override (ReferenceEffectController)
		void             RemoveHitEffect(ReferenceEffect* a_refEffect) override;  // 0A - { return; }
		TESObjectREFR*   GetTargetReference() override;                           // 0B - { return g_thePlayer; }
		BGSArtObject*    GetHitEffectArt() override;                              // 0C - { return GetSkyReferenceEffectArt(); }
		TESEffectShader* GetHitEffectShader() override;                           // 0D - { return 0; }
		bool             GetManagerHandlesSaveLoad() override;                    // 0E - { return 0; }
		NiAVObject*      GetAttachRoot() override;                                // 0F
		bool             EffectAttachesToCamera() override;                       // 1A - { return true; }
		bool             EffectRotatesWithCamera() override;                      // 1B
	};
	static_assert(sizeof(SkyEffectController) == 0x8);
}


===============================================
File: include/RE/S/SkyObject.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiNode;
	class Sky;

	class SkyObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_SkyObject;
		inline static constexpr auto VTABLE = VTABLE_SkyObject;

		virtual ~SkyObject();  // 00

		// add
		virtual NiNode* GetRoot();                         // 01 - { return root.get(); }
		virtual void    Init(NiNode* a_root);              // 02
		virtual void    Update(Sky* a_sky, float a_arg2);  // 03 - { return; }

		// members
		NiPointer<NiNode> root;  // 10
	};
	static_assert(sizeof(SkyObject) == 0x10);
}


===============================================
File: include/RE/S/SkyrimScriptObjectBindPolicy.h
===============================================
#pragma once

#include "RE/B/BSScriptObjectBindPolicy.h"
#include "RE/B/BSTHashMap.h"

namespace RE
{
	namespace SkyrimScript
	{
		class ObjectBindPolicy : public BSScript::ObjectBindPolicy
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript__ObjectBindPolicy;

			~ObjectBindPolicy() override;  // 00

			// override (BSScript::ObjectBindPolicy)
			void Unk_01(VMHandle a_handle) override;  // 01
			void Unk_02(VMHandle a_handle) override;  // 02
			void Unk_03(VMHandle a_handle) override;  // 03
			void Unk_04() override;                   // 04
			void Unk_05(void) override;               // 05 - { return 0; }
			void Unk_06(void) override;               // 06
			void Unk_07(void) override;               // 07
			void Unk_08(void) override;               // 08
			void Unk_09(void) override;               // 09
			void Unk_0A(void) override;               // 0A
			void Unk_0B(void) override;               // 0B
			void Unk_0C(void) override;               // 0C

			// members
			mutable BSSpinLock           unk50;  // 50
			std::byte                    unk58;  // 58
			std::byte                    unk59;  // 59
			std::byte                    unk5A;  // 5A
			BSTHashMap<UnkKey, UnkValue> unk60;  // 60
			std::uint64_t                unk90;  // 90
			std::uint64_t                unk98;  // 98
			std::uint64_t                unkA0;  // A0
			BSTSet<VMHandle>             unkA8;  // A8
		};
		static_assert(sizeof(ObjectBindPolicy) == 0xD8);
	}
}


===============================================
File: include/RE/S/SkyrimScriptStore.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/I/IStore.h"

namespace RE
{
	namespace BSResource
	{
		class Stream;
	}

	namespace SkyrimScript
	{
		class Store : public BSScript::IStore
		{
		public:
			inline static constexpr auto RTTI = RTTI_SkyrimScript__Store;

			~Store() override;  // 00

			// override (BSScript::IStore)
			std::size_t              GetSize() const override;                                                       // 01
			std::size_t              GetPosition() const override;                                                   // 02
			BSStorageDefs::ErrorCode Seek(std::size_t a_offset, BSStorageDefs::SeekMode a_seekMode) const override;  // 03
			BSStorageDefs::ErrorCode Read(std::size_t a_numBytes, std::byte* a_bytes) const override;                // 04
			bool                     Open(const char* a_fileName) override;                                          // 06
			void                     Close(void) override;                                                           // 07
			const BSFixedString&     GetRelPath() override;                                                          // 08 - { return relPath; }
			bool                     HasOpenFile() override;                                                         // 09 - { return hasOpenFile; }
			bool                     FileIsGood() override;                                                          // 0A - { return fileIsGood; }
			void                     Unk_0B(void) override;                                                          // 0B

			// members
			std::uint64_t       unk20;        // 20
			BSResource::Stream* stream;       // 28
			BSFixedString       relPath;      // 30
			bool                hasOpenFile;  // 38
			bool                fileIsGood;   // 39
			std::uint16_t       pad3A;        // 3A
			std::uint32_t       pad3C;        // 3C
		};
		static_assert(sizeof(Store) == 0x40);
	}
}


===============================================
File: include/RE/S/SkyrimVM.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTFreeList.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTMessageQueue.h"
#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/C/CompiledScriptLoader.h"
#include "RE/D/DelayFunctor.h"
#include "RE/F/FragmentSystem.h"
#include "RE/H/HandlePolicy.h"
#include "RE/I/IFreezeQuery.h"
#include "RE/I/IStackCallbackSaveInterface.h"
#include "RE/L/Logger.h"
#include "RE/P/Profiler.h"
#include "RE/S/SavePatcher.h"
#include "RE/S/SimpleAllocMemoryPagePolicy.h"
#include "RE/S/SkyrimScriptObjectBindPolicy.h"
#include "RE/S/SkyrimScriptStore.h"

namespace RE
{
	namespace BSScript
	{
		class IFunctionArguments;
		class IVirtualMachine;
		class IVMDebugInterface;
		class IVMSaveLoadInterface;
		struct StatsEvent;
	}

	struct PositionPlayerEvent;
	struct TESActivateEvent;
	struct TESActiveEffectApplyRemoveEvent;
	struct TESActorLocationChangeEvent;
	struct TESBookReadEvent;
	struct TESCellAttachDetachEvent;
	struct TESCellFullyLoadedEvent;
	struct TESCombatEvent;
	struct TESContainerChangedEvent;
	struct TESDeathEvent;
	struct TESDestructionStageChangedEvent;
	struct TESEnterBleedoutEvent;
	struct TESEquipEvent;
	struct TESFastTravelEndEvent;
	struct TESFormDeleteEvent;
	struct TESFurnitureEvent;
	struct TESGrabReleaseEvent;
	struct TESHitEvent;
	struct TESInitScriptEvent;
	struct TESLoadGameEvent;
	struct TESLockChangedEvent;
	struct TESMagicEffectApplyEvent;
	struct TESMagicWardHitEvent;
	struct TESMoveAttachDetachEvent;
	struct TESObjectLoadedEvent;
	struct TESObjectREFRTranslationEvent;
	struct TESOpenCloseEvent;
	struct TESPackageEvent;
	struct TESPerkEntryRunEvent;
	struct TESPlayerBowShotEvent;
	struct TESQuestInitEvent;
	struct TESQuestStageEvent;
	struct TESResetEvent;
	struct TESResolveNPCTemplatesEvent;
	struct TESSceneActionEvent;
	struct TESSceneEvent;
	struct TESScenePhaseEvent;
	struct TESSellEvent;
	struct TESSleepStartEvent;
	struct TESSleepStopEvent;
	struct TESSpellCastEvent;
	struct TESSwitchRaceCompleteEvent;
	struct TESTopicInfoEvent;
	struct TESTrackedStatsEvent;
	struct TESTrapHitEvent;
	struct TESTriggerEnterEvent;
	struct TESTriggerEvent;
	struct TESTriggerLeaveEvent;
	struct TESUniqueIDChangeEvent;

	class SkyrimVM :
		public BSTSingletonSDM<SkyrimVM>,                      // 01A0
		public BSScript::IFreezeQuery,                         // 0000
		public BSScript::IStackCallbackSaveInterface,          // 0008
		public BSTEventSink<TESActivateEvent>,                 // 0010
		public BSTEventSink<TESActiveEffectApplyRemoveEvent>,  // 0018
		public BSTEventSink<TESActorLocationChangeEvent>,      // 0020
		public BSTEventSink<TESBookReadEvent>,                 // 0028
		public BSTEventSink<TESCellAttachDetachEvent>,         // 0030
		public BSTEventSink<TESCellFullyLoadedEvent>,          // 0038
		public BSTEventSink<TESCombatEvent>,                   // 0040
		public BSTEventSink<TESContainerChangedEvent>,         // 0048
		public BSTEventSink<TESDeathEvent>,                    // 0050
		public BSTEventSink<TESDestructionStageChangedEvent>,  // 0058
		public BSTEventSink<TESEnterBleedoutEvent>,            // 0060
		public BSTEventSink<TESEquipEvent>,                    // 0068
		public BSTEventSink<TESFormDeleteEvent>,               // 0070
		public BSTEventSink<TESFurnitureEvent>,                // 0078
		public BSTEventSink<TESGrabReleaseEvent>,              // 0080
		public BSTEventSink<TESHitEvent>,                      // 0088
		public BSTEventSink<TESInitScriptEvent>,               // 0090
		public BSTEventSink<TESLoadGameEvent>,                 // 0098
		public BSTEventSink<TESLockChangedEvent>,              // 00A0
		public BSTEventSink<TESMagicEffectApplyEvent>,         // 00A8
		public BSTEventSink<TESMagicWardHitEvent>,             // 00B0
		public BSTEventSink<TESMoveAttachDetachEvent>,         // 00B8
		public BSTEventSink<TESObjectLoadedEvent>,             // 00C0
		public BSTEventSink<TESObjectREFRTranslationEvent>,    // 00C8
		public BSTEventSink<TESOpenCloseEvent>,                // 00D0
		public BSTEventSink<TESPackageEvent>,                  // 00D8
		public BSTEventSink<TESPerkEntryRunEvent>,             // 00E0
		public BSTEventSink<TESQuestInitEvent>,                // 00E8
		public BSTEventSink<TESQuestStageEvent>,               // 00F0
		public BSTEventSink<TESResetEvent>,                    // 00F8
		public BSTEventSink<TESResolveNPCTemplatesEvent>,      // 0100
		public BSTEventSink<TESSceneEvent>,                    // 0108
		public BSTEventSink<TESSceneActionEvent>,              // 0110
		public BSTEventSink<TESScenePhaseEvent>,               // 0118
		public BSTEventSink<TESSellEvent>,                     // 0120
		public BSTEventSink<TESSleepStartEvent>,               // 0128
		public BSTEventSink<TESSleepStopEvent>,                // 0130
		public BSTEventSink<TESSpellCastEvent>,                // 0138
		public BSTEventSink<TESTopicInfoEvent>,                // 0140
		public BSTEventSink<TESTrackedStatsEvent>,             // 0148
		public BSTEventSink<TESTrapHitEvent>,                  // 0150
		public BSTEventSink<TESTriggerEvent>,                  // 0158
		public BSTEventSink<TESTriggerEnterEvent>,             // 0160
		public BSTEventSink<TESTriggerLeaveEvent>,             // 0168
		public BSTEventSink<TESUniqueIDChangeEvent>,           // 0170
		public BSTEventSink<TESSwitchRaceCompleteEvent>,       // 0178
		public BSTEventSink<TESPlayerBowShotEvent>,            // 0180
		public BSTEventSink<TESFastTravelEndEvent>,            // 0188
		public BSTEventSink<PositionPlayerEvent>,              // 0190
		public BSTEventSink<BSScript::StatsEvent>,             // 0198
		public BSTEventSource<BSScript::StatsEvent>            // 01A8
	{
	public:
		inline static constexpr auto RTTI = RTTI_SkyrimVM;

		struct UpdateDataEvent : public BSIntrusiveRefCounted
		{
		public:
			enum class UpdateType : bool
			{
				kRepeat = 0,    // RegisterForUpdate/RegisterForUpdateGameTime
				kNoRepeat = 1,  // RegisterForSingleUpdate/RegisterForSingleUpdateGameTime
			};

			// members
			UpdateType    updateType;       // 04
			std::uint16_t pad06;            // 06
			std::uint32_t timeToSendEvent;  // 08 - updateTime + currentVMMenuMode/currentVMDaysPassed
			std::uint32_t updateTime;       // 0C
			VMHandle      handle;           // 10
		};
		static_assert(sizeof(UpdateDataEvent) == 0x18);

		struct WaitCall
		{
		public:
			// members
			std::uint32_t              timeToSendEvent;  // 00 - Same as UpdateDataEvent, updateTime is discarded
			VMStackID                  stackID;          // 04 - used for vm->ReturnFromLatent()
			BSScript::IVirtualMachine* vm;               // 08
		};
		static_assert(sizeof(WaitCall) == 0x10);

		struct LOSDataEvent : public BSIntrusiveRefCounted
		{
		public:
			enum class LOSEventType
			{
				kGain = 0,
				kLost,
				kBoth,
			};

			enum class PreviousLOS
			{
				kLOS = 1,
				kNoLOS = 2
			};

			// members
			std::uint32_t pad04;               // 04
			VMHandle      handle;              // 08
			FormID        akViewerFormID;      // 10
			FormID        akTargetFormID;      // 14
			LOSEventType  losEventType;        // 18
			PreviousLOS   lastLOSCheckResult;  // 1C - (2 - (akViewer::HasLOS(akTarget) != 0))
		};
		static_assert(sizeof(LOSDataEvent) == 0x20);

		struct InventoryEventFilterLists : public BSIntrusiveRefCounted
		{
			// members
			BSTSet<FormID> itemsForFiltering;      // 08
			BSTSet<FormID> itemListsForFiltering;  // 38
		};
		static_assert(sizeof(InventoryEventFilterLists) == 0x68);

		struct ISendEventFilter
		{
			virtual bool matchesFilter(VMHandle handle) = 0;
		};

		~SkyrimVM() override;  // 00

		static SkyrimVM* GetSingleton();

		bool QueuePostRenderCall(const BSTSmartPointer<SkyrimScript::DelayFunctor>& a_functor);
		void RelayEvent(VMHandle handle, BSFixedString* event, BSScript::IFunctionArguments* args, ISendEventFilter* optionalFilter);
		void SendAndRelayEvent(VMHandle handle, BSFixedString* event, BSScript::IFunctionArguments* args, ISendEventFilter* optionalFilter);

		// members
		BSTSmartPointer<BSScript::IVirtualMachine>                            impl;                         // 0200
		BSScript::IVMSaveLoadInterface*                                       saveLoadInterface;            // 0208
		BSScript::IVMDebugInterface*                                          debugInterface;               // 0210
		BSScript::SimpleAllocMemoryPagePolicy                                 memoryPagePolicy;             // 0218
		BSScript::CompiledScriptLoader                                        scriptLoader;                 // 0240
		SkyrimScript::Logger                                                  logger;                       // 0278
		SkyrimScript::HandlePolicy                                            handlePolicy;                 // 0328
		SkyrimScript::ObjectBindPolicy                                        objectBindPolicy;             // 0398
		BSTSmartPointer<SkyrimScript::Store>                                  scriptStore;                  // 0470
		SkyrimScript::FragmentSystem                                          fragmentSystem;               // 0478
		SkyrimScript::Profiler                                                profiler;                     // 0590
		SkyrimScript::SavePatcher                                             savePatcher;                  // 0670
		mutable BSSpinLock                                                    frozenLock;                   // 0678
		std::uint32_t                                                         isFrozen;                     // 0680
		mutable BSSpinLock                                                    currentVMTimeLock;            // 0684
		std::uint32_t                                                         currentVMTime;                // 068C
		std::uint32_t                                                         currentVMMenuModeTime;        // 0690
		std::uint32_t                                                         currentVMGameTime;            // 0694
		std::uint32_t                                                         currentVMDaysPassed;          // 0698 - Calender.GetDaysPassed() * 1000
		mutable BSSpinLock                                                    queuedWaitEventLock;          // 069C
		std::uint32_t                                                         pad06A4;                      // 06A4
		BSTArray<WaitCall>                                                    queuedWaitCalls;              // 06A8 - Utility.Wait() calls
		BSTArray<WaitCall>                                                    queuedWaitMenuModeCalls;      // 06C0 - Utility.WaitMenuMode() calls
		BSTArray<WaitCall>                                                    queuedWaitGameCalls;          // 06D8 - Utility.WaitGameTime() calls
		mutable BSSpinLock                                                    queuedLOSEventCheckLock;      // 06F0
		BSTArray<BSTSmartPointer<LOSDataEvent>>                               queuedLOSEventChecks;         // 06F8 - OnGainLOS/OnLostLOS
		std::uint32_t                                                         currentLOSEventCheckIndex;    // 0710
		mutable BSSpinLock                                                    queuedOnUpdateEventLock;      // 0714
		std::uint32_t                                                         pad071C;                      // 071C
		BSTArray<BSTSmartPointer<UpdateDataEvent>>                            queuedOnUpdateEvents;         // 0720
		BSTArray<BSTSmartPointer<UpdateDataEvent>>                            queuedOnUpdateGameEvents;     // 0738
		std::uint32_t                                                         unk0750;                      // 0750
		mutable BSSpinLock                                                    registeredSleepEventsLock;    // 0754
		std::uint32_t                                                         pad075C;                      // 075C
		BSTSet<VMHandle>                                                      registeredSleepEvents;        // 0760 - RegisterForSleep
		mutable BSSpinLock                                                    registeredStatsEventsLock;    // 0790
		BSTSet<VMHandle>                                                      registeredStatsEvents;        // 0798 - RegisterForTrackedStats
		BSTStaticFreeList<BSTSmartPointer<SkyrimScript::DelayFunctor>, 512>   renderSafeFunctorPool1;       // 07C8
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>  renderSafeFunctorQueue1;      // 27E0
		BSTStaticFreeList<BSTSmartPointer<SkyrimScript::DelayFunctor>, 512>   renderSafeFunctorPool2;       // 2808
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>  renderSafeFunctorQueue2;      // 4820
		BSTStaticFreeList<BSTSmartPointer<SkyrimScript::DelayFunctor>, 512>   postRenderFunctorPool1;       // 4848
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>  postRenderFunctorQueue1;      // 6860
		BSTStaticFreeList<BSTSmartPointer<SkyrimScript::DelayFunctor>, 512>   postRenderFunctorPool2;       // 6888
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>  postRenderFunctorQueue2;      // 88A0
		mutable BSSpinLock                                                    renderSafeQueueLock;          // 88C8
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>* renderSafeQueueToReadFrom;    // 88D0
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>* renderSafeQueueToWriteTo;     // 88D8
		mutable BSSpinLock                                                    postRenderQueueLock;          // 88E0
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>* postRenderQueueToReadFrom;    // 88E8
		BSTCommonLLMessageQueue<BSTSmartPointer<SkyrimScript::DelayFunctor>>* postRenderQueueToWriteTo;     // 88F0
		mutable BSSpinLock                                                    userLogMapLock;               // 88F8
		BSTHashMap<const char*, SkyrimScript::Logger*>                        userLogMap;                   // 8900 - Debug.OpenUserLog()
		mutable BSSpinLock                                                    currentVMOverstressTimeLock;  // 8930
		std::uint32_t                                                         currentVMOverstressTime;      // 8938
		std::uint32_t                                                         lastVMStackDumpTime;          // 893C
		mutable BSSpinLock                                                    InventoryEventFilterMapLock;  // 8940
		BSTHashMap<VMHandle, InventoryEventFilterLists*>                      InventoryEventFilterMap;      // 8948 - AddInventoryEventFilter()
	};
	static_assert(sizeof(SkyrimVM) == 0x8978);
}


===============================================
File: include/RE/S/SleepWaitMenu.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 4
	// flags = kPausesGame | kRequiresUpdate | kAllowSaving | kApplicationMenu
	// kUsesCursor if gamepad disabled
	// context = kMenuMode
	class SleepWaitMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_SleepWaitMenu;
		constexpr static std::string_view MENU_NAME = "Sleep/Wait Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                           \
	std::uint32_t unk30; /* 00 */                      \
	std::uint32_t pad34; /* 04 */                      \
	GFxValue      root;  /* 08 - "SleepWaitMenu_mc" */ \
	std::uint8_t  unk50; /* 20 */                      \
	std::uint8_t  unk51; /* 21 */                      \
	std::uint16_t pad52; /* 22 */                      \
	std::uint32_t pad54; /* 24 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x28);

		~SleepWaitMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(SleepWaitMenu) == 0x58);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(SleepWaitMenu) == 0x68);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/S/SlowTimeEffect.h
===============================================
#pragma once

#include "RE/B/BSSoundHandle.h"
#include "RE/S/ScriptEffect.h"

namespace RE
{
	class SlowTimeEffect :
		public ScriptEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_SlowTimeEffect;
		inline static constexpr auto VTABLE = VTABLE_SlowTimeEffect;

		// override (ActiveEffect)
		virtual ~SlowTimeEffect();       // 13
		virtual void Start() override;   // 14
		virtual void Finish() override;  // 15

		// members
		BSSoundHandle activeSound;  // A0
	};
	static_assert(sizeof(SlowTimeEffect) == 0xB0);
}


===============================================
File: include/RE/S/SmithingMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/C/CraftingSubMenu.h"
#include "RE/I/IMessageBoxCallback.h"

namespace RE
{
	class InventoryEntryData;

	namespace CraftingSubMenus
	{
		class SmithingMenu : public CraftingSubMenu
		{
		public:
			inline static constexpr auto RTTI = RTTI_CraftingSubMenus__SmithingMenu;

			class SmithingConfirmCallback : public IMessageBoxCallback
			{
			public:
				inline static constexpr auto RTTI = RTTI_CraftingSubMenus__SmithingMenu__SmithingConfirmCallback;

				~SmithingConfirmCallback() override;  // 00

				// override (IMessageBoxCallback)
				void Run(Message a_msg) override;  // 01

				// members
				SmithingMenu* subMenu;  // 10
			};
			static_assert(sizeof(SmithingConfirmCallback) == 0x18);

			struct SmithingItemEntry
			{
				// members
				TESForm*                item;                 // 00
				std::int64_t            unk08;                // 08
				BGSConstructibleObject* constructibleObject;  // 10
				float                   unk18;                // 18 - Health of item?
				float                   unk1C;                // 1C - kSmithing actor value?
				int                     unk20;                // 20
				int                     unk24;                // 24
				std::byte               unk28;                // 28
				std::byte               unk29;                // 29
				std::byte               unk2A;                // 2A
				std::byte               pad2B;                // 2B
				std::uint32_t           pad2C;                // 2C
			};
			static_assert(sizeof(SmithingItemEntry) == 0x30);

			~SmithingMenu() override;  // 00

			// override (CraftingSubMenu)
			void Accept(CallbackProcessor* a_cbReg) override;          // 01
			void Unk_02(void) override;                                // 02
			bool ProcessUserEvent(BSFixedString* a_control) override;  // 05

			// members
			BSTArray<SmithingItemEntry>  unk100;        // 100
			BSTHashMap<UnkKey, UnkValue> unk118;        // 118 - constructibleObject map?
			NiPointer<TESObjectREFR>     furnitureRef;  // 148
			std::uint32_t                unk150;        // 150
			std::int32_t                 unk154;        // 154
			FormType                     smithingType;  // 158
			std::uint32_t                unk15C;        // 15C
			InventoryEntryData*          unk160;        // 160
		};
		static_assert(sizeof(SmithingMenu) == 0x168);
	}
}


===============================================
File: include/RE/S/SneakHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	struct SneakHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_SneakHandler;

		~SneakHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04
	};
	static_assert(sizeof(SneakHandler) == 0x10);
}


===============================================
File: include/RE/S/SoulLevels.h
===============================================
#pragma once

namespace RE
{
	enum class SOUL_LEVEL
	{
		kNone = 0,
		kPetty = 1,
		kLesser = 2,
		kCommon = 3,
		kGreater = 4,
		kGrand = 5
	};
}


===============================================
File: include/RE/S/SoulTrapEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class SoulTrapEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_SoulTrapEffect;
		inline static constexpr auto VTABLE = VTABLE_SoulTrapEffect;

		// override (ActiveEffect)
		virtual void Update(float a_delta) override;  // 04
		virtual ~SoulTrapEffect();                    // 13
		virtual void Finish() override;               // 15
	};
	static_assert(sizeof(SoulTrapEffect) == 0x90);
}


===============================================
File: include/RE/S/SoulsTrapped.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class Actor;

	struct SoulsTrapped
	{
	public:
		struct Event
		{
		public:
			// members
			Actor* trapper;  // 00
			Actor* target;   // 08
		};
		static_assert(sizeof(Event) == 0x10);

		static BSTEventSource<SoulsTrapped::Event>* GetEventSource();
		static void                                 SendEvent(Actor* a_trapper, Actor* a_target);
	};
}


===============================================
File: include/RE/S/SoundLevels.h
===============================================
#pragma once

namespace RE
{
	enum class SOUND_LEVEL
	{
		kLoud = 0,
		kNormal = 1,
		kSilent = 2,
		kVeryLoud = 3,
		kQuiet = 4
	};
}


===============================================
File: include/RE/S/SourceActionMap.h
===============================================
#pragma once

#include "RE/B/BGSDefaultObjectManager.h"

namespace RE
{
	class Actor;

	namespace SourceActionMap
	{
		[[nodiscard]] std::span<DEFAULT_OBJECT, 12> GetSingleton();
		bool                                        DoAction(Actor* a_actor, DEFAULT_OBJECT a_action);
	}
}


===============================================
File: include/RE/S/SpawnHazardEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/B/BSPointerHandle.h"

namespace RE
{
	class ActorCause;
	template <class>
	class NiPointer;

	class SpawnHazardEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_SpawnHazardEffect;
		inline static constexpr auto VTABLE = VTABLE_SpawnHazardEffect;

		// override (ActiveEffect)
		virtual void HandleQueuedStart() override;  // 0F
		virtual ~SpawnHazardEffect();               // 13
		virtual void Start() override;              // 14
		virtual void Finish() override;             // 15

		// members
		NiPointer<ActorCause> actorCause;  // 90
		ObjectRefHandle       hazard;      // 98
	};
	static_assert(sizeof(SpawnHazardEffect) == 0xA0);
}


===============================================
File: include/RE/S/SpellItem.h
===============================================
#pragma once

#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSMenuDisplayObject.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MagicItem.h"
#include "RE/T/TESDescription.h"

namespace RE
{
	class SpellItem :
		public MagicItem,             // 00
		public BGSEquipType,          // 90
		public BGSMenuDisplayObject,  // A0
		public TESDescription         // B0
	{
	public:
		inline static constexpr auto RTTI = RTTI_SpellItem;
		inline static constexpr auto VTABLE = VTABLE_SpellItem;
		inline static constexpr auto FORMTYPE = FormType::Spell;

		enum class SpellFlag
		{
			kNone = 0,
			kCostOverride = 1 << 0,
			kFoodItem = 1 << 1,
			kExtendDuration = 1 << 3,
			kPCStartSpell = 1 << 17,
			kInstantCast = 1 << 18,
			kIgnoreLOSCheck = 1 << 19,
			kIgnoreResistance = 1 << 20,
			kNoAbsorb = 1 << 21,
			kNoDualCastMods = 1 << 23
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		class Data  // SPIT
		{
		public:
			// members
			std::int32_t                               costOverride;  // 00
			stl::enumeration<SpellFlag, std::uint32_t> flags;         // 04
			MagicSystem::SpellType                     spellType;     // 08
			float                                      chargeTime;    // 0C
			MagicSystem::CastingType                   castingType;   // 10
			MagicSystem::Delivery                      delivery;      // 14
			float                                      castDuration;  // 18
			float                                      range;         // 1C
			BGSPerk*                                   castingPerk;   // 20
		};
		static_assert(sizeof(Data) == 0x28);

		~SpellItem() override;  // 00

		// override (MagicItem)
		void                                   InitializeData() override;                                             // 04
		void                                   ClearData() override;                                                  // 05
		void                                   InitItemImpl() override;                                               // 13
		[[nodiscard]] MagicSystem::SpellType   GetSpellType() const override;                                         // 53 - { return data.spellType; }
		void                                   SetCastingType(MagicSystem::CastingType a_type) override;              // 54 - { data.castingType = a_type; }
		[[nodiscard]] MagicSystem::CastingType GetCastingType() const override;                                       // 55 - { return data.castingType; }
		void                                   SetDelivery(MagicSystem::Delivery a_type) override;                    // 56 - { if (Unk_58()) { data.delivery = a_type; } }
		[[nodiscard]] MagicSystem::Delivery    GetDelivery() const override;                                          // 57 - { return data.delivery; }
		[[nodiscard]] float                    GetFixedCastDuration() const override;                                 // 59 - { return (GetCastingType() == MagicSystem::CastingType::kConcentration) ? data.castDuration : 0.0; }
		[[nodiscard]] float                    GetRange() const override;                                             // 5A - { return data.range; }
		[[nodiscard]] bool                     IgnoresResistance() const override;                                    // 5B - { return (GetData()->flags >> 20) & 1; }
		[[nodiscard]] bool                     IgnoreLOS() const override;                                            // 5C - { return (GetData()->flags >> 19) & 1; }
		[[nodiscard]] bool                     GetNoAbsorb() const override;                                          // 5E - { return (GetData()->flags >> 21) & 1; }
		[[nodiscard]] bool                     GetNoDualCastModifications() const override;                           // 5F - { return (GetData()->flags >> 23) & 1; }
		bool                                   GetSkillUsageData(SkillUsageData& a_data) const override;              // 60
		void                                   AdjustCost(float& a_cost, Actor* a_actor) const override;              // 63
		[[nodiscard]] float                    GetChargeTime() const override;                                        // 64
		[[nodiscard]] ActorValue               GetAssociatedSkill() const override;                                   // 66
		[[nodiscard]] bool                     IsTwoHanded() const override;                                          // 67 - { BGSEquipSlot* equipSlot = BGSEquipType::GetEquipSlot(); return equipSlot && equipSlot->flags & 1; }
		[[nodiscard]] std::uint32_t            GetChunkID() override;                                                 // 68 - { return 'SPIT'; }
		void                                   CopyMagicItemData(MagicItem* a_src) override;                          // 69
		void                                   LoadMagicItemChunk(TESFile* a_mod, std::uint32_t a_chunkID) override;  // 6A
		void                                   LoadChunkDataPostProcess(TESFile* a_mod) override;                     // 6B
		[[nodiscard]] const MagicItem::Data*   GetData1() const override;                                             // 6C - { return &data; }
		[[nodiscard]] MagicItem::Data*         GetData2() override;                                                   // 6D - { return &data; }
		[[nodiscard]] std::uint32_t            GetDataSize() const override;                                          // 6E - { return 0x28; }
		void                                   InitFromChunk(TESFile* a_mod) override;                                // 6F
		void                                   InitChunk() override;                                                  // 70

		// override (BGSMenuDisplayObject)
		[[nodiscard]] TESBoundObject* GetMenuDisplayObject() const override;  // 04 - { return menuDispObject; }

		// members
		Data data;  // C0 - SPIT
	};
	static_assert(sizeof(SpellItem) == 0xE8);
}


===============================================
File: include/RE/S/SpellsLearned.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"

namespace RE
{
	class SpellItem;

	struct SpellsLearned
	{
	public:
		struct Event
		{
		public:
			// members
			SpellItem* spell;  // 00
		};
		static_assert(sizeof(Event) == 0x8);

		static BSTEventSource<Event>* GetEventSource();
		static void                   SendEvent(SpellItem* a_spell);
	};
}


===============================================
File: include/RE/S/SprintHandler.h
===============================================
#pragma once

#include "RE/H/HeldStateHandler.h"

namespace RE
{
	struct SprintHandler : public HeldStateHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_SprintHandler;

		~SprintHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04
	};
	static_assert(sizeof(SprintHandler) == 0x18);
}


===============================================
File: include/RE/S/Stack.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/M/MemoryPage.h"
#include "RE/V/Variable.h"

namespace RE
{
	namespace BSScript
	{
		namespace Internal
		{
			class CodeTasklet;
		}

		class IProfilePolicy;
		class IStackCallbackFunctor;
		class StackFrame;
		class Variable;
		struct IMemoryPagePolicy;

		class Stack : public BSIntrusiveRefCounted
		{
		public:
			enum class State
			{
				kRunning = 0,
				kFinished = 1,
				kWaitingOnMemory = 2,
				kWaitingOnLatentFunction = 3,
				kWaitingOnOtherStackForCall = 4,
				kWaitingOnOtherStackForReturn = 5,
				kWaitingOnOtherStackForReturnNoPop = 6,
				kRetryReturnNoPop = 7,
				kRetryCall = 8
			};

			enum class FreezeState
			{
				kUnfrozen = 0,
				kFreezing = 1,
				kFrozen = 2
			};

			enum class StackType
			{
				kNormal,
				kPropertyInitialize,
				kInitialize
			};

			struct MemoryPageData
			{
			public:
				// members
				BSTAutoPointer<MemoryPage> page;                    // 00
				std::uint32_t              availableMemoryInBytes;  // 08 - e.g. a function with 1 arg will have 3 unused args, so this will be 0x30, a function with 6 args will have 0 unused args, so this will be 0x0
				std::uint32_t              pad0C;                   // 0C
			};
			static_assert(sizeof(MemoryPageData) == 0x10);

			~Stack();

			std::uint32_t GetPageForFrame(const StackFrame* a_frame) const;
			Variable&     GetStackFrameVariable(const StackFrame* a_frame, std::uint32_t a_index, std::uint32_t a_pageHint);

			// members
			std::uint32_t                                pad04;          // 04
			IMemoryPagePolicy*                           policy;         // 08
			IProfilePolicy*                              profilePolicy;  // 10
			BSTSmallArray<MemoryPageData, 3>             pages;          // 18
			std::uint32_t                                frames;         // 58
			std::uint32_t                                pad5C;          // 5C
			StackFrame*                                  top;            // 60
			stl::enumeration<State, std::uint32_t>       state;          // 68
			stl::enumeration<FreezeState, std::uint32_t> freezeState;    // 6C
			Variable                                     returnValue;    // 70
			VMStackID                                    stackID;        // 80
			stl::enumeration<StackType, std::uint32_t>   stackType;      // 84
			BSTSmartPointer<Internal::CodeTasklet>       owningTasklet;  // 88
			BSTSmartPointer<IStackCallbackFunctor>       callback;       // 90
			BSTSmartPointer<Stack>                       nextStack;      // 98

		private:
			void Dtor();
		};
		static_assert(sizeof(Stack) == 0xA0);
	}
}


===============================================
File: include/RE/S/StackFrame.h
===============================================
#pragma once

#include "RE/B/BSTSmartPointer.h"
#include "RE/V/Variable.h"

namespace RE
{
	namespace BSScript
	{
		class IFunction;
		class ObjectTypeInfo;
		class Stack;

		class StackFrame
		{
		public:
			[[nodiscard]] std::uint32_t GetPageForFrame() const;
			[[nodiscard]] Variable&     GetStackFrameVariable(std::uint32_t a_index, std::uint32_t a_pageHint) const;

			// members
			Stack*                          parent;              // 00
			StackFrame*                     previousFrame;       // 08
			BSTSmartPointer<IFunction>      owningFunction;      // 10
			BSTSmartPointer<ObjectTypeInfo> owningObjectType;    // 18
			std::uint32_t                   instructionPointer;  // 20
			std::uint32_t                   pad24;               // 24
			Variable                        self;                // 28
			std::uint32_t                   size;                // 38
			bool                            instructionsValid;   // 3C
			std::uint8_t                    pad3D;               // 3D
			std::uint16_t                   pad3E;               // 3E

			//Variable args[4];	40 - minimum space for 4 args is allocated
		};
		static_assert(sizeof(StackFrame) == 0x40);  // frames can be larger
	}
}


===============================================
File: include/RE/S/StaggerEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class StaggerEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_StaggerEffect;
		inline static constexpr auto VTABLE = VTABLE_StaggerEffect;

		// override (ActiveEffect)
		virtual ~StaggerEffect();       // 13
		virtual void Start() override;  // 14
	};
	static_assert(sizeof(StaggerEffect) == 0x90);
}


===============================================
File: include/RE/S/StandardItemData.h
===============================================
#pragma once

namespace RE
{
	class InventoryEntryData;

	class StandardItemData
	{
	public:
		inline static constexpr auto RTTI = RTTI_StandardItemData;

		virtual ~StandardItemData();  // 00

		virtual const char*   GetName();        // 01 - { return objDesc->GenerateName(); }
		virtual std::uint32_t GetCount();       // 02 - { return objDesc->GetCount(); }
		virtual std::uint32_t GetEquipState();  // 03
		virtual std::uint32_t GetFilterFlag();  // 04
		virtual std::uint32_t GetFavorite();    // 05
		virtual bool          GetEnabled();     // 06 - { return true; }

		// members
		InventoryEntryData* objDesc;  // 08
		RefHandle           owner;    // 10
		std::uint32_t       pad14;    // 14
	};
	static_assert(sizeof(StandardItemData) == 0x18);
}


===============================================
File: include/RE/S/Stars.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"
#include "RE/S/SkyObject.h"

namespace RE
{
	class NiNode;

	class Stars : public SkyObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_Stars;
		inline static constexpr auto VTABLE = VTABLE_Stars;

		~Stars() override;  // 00

		// override (SkyObject)
		void Init(NiNode* a_root) override;              // 02
		void Update(Sky* a_sky, float a_arg2) override;  // 03

		// members
		NiPointer<NiNode> stars;  // 10
		float             alpha;  // 18
		std::uint32_t     pad1C;  // 1C
	};
	static_assert(sizeof(Stars) == 0x20);
}


===============================================
File: include/RE/S/State.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTexture.h"

namespace RE
{
	namespace BSGraphics
	{
		class State
		{
		public:
			[[nodiscard]] static State* GetSingleton()
			{
				REL::Relocation<State*> singleton{ RELOCATION_ID(524998, 411479) };
				return singleton.get();
			}

			// members
			std::uint64_t        unk00;                     // 000
			std::uint64_t        unk08;                     // 008
			std::uint64_t        unk10;                     // 010
			std::uint64_t        unk18;                     // 018
			std::uint32_t        unk20;                     // 020
			std::uint32_t        screenWidth;               // 024
			std::uint32_t        screenHeight;              // 028
			std::uint32_t        frameBufferViewport[2];    // 02C
			std::uint32_t        unk34;                     // 034
			std::uint64_t        unk38;                     // 038
			std::uint64_t        unk40;                     // 040
			std::uint64_t        unk48;                     // 048
			bool                 insideFrame;               // 050
			bool                 letterbox;                 // 051
			std::uint16_t        unk52;                     // 052
			std::uint32_t        unk54;                     // 054
			NiPointer<NiTexture> unk058;                    // 058 - black?
			NiPointer<NiTexture> defaultTextureWhite;       // 060
			NiPointer<NiTexture> defaultTextureGrey;        // 068
			NiPointer<NiTexture> defaultHeightMap;          // 070
			NiPointer<NiTexture> defaultReflectionCubeMap;  // 078
			NiPointer<NiTexture> defaultFaceDetailMap;      // 080
			NiPointer<NiTexture> defaultTexEffectMap;       // 088
			NiPointer<NiTexture> defaultTextureNormalMap;   // 090
		};
		static_assert(offsetof(State, screenWidth) == 0x24);
		static_assert(offsetof(State, frameBufferViewport) == 0x2C);
		static_assert(offsetof(State, letterbox) == 0x51);
	}
}


===============================================
File: include/RE/S/StatsEvent.h
===============================================
#pragma once

namespace RE
{
	namespace BSScript
	{
		struct StatsEvent
		{
		public:
			// members
			std::uint32_t runningStacksCount;    // 00
			std::uint32_t suspendedStacksCount;  // 04
			std::uint32_t functionMsgCount;      // 08
			std::uint32_t detachedObjectCount;   // 0C
		};
		static_assert(sizeof(StatsEvent) == 0x10);
	}
}


===============================================
File: include/RE/S/StatsMenu.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BSTArray.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"
#include "RE/M/MenuEventHandler.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class BSEffectShaderProperty;
	class BSFadeNode;
	class BSScaleformMovieLoadTask;
	class NiCamera;
	class NiControllerManager;
	class NiControllerSequence;
	class NiNode;
	class StatsNode;

	namespace BSResource
	{
		struct ID;
	}

	// menuDepth = 3
	// flags = kPausesGame | kUsesMenuContext | kDisablePauseMenu | kRequiresUpdate | kCustomRendering
	// kUsesCursor if gamepad disabled
	// context = kStats
	class StatsMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,            // 000
		public MenuEventHandler  // 030, 040
#else
		public IMenu  // 000
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_StatsMenu;
		constexpr static std::string_view MENU_NAME = "StatsMenu";

		enum
		{
			kTotalTrees = 18
		};

		struct UnkData
		{
		public:
			enum class State
			{
				kResting = 0,
				kEntering = 1,
				kExiting = 2
			};

			// members
			BSEffectShaderProperty*                unk00;  // 00
			stl::enumeration<State, std::uint32_t> state;  // 08
			std::uint32_t                          unk0C;  // 0C
		};
		static_assert(sizeof(UnkData) == 0x10);

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                                             \
	NiCamera*                 unk040;                 /* 000 */                                          \
	float                     horizontalVelocity;     /* 008 */                                          \
	std::uint32_t             unk04C;                 /* 00C */                                          \
	BSTArray<ActorValue>      skillTrees;             /* 010 */                                          \
	BSResource::ID*           skydomeHash;            /* 028 */                                          \
	BSResource::ID*           starsHash;              /* 030 */                                          \
	BSResource::ID*           linesHash;              /* 038 */                                          \
	BSFadeNode*               skydomeNode;            /* 040 */                                          \
	BSFadeNode*               starsNode;              /* 048 */                                          \
	BSFadeNode*               linesNode;              /* 050 */                                          \
	UnkData                   unk098[kTotalTrees];    /* 058 */                                          \
	bool                      zoomed;                 /* 178 */                                          \
	std::uint8_t              unk1B9;                 /* 179 */                                          \
	std::uint16_t             unk1BA;                 /* 17A */                                          \
	bool                      scrolling;              /* 17C */                                          \
	std::uint8_t              unk1BD;                 /* 17D */                                          \
	std::uint16_t             unk1BE;                 /* 17E */                                          \
	std::uint32_t             selectedTree;           /* 180 */                                          \
	std::uint32_t             unk1C4;                 /* 184 */                                          \
	StatsNode*                unk1C8;                 /* 188 */                                          \
	std::uint32_t             unk1D0;                 /* 190 */                                          \
	std::uint32_t             unk1D4;                 /* 194 */                                          \
	std::uint32_t             unk1D8;                 /* 198 */                                          \
	std::uint32_t             unk1DC;                 /* 19C */                                          \
	std::uint64_t             unk1E0;                 /* 1A0 */                                          \
	std::uint32_t             unk1E8;                 /* 1A8 */                                          \
	NiPoint3                  skillsLookAt;           /* 1AC */                                          \
	NiPoint3                  starCameraOffset;       /* 1B8 */                                          \
	NiPoint3                  starLookAt;             /* 0C4 */                                          \
	std::uint64_t             unk210;                 /* 0D0 */                                          \
	std::uint64_t             unk218;                 /* 0D8 */                                          \
	std::uint64_t             unk220;                 /* 0E0 */                                          \
	std::uint64_t             unk228;                 /* 0E8 */                                          \
	std::uint64_t             unk230;                 /* 0F0 */                                          \
	std::uint64_t             unk238;                 /* 0F8 */                                          \
	float                     unk240;                 /* 200 */                                          \
	float                     unk244;                 /* 204 */                                          \
	float                     unk248;                 /* 208 */                                          \
	float                     unk24C;                 /* 20C */                                          \
	float                     unk250;                 /* 210 */                                          \
	float                     unk254;                 /* 214 */                                          \
	float                     unk258;                 /* 218 */                                          \
	float                     unk25C;                 /* 21C */                                          \
	float                     unk260;                 /* 220 */                                          \
	float                     unk264;                 /* 224 */                                          \
	float                     unk268;                 /* 228 */                                          \
	float                     unk26C;                 /* 22C */                                          \
	float                     unk270;                 /* 230 */                                          \
	float                     unk274;                 /* 234 */                                          \
	std::uint32_t             unk278;                 /* 238 */                                          \
	float                     unk27C;                 /* 23C */                                          \
	float                     horizontalAcceleration; /* 240 */                                          \
	std::uint32_t             unk284;                 /* 244 */                                          \
	NiNode*                   cameraPosition;         /* 248 */                                          \
	NiControllerSequence*     cameraIntro;            /* 250 */                                          \
	NiControllerSequence*     cameraOutro;            /* 258 */                                          \
	NiControllerSequence*     idle;                   /* 260 */                                          \
	NiControllerManager*      unk2A8;                 /* 268 */                                          \
	std::uint64_t             unk2B0;                 /* 270 */                                          \
	std::uint64_t             unk2B8;                 /* 278 */                                          \
	BSTArray<StatsNode*>      unk2C0;                 /* 280 */                                          \
	BSTArray<GFxValue>        unk2D8;                 /* 298 */                                          \
	BSScaleformMovieLoadTask* unk2F0;                 /* 2B0 */                                          \
	GFxValue                  unk2F8;                 /* 2B8 - StatsMenuBaseInstance.BeastSkillHolder */ \
	std::uint32_t             numSelectableTrees;     /* 2D0 */                                          \
	float                     unk314;                 /* 2D4 */                                          \
	float                     unk318;                 /* 2D8 */                                          \
	std::uint32_t             flags;                  /* 2DC */                                          \
	std::uint8_t              unk320;                 /* 2E0 */                                          \
	std::uint8_t              unk321;                 /* 2E1 */                                          \
	std::uint16_t             unk322;                 /* 2E2 */                                          \
	std::uint32_t             unk324;                 /* 2E4 */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x2E8);

		~StatsMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		void               Unk_03(void) override;                            // 03 - { unk321 = 1; }
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04
		void               PostDisplay() override;                           // 06

		// override (MenuEventHandler)
#ifndef SKYRIM_CROSS_VR
		bool CanProcess(InputEvent* a_event) override;              // 01
		bool ProcessThumbstick(ThumbstickEvent* a_event) override;  // 03
		bool ProcessButton(ButtonEvent* a_event) override;          // 05
#endif

		[[nodiscard]] MenuEventHandler* AsMenuEventHandler() noexcept
		{
			return &REL::RelocateMember<MenuEventHandler>(this, 0x30, 0x40);
		}

		[[nodiscard]] const MenuEventHandler* AsMenuEventHandler() const noexcept
		{
			return const_cast<StatsMenu*>(this)->AsMenuEventHandler();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x50);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x40, 0x50);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 40, 50
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(StatsMenu) == 0x328);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(StatsMenu) == 0x338);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/S/StatsNode.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/S/SimpleAnimationGraphManagerHolder.h"

namespace RE
{
	struct BSAnimationGraphEvent;

	class StatsNode :
		public SimpleAnimationGraphManagerHolder,   // 00
		public BSIntrusiveRefCounted,               // 20
		public BSTEventSink<BSAnimationGraphEvent>  // 18
	{
	public:
		inline static constexpr auto RTTI = RTTI_StatsNode;

		~StatsNode() override;  // 00

		// override (SimpleAnimationGraphManagerHolder)
		bool SetupAnimEventSinks(const BSTSmartPointer<BShkbAnimationGraph>& a_animGraph) override;  // 08
		void Unk_0C(void) override;                                                                  // 0C

		// override (BSTEventSink<BSAnimationGraphEvent>)
		BSEventNotifyControl ProcessEvent(const BSAnimationGraphEvent* a_event, BSTEventSource<BSAnimationGraphEvent>* a_eventSource) override;  // 01 - runs PlaySound on BSAnimationGraphEvent::optionalStr

		// members
		std::uint32_t                                    unk24;  // 24
		BSTArray<BSTSmartPointer<BSIntrusiveRefCounted>> unk28;  // 28
		std::uint64_t                                    unk40;  // 40
		std::uint64_t                                    unk48;  // 48
		BSTSmartPointer<BSIntrusiveRefCounted>           unk50;  // 50
		BSTSmartPointer<BSIntrusiveRefCounted>           unk58;  // 58
		std::uint64_t                                    unk60;  // 60
	};
	static_assert(sizeof(StatsNode) == 0x68);
}


===============================================
File: include/RE/S/StealthMeter.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"
#include "RE/H/HUDObject.h"

namespace RE
{
	class StealthMeter : public HUDObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_StealthMeter;

		~StealthMeter() override;  // 00

		// override (HUDObject)
		void Update() override;                                        // 01
		bool ProcessMessage(UIMessage* a_message) override;            // 02
		void RegisterHUDComponent(FxDelegateArgs& a_params) override;  // 03

		// members
		GFxValue      stealthMeter;     // 28
		GFxValue      sneakAnim;        // 40
		GFxValue      sneakTextHolder;  // 58
		GFxValue      sneakText;        // 70
		std::uint32_t unk88;            // 88
		std::uint32_t unk8C;            // 8C
		std::uint8_t  unk90;            // 90
		std::uint8_t  unk91;            // 91
		std::uint16_t pad92;            // 92
		std::uint32_t pad94;            // 94
	};
	static_assert(sizeof(StealthMeter) == 0x98);
}


===============================================
File: include/RE/S/Stream.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/S/StreamBase.h"

namespace RE
{
	namespace BSResource
	{
		class AsyncStream;

		enum class SeekMode
		{
			kSet = 0,
			kCur = 1,
			kEnd = 2
		};

		class Stream : public StreamBase
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource__Stream;

			Stream();
			Stream(const Stream& a_rhs);
			Stream(Stream&& a_rhs);
			Stream(std::uint32_t a_totalSize);
			~Stream() override = default;  // 00

			// add
			virtual void      DoClone(BSTSmartPointer<Stream>& a_out) const = 0;                                           // 05
			virtual ErrorCode DoRead(void* a_buffer, std::uint64_t a_toRead, std::uint64_t& a_read) const = 0;             // 06
			virtual ErrorCode DoWrite(const void* a_buffer, std::uint64_t a_toWrite, std::uint64_t& a_written) const = 0;  // 07
			virtual ErrorCode DoSeek(std::uint64_t a_toSeek, SeekMode a_mode, std::uint64_t& a_sought) const = 0;          // 08
			virtual ErrorCode DoSetEndOfStream();                                                                          // 09 - { return ErrorCode::kUnsupported; }
			virtual bool      DoGetName(BSFixedString& a_dst) const;                                                       // 0A - { a_dst = ""; return false; }
			virtual ErrorCode DoCreateAsync(BSTSmartPointer<AsyncStream>& a_streamOut) const;                              // 0B - { return ErrorCode::kUnsupported; }
		};
		static_assert(sizeof(Stream) == 0x10);
	}
}


===============================================
File: include/RE/S/StreamBase.h
===============================================
#pragma once

#include "RE/E/ErrorCodes.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	namespace BSResource
	{
		struct Info;

		class StreamBase
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSResource__StreamBase;

			enum : std::uint32_t
			{
				kWritable = 1 << 0,
				kRefCountBeg = 0x1000,
				kRefCountMask = (std::uint32_t)0xFFFFF000
			};

			StreamBase();
			StreamBase(const StreamBase& a_rhs);
			StreamBase(StreamBase&& a_rhs);
			StreamBase(std::uint32_t a_totalSize);
			virtual ~StreamBase() = default;  // 00

			// add
			virtual ErrorCode                   DoOpen() = 0;             // 01
			virtual void                        DoClose() = 0;            // 02
			[[nodiscard]] virtual std::uint64_t DoGetKey() const;         // 03 - { return 0; }
			virtual ErrorCode                   DoGetInfo(Info& a_info);  // 04 - { return ErrorCode::kUnsupported; }

			TES_HEAP_REDEFINE_NEW();

			std::uint32_t      DecRef();
			std::uint32_t      IncRef();
			[[nodiscard]] bool IsWritable() const;

			// members
			std::uint32_t totalSize;  // 08
			std::uint32_t flags;      // 0C
		};
		static_assert(sizeof(StreamBase) == 0x10);
	}
}


===============================================
File: include/RE/S/SubtitleManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	struct SubtitleInfo
	{
		// members
		ObjectRefHandle speaker;         // 00
		std::uint32_t   pad04;           // 04
		BSString        subtitle;        // 08
		float           targetDistance;  // 18
		bool            forceDisplay;    // 1C
	};
	static_assert(sizeof(SubtitleInfo) == 0x20);

	class SubtitleManager : public BSTSingletonSDM<SubtitleManager>
	{
	public:
		static SubtitleManager* GetSingleton()
		{
			REL::Relocation<SubtitleManager**> singleton{ RELOCATION_ID(514283, 400443) };
			return *singleton;
		}

		void KillSubtitles()
		{
			using func_t = decltype(&SubtitleManager ::KillSubtitles);
			REL::Relocation<func_t> func{ RELOCATION_ID(51755, 52628) };
			return func(this);
		}

		// members
		std::uint8_t           pad01;           // 01
		std::uint16_t          pad02;           // 02
		std::uint32_t          pad04;           // 04
		BSTArray<SubtitleInfo> subtitles;       // 18
		mutable BSSpinLock     lock;            // 20
		ObjectRefHandle        currentSpeaker;  // 28
	};
	static_assert(sizeof(SubtitleManager) == 0x30);
}


===============================================
File: include/RE/S/SummonCreatureEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/N/NiPoint3.h"

namespace RE
{
	class SummonPlacementEffect;

	class SummonCreatureEffect : public ActiveEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_SummonCreatureEffect;
		inline static constexpr auto VTABLE = VTABLE_SummonCreatureEffect;

		// override (ActiveEffect)
		void Update(float a_delta) override;                          // 04
		void SetLocation(const NiPoint3& a_location) override;        // 07 - { location = a_location; }
		void SaveGame(BGSSaveFormBuffer* a_buf) override;             // 08
		void LoadGame(BGSLoadFormBuffer* a_buf) override;             // 09
		void FinishLoadGame(BGSLoadFormBuffer* a_buf) override;       // 0A
		void HandleEvent(const BSFixedString& a_eventName) override;  // 0D
		void ClearTargetImpl() override;                              // 12

		~SummonCreatureEffect() override;  // 13

		void Start() override;   // 14
		void Finish() override;  // 15

		// members
		NiPoint3               location;               // 90
		NiPoint3               rotation;               // 9C
		ActorHandle            commandedActor;         // A8
		std::uint32_t          unkAC;                  // AC
		SummonPlacementEffect* summonPlacementEffect;  // B0
		bool                   unkB8;                  // B8
		bool                   unkB9;                  // B9
		std::uint16_t          padBA;                  // BA
		std::uint32_t          padBC;                  // BC
	};
	static_assert(sizeof(SummonCreatureEffect) == 0xC0);
}


===============================================
File: include/RE/S/SummonPlacementEffect.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/R/RefAttachTechniqueInput.h"
#include "RE/R/ReferenceEffect.h"
#include "RE/S/SimpleAnimationGraphManagerHolder.h"

namespace RE
{
	class BGSArtObject;
	class BGSArtObjectCloneTask;
	class NiAVObject;
	struct BSAnimationGraphEvent;

	class SummonPlacementEffect :
		public ReferenceEffect,                     // 00
		public SimpleAnimationGraphManagerHolder,   // 48
		public BSTEventSink<BSAnimationGraphEvent>  // 60
	{
	public:
		inline static constexpr auto RTTI = RTTI_SummonPlacementEffect;
		inline static auto           Ni_RTTI = NiRTTI_SummonPlacementEffect;
		inline static constexpr auto TYPE = TEMP_EFFECT_TYPE::kMagicSummon;

		~SummonPlacementEffect() override;  // 00

		// override (ReferenceEffect)
		const NiRTTI*    GetRTTI() const override;                           // 02
		bool             Update(float a_arg1) override;                      // 28
		TEMP_EFFECT_TYPE GetType() const override;                           // 2C - { return kMagicSummon; }
		void             SaveGame(BGSSaveGameBuffer* a_buf) override;        // 2D
		void             LoadGame(BGSLoadGameBuffer* a_buf) override;        // 2E
		void             FinishLoadGame(BGSLoadGameBuffer* a_buf) override;  // 2F
		void             Init() override;                                    // 36

		// override (SimpleAnimationGraphManagerHolder)
		bool SetupAnimEventSinks(const BSTSmartPointer<BShkbAnimationGraph>& a_animGraph) override;  // 08

		// override (BSTEventSink<BSAnimationGraphEvent>)
		BSEventNotifyControl ProcessEvent(const BSAnimationGraphEvent* a_event, BSTEventSource<BSAnimationGraphEvent>* a_eventSource) override;  // 01

		// members
		BGSArtObject*                          effectArt;  // 68
		NiPoint3                               location;   // 70
		std::uint32_t                          pad7C;      // 7C
		NiPointer<NiAVObject>                  effect3D;   // 80
		std::uint64_t                          unk88;      // 88
		BSTSmartPointer<BGSArtObjectCloneTask> cloneTask;  // 90
		std::uint8_t                           unk98;      // 98
	};
	static_assert(sizeof(SummonPlacementEffect) == 0xA0);
}


===============================================
File: include/RE/S/Sun.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"
#include "RE/S/SkyObject.h"

namespace RE
{
	class BSShaderAccumulator;
	class BSTriShape;
	class NiBillboardNode;
	class NiDirectionalLight;

	class Sun : public SkyObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_Sun;
		inline static constexpr auto VTABLE = VTABLE_Sun;

		~Sun() override;  // 00

		// override (SkyObject)
		void Init(NiNode* a_root) override;              // 02
		void Update(Sky* a_sky, float a_arg2) override;  // 03

		// members
		NiPointer<NiBillboardNode>     sunBaseNode;       // 10
		NiPointer<NiBillboardNode>     sunGlareNode;      // 18
		NiPointer<BSTriShape>          sunBase;           // 20
		NiPointer<BSTriShape>          sunQuery;          // 28
		NiPointer<BSTriShape>          sunGlare;          // 30
		NiPointer<NiDirectionalLight>  light;             // 38
		NiPointer<NiDirectionalLight>  cloudLight;        // 40
		float                          glareScale;        // 48
		bool                           doOcclusionTests;  // 4C
		std::uint8_t                   pad4D;             // 4D
		std::uint16_t                  pad4E;             // 4E
		NiPointer<BSShaderAccumulator> sunAccumulator;    // 50
	};
	static_assert(sizeof(Sun) == 0x58);
}


===============================================
File: include/RE/S/SuspendedStack.h
===============================================
#pragma once

#include "RE/S/Stack.h"

namespace RE
{
	namespace BSScript
	{
		class Stack;

		namespace Internal
		{
			class IFuncCallQuery;

			struct SuspendedStack
			{
			public:
				// members
				BSTSmartPointer<Stack>          stack;          // 00
				BSTSmartPointer<IFuncCallQuery> funcCallQuery;  // 08
			};
			static_assert(sizeof(SuspendedStack) == 0x10);
		}
	}
}


===============================================
File: include/RE/S/SyncQueueObj.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"

namespace RE
{
	class SyncQueueObj : public BSIntrusiveRefCounted
	{
	public:
		inline static constexpr auto RTTI = RTTI_SyncQueueObj;

		virtual ~SyncQueueObj();  // 00

		// add
		virtual void Unk_01(void) = 0;  // 01

		// members
		std::uint32_t unk0C;  // 0C
	};
	static_assert(sizeof(SyncQueueObj) == 0x10);
}


===============================================
File: include/RE/Skyrim.h
===============================================
#pragma once

#include "SKSE/Impl/PCH.h"

#include "RE/A/AIFormulas.h"
#include "RE/A/AIProcess.h"
#include "RE/A/AITimeStamp.h"
#include "RE/A/AITimer.h"
#include "RE/A/AbsorbEffect.h"
#include "RE/A/AbstractHeap.h"
#include "RE/A/AccumulatingValueModifierEffect.h"
#include "RE/A/ActionInput.h"
#include "RE/A/ActionOutput.h"
#include "RE/A/ActivateHandler.h"
#include "RE/A/ActiveEffect.h"
#include "RE/A/ActiveEffectFactory.h"
#include "RE/A/ActiveEffectReferenceEffectController.h"
#include "RE/A/Actor.h"
#include "RE/A/ActorCause.h"
#include "RE/A/ActorEquipManager.h"
#include "RE/A/ActorInventoryEvent.h"
#include "RE/A/ActorKill.h"
#include "RE/A/ActorKnowledge.h"
#include "RE/A/ActorMagicCaster.h"
#include "RE/A/ActorMover.h"
#include "RE/A/ActorPackage.h"
#include "RE/A/ActorSpeedChannel.h"
#include "RE/A/ActorState.h"
#include "RE/A/ActorTargetCheck.h"
#include "RE/A/ActorValueInfo.h"
#include "RE/A/ActorValueList.h"
#include "RE/A/ActorValueMeter.h"
#include "RE/A/ActorValueOwner.h"
#include "RE/A/ActorValues.h"
#include "RE/A/AddCallbackVisitor.h"
#include "RE/A/AlchemyItem.h"
#include "RE/A/AlchemyMenu.h"
#include "RE/A/AnimationFileManagerSingleton.h"
#include "RE/A/AnimationObjects.h"
#include "RE/A/Archive.h"
#include "RE/A/ArmorRatingVisitor.h"
#include "RE/A/ArmorRatingVisitorBase.h"
#include "RE/A/Array.h"
#include "RE/A/ArrowProjectile.h"
#include "RE/A/AsyncStream.h"
#include "RE/A/Atmosphere.h"
#include "RE/A/AttachAshPileFunctor.h"
#include "RE/A/AttachLightHitEffectVisitor.h"
#include "RE/A/AttachTechniqueInput.h"
#include "RE/A/AttachedScript.h"
#include "RE/A/AttackAnimationArrayMap.h"
#include "RE/A/AttackBlockHandler.h"
#include "RE/A/AutoMoveHandler.h"
#include "RE/A/AutoRegisterCreator.h"
#include "RE/A/AutoRegisterFactory.h"
#include "RE/A/ahkpCharacterProxy.h"
#include "RE/A/ahkpWorld.h"
#include "RE/B/BGSAbilityPerkEntry.h"
#include "RE/B/BGSAcousticSpace.h"
#include "RE/B/BGSAction.h"
#include "RE/B/BGSActionData.h"
#include "RE/B/BGSActorCellEvent.h"
#include "RE/B/BGSActorEvent.h"
#include "RE/B/BGSAddToPlayerInventoryEvent.h"
#include "RE/B/BGSAddonNode.h"
#include "RE/B/BGSAnimationSequencer.h"
#include "RE/B/BGSApparatus.h"
#include "RE/B/BGSArtObject.h"
#include "RE/B/BGSAssociationType.h"
#include "RE/B/BGSAttackData.h"
#include "RE/B/BGSAttackDataForm.h"
#include "RE/B/BGSAttackDataMap.h"
#include "RE/B/BGSBaseAlias.h"
#include "RE/B/BGSBehaviorGraphModel.h"
#include "RE/B/BGSBipedObjectForm.h"
#include "RE/B/BGSBlockBashData.h"
#include "RE/B/BGSBodyPartData.h"
#include "RE/B/BGSBodyPartDefs.h"
#include "RE/B/BGSCameraPath.h"
#include "RE/B/BGSCameraShot.h"
#include "RE/B/BGSCollisionLayer.h"
#include "RE/B/BGSColorForm.h"
#include "RE/B/BGSConstructibleObject.h"
#include "RE/B/BGSCreatedObjectManager.h"
#include "RE/B/BGSDebris.h"
#include "RE/B/BGSDecalEmitter.h"
#include "RE/B/BGSDecalGroup.h"
#include "RE/B/BGSDecalManager.h"
#include "RE/B/BGSDecalNode.h"
#include "RE/B/BGSDefaultObjectManager.h"
#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSDialogueBranch.h"
#include "RE/B/BGSDirectionalAmbientLightingColors.h"
#include "RE/B/BGSDistantTreeBlock.h"
#include "RE/B/BGSDualCastData.h"
#include "RE/B/BGSEncounterZone.h"
#include "RE/B/BGSEntryPoint.h"
#include "RE/B/BGSEntryPointFunctionData.h"
#include "RE/B/BGSEntryPointFunctionDataActivateChoice.h"
#include "RE/B/BGSEntryPointFunctionDataOneValue.h"
#include "RE/B/BGSEntryPointFunctionDataText.h"
#include "RE/B/BGSEntryPointPerkEntry.h"
#include "RE/B/BGSEquipSlot.h"
#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSExplosion.h"
#include "RE/B/BGSFootstep.h"
#include "RE/B/BGSFootstepEvent.h"
#include "RE/B/BGSFootstepManager.h"
#include "RE/B/BGSFootstepSet.h"
#include "RE/B/BGSGrassManager.h"
#include "RE/B/BGSHazard.h"
#include "RE/B/BGSHeadPart.h"
#include "RE/B/BGSIdleCollection.h"
#include "RE/B/BGSIdleMarker.h"
#include "RE/B/BGSImpactData.h"
#include "RE/B/BGSImpactDataSet.h"
#include "RE/B/BGSImpactManager.h"
#include "RE/B/BGSInstancedQuestObjective.h"
#include "RE/B/BGSKeyword.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSLensFlare.h"
#include "RE/B/BGSLightingTemplate.h"
#include "RE/B/BGSListForm.h"
#include "RE/B/BGSLoadFormBuffer.h"
#include "RE/B/BGSLoadFormData.h"
#include "RE/B/BGSLoadGameBuffer.h"
#include "RE/B/BGSLoadGameSubBuffer.h"
#include "RE/B/BGSLocAlias.h"
#include "RE/B/BGSLocalizedStringDL.h"
#include "RE/B/BGSLocation.h"
#include "RE/B/BGSLocationRefType.h"
#include "RE/B/BGSMaterialObject.h"
#include "RE/B/BGSMaterialType.h"
#include "RE/B/BGSMenuDisplayObject.h"
#include "RE/B/BGSMenuIcon.h"
#include "RE/B/BGSMessage.h"
#include "RE/B/BGSMessageIcon.h"
#include "RE/B/BGSMovableStatic.h"
#include "RE/B/BGSMovementType.h"
#include "RE/B/BGSMoviePlayer.h"
#include "RE/B/BGSMusicPaletteTrack.h"
#include "RE/B/BGSMusicSilenceTrack.h"
#include "RE/B/BGSMusicSingleTrack.h"
#include "RE/B/BGSMusicTrack.h"
#include "RE/B/BGSMusicTrackFormWrapper.h"
#include "RE/B/BGSMusicType.h"
#include "RE/B/BGSNamedPackageData.h"
#include "RE/B/BGSNote.h"
#include "RE/B/BGSOpenCloseForm.h"
#include "RE/B/BGSOutfit.h"
#include "RE/B/BGSOverridePackCollection.h"
#include "RE/B/BGSPackageDataBool.h"
#include "RE/B/BGSPackageDataLocation.h"
#include "RE/B/BGSPackageDataPointerTemplate.h"
#include "RE/B/BGSPerk.h"
#include "RE/B/BGSPerkEntry.h"
#include "RE/B/BGSPerkRankArray.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/B/BGSPreloadable.h"
#include "RE/B/BGSProcedureTreeBranch.h"
#include "RE/B/BGSProcedureTreeConditionalItem.h"
#include "RE/B/BGSProcedureTreeProcedure.h"
#include "RE/B/BGSProcedureTreeSequence.h"
#include "RE/B/BGSProjectile.h"
#include "RE/B/BGSRagdoll.h"
#include "RE/B/BGSRefAlias.h"
#include "RE/B/BGSReferenceEffect.h"
#include "RE/B/BGSRelationship.h"
#include "RE/B/BGSReverbParameters.h"
#include "RE/B/BGSSaveLoadManager.h"
#include "RE/B/BGSScene.h"
#include "RE/B/BGSSceneAction.h"
#include "RE/B/BGSSceneActionDialogue.h"
#include "RE/B/BGSSceneActionPackage.h"
#include "RE/B/BGSSceneActionTimer.h"
#include "RE/B/BGSShaderParticleGeometryData.h"
#include "RE/B/BGSSkillPerkTreeNode.h"
#include "RE/B/BGSSkinForm.h"
#include "RE/B/BGSSoundCategory.h"
#include "RE/B/BGSSoundDescriptor.h"
#include "RE/B/BGSSoundDescriptorForm.h"
#include "RE/B/BGSSoundOutput.h"
#include "RE/B/BGSStandardSoundDef.h"
#include "RE/B/BGSStaticCollection.h"
#include "RE/B/BGSStoryEventManager.h"
#include "RE/B/BGSStoryManagerBranchNode.h"
#include "RE/B/BGSStoryManagerEventNode.h"
#include "RE/B/BGSStoryManagerNodeBase.h"
#include "RE/B/BGSStoryManagerQuestNode.h"
#include "RE/B/BGSStoryManagerTreeForm.h"
#include "RE/B/BGSStoryTeller.h"
#include "RE/B/BGSTalkingActivator.h"
#include "RE/B/BGSTextureModel.h"
#include "RE/B/BGSTextureSet.h"
#include "RE/B/BGSTypedItem.h"
#include "RE/B/BGSVoiceType.h"
#include "RE/B/BGSVolumetricLighting.h"
#include "RE/B/BGSWorldLocation.h"
#include "RE/B/BSAnimNote.h"
#include "RE/B/BSAnimNoteListener.h"
#include "RE/B/BSAnimationGraphChannel.h"
#include "RE/B/BSAnimationGraphEvent.h"
#include "RE/B/BSAnimationGraphManager.h"
#include "RE/B/BSAnimationUpdateData.h"
#include "RE/B/BSArchive.h"
#include "RE/B/BSArchiveHeader.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSAudioManager.h"
#include "RE/B/BSAudioManagerThread.h"
#include "RE/B/BSBatchRenderer.h"
#include "RE/B/BSBitField.h"
#include "RE/B/BSBloodSplatterShaderProperty.h"
#include "RE/B/BSBound.h"
#include "RE/B/BSContainer.h"
#include "RE/B/BSCullingProcess.h"
#include "RE/B/BSDirectInputManager.h"
#include "RE/B/BSDismemberSkinInstance.h"
#include "RE/B/BSDynamicTriShape.h"
#include "RE/B/BSEffectShaderData.h"
#include "RE/B/BSEffectShaderMaterial.h"
#include "RE/B/BSEffectShaderProperty.h"
#include "RE/B/BSExtraData.h"
#include "RE/B/BSFaceGenAnimationData.h"
#include "RE/B/BSFaceGenKeyframe.h"
#include "RE/B/BSFaceGenKeyframeMultiple.h"
#include "RE/B/BSFaceGenManager.h"
#include "RE/B/BSFaceGenModel.h"
#include "RE/B/BSFaceGenModelExtraData.h"
#include "RE/B/BSFaceGenNiNode.h"
#include "RE/B/BSFadeNode.h"
#include "RE/B/BSFile.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSFurnitureMarkerNode.h"
#include "RE/B/BSGameSound.h"
#include "RE/B/BSGamepadDevice.h"
#include "RE/B/BSGeometry.h"
#include "RE/B/BSHandleRefObject.h"
#include "RE/B/BSIInputDevice.h"
#include "RE/B/BSIMusicTrack.h"
#include "RE/B/BSIMusicType.h"
#include "RE/B/BSIRagdollDriver.h"
#include "RE/B/BSIReverbType.h"
#include "RE/B/BSISoundCategory.h"
#include "RE/B/BSISoundDescriptor.h"
#include "RE/B/BSISoundOutputModel.h"
#include "RE/B/BSImagespaceShader.h"
#include "RE/B/BSImagespaceShaderBlur3.h"
#include "RE/B/BSInputDevice.h"
#include "RE/B/BSInputDeviceFactory.h"
#include "RE/B/BSInputDeviceManager.h"
#include "RE/B/BSInputEventQueue.h"
#include "RE/B/BSInstanceTriShape.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSKeyboardDevice.h"
#include "RE/B/BSLensFlareRenderData.h"
#include "RE/B/BSLight.h"
#include "RE/B/BSLightingShaderMaterial.h"
#include "RE/B/BSLightingShaderMaterialBase.h"
#include "RE/B/BSLightingShaderMaterialEnvmap.h"
#include "RE/B/BSLightingShaderMaterialEye.h"
#include "RE/B/BSLightingShaderMaterialFacegen.h"
#include "RE/B/BSLightingShaderMaterialFacegenTint.h"
#include "RE/B/BSLightingShaderMaterialGlowmap.h"
#include "RE/B/BSLightingShaderMaterialHairTint.h"
#include "RE/B/BSLightingShaderMaterialLODLandscape.h"
#include "RE/B/BSLightingShaderMaterialLandscape.h"
#include "RE/B/BSLightingShaderMaterialMultiLayerParallax.h"
#include "RE/B/BSLightingShaderMaterialParallax.h"
#include "RE/B/BSLightingShaderMaterialParallaxOcc.h"
#include "RE/B/BSLightingShaderMaterialSnow.h"
#include "RE/B/BSLightingShaderProperty.h"
#include "RE/B/BSMasterParticleSystem.h"
#include "RE/B/BSMaterialObject.h"
#include "RE/B/BSMemStorage.h"
#include "RE/B/BSModelDB.h"
#include "RE/B/BSMouseDevice.h"
#include "RE/B/BSMultiBound.h"
#include "RE/B/BSMultiBoundAABB.h"
#include "RE/B/BSMultiBoundNode.h"
#include "RE/B/BSMultiBoundOBB.h"
#include "RE/B/BSMultiBoundShape.h"
#include "RE/B/BSMultiIndexTriShape.h"
#include "RE/B/BSMultiStreamInstanceTriShape.h"
#include "RE/B/BSMusicEvent.h"
#include "RE/B/BSMusicManager.h"
#include "RE/B/BSNavmesh.h"
#include "RE/B/BSNavmeshInfoMap.h"
#include "RE/B/BSNiAllocator.h"
#include "RE/B/BSNiNode.h"
#include "RE/B/BSOpenVR.h"
#include "RE/B/BSOpenVRControllerDevice.h"
#include "RE/B/BSOrderedNode.h"
#include "RE/B/BSPCGamepadDeviceDelegate.h"
#include "RE/B/BSPCGamepadDeviceHandler.h"
#include "RE/B/BSPCOrbisGamepadDevice.h"
#include "RE/B/BSParticleShaderCubeEmitter.h"
#include "RE/B/BSParticleShaderEmitter.h"
#include "RE/B/BSParticleShaderObjectEmitter.h"
#include "RE/B/BSParticleShaderProperty.h"
#include "RE/B/BSPathingCell.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSPointerHandleManager.h"
#include "RE/B/BSPointerHandleSmartPointer.h"
#include "RE/B/BSPortalGraph.h"
#include "RE/B/BSPrecomputedNavmeshInfoPathMap.h"
#include "RE/B/BSReloadShaderI.h"
#include "RE/B/BSRenderPass.h"
#include "RE/B/BSResourceEntryDB.h"
#include "RE/B/BSResourceNiBinaryStream.h"
#include "RE/B/BSResponse.h"
#include "RE/B/BSSaveDataSystemUtility.h"
#include "RE/B/BSScaleformManager.h"
#include "RE/B/BSScaleformTranslator.h"
#include "RE/B/BSSceneGraph.h"
#include "RE/B/BSScriptObjectBindPolicy.h"
#include "RE/B/BSShader.h"
#include "RE/B/BSShaderManager.h"
#include "RE/B/BSShaderMaterial.h"
#include "RE/B/BSShaderProperty.h"
#include "RE/B/BSShaderPropertyLightData.h"
#include "RE/B/BSShaderRenderTargets.h"
#include "RE/B/BSShaderTextureSet.h"
#include "RE/B/BSShadowLight.h"
#include "RE/B/BSSimpleScaleController.h"
#include "RE/B/BSSmallBlockAllocator.h"
#include "RE/B/BSSoundHandle.h"
#include "RE/B/BSStorage.h"
#include "RE/B/BSStream.h"
#include "RE/B/BSString.h"
#include "RE/B/BSStringPool.h"
#include "RE/B/BSSystemFile.h"
#include "RE/B/BSSystemFileStorage.h"
#include "RE/B/BSTAnimationGraphDataChannel.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTCaseInsensitiveStringMap.h"
#include "RE/B/BSTCreateFactoryManager.h"
#include "RE/B/BSTDerivedCreator.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTFreeList.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTLocklessQueue.h"
#include "RE/B/BSTMessageQueue.h"
#include "RE/B/BSTObjectDictionary.h"
#include "RE/B/BSTPoint.h"
#include "RE/B/BSTPointerAndFlags.h"
#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BSTTuple.h"
#include "RE/B/BSTempEffect.h"
#include "RE/B/BSTempEffectDebris.h"
#include "RE/B/BSTempEffectGeometryDecal.h"
#include "RE/B/BSTempEffectParticle.h"
#include "RE/B/BSTempEffectSPG.h"
#include "RE/B/BSTempEffectSimpleDecal.h"
#include "RE/B/BSTempEffectWeaponBlood.h"
#include "RE/B/BSTerrainEffect.h"
#include "RE/B/BSTextureSet.h"
#include "RE/B/BSThread.h"
#include "RE/B/BSThreadEvent.h"
#include "RE/B/BSTimer.h"
#include "RE/B/BSTrackedControllerDevice.h"
#include "RE/B/BSTreeManager.h"
#include "RE/B/BSTriShape.h"
#include "RE/B/BSUIMessageData.h"
#include "RE/B/BSUIScaleformData.h"
#include "RE/B/BSValueNode.h"
#include "RE/B/BSVRInterface.h"
#include "RE/B/BSVirtualKeyboardDevice.h"
#include "RE/B/BSVisit.h"
#include "RE/B/BSVolumetricLightingRenderData.h"
#include "RE/B/BSWaterShaderMaterial.h"
#include "RE/B/BSWaterShaderProperty.h"
#include "RE/B/BSWin32GamepadDevice.h"
#include "RE/B/BSWin32KeyboardDevice.h"
#include "RE/B/BSWin32MouseDevice.h"
#include "RE/B/BSWin32SaveDataSystemUtility.h"
#include "RE/B/BSWin32VirtualKeyboardDevice.h"
#include "RE/B/BSWindModifier.h"
#include "RE/B/BSXAudio2GameSound.h"
#include "RE/B/BSXFlags.h"
#include "RE/B/BShkbAnimationGraph.h"
#include "RE/B/BanishEffect.h"
#include "RE/B/BarrierProjectile.h"
#include "RE/B/BarterMenu.h"
#include "RE/B/BaseFormComponent.h"
#include "RE/B/BaseHandleReaderWriter.h"
#include "RE/B/BeamProjectile.h"
#include "RE/B/BipedAnim.h"
#include "RE/B/BipedObjects.h"
#include "RE/B/BleedoutCameraState.h"
#include "RE/B/BookMenu.h"
#include "RE/B/BooksRead.h"
#include "RE/B/BottomBar.h"
#include "RE/B/BoundItemEffect.h"
#include "RE/B/ButtonEvent.h"
#include "RE/B/bhkBackfaceContactListener.h"
#include "RE/B/bhkCachingShapePhantom.h"
#include "RE/B/bhkCharProxyController.h"
#include "RE/B/bhkCharacterController.h"
#include "RE/B/bhkCharacterPointCollector.h"
#include "RE/B/bhkCharacterProxy.h"
#include "RE/B/bhkCharacterState.h"
#include "RE/B/bhkCharacterStateClimbing.h"
#include "RE/B/bhkCharacterStateFlying.h"
#include "RE/B/bhkCharacterStateInAir.h"
#include "RE/B/bhkCharacterStateJumping.h"
#include "RE/B/bhkCharacterStateOnGround.h"
#include "RE/B/bhkCharacterStateSwimming.h"
#include "RE/B/bhkCollisionFilter.h"
#include "RE/B/bhkCollisionObject.h"
#include "RE/B/bhkCompressedMeshShape.h"
#include "RE/B/bhkCompressedMeshShapeData.h"
#include "RE/B/bhkContactListener.h"
#include "RE/B/bhkEntity.h"
#include "RE/B/bhkListShape.h"
#include "RE/B/bhkMeshMaterial.h"
#include "RE/B/bhkNiCollisionObject.h"
#include "RE/B/bhkPCollisionObject.h"
#include "RE/B/bhkPhantom.h"
#include "RE/B/bhkPickData.h"
#include "RE/B/bhkRefObject.h"
#include "RE/B/bhkRigidBody.h"
#include "RE/B/bhkSPCollisionObject.h"
#include "RE/B/bhkSerializable.h"
#include "RE/B/bhkShape.h"
#include "RE/B/bhkShapeCollection.h"
#include "RE/B/bhkShapePhantom.h"
#include "RE/B/bhkThreadMemorySource.h"
#include "RE/B/bhkWorld.h"
#include "RE/B/bhkWorldObject.h"
#include "RE/C/CFilter.h"
#include "RE/C/CRC.h"
#include "RE/C/Calendar.h"
#include "RE/C/CalmEffect.h"
#include "RE/C/CharEvent.h"
#include "RE/C/Character.h"
#include "RE/C/ChestsLooted.h"
#include "RE/C/CloakEffect.h"
#include "RE/C/Clouds.h"
#include "RE/C/CodeTasklet.h"
#include "RE/C/CollisionLayers.h"
#include "RE/C/Color.h"
#include "RE/C/ColorUtil.h"
#include "RE/C/CombatController.h"
#include "RE/C/CombatGroup.h"
#include "RE/C/CombatGroupDetectionListener.h"
#include "RE/C/CombatInventory.h"
#include "RE/C/CombatInventoryItem.h"
#include "RE/C/CombatInventoryItemMagic.h"
#include "RE/C/CombatInventoryItemMagicT.h"
#include "RE/C/CombatInventoryItemPotion.h"
#include "RE/C/CombatInventoryItemScroll.h"
#include "RE/C/CombatInventoryItemShout.h"
#include "RE/C/CombatInventoryItemStaff.h"
#include "RE/C/CombatMagicCaster.h"
#include "RE/C/CombatMagicCasterBoundItem.h"
#include "RE/C/CombatMagicCasterCloak.h"
#include "RE/C/CombatMagicCasterDisarm.h"
#include "RE/C/CombatMagicCasterInvisibility.h"
#include "RE/C/CombatMagicCasterLight.h"
#include "RE/C/CombatMagicCasterOffensive.h"
#include "RE/C/CombatMagicCasterParalyze.h"
#include "RE/C/CombatMagicCasterReanimate.h"
#include "RE/C/CombatMagicCasterRestore.h"
#include "RE/C/CombatMagicCasterScript.h"
#include "RE/C/CombatMagicCasterStagger.h"
#include "RE/C/CombatMagicCasterSummon.h"
#include "RE/C/CombatMagicCasterTargetEffect.h"
#include "RE/C/CombatMagicCasterWard.h"
#include "RE/C/CombatManager.h"
#include "RE/C/CombatObject.h"
#include "RE/C/CombatSearchLocation.h"
#include "RE/C/CombatState.h"
#include "RE/C/CommandEffect.h"
#include "RE/C/CommandSummonedEffect.h"
#include "RE/C/CommandTable.h"
#include "RE/C/CommonTypeTraits.h"
#include "RE/C/CompactingStore.h"
#include "RE/C/CompiledScriptLoader.h"
#include "RE/C/ConcreteFormFactory.h"
#include "RE/C/ConcreteObjectFormFactory.h"
#include "RE/C/ConcussionEffect.h"
#include "RE/C/ConeProjectile.h"
#include "RE/C/Console.h"
#include "RE/C/ConsoleData.h"
#include "RE/C/ConsoleLog.h"
#include "RE/C/ConsoleNativeUIMenu.h"
#include "RE/C/ConstructibleObjectMenu.h"
#include "RE/C/ContainerItemExtra.h"
#include "RE/C/ContainerMenu.h"
#include "RE/C/ControlMap.h"
#include "RE/C/CraftingMenu.h"
#include "RE/C/CraftingSubMenu.h"
#include "RE/C/CreationClubMenu.h"
#include "RE/C/CreditsMenu.h"
#include "RE/C/Crime.h"
#include "RE/C/CriticalHit.h"
#include "RE/C/CrosshairPickData.h"
#include "RE/C/CureEffect.h"
#include "RE/C/CursorMenu.h"
#include "RE/D/DBTraits.h"
#include "RE/D/DarknessEffect.h"
#include "RE/D/DecalData.h"
#include "RE/D/DefaultObjectsReadyEvent.h"
#include "RE/D/DelayFunctor.h"
#include "RE/D/DemoralizeEffect.h"
#include "RE/D/DepthStencilDepthModes.h"
#include "RE/D/DetectLifeEffect.h"
#include "RE/D/DetectionListener.h"
#include "RE/D/DetectionPriorities.h"
#include "RE/D/DetectionState.h"
#include "RE/D/DevNull.h"
#include "RE/D/DeviceConnectEvent.h"
#include "RE/D/DialogueItem.h"
#include "RE/D/DialogueMenu.h"
#include "RE/D/DialoguePackage.h"
#include "RE/D/DialogueTypes.h"
#include "RE/D/DisarmEffect.h"
#include "RE/D/DisarmedEvent.h"
#include "RE/D/DisguiseEffect.h"
#include "RE/D/DispelEffect.h"
#include "RE/D/DoNothingUnhandledPolicy.h"
#include "RE/D/DragonSoulsGained.h"
#include "RE/D/DropObjectFunctor.h"
#include "RE/D/DualValueModifierEffect.h"
#include "RE/E/Effect.h"
#include "RE/E/EffectArchetypes.h"
#include "RE/E/EffectSetting.h"
#include "RE/E/EmotionTypes.h"
#include "RE/E/EnchantConstructMenu.h"
#include "RE/E/EnchantmentItem.h"
#include "RE/E/EnhanceWeaponEffect.h"
#include "RE/E/ErrorCodes.h"
#include "RE/E/ErrorLogger.h"
#include "RE/E/EtherealizationEffect.h"
#include "RE/E/Explosion.h"
#include "RE/E/ExtraAction.h"
#include "RE/E/ExtraActivateLoopSound.h"
#include "RE/E/ExtraActivateRef.h"
#include "RE/E/ExtraActivateRefChildren.h"
#include "RE/E/ExtraActorCause.h"
#include "RE/E/ExtraAliasInstanceArray.h"
#include "RE/E/ExtraAlphaCutoff.h"
#include "RE/E/ExtraAmmo.h"
#include "RE/E/ExtraAnimGraphManager.h"
#include "RE/E/ExtraAnimNoteReceiver.h"
#include "RE/E/ExtraAnimationSequencer.h"
#include "RE/E/ExtraAshPileRef.h"
#include "RE/E/ExtraAttachRef.h"
#include "RE/E/ExtraAttachRefChildren.h"
#include "RE/E/ExtraAttachedArrows3D.h"
#include "RE/E/ExtraBadPosition.h"
#include "RE/E/ExtraBiped.h"
#include "RE/E/ExtraCachedScale.h"
#include "RE/E/ExtraCanTalkToPlayer.h"
#include "RE/E/ExtraCannotWear.h"
#include "RE/E/ExtraCell3D.h"
#include "RE/E/ExtraCellAcousticSpace.h"
#include "RE/E/ExtraCellGrassData.h"
#include "RE/E/ExtraCellImageSpace.h"
#include "RE/E/ExtraCellMusicType.h"
#include "RE/E/ExtraCellSkyRegion.h"
#include "RE/E/ExtraCellWaterEnvMap.h"
#include "RE/E/ExtraCellWaterType.h"
#include "RE/E/ExtraCharge.h"
#include "RE/E/ExtraCollisionData.h"
#include "RE/E/ExtraCombatStyle.h"
#include "RE/E/ExtraContainerChanges.h"
#include "RE/E/ExtraCount.h"
#include "RE/E/ExtraCreatureAwakeSound.h"
#include "RE/E/ExtraCreatureMovementSound.h"
#include "RE/E/ExtraDataList.h"
#include "RE/E/ExtraDataTypes.h"
#include "RE/E/ExtraDecalGroup.h"
#include "RE/E/ExtraDetachTime.h"
#include "RE/E/ExtraDismemberedLimbs.h"
#include "RE/E/ExtraDistantData.h"
#include "RE/E/ExtraDroppedItemList.h"
#include "RE/E/ExtraEditorID.h"
#include "RE/E/ExtraEditorRef3DData.h"
#include "RE/E/ExtraEditorRefMoveData.h"
#include "RE/E/ExtraEmittanceSource.h"
#include "RE/E/ExtraEnableStateChildren.h"
#include "RE/E/ExtraEnableStateParent.h"
#include "RE/E/ExtraEnchantment.h"
#include "RE/E/ExtraEncounterZone.h"
#include "RE/E/ExtraFactionChanges.h"
#include "RE/E/ExtraFavorCost.h"
#include "RE/E/ExtraFlags.h"
#include "RE/E/ExtraFollower.h"
#include "RE/E/ExtraFollowerSwimBreadcrumbs.h"
#include "RE/E/ExtraForcedLandingMarker.h"
#include "RE/E/ExtraForcedTarget.h"
#include "RE/E/ExtraFriendHits.h"
#include "RE/E/ExtraFromAlias.h"
#include "RE/E/ExtraGIDBuffer.h"
#include "RE/E/ExtraGhost.h"
#include "RE/E/ExtraGlobal.h"
#include "RE/E/ExtraGroupConstraint.h"
#include "RE/E/ExtraGuardedRefData.h"
#include "RE/E/ExtraHasNoRumors.h"
#include "RE/E/ExtraHavok.h"
#include "RE/E/ExtraHeadTrackingWeight.h"
#include "RE/E/ExtraHeadingTarget.h"
#include "RE/E/ExtraHealth.h"
#include "RE/E/ExtraHealthPerc.h"
#include "RE/E/ExtraHorse.h"
#include "RE/E/ExtraHotkey.h"
#include "RE/E/ExtraIgnoredBySandbox.h"
#include "RE/E/ExtraInfoGeneralTopic.h"
#include "RE/E/ExtraInteraction.h"
#include "RE/E/ExtraItemDropper.h"
#include "RE/E/ExtraLargeRefOwnerCells.h"
#include "RE/E/ExtraLastFinishedSequence.h"
#include "RE/E/ExtraLevCreaModifier.h"
#include "RE/E/ExtraLeveledCreature.h"
#include "RE/E/ExtraLeveledItem.h"
#include "RE/E/ExtraLeveledItemBase.h"
#include "RE/E/ExtraLight.h"
#include "RE/E/ExtraLightData.h"
#include "RE/E/ExtraLinkedRef.h"
#include "RE/E/ExtraLinkedRefChildren.h"
#include "RE/E/ExtraLitWaterRefs.h"
#include "RE/E/ExtraLocation.h"
#include "RE/E/ExtraLocationRefType.h"
#include "RE/E/ExtraLock.h"
#include "RE/E/ExtraLockList.h"
#include "RE/E/ExtraMagicCaster.h"
#include "RE/E/ExtraMagicLight.h"
#include "RE/E/ExtraMapMarker.h"
#include "RE/E/ExtraMissingLinkedRefIDs.h"
#include "RE/E/ExtraMissingRefIDs.h"
#include "RE/E/ExtraModelSwap.h"
#include "RE/E/ExtraMultiBound.h"
#include "RE/E/ExtraMultiBoundRef.h"
#include "RE/E/ExtraNavMeshPortal.h"
#include "RE/E/ExtraNorthRotation.h"
#include "RE/E/ExtraObjectHealth.h"
#include "RE/E/ExtraOcclusionPlaneRefData.h"
#include "RE/E/ExtraOcclusionShape.h"
#include "RE/E/ExtraOpenCloseActivateRef.h"
#include "RE/E/ExtraOriginalReference.h"
#include "RE/E/ExtraOutfitItem.h"
#include "RE/E/ExtraOwnership.h"
#include "RE/E/ExtraPackage.h"
#include "RE/E/ExtraPackageData.h"
#include "RE/E/ExtraPackageStartLocation.h"
#include "RE/E/ExtraPatrolRefData.h"
#include "RE/E/ExtraPatrolRefInUseData.h"
#include "RE/E/ExtraPersistentCell.h"
#include "RE/E/ExtraPlayerCrimeList.h"
#include "RE/E/ExtraPoison.h"
#include "RE/E/ExtraPortal.h"
#include "RE/E/ExtraPortalRefData.h"
#include "RE/E/ExtraPrimitive.h"
#include "RE/E/ExtraProcessMiddleLow.h"
#include "RE/E/ExtraPromotedRef.h"
#include "RE/E/ExtraRaceData.h"
#include "RE/E/ExtraRadius.h"
#include "RE/E/ExtraRagDollData.h"
#include "RE/E/ExtraRandomTeleportMarker.h"
#include "RE/E/ExtraRank.h"
#include "RE/E/ExtraReferenceHandle.h"
#include "RE/E/ExtraReflectedRefs.h"
#include "RE/E/ExtraReflectorRefs.h"
#include "RE/E/ExtraRefrPath.h"
#include "RE/E/ExtraRefractionProperty.h"
#include "RE/E/ExtraRegionList.h"
#include "RE/E/ExtraReservedMarkers.h"
#include "RE/E/ExtraResourcesPreload.h"
#include "RE/E/ExtraRoom.h"
#include "RE/E/ExtraRoomRefData.h"
#include "RE/E/ExtraRunOncePacks.h"
#include "RE/E/ExtraSavedAnimation.h"
#include "RE/E/ExtraSavedHavokData.h"
#include "RE/E/ExtraSayToTopicInfo.h"
#include "RE/E/ExtraSayTopicInfoOnceADay.h"
#include "RE/E/ExtraScale.h"
#include "RE/E/ExtraSceneData.h"
#include "RE/E/ExtraScriptedAnimDependence.h"
#include "RE/E/ExtraSeenData.h"
#include "RE/E/ExtraShouldWear.h"
#include "RE/E/ExtraSoul.h"
#include "RE/E/ExtraSound.h"
#include "RE/E/ExtraSpawnContainer.h"
#include "RE/E/ExtraStartingPosition.h"
#include "RE/E/ExtraStartingWorldOrCell.h"
#include "RE/E/ExtraTeleport.h"
#include "RE/E/ExtraTeleportName.h"
#include "RE/E/ExtraTerminalState.h"
#include "RE/E/ExtraTextDisplayData.h"
#include "RE/E/ExtraTimeLeft.h"
#include "RE/E/ExtraTresPassPackage.h"
#include "RE/E/ExtraUniqueID.h"
#include "RE/E/ExtraUsedMarkers.h"
#include "RE/E/ExtraWaterCurrentZoneData.h"
#include "RE/E/ExtraWaterData.h"
#include "RE/E/ExtraWaterLightRefs.h"
#include "RE/E/ExtraWeaponAttackSound.h"
#include "RE/E/ExtraWeaponIdleSound.h"
#include "RE/E/ExtraWorn.h"
#include "RE/E/ExtraWornLeft.h"
#include "RE/F/FOCollisionListener.h"
#include "RE/F/FORM.h"
#include "RE/F/FORM_ENUM_STRING.h"
#include "RE/F/FactionRank.h"
#include "RE/F/FaderMenu.h"
#include "RE/F/FastTravelConfirmCallback.h"
#include "RE/F/FavoritesHandler.h"
#include "RE/F/FavoritesMenu.h"
#include "RE/F/FightReactions.h"
#include "RE/F/FileID.h"
#include "RE/F/FirstPersonState.h"
#include "RE/F/FixedStrings.h"
#include "RE/F/FlameProjectile.h"
#include "RE/F/FormTraits.h"
#include "RE/F/FormTypes.h"
#include "RE/F/FragmentSystem.h"
#include "RE/F/FreeCameraState.h"
#include "RE/F/FrenzyEffect.h"
#include "RE/F/FunctionArguments.h"
#include "RE/F/FunctionMessage.h"
#include "RE/F/FxDelegate.h"
#include "RE/F/FxDelegateArgs.h"
#include "RE/F/FxDelegateHandler.h"
#include "RE/F/FxResponseArgs.h"
#include "RE/F/FxResponseArgsBase.h"
#include "RE/G/GASActionBufferData.h"
#include "RE/G/GASDoAction.h"
#include "RE/G/GASDoInitAction.h"
#include "RE/G/GASEnvironment.h"
#include "RE/G/GASExecuteTag.h"
#include "RE/G/GASFunctionObject.h"
#include "RE/G/GASGlobalContext.h"
#include "RE/G/GASObject.h"
#include "RE/G/GASObjectInterface.h"
#include "RE/G/GASRefCountBase.h"
#include "RE/G/GASStringBuiltinManager.h"
#include "RE/G/GASStringManager.h"
#include "RE/G/GASUserDefinedFunctionObject.h"
#include "RE/G/GAcquireInterface.h"
#include "RE/G/GAllocator.h"
#include "RE/G/GAllocatorBaseGH.h"
#include "RE/G/GAllocatorBaseLH.h"
#include "RE/G/GArray.h"
#include "RE/G/GArrayBase.h"
#include "RE/G/GArrayConstPolicy.h"
#include "RE/G/GArrayData.h"
#include "RE/G/GArrayDataBase.h"
#include "RE/G/GArrayDefaultPolicy.h"
#include "RE/G/GArrayLH.h"
#include "RE/G/GAtomic.h"
#include "RE/G/GColor.h"
#include "RE/G/GConstructorMov.h"
#include "RE/G/GEvent.h"
#include "RE/G/GFixedSizeHash.h"
#include "RE/G/GFxASCharacter.h"
#include "RE/G/GFxActionControl.h"
#include "RE/G/GFxButtonCharacterDef.h"
#include "RE/G/GFxCharacter.h"
#include "RE/G/GFxCharacterDef.h"
#include "RE/G/GFxConstShapeCharacterDef.h"
#include "RE/G/GFxConstShapeNoStyles.h"
#include "RE/G/GFxConstShapeWithStyles.h"
#include "RE/G/GFxEditTextCharacterDef.h"
#include "RE/G/GFxEvent.h"
#include "RE/G/GFxExternalInterface.h"
#include "RE/G/GFxFileConstants.h"
#include "RE/G/GFxFunctionHandler.h"
#include "RE/G/GFxInitImportActions.h"
#include "RE/G/GFxKey.h"
#include "RE/G/GFxKeyboardState.h"
#include "RE/G/GFxLoadProcess.h"
#include "RE/G/GFxLoadStates.h"
#include "RE/G/GFxLoadUpdateSync.h"
#include "RE/G/GFxLoader.h"
#include "RE/G/GFxLoaderImpl.h"
#include "RE/G/GFxLoaderTask.h"
#include "RE/G/GFxLog.h"
#include "RE/G/GFxLogBase.h"
#include "RE/G/GFxLogConstants.h"
#include "RE/G/GFxMorphCharacterDef.h"
#include "RE/G/GFxMovie.h"
#include "RE/G/GFxMovieBindProcess.h"
#include "RE/G/GFxMovieDataDef.h"
#include "RE/G/GFxMovieDef.h"
#include "RE/G/GFxMovieDefBindStates.h"
#include "RE/G/GFxMovieDefImpl.h"
#include "RE/G/GFxMovieImageLoadTask.h"
#include "RE/G/GFxMovieRoot.h"
#include "RE/G/GFxMovieView.h"
#include "RE/G/GFxPlaceObject.h"
#include "RE/G/GFxPlaceObject2.h"
#include "RE/G/GFxPlaceObject2a.h"
#include "RE/G/GFxPlaceObject3.h"
#include "RE/G/GFxPlaceObjectBase.h"
#include "RE/G/GFxPlaceObjectUnpacked.h"
#include "RE/G/GFxPlayerStats.h"
#include "RE/G/GFxRemoveObject.h"
#include "RE/G/GFxRemoveObject2.h"
#include "RE/G/GFxRenderConfig.h"
#include "RE/G/GFxResource.h"
#include "RE/G/GFxResourceID.h"
#include "RE/G/GFxResourceKey.h"
#include "RE/G/GFxResourceLib.h"
#include "RE/G/GFxResourceLibBase.h"
#include "RE/G/GFxResourceReport.h"
#include "RE/G/GFxResourceWeakLib.h"
#include "RE/G/GFxSetBackgroundColor.h"
#include "RE/G/GFxShapeBase.h"
#include "RE/G/GFxShapeBaseCharacterDef.h"
#include "RE/G/GFxShapeCharacterDef.h"
#include "RE/G/GFxShapeNoStyles.h"
#include "RE/G/GFxShapeWithStyles.h"
#include "RE/G/GFxSpecialKeysState.h"
#include "RE/G/GFxSprite.h"
#include "RE/G/GFxSpriteDef.h"
#include "RE/G/GFxState.h"
#include "RE/G/GFxStateBag.h"
#include "RE/G/GFxStateBagImpl.h"
#include "RE/G/GFxStaticTextCharacterDef.h"
#include "RE/G/GFxStream.h"
#include "RE/G/GFxTask.h"
#include "RE/G/GFxTimelineDef.h"
#include "RE/G/GFxTranslator.h"
#include "RE/G/GFxValue.h"
#include "RE/G/GFxWStringBuffer.h"
#include "RE/G/GFxWWHelper.h"
#include "RE/G/GHash.h"
#include "RE/G/GHashNode.h"
#include "RE/G/GHashSet.h"
#include "RE/G/GHashSetBase.h"
#include "RE/G/GHashSetUncached.h"
#include "RE/G/GHashUncached.h"
#include "RE/G/GHashsetCachedEntry.h"
#include "RE/G/GHashsetCachedNodeEntry.h"
#include "RE/G/GHashsetEntry.h"
#include "RE/G/GHashsetNodeEntry.h"
#include "RE/G/GImage.h"
#include "RE/G/GImageBase.h"
#include "RE/G/GList.h"
#include "RE/G/GMath.h"
#include "RE/G/GMatrix2D.h"
#include "RE/G/GMatrix3D.h"
#include "RE/G/GMemory.h"
#include "RE/G/GMemoryHeap.h"
#include "RE/G/GMutex.h"
#include "RE/G/GNewOverrideBase.h"
#include "RE/G/GPoint.h"
#include "RE/G/GPtr.h"
#include "RE/G/GRect.h"
#include "RE/G/GRefCountBase.h"
#include "RE/G/GRefCountBaseGC.h"
#include "RE/G/GRefCountBaseNTS.h"
#include "RE/G/GRefCountBaseStatImpl.h"
#include "RE/G/GRefCountBaseWeakSupport.h"
#include "RE/G/GRefCountImpl.h"
#include "RE/G/GRefCountImplCore.h"
#include "RE/G/GRefCountNTSImpl.h"
#include "RE/G/GRefCountWeakSupportImpl.h"
#include "RE/G/GRenderer.h"
#include "RE/G/GRendererEventHandler.h"
#include "RE/G/GStats.h"
#include "RE/G/GStd.h"
#include "RE/G/GString.h"
#include "RE/G/GStringDH.h"
#include "RE/G/GStringHash.h"
#include "RE/G/GSysAllocBase.h"
#include "RE/G/GSysAllocPaged.h"
#include "RE/G/GTexture.h"
#include "RE/G/GViewport.h"
#include "RE/G/GWaitCondition.h"
#include "RE/G/GWaitable.h"
#include "RE/G/GameSettingCollection.h"
#include "RE/G/GiftMenu.h"
#include "RE/G/GlobalLocations.h"
#include "RE/G/GlobalPaths.h"
#include "RE/G/GrabActorEffect.h"
#include "RE/G/GrassParam.h"
#include "RE/G/GrenadeProjectile.h"
#include "RE/G/GridArray.h"
#include "RE/G/GridCellArray.h"
#include "RE/G/GuideEffect.h"
#include "RE/H/HUDChargeMeter.h"
#include "RE/H/HUDData.h"
#include "RE/H/HUDMenu.h"
#include "RE/H/HUDMeter.h"
#include "RE/H/HUDNotifications.h"
#include "RE/H/HUDObject.h"
#include "RE/H/HandleManager.h"
#include "RE/H/HandlePolicy.h"
#include "RE/H/Hazard.h"
#include "RE/H/HeapBlock.h"
#include "RE/H/HeapBlockFreeHead.h"
#include "RE/H/HeldStateHandler.h"
#include "RE/H/HighProcessData.h"
#include "RE/H/HitData.h"
#include "RE/H/HorseCameraState.h"
#include "RE/H/hkAabb.h"
#include "RE/H/hkArray.h"
#include "RE/H/hkBaseObject.h"
#include "RE/H/hkBaseTypes.h"
#include "RE/H/hkContactPoint.h"
#include "RE/H/hkContainerAllocators.h"
#include "RE/H/hkFinishLoadedObjectFlag.h"
#include "RE/H/hkMatrix3.h"
#include "RE/H/hkMemoryAllocator.h"
#include "RE/H/hkMoppBvTreeShapeBase.h"
#include "RE/H/hkMotionState.h"
#include "RE/H/hkMultiThreadCheck.h"
#include "RE/H/hkQsTransform.h"
#include "RE/H/hkQuaternion.h"
#include "RE/H/hkRefPtr.h"
#include "RE/H/hkRefVariant.h"
#include "RE/H/hkReferencedObject.h"
#include "RE/H/hkRotation.h"
#include "RE/H/hkSmallArray.h"
#include "RE/H/hkSseMathTypes.h"
#include "RE/H/hkStepInfo.h"
#include "RE/H/hkStringPtr.h"
#include "RE/H/hkSweptTransform.h"
#include "RE/H/hkTransform.h"
#include "RE/H/hkVector4.h"
#include "RE/H/hkaAnimatedReferenceFrame.h"
#include "RE/H/hkaAnimation.h"
#include "RE/H/hkaAnimationBinding.h"
#include "RE/H/hkaAnimationControl.h"
#include "RE/H/hkaAnnotationTrack.h"
#include "RE/H/hkaDefaultAnimationControl.h"
#include "RE/H/hkaRagdollInstance.h"
#include "RE/H/hkbAnimationBindingSet.h"
#include "RE/H/hkbAssetBundleStringData.h"
#include "RE/H/hkbBehaviorGraph.h"
#include "RE/H/hkbBehaviorGraphData.h"
#include "RE/H/hkbBehaviorGraphStringData.h"
#include "RE/H/hkbBindable.h"
#include "RE/H/hkbCharacter.h"
#include "RE/H/hkbCharacterControllerSetup.h"
#include "RE/H/hkbCharacterData.h"
#include "RE/H/hkbCharacterSetup.h"
#include "RE/H/hkbCharacterStringData.h"
#include "RE/H/hkbClipGenerator.h"
#include "RE/H/hkbContext.h"
#include "RE/H/hkbEvent.h"
#include "RE/H/hkbEventBase.h"
#include "RE/H/hkbGenerator.h"
#include "RE/H/hkbNode.h"
#include "RE/H/hkbProjectData.h"
#include "RE/H/hkbProjectStringData.h"
#include "RE/H/hkbRagdollDriver.h"
#include "RE/H/hkbRigidBodySetup.h"
#include "RE/H/hkbShapeSetup.h"
#include "RE/H/hkbStateMachine.h"
#include "RE/H/hkp3AxisSweep.h"
#include "RE/H/hkpAction.h"
#include "RE/H/hkpAgentNnTrack.h"
#include "RE/H/hkpAllCdPointCollector.h"
#include "RE/H/hkpArrayAction.h"
#include "RE/H/hkpBoxShape.h"
#include "RE/H/hkpBroadPhase.h"
#include "RE/H/hkpBroadPhaseCastCollector.h"
#include "RE/H/hkpBroadPhaseHandle.h"
#include "RE/H/hkpBvTreeShape.h"
#include "RE/H/hkpCachingShapePhantom.h"
#include "RE/H/hkpCapsuleShape.h"
#include "RE/H/hkpCdBody.h"
#include "RE/H/hkpCdPoint.h"
#include "RE/H/hkpCdPointCollector.h"
#include "RE/H/hkpCharacterContext.h"
#include "RE/H/hkpCharacterControl.h"
#include "RE/H/hkpCharacterProxy.h"
#include "RE/H/hkpCharacterProxyListener.h"
#include "RE/H/hkpCharacterState.h"
#include "RE/H/hkpCharacterStateManager.h"
#include "RE/H/hkpClosestRayHitCollector.h"
#include "RE/H/hkpCollidable.h"
#include "RE/H/hkpCollidableCollidableFilter.h"
#include "RE/H/hkpCollisionEvent.h"
#include "RE/H/hkpCollisionFilter.h"
#include "RE/H/hkpCollisionInput.h"
#include "RE/H/hkpCompressedMeshShape.h"
#include "RE/H/hkpConstraintAtom.h"
#include "RE/H/hkpConstraintData.h"
#include "RE/H/hkpConstraintInfo.h"
#include "RE/H/hkpConstraintInstance.h"
#include "RE/H/hkpConstraintOwner.h"
#include "RE/H/hkpContactListener.h"
#include "RE/H/hkpContactPointEvent.h"
#include "RE/H/hkpConvexListFilter.h"
#include "RE/H/hkpConvexShape.h"
#include "RE/H/hkpEaseConstraintsAction.h"
#include "RE/H/hkpEntity.h"
#include "RE/H/hkpEntityListener.h"
#include "RE/H/hkpFixedRigidMotion.h"
#include "RE/H/hkpKeyframedRigidMotion.h"
#include "RE/H/hkpLimitedHingeConstraintData.h"
#include "RE/H/hkpLinearCastCollisionInput.h"
#include "RE/H/hkpLinearCastInput.h"
#include "RE/H/hkpLinkedCollidable.h"
#include "RE/H/hkpListShape.h"
#include "RE/H/hkpMaterial.h"
#include "RE/H/hkpMeshMaterial.h"
#include "RE/H/hkpMoppAabbCastVirtualMachine.h"
#include "RE/H/hkpMoppBvTreeShape.h"
#include "RE/H/hkpMoppCode.h"
#include "RE/H/hkpMotion.h"
#include "RE/H/hkpPhantom.h"
#include "RE/H/hkpPhantomListener.h"
#include "RE/H/hkpPhantomType.h"
#include "RE/H/hkpProperty.h"
#include "RE/H/hkpRagdollConstraintData.h"
#include "RE/H/hkpRayCollidableFilter.h"
#include "RE/H/hkpRayHitCollector.h"
#include "RE/H/hkpRayShapeCollectionFilter.h"
#include "RE/H/hkpRigidBody.h"
#include "RE/H/hkpRootCdPoint.h"
#include "RE/H/hkpShape.h"
#include "RE/H/hkpShapeBuffer.h"
#include "RE/H/hkpShapeCollection.h"
#include "RE/H/hkpShapeCollectionFilter.h"
#include "RE/H/hkpShapeContainer.h"
#include "RE/H/hkpShapePhantom.h"
#include "RE/H/hkpShapeRayCastCollectorOutput.h"
#include "RE/H/hkpShapeRayCastOutput.h"
#include "RE/H/hkpShapeType.h"
#include "RE/H/hkpSimplexSolver.h"
#include "RE/H/hkpSimulationIsland.h"
#include "RE/H/hkpSingleShapeContainer.h"
#include "RE/H/hkpSolverInfo.h"
#include "RE/H/hkpSphereRepShape.h"
#include "RE/H/hkpSphereShape.h"
#include "RE/H/hkpTypedBroadPhaseHandle.h"
#include "RE/H/hkpWeldingUtility.h"
#include "RE/H/hkpWorld.h"
#include "RE/H/hkpWorldCinfo.h"
#include "RE/H/hkpWorldLinearCaster.h"
#include "RE/H/hkpWorldObject.h"
#include "RE/H/hkpWorldPostSimulationListener.h"
#include "RE/H/hkpWorldRayCastInput.h"
#include "RE/H/hkpWorldRayCastOutput.h"
#include "RE/I/IAIWorldLocationHandle.h"
#include "RE/I/IAnimationClipLoaderSingleton.h"
#include "RE/I/IAnimationGraphManagerHolder.h"
#include "RE/I/IAnimationSetCallbackFunctor.h"
#include "RE/I/IBSTCreator.h"
#include "RE/I/ICellAttachDetachEventSource.h"
#include "RE/I/ID.h"
#include "RE/I/IDEvent.h"
#include "RE/I/IFormFactory.h"
#include "RE/I/IFreezeQuery.h"
#include "RE/I/IFuncCallQuery.h"
#include "RE/I/IFunction.h"
#include "RE/I/IFunctionArguments.h"
#include "RE/I/IHandleReaderWriter.h"
#include "RE/I/IHandlerFunctor.h"
#include "RE/I/ILoader.h"
#include "RE/I/IMapCameraCallbacks.h"
#include "RE/I/IMemoryHeap.h"
#include "RE/I/IMemoryPagePolicy.h"
#include "RE/I/IMemoryStore.h"
#include "RE/I/IMemoryStoreBase.h"
#include "RE/I/IMenu.h"
#include "RE/I/IMessageBoxCallback.h"
#include "RE/I/IMovementControllerRegisterInterface.h"
#include "RE/I/IMovementDirectControl.h"
#include "RE/I/IMovementInterface.h"
#include "RE/I/IMovementMessageInterface.h"
#include "RE/I/IMovementMotionDrivenControl.h"
#include "RE/I/IMovementPlannerDirectControl.h"
#include "RE/I/IMovementSelectIdle.h"
#include "RE/I/IMovementState.h"
#include "RE/I/INIPrefSettingCollection.h"
#include "RE/I/INISettingCollection.h"
#include "RE/I/IObjectHandlePolicy.h"
#include "RE/I/IObjectProcessor.h"
#include "RE/I/IPackageData.h"
#include "RE/I/IPackageDataAIWorldLocationHandle.h"
#include "RE/I/IPostAnimationChannelUpdateFunctor.h"
#include "RE/I/IProcedureTreeItem.h"
#include "RE/I/IProfilePolicy.h"
#include "RE/I/ISavePatcherInterface.h"
#include "RE/I/IStackCallbackFunctor.h"
#include "RE/I/IStackCallbackSaveInterface.h"
#include "RE/I/IStore.h"
#include "RE/I/IUIMessageData.h"
#include "RE/I/IVMDebugInterface.h"
#include "RE/I/IVMObjectBindInterface.h"
#include "RE/I/IVMSaveLoadInterface.h"
#include "RE/I/IVirtualMachine.h"
#include "RE/I/IXAudio2VoiceCallback.h"
#include "RE/I/ImageData.h"
#include "RE/I/ImageSpaceData.h"
#include "RE/I/ImageSpaceEffect.h"
#include "RE/I/ImageSpaceEffectDepthOfField.h"
#include "RE/I/ImageSpaceEffectOption.h"
#include "RE/I/ImageSpaceEffectParam.h"
#include "RE/I/ImageSpaceManager.h"
#include "RE/I/ImageSpaceModifierInstance.h"
#include "RE/I/ImageSpaceModifierInstanceDOF.h"
#include "RE/I/ImageSpaceModifierInstanceForm.h"
#include "RE/I/ImageSpaceModifierInstanceTemp.h"
#include "RE/I/ImageSpaceShaderParam.h"
#include "RE/I/ImageSpaceTexture.h"
#include "RE/I/ImpactResults.h"
#include "RE/I/Info.h"
#include "RE/I/IngredientItem.h"
#include "RE/I/InputDevices.h"
#include "RE/I/InputEvent.h"
#include "RE/I/InterfaceStrings.h"
#include "RE/I/InteriorData.h"
#include "RE/I/Inventory.h"
#include "RE/I/Inventory3DManager.h"
#include "RE/I/InventoryChanges.h"
#include "RE/I/InventoryEntryData.h"
#include "RE/I/InventoryEvent.h"
#include "RE/I/InventoryMenu.h"
#include "RE/I/InventoryUpdateData.h"
#include "RE/I/InvisibilityEffect.h"
#include "RE/I/ItemCard.h"
#include "RE/I/ItemCrafted.h"
#include "RE/I/ItemHarvested.h"
#include "RE/I/ItemList.h"
#include "RE/I/ItemsPickpocketed.h"
#include "RE/J/JournalMenu.h"
#include "RE/J/JournalTab.h"
#include "RE/J/Journal_QuestsTab.h"
#include "RE/J/Journal_StatsTab.h"
#include "RE/J/Journal_SystemTab.h"
#include "RE/J/JumpHandler.h"
#include "RE/K/KinectEvent.h"
#include "RE/K/KinectMenu.h"
#include "RE/L/LegendarySkillResetConfirmCallback.h"
#include "RE/L/LevelIncrease.h"
#include "RE/L/LevelUpMenu.h"
#include "RE/L/LightEffect.h"
#include "RE/L/LinkerProcessor.h"
#include "RE/L/LoadStorageWrapper.h"
#include "RE/L/LoadWaitSpinner.h"
#include "RE/L/LoadingMenu.h"
#include "RE/L/LocalMapCamera.h"
#include "RE/L/LocalMapMenu.h"
#include "RE/L/Location.h"
#include "RE/L/LocationCleared.h"
#include "RE/L/LocationDiscovery.h"
#include "RE/L/LocationTraverser.h"
#include "RE/L/LocationTree.h"
#include "RE/L/LockEffect.h"
#include "RE/L/LockpickingMenu.h"
#include "RE/L/LogEvent.h"
#include "RE/L/Logger.h"
#include "RE/L/LoggingDisabler.h"
#include "RE/L/LookHandler.h"
#include "RE/L/LooseFileLocation.h"
#include "RE/L/LooseFileStream.h"
#include "RE/L/LooseFileStreamBase.h"
#include "RE/M/MagicCaster.h"
#include "RE/M/MagicFavorites.h"
#include "RE/M/MagicFormulas.h"
#include "RE/M/MagicItem.h"
#include "RE/M/MagicItemDataCollector.h"
#include "RE/M/MagicItemTraversalFunctor.h"
#include "RE/M/MagicMenu.h"
#include "RE/M/MagicSystem.h"
#include "RE/M/MagicTarget.h"
#include "RE/M/MagicUtilities.h"
#include "RE/M/Main.h"
#include "RE/M/MainMenu.h"
#include "RE/M/MapCamera.h"
#include "RE/M/MapInputHandler.h"
#include "RE/M/MapLookHandler.h"
#include "RE/M/MapMenu.h"
#include "RE/M/MapMoveHandler.h"
#include "RE/M/MapZoomHandler.h"
#include "RE/M/MarkerUsedData.h"
#include "RE/M/MaterialIDs.h"
#include "RE/M/MemoryHeap.h"
#include "RE/M/MemoryManager.h"
#include "RE/M/MemoryPage.h"
#include "RE/M/MenuControls.h"
#include "RE/M/MenuCursor.h"
#include "RE/M/MenuEventHandler.h"
#include "RE/M/MenuModeChangeEvent.h"
#include "RE/M/MenuOpenCloseEvent.h"
#include "RE/M/MenuOpenHandler.h"
#include "RE/M/MenuTopicManager.h"
#include "RE/M/MessageBoxData.h"
#include "RE/M/MessageBoxMenu.h"
#include "RE/M/MiddleHighProcessData.h"
#include "RE/M/Misc.h"
#include "RE/M/MissileProjectile.h"
#include "RE/M/MistMenu.h"
#include "RE/M/ModManagerMenu.h"
#include "RE/M/ModelProcessor.h"
#include "RE/M/ModelReferenceEffect.h"
#include "RE/M/Moon.h"
#include "RE/M/MouseMoveEvent.h"
#include "RE/M/MoveToFunctor.h"
#include "RE/M/Movement.h"
#include "RE/M/MovementControllerAI.h"
#include "RE/M/MovementControllerNPC.h"
#include "RE/M/MovementHandler.h"
#include "RE/M/MoviePlayer.h"
#include "RE/M/MultiBoundMarkerData.h"
#include "RE/N/NativeFunction.h"
#include "RE/N/NativeFunctionBase.h"
#include "RE/N/NativeLatentFunction.h"
#include "RE/N/NavMesh.h"
#include "RE/N/NavMeshInfoMap.h"
#include "RE/N/NiAVObject.h"
#include "RE/N/NiAllocator.h"
#include "RE/N/NiAlphaProperty.h"
#include "RE/N/NiAnimationKey.h"
#include "RE/N/NiBinaryStream.h"
#include "RE/N/NiBoneMatrixSetterI.h"
#include "RE/N/NiBooleanExtraData.h"
#include "RE/N/NiBound.h"
#include "RE/N/NiCamera.h"
#include "RE/N/NiCloningProcess.h"
#include "RE/N/NiCollisionObject.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiColorData.h"
#include "RE/N/NiColorInterpolator.h"
#include "RE/N/NiColorKey.h"
#include "RE/N/NiControllerManager.h"
#include "RE/N/NiControllerSequence.h"
#include "RE/N/NiCullingProcess.h"
#include "RE/N/NiExtraData.h"
#include "RE/N/NiFile.h"
#include "RE/N/NiFloatData.h"
#include "RE/N/NiFloatExtraData.h"
#include "RE/N/NiFloatInterpolator.h"
#include "RE/N/NiFloatKey.h"
#include "RE/N/NiFloatsExtraData.h"
#include "RE/N/NiFrustum.h"
#include "RE/N/NiFrustumPlanes.h"
#include "RE/N/NiGeometry.h"
#include "RE/N/NiGeometryData.h"
#include "RE/N/NiIntegerExtraData.h"
#include "RE/N/NiIntegersExtraData.h"
#include "RE/N/NiInterpController.h"
#include "RE/N/NiInterpolator.h"
#include "RE/N/NiKeyBasedInterpolator.h"
#include "RE/N/NiLight.h"
#include "RE/N/NiMath.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiMemManager.h"
#include "RE/N/NiMeshParticleSystem.h"
#include "RE/N/NiMultiTargetTransformController.h"
#include "RE/N/NiNode.h"
#include "RE/N/NiObject.h"
#include "RE/N/NiObjectGroup.h"
#include "RE/N/NiObjectNET.h"
#include "RE/N/NiPSysData.h"
#include "RE/N/NiPSysGravityModifier.h"
#include "RE/N/NiPSysModifier.h"
#include "RE/N/NiParticleSystem.h"
#include "RE/N/NiParticles.h"
#include "RE/N/NiParticlesData.h"
#include "RE/N/NiPlane.h"
#include "RE/N/NiPoint2.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiPointLight.h"
#include "RE/N/NiProperty.h"
#include "RE/N/NiQuaternion.h"
#include "RE/N/NiRTTI.h"
#include "RE/N/NiRect.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiShadeProperty.h"
#include "RE/N/NiSkinData.h"
#include "RE/N/NiSkinInstance.h"
#include "RE/N/NiSkinPartition.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiSourceTexture.h"
#include "RE/N/NiStream.h"
#include "RE/N/NiStringExtraData.h"
#include "RE/N/NiStringsExtraData.h"
#include "RE/N/NiSystem.h"
#include "RE/N/NiTArray.h"
#include "RE/N/NiTCollection.h"
#include "RE/N/NiTDefaultAllocator.h"
#include "RE/N/NiTList.h"
#include "RE/N/NiTListBase.h"
#include "RE/N/NiTMap.h"
#include "RE/N/NiTMapBase.h"
#include "RE/N/NiTPointerAllocator.h"
#include "RE/N/NiTPointerList.h"
#include "RE/N/NiTPointerListBase.h"
#include "RE/N/NiTPointerMap.h"
#include "RE/N/NiTSet.h"
#include "RE/N/NiTStringMap.h"
#include "RE/N/NiTexture.h"
#include "RE/N/NiTimeController.h"
#include "RE/N/NiTransform.h"
#include "RE/N/NightEyeEffect.h"
#include "RE/N/NonActorMagicCaster.h"
#include "RE/N/NonActorMagicTarget.h"
#include "RE/O/Object.h"
#include "RE/O/ObjectTypeInfo.h"
#include "RE/O/ObjectiveState.h"
#include "RE/O/OldMessageBoxCallback.h"
#include "RE/O/OpenEffect.h"
#include "RE/Offsets_VTABLE.h"
#include "RE/P/PCGamepadType.h"
#include "RE/P/PackUnpack.h"
#include "RE/P/PackUnpackImpl.h"
#include "RE/P/PackageLocation.h"
#include "RE/P/PackedInstructionStream.h"
#include "RE/P/ParalysisEffect.h"
#include "RE/P/PathingCell.h"
#include "RE/P/PeakValueModifierEffect.h"
#include "RE/P/PerkEntryVisitor.h"
#include "RE/P/PerkRankVisitor.h"
#include "RE/P/PermanentMagicFunctor.h"
#include "RE/P/PlayerCamera.h"
#include "RE/P/PlayerCameraTransitionState.h"
#include "RE/P/PlayerCharacter.h"
#include "RE/P/PlayerControls.h"
#include "RE/P/PlayerControlsData.h"
#include "RE/P/PlayerInputHandler.h"
#include "RE/P/PoisonedWeapon.h"
#include "RE/P/PositionPlayerEvent.h"
#include "RE/P/Precipitation.h"
#include "RE/P/PrecomputedNavmeshInfoPathMap.h"
#include "RE/P/ProcessLists.h"
#include "RE/P/Profiler.h"
#include "RE/P/Projectile.h"
#include "RE/P/PropertyTypeInfo.h"
#include "RE/Q/QuestEvents.h"
#include "RE/Q/QuestObjectiveStates.h"
#include "RE/Q/QuestStatus.h"
#include "RE/R/RaceSexCamera.h"
#include "RE/R/RaceSexMenu.h"
#include "RE/R/RaceSexMenuEvent.h"
#include "RE/R/RallyEffect.h"
#include "RE/R/RawFuncCallQuery.h"
#include "RE/R/ReadyWeaponHandler.h"
#include "RE/R/ReanimateEffect.h"
#include "RE/R/RefActivateData.h"
#include "RE/R/RefAttachTechniqueInput.h"
#include "RE/R/ReferenceArray.h"
#include "RE/R/ReferenceEffect.h"
#include "RE/R/ReferenceEffectController.h"
#include "RE/R/RefrInteraction.h"
#include "RE/R/RegSettingCollection.h"
#include "RE/R/RegisterPrefix.h"
#include "RE/R/RemoveCallbackVisitor.h"
#include "RE/R/RemoveItemFunctor.h"
#include "RE/R/RenderTargetData.h"
#include "RE/R/RenderTargetManager.h"
#include "RE/R/RenderTargetProperties.h"
#include "RE/R/Renderer.h"
#include "RE/R/Request.h"
#include "RE/R/ReticuleController.h"
#include "RE/R/Rumble.h"
#include "RE/R/RunHandler.h"
#include "RE/RTTI.h"
#include "RE/S/SafeZoneMenu.h"
#include "RE/S/SaveFileHandleReaderWriter.h"
#include "RE/S/SavePatcher.h"
#include "RE/S/SaveStorageWrapper.h"
#include "RE/S/SceneGraph.h"
#include "RE/S/ScrapHeap.h"
#include "RE/S/ScreenSplatter.h"
#include "RE/S/ScreenshotHandler.h"
#include "RE/S/Script.h"
#include "RE/S/ScriptEffect.h"
#include "RE/S/ScriptEventSourceHolder.h"
#include "RE/S/ScriptFunction.h"
#include "RE/S/ScriptedRefEffect.h"
#include "RE/S/ScrollItem.h"
#include "RE/S/SendPlayerToJailFunctor.h"
#include "RE/S/SetEventData.h"
#include "RE/S/SetMotionTypeFunctor.h"
#include "RE/S/SetPositionFunctor.h"
#include "RE/S/Setting.h"
#include "RE/S/SettingCollection.h"
#include "RE/S/SettingCollectionList.h"
#include "RE/S/SettingCollectionMap.h"
#include "RE/S/SettingT.h"
#include "RE/S/Sexes.h"
#include "RE/S/ShaderReferenceEffect.h"
#include "RE/S/ShadowSceneNode.h"
#include "RE/S/ShoutAttack.h"
#include "RE/S/ShoutHandler.h"
#include "RE/S/ShoutMeter.h"
#include "RE/S/SimpleAllocMemoryPagePolicy.h"
#include "RE/S/SimpleAnimationGraphManagerHolder.h"
#include "RE/S/SkillIncrease.h"
#include "RE/S/Sky.h"
#include "RE/S/SkyEffectController.h"
#include "RE/S/SkyObject.h"
#include "RE/S/SkyrimScriptObjectBindPolicy.h"
#include "RE/S/SkyrimScriptStore.h"
#include "RE/S/SkyrimVM.h"
#include "RE/S/SleepWaitMenu.h"
#include "RE/S/SlowTimeEffect.h"
#include "RE/S/SmithingMenu.h"
#include "RE/S/SneakHandler.h"
#include "RE/S/SoulLevels.h"
#include "RE/S/SoulTrapEffect.h"
#include "RE/S/SoulsTrapped.h"
#include "RE/S/SoundLevels.h"
#include "RE/S/SourceActionMap.h"
#include "RE/S/SpawnHazardEffect.h"
#include "RE/S/SpellItem.h"
#include "RE/S/SpellsLearned.h"
#include "RE/S/SprintHandler.h"
#include "RE/S/Stack.h"
#include "RE/S/StackFrame.h"
#include "RE/S/StaggerEffect.h"
#include "RE/S/StandardItemData.h"
#include "RE/S/Stars.h"
#include "RE/S/State.h"
#include "RE/S/StatsEvent.h"
#include "RE/S/StatsMenu.h"
#include "RE/S/StatsNode.h"
#include "RE/S/StealthMeter.h"
#include "RE/S/Stream.h"
#include "RE/S/StreamBase.h"
#include "RE/S/SubtitleManager.h"
#include "RE/S/SummonCreatureEffect.h"
#include "RE/S/SummonPlacementEffect.h"
#include "RE/S/Sun.h"
#include "RE/S/SuspendedStack.h"
#include "RE/S/SyncQueueObj.h"
#include "RE/T/TES.h"
#include "RE/T/TESAIForm.h"
#include "RE/T/TESActionData.h"
#include "RE/T/TESActivateEvent.h"
#include "RE/T/TESActiveEffectApplyRemoveEvent.h"
#include "RE/T/TESActorBase.h"
#include "RE/T/TESActorBaseData.h"
#include "RE/T/TESActorLocationChangeEvent.h"
#include "RE/T/TESAmmo.h"
#include "RE/T/TESAttackDamageForm.h"
#include "RE/T/TESBipedModelForm.h"
#include "RE/T/TESBoundAnimObject.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESCamera.h"
#include "RE/T/TESCameraState.h"
#include "RE/T/TESCellAttachDetachEvent.h"
#include "RE/T/TESCellFullyLoadedEvent.h"
#include "RE/T/TESChildCell.h"
#include "RE/T/TESClass.h"
#include "RE/T/TESClimate.h"
#include "RE/T/TESCombatEvent.h"
#include "RE/T/TESCombatStyle.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESContainer.h"
#include "RE/T/TESContainerChangedEvent.h"
#include "RE/T/TESCustomPackageData.h"
#include "RE/T/TESDataHandler.h"
#include "RE/T/TESDeathEvent.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESEffectShader.h"
#include "RE/T/TESEnchantableForm.h"
#include "RE/T/TESEnterBleedoutEvent.h"
#include "RE/T/TESEquipEvent.h"
#include "RE/T/TESEyes.h"
#include "RE/T/TESFaction.h"
#include "RE/T/TESFastTravelEndEvent.h"
#include "RE/T/TESFile.h"
#include "RE/T/TESFlora.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFormDeleteEvent.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESFurniture.h"
#include "RE/T/TESFurnitureEvent.h"
#include "RE/T/TESGlobal.h"
#include "RE/T/TESGrabReleaseEvent.h"
#include "RE/T/TESGrass.h"
#include "RE/T/TESHavokUtilities.h"
#include "RE/T/TESHitEvent.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESIdleForm.h"
#include "RE/T/TESImageSpace.h"
#include "RE/T/TESImageSpaceModifiableForm.h"
#include "RE/T/TESImageSpaceModifier.h"
#include "RE/T/TESInitScriptEvent.h"
#include "RE/T/TESKey.h"
#include "RE/T/TESLandTexture.h"
#include "RE/T/TESLevCharacter.h"
#include "RE/T/TESLevItem.h"
#include "RE/T/TESLevSpell.h"
#include "RE/T/TESLeveledList.h"
#include "RE/T/TESLoadGameEvent.h"
#include "RE/T/TESLoadScreen.h"
#include "RE/T/TESLockChangedEvent.h"
#include "RE/T/TESMagicCasterForm.h"
#include "RE/T/TESMagicEffectApplyEvent.h"
#include "RE/T/TESMagicTargetForm.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESModelPSA.h"
#include "RE/T/TESModelRDT.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESModelTri.h"
#include "RE/T/TESMoveAttachDetachEvent.h"
#include "RE/T/TESNPC.h"
#include "RE/T/TESObject.h"
#include "RE/T/TESObjectACTI.h"
#include "RE/T/TESObjectANIO.h"
#include "RE/T/TESObjectARMA.h"
#include "RE/T/TESObjectARMO.h"
#include "RE/T/TESObjectBOOK.h"
#include "RE/T/TESObjectCELL.h"
#include "RE/T/TESObjectCONT.h"
#include "RE/T/TESObjectDOOR.h"
#include "RE/T/TESObjectLAND.h"
#include "RE/T/TESObjectLIGH.h"
#include "RE/T/TESObjectLoadedEvent.h"
#include "RE/T/TESObjectMISC.h"
#include "RE/T/TESObjectREFR.h"
#include "RE/T/TESObjectSTAT.h"
#include "RE/T/TESObjectTREE.h"
#include "RE/T/TESObjectWEAP.h"
#include "RE/T/TESOpenCloseEvent.h"
#include "RE/T/TESPackage.h"
#include "RE/T/TESPackageData.h"
#include "RE/T/TESPlayerBowShotEvent.h"
#include "RE/T/TESProduceForm.h"
#include "RE/T/TESQualityForm.h"
#include "RE/T/TESQuest.h"
#include "RE/T/TESQuestStageEvent.h"
#include "RE/T/TESQuestStageItem.h"
#include "RE/T/TESQuestStartStopEvent.h"
#include "RE/T/TESRace.h"
#include "RE/T/TESRaceForm.h"
#include "RE/T/TESReactionForm.h"
#include "RE/T/TESRegion.h"
#include "RE/T/TESRegionData.h"
#include "RE/T/TESRegionDataLandscape.h"
#include "RE/T/TESRegionDataManager.h"
#include "RE/T/TESRegionDataMap.h"
#include "RE/T/TESRegionDataSound.h"
#include "RE/T/TESRegionDataWeather.h"
#include "RE/T/TESRegionList.h"
#include "RE/T/TESResetEvent.h"
#include "RE/T/TESResolveNPCTemplatesEvent.h"
#include "RE/T/TESShout.h"
#include "RE/T/TESSleepStopEvent.h"
#include "RE/T/TESSoulGem.h"
#include "RE/T/TESSound.h"
#include "RE/T/TESSpellCastEvent.h"
#include "RE/T/TESSpellList.h"
#include "RE/T/TESSwitchRaceCompleteEvent.h"
#include "RE/T/TESTexture.h"
#include "RE/T/TESTexture1024.h"
#include "RE/T/TESTopic.h"
#include "RE/T/TESTopicInfo.h"
#include "RE/T/TESTrackedStatsEvent.h"
#include "RE/T/TESUniqueIDChangeEvent.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWaitStopEvent.h"
#include "RE/T/TESWaterDisplacement.h"
#include "RE/T/TESWaterForm.h"
#include "RE/T/TESWaterNormals.h"
#include "RE/T/TESWaterObject.h"
#include "RE/T/TESWaterReflections.h"
#include "RE/T/TESWaterSystem.h"
#include "RE/T/TESWeather.h"
#include "RE/T/TESWeightForm.h"
#include "RE/T/TESWordOfPower.h"
#include "RE/T/TESWorldSpace.h"
#include "RE/T/TLSData.h"
#include "RE/T/TargetValueModifierEffect.h"
#include "RE/T/TaskQueueInterface.h"
#include "RE/T/TelekinesisEffect.h"
#include "RE/T/TempEffectTraits.h"
#include "RE/T/TextureAddressModes.h"
#include "RE/T/TextureFileFormat.h"
#include "RE/T/TextureFilterModes.h"
#include "RE/T/TextureFormat.h"
#include "RE/T/ThirdPersonState.h"
#include "RE/T/ThumbstickEvent.h"
#include "RE/T/TitleSequenceMenu.h"
#include "RE/T/TogglePOVHandler.h"
#include "RE/T/ToggleRunHandler.h"
#include "RE/T/TrainingMenu.h"
#include "RE/T/TurnUndeadEffect.h"
#include "RE/T/TutorialMenu.h"
#include "RE/T/TweenMenu.h"
#include "RE/T/TypeInfo.h"
#include "RE/T/TypeTraits.h"
#include "RE/U/UI.h"
#include "RE/U/UI3DSceneManager.h"
#include "RE/U/UIBlurManager.h"
#include "RE/U/UIMessage.h"
#include "RE/U/UIMessageQueue.h"
#include "RE/U/UIRenderManager.h"
#include "RE/U/UISaveLoadManager.h"
#include "RE/U/UnlinkedTypes.h"
#include "RE/U/UserEventEnabled.h"
#include "RE/U/UserEvents.h"
#include "RE/V/VATS.h"
#include "RE/V/VDescTable.h"
#include "RE/V/ValueAndConditionsEffect.h"
#include "RE/V/ValueModifierEffect.h"
#include "RE/V/VampireLordEffect.h"
#include "RE/V/Variable.h"
#include "RE/V/VertexDesc.h"
#include "RE/V/VirtualMachine.h"
#include "RE/V/VoiceSpellFireHandler.h"
#include "RE/W/WeaponAnimationGraphManagerHolder.h"
#include "RE/W/WeatherType.h"
#include "RE/W/WerewolfEffect.h"
#include "RE/W/WerewolfFeedEffect.h"
#include "RE/W/WorldSpaceMenu.h"
#include "RE/Z/ZeroFunctionArguments.h"
#include "RE/Z/ZeroOverheadHeap.h"


===============================================
File: include/RE/T/TES.h
===============================================
#pragma once

#include "RE/B/BSContainer.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTTuple.h"
#include "RE/I/ICellAttachDetachEventSource.h"
#include "RE/M/MaterialIDs.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	namespace BSResource
	{
		struct ArchiveStreamOpenedEvent;
	}

	class BSSystemEvent;
	class BSTempNodeManager;
	class GridCellArray;
	class ImageSpaceModifierInstance;
	class NavMeshInfoMap;
	class NiAVObject;
	class NiNode;
	class Sky;
	class TESLandTexture;
	class TESNPC;
	class TESObjectCELL;
	class TESObjectREFR;
	class TESWorldSpace;

	struct bhkPickData;
	struct PositionPlayerEvent;

	class TES :
		public ICellAttachDetachEventSource,                        // 000
		public BSTEventSink<BSResource::ArchiveStreamOpenedEvent>,  // 060
		public BSTEventSink<PositionPlayerEvent>                    // 068
	{
	public:
		inline static constexpr auto RTTI = RTTI_TES;

		class SystemEventAdapter : public BSTEventSink<BSSystemEvent>
		{
		public:
			inline static constexpr auto RTTI = RTTI_TES;

			~SystemEventAdapter() override;  // 00

			// override (BSTEventSink<BSSystemEvent>)
			BSEventNotifyControl ProcessEvent(const BSSystemEvent* a_event, BSTEventSource<BSSystemEvent>* a_eventSource) override;  // 01

			// members
			std::uint64_t unk08;  // 08
		};
		static_assert(sizeof(SystemEventAdapter) == 0x10);

		~TES() override;  // 00

		// override (BSTEventSink<BSResource::ArchiveStreamOpenedEvent>)
		BSEventNotifyControl ProcessEvent(const BSResource::ArchiveStreamOpenedEvent* a_event, BSTEventSource<BSResource::ArchiveStreamOpenedEvent>* a_eventSource) override;  // 01 - { return BSEventNotifyControl::kContinue; }

		// override (BSTEventSink<PositionPlayerEvent>)
		BSEventNotifyControl ProcessEvent(const PositionPlayerEvent* a_event, BSTEventSource<PositionPlayerEvent>* a_eventSource) override;  // 01

		static TES* GetSingleton();

		void ForEachReference(std::function<BSContainer::ForEachResult(TESObjectREFR& a_ref)> a_callback);
		void ForEachReferenceInRange(TESObjectREFR* a_origin, float a_radius, std::function<BSContainer::ForEachResult(TESObjectREFR& a_ref)> a_callback);

		TESObjectCELL*  GetCell(const NiPoint3& a_position) const;
		MATERIAL_ID     GetLandMaterialType(const NiPoint3& a_position) const;
		bool            GetLandHeight(const NiPoint3& a_positionIn, float& a_heightOut);
		TESLandTexture* GetLandTexture(const NiPoint3& a_position) const;
		float           GetWaterHeight(const NiPoint3& a_pos, TESObjectCELL* a_cell) const;
		NiAVObject*     Pick(bhkPickData& a_pickData);
		void            PurgeBufferedCells();

		// members
		std::uint64_t                                       unk070;                     // 070
		GridCellArray*                                      gridCells;                  // 078
		NiNode*                                             objRoot;                    // 080
		NiNode*                                             lodLandRoot;                // 088
		NiNode*                                             objLODWaterRoot;            // 090
		BSTempNodeManager*                                  tempNodeManager;            // 098
		std::uint64_t                                       unk0A0;                     // 0A0
		std::uint64_t                                       unk0A8;                     // 0A8
		std::uint32_t                                       unk0B0;                     // 0B0
		std::uint32_t                                       unk0B4;                     // 0B4
		std::uint64_t                                       unk0B8;                     // 0B8
		TESObjectCELL*                                      interiorCell;               // 0C0
		TESObjectCELL**                                     interiorBuffer;             // 0C8
		TESObjectCELL**                                     exteriorBuffer;             // 0D0
		std::uint64_t                                       unk0D8;                     // 0D8
		std::uint64_t                                       unk0E0;                     // 0E0
		std::uint64_t                                       unk0E8;                     // 0E8
		std::uint64_t                                       unk0F0;                     // 0F0
		std::uint64_t                                       unk0F8;                     // 0F8
		Sky*                                                sky;                        // 100
		BSSimpleList<NiPointer<ImageSpaceModifierInstance>> activeImageSpaceModifiers;  // 108
		std::uint64_t                                       unk118;                     // 118
		std::uint64_t                                       unk120;                     // 120
		std::uint8_t                                        unk128;                     // 128
		bool                                                showLANDborders;            // 129
		std::uint8_t                                        unk12A;                     // 12A
		std::uint8_t                                        unk12B;                     // 12B
		std::uint8_t                                        unk12C;                     // 12C
		std::uint8_t                                        unk12D;                     // 12D
		std::uint8_t                                        unk12E;                     // 12E
		std::uint8_t                                        unk12F;                     // 12F
		std::uint16_t                                       unk130;                     // 130
		std::uint8_t                                        unk132;                     // 132
		std::uint8_t                                        unk133;                     // 133
		std::uint32_t                                       unk134;                     // 134
		std::uint64_t                                       unk138;                     // 138
		TESWorldSpace*                                      worldSpace;                 // 140
		BSSimpleList<BSTTuple<TESNPC*, std::uint16_t>*>     deadCount;                  // 148
		void*                                               unk158;                     // 158 - smart ptr
		void*                                               unk160;                     // 160 - smart ptr
		void*                                               unk168;                     // 168 - smart ptr
		void*                                               unk170;                     // 170 - smart ptr
		std::uint64_t                                       unk178;                     // 178
		std::uint64_t                                       unk180;                     // 180
		std::uint64_t                                       unk188;                     // 188
		std::uint64_t                                       unk190;                     // 190
		std::uint64_t                                       unk198;                     // 198
		std::uint64_t                                       unk1A0;                     // 1A0
		std::uint64_t                                       unk1A8;                     // 1A8
		std::uint64_t                                       unk1B0;                     // 1B0
		std::uint64_t                                       unk1B8;                     // 1B8
		std::uint64_t                                       unk1C0;                     // 1C0
		std::uint64_t                                       unk1C8;                     // 1C8
		std::uint64_t                                       unk1D0;                     // 1D0
		std::uint64_t                                       unk1D8;                     // 1D8
		std::uint64_t                                       unk1E0;                     // 1E0
		std::uint64_t                                       unk1E8;                     // 1E8
		std::uint64_t                                       unk1F0;                     // 1F0
		std::uint64_t                                       unk1F8;                     // 1F8
		std::uint64_t                                       unk200;                     // 200
		std::uint64_t                                       unk208;                     // 208
		std::uint64_t                                       unk210;                     // 210
		std::uint64_t                                       unk218;                     // 218
		std::uint64_t                                       unk220;                     // 220
		std::uint64_t                                       unk228;                     // 228
		std::uint64_t                                       unk230;                     // 230
		std::uint64_t                                       unk238;                     // 238
		std::uint64_t                                       unk240;                     // 240
		std::uint64_t                                       unk248;                     // 248
		std::uint64_t                                       unk250;                     // 250
		std::uint64_t                                       unk258;                     // 258
		std::uint64_t                                       unk260;                     // 260
		std::uint64_t                                       unk268;                     // 268
		std::uint64_t                                       unk270;                     // 270
		std::uint64_t                                       unk278;                     // 278
		std::uint64_t                                       unk280;                     // 280
		std::uint64_t                                       unk288;                     // 288
		SystemEventAdapter                                  unk290;                     // 290
		std::uint64_t                                       unk2A0;                     // 2A0
		NavMeshInfoMap*                                     unk2A8;                     // 2A8
		std::uint64_t                                       unk2B0;                     // 2B0
	};
	static_assert(sizeof(TES) == 0x2B8);
}


===============================================
File: include/RE/T/TESAIForm.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESPackage;

	enum class ACTOR_AGGRESSION
	{
		kCalmed = static_cast<std::underlying_type_t<ACTOR_AGGRESSION>>(-1),
		kUnaggressive = 0,
		kAggressive = 1,
		kVeryAggressive = 2,
		kFrenzied = 3
	};

	struct ACTOR_AGGRO_RADIUS
	{
		enum
		{
			kWarn,
			kWarnAndAttack,
			kAttack,

			kTotal
		};
	};

	enum class ACTOR_ASSISTANCE
	{
		kHelpsNobody = 0,
		kHelpsAllies = 1,
		kHelpsFriends = 2
	};

	enum class ACTOR_CONFIDENCE
	{
		kCowardly = 0,
		kCautious = 1,
		kAverage = 2,
		kBrave = 3,
		kFoolhardy = 4
	};

	enum class ACTOR_MOOD
	{
		kNeutral = 0,
		kAngry = 1,
		kFear = 2,
		kHappy = 3,
		kSad = 4,
		kSurprised = 5,
		kPuzzled = 6,
		kDisgusted = 7
	};

	enum class ACTOR_MORALITY
	{
		kAnyCrime = 0,
		kViolenceAgainstEnemy = 1,
		kPropertyCrimeOnly = 2,
		kNoCrime = 3
	};

	struct AIDATA_GAME
	{
	public:
		// members
		bool          aggression1: 1;                           // 0 - 0
		bool          aggression2: 1;                           // 0 - 1
		bool          confidence1: 1;                           // 0 - 2
		bool          confidence2: 1;                           // 0 - 3
		bool          confidence3: 1;                           // 0 - 4
		bool          energyLevel1: 1;                          // 0 - 5
		bool          energyLevel2: 1;                          // 0 - 6
		bool          energyLevel3: 1;                          // 0 - 7
		bool          energyLevel4: 1;                          // 1 - 0
		bool          energyLevel5: 1;                          // 1 - 1
		bool          energyLevel6: 1;                          // 1 - 2
		bool          energyLevel7: 1;                          // 1 - 3
		bool          energyLevel8: 1;                          // 1 - 4
		bool          morality1: 1;                             // 1 - 5
		bool          morality2: 1;                             // 1 - 6
		bool          mood1: 1;                                 // 1 - 7
		bool          mood2: 1;                                 // 2 - 0
		bool          mood3: 1;                                 // 2 - 1
		bool          assistance1: 1;                           // 2 - 2
		bool          assistance2: 1;                           // 2 - 3
		bool          aggroRadiusBehaviour: 1;                  // 2 - 4
		bool          pad2_5: 1;                                // 2 - 5
		bool          pad2_6: 1;                                // 2 - 6
		bool          pad2_7: 1;                                // 2 - 7
		std::uint8_t  pad3;                                     // 3
		std::uint16_t aggroRadius[ACTOR_AGGRO_RADIUS::kTotal];  // 4
		bool          noSlowApproach: 1;                        // A - 0
		bool          padA_1: 1;                                // A - 1
		bool          padA_2: 1;                                // A - 2
		bool          padA_3: 1;                                // A - 3
		bool          padA_4: 1;                                // A - 4
		bool          padA_5: 1;                                // A - 5
		bool          padA_6: 1;                                // A - 6
		bool          padA_7: 1;                                // A - 7
		std::uint8_t  padB;                                     // B
	};
	static_assert(sizeof(AIDATA_GAME) == 0xC);

	struct PackageList
	{
	public:
		// members
		BSSimpleList<TESPackage*> packages;  // 00
	};
	static_assert(sizeof(PackageList) == 0x10);

	class TESAIForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESAIForm;

		~TESAIForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		[[nodiscard]] bool             AggroRadiusBehaviourIsEnabled() const;
		[[nodiscard]] ACTOR_AGGRESSION GetAggressionLevel() const;
		[[nodiscard]] ACTOR_ASSISTANCE GetAssistanceLevel() const;
		[[nodiscard]] ACTOR_CONFIDENCE GetConfidenceLevel() const;
		[[nodiscard]] std::uint8_t     GetEnergyLevel() const;
		[[nodiscard]] ACTOR_MOOD       GetMoodLevel() const;
		[[nodiscard]] ACTOR_MORALITY   GetMoralityLevel() const;
		[[nodiscard]] bool             NoSlowApproach() const;
		void                           SetAggressionLevel(ACTOR_AGGRESSION a_level);
		void                           SetAssistanceLevel(ACTOR_ASSISTANCE a_level);
		void                           SetConfidenceLevel(ACTOR_CONFIDENCE a_level);

		// members
		AIDATA_GAME aiData;      // 08 - AIDT
		PackageList aiPackages;  // 18 - PKID
	};
	static_assert(sizeof(TESAIForm) == 0x28);
}


===============================================
File: include/RE/T/TESActionData.h
===============================================
#pragma once

#include "RE/B/BGSActionData.h"

namespace RE
{
	class TESActionData : public BGSActionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESActionData;
		inline static constexpr auto VTABLE = VTABLE_TESActionData;

		virtual ~TESActionData() override;  // 00

		// override (ActionInput)
		ActorState*            GetSourceActorState() const override;  // 01
		void                   Unk_02(void) override;                 // 02 - { return 0; }
		BGSAnimationSequencer* GetSourceSequencer() const override;   // 03

		// override (BGSActionData)
		BGSActionData* Clone() const override;  // 04
		bool           Process() override;      // 05

		static TESActionData* Create()
		{
			auto tesActionData = malloc<TESActionData>();
			std::memset(reinterpret_cast<void*>(tesActionData), 0, sizeof(TESActionData));
			if (tesActionData) {
				tesActionData->Ctor();
			}
			return tesActionData;
		}

	private:
		TESActionData* Ctor()
		{
			using func_t = decltype(&TESActionData::Ctor);
			REL::Relocation<func_t> func{ RELOCATION_ID(15916, 41558) };
			TESActionData*          tesActionData = func(this);
			stl::emplace_vtable<TESActionData>(tesActionData);
			return tesActionData;
		}
	};
	static_assert(sizeof(TESActionData) == 0x60);
}


===============================================
File: include/RE/T/TESActivateEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESActivateEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> objectActivated;  // 00
		NiPointer<TESObjectREFR> actionRef;        // 08
	};
	static_assert(sizeof(TESActivateEvent) == 0x10);
}


===============================================
File: include/RE/T/TESActiveEffectApplyRemoveEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESActiveEffectApplyRemoveEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> caster;                // 00
		NiPointer<TESObjectREFR> target;                // 08
		std::uint16_t            activeEffectUniqueID;  // 10
		bool                     isApplied;             // 12
		std::uint8_t             pad13;                 // 13
		std::uint32_t            pad14;                 // 14
	};
	static_assert(sizeof(TESActiveEffectApplyRemoveEvent) == 0x18);
}


===============================================
File: include/RE/T/TESActorBase.h
===============================================
#pragma once

#include "RE/A/ActorValueOwner.h"
#include "RE/B/BGSAttackDataForm.h"
#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSPerkRankArray.h"
#include "RE/B/BGSSkinForm.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESAIForm.h"
#include "RE/T/TESActorBaseData.h"
#include "RE/T/TESBoundAnimObject.h"
#include "RE/T/TESContainer.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESSpellList.h"

namespace RE
{
	class TESActorBase :
		public TESBoundAnimObject,         // 000
		public TESActorBaseData,           // 030
		public TESContainer,               // 088
		public TESSpellList,               // 0A0
		public TESAIForm,                  // 0B0
		public TESFullName,                // 0D8
		public ActorValueOwner,            // 0E8
		public BGSDestructibleObjectForm,  // 0F0
		public BGSSkinForm,                // 100
		public BGSKeywordForm,             // 110
		public BGSAttackDataForm,          // 128
		public BGSPerkRankArray            // 138
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESActorBase;

		~TESActorBase() override;  // 00

		// override (TESBoundAnimObject)
		bool AddChange(std::uint32_t a_changeFlags) override;     // 0A
		void RemoveChange(std::uint32_t a_changeFlags) override;  // 0B
		void SaveGame(BGSSaveFormBuffer* a_buf) override;         // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;         // 0F
		bool IsAutoCalc() const override;                         // 3E - { return formType == FormType::NPC && (TESActorBaseData::flags >> 4) & 1; }
		void SetAutoCalc(bool a_autoCalc) override;               // 3F

		// override (ActorValueOwner)
		float              GetActorValue(ActorValue a_akValue) override;                                                      // 01
		float              GetPermanentActorValue(ActorValue a_akValue) override;                                             // 02
		float              GetBaseActorValue(ActorValue a_akValue) override;                                                  // 03
		void               SetBaseActorValue(ActorValue a_akValue, float a_value) override;                                   // 04
		void               ModActorValue(ActorValue a_akValue, float a_value) override;                                       // 05
		void               RestoreActorValue(ACTOR_VALUE_MODIFIER a_modifier, ActorValue a_akValue, float a_value) override;  // 06
		void               SetActorValue(ActorValue a_akValue, float a_value) override;                                       // 07
		[[nodiscard]] bool GetIsPlayerOwner() const override;                                                                 // 08

		// add
		[[nodiscard]] virtual bool GetHasPLSpecTex() const;                        // 53 - { return false; }
		virtual TESCombatStyle*    GetCombatStyle();                               // 54 - { return 0; }
		virtual void               SetCombatStyle(TESCombatStyle* a_combatStyle);  // 55 - { return; }
		virtual TESForm*           GetAsForm();                                    // 56 - { return this; }

		[[nodiscard]] bool IsLeveled() const;
	};
	static_assert(sizeof(TESActorBase) == 0x150);
}


===============================================
File: include/RE/T/TESActorBaseData.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BaseFormComponent.h"
#include "RE/F/FactionRank.h"

namespace RE
{
	class BGSVoiceType;
	class TESActorBase;
	class TESFaction;
	class TESForm;
	class TESLevItem;
	class TESNPC;

	struct ACTOR_BASE_DATA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kFemale = 1 << 0,
			kEssential = 1 << 1,
			kIsChargenFacePreset = 1 << 2,
			kRespawn = 1 << 3,
			kAutoCalcStats = 1 << 4,
			kUnique = 1 << 5,
			kDoesntAffectStealthMeter = 1 << 6,
			kPCLevelMult = 1 << 7,
			kUsesTemplate = 1 << 8,
			kCalcForAllTemplates = 1 << 9,
			kProtected = 1 << 11,
			kNoRumors = 1 << 13,
			kSummonable = 1 << 14,
			kDoesntBleed = 1 << 16,
			kBleedoutOverride = 1 << 18,
			kOppositeGenderAnims = 1 << 19,
			kSimpleActor = 1 << 20,
			kLoopedScript = 1 << 21,  // ?
			kNoActivation = 1 << 23,
			kLoopedAudio = 1 << 28,  // ?
			kIsGhost = 1 << 29,
			kInvulnerable = 1 << 31
		};

		enum class TEMPLATE_USE_FLAG
		{
			kNone = 0,
			kTraits = 1 << 0,
			kStats = 1 << 1,
			kFactions = 1 << 2,
			kSpells = 1 << 3,
			kAIData = 1 << 4,
			kAIPackages = 1 << 5,
			kUnused = 1 << 6,
			kBaseData = 1 << 7,
			kInventory = 1 << 8,
			kScript = 1 << 9,
			kAIDefPackList = 1 << 10,
			kAttackData = 1 << 11,
			kKeywords = 1 << 12,
			kCopiedTemplate = 1 << 15
		};

		// members
		stl::enumeration<Flag, std::uint32_t>              actorBaseFlags;    // 00
		std::int16_t                                       magickaOffset;     // 04
		std::int16_t                                       staminaOffset;     // 06
		std::uint16_t                                      level;             // 08
		std::uint16_t                                      calcLevelMin;      // 0A
		std::uint16_t                                      calcLevelMax;      // 0C
		std::uint16_t                                      speedMult;         // 0E
		std::uint16_t                                      baseDisposition;   // 10 - unused
		stl::enumeration<TEMPLATE_USE_FLAG, std::uint16_t> templateUseFlags;  // 12
		std::int16_t                                       healthOffset;      // 14
		std::int16_t                                       bleedoutOverride;  // 16
	};
	static_assert(sizeof(ACTOR_BASE_DATA) == 0x18);

	class TESActorBaseData : public BaseFormComponent  // ACBS
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESActorBaseData;

		~TESActorBaseData() override;

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		virtual void               CopyFromTemplateForms(TESActorBase** a_templateForms);  // 04 - { return; }
		[[nodiscard]] virtual bool GetIsGhost() const;                                     // 05 - { return (flags >> 29) & 1; }
		[[nodiscard]] virtual bool GetInvulnerable() const;                                // 06 - { test flags, 80000000h; }
		virtual void               Unk_07(void);                                           // 07 - { return 1; }
		virtual BGSVoiceType*      GetVoiceType(void);                                     // 08 - { return voice; }

		[[nodiscard]] constexpr bool AffectsStealthMeter() const noexcept { return actorData.actorBaseFlags.none(ACTOR_BASE_DATA::Flag::kDoesntAffectStealthMeter); }
		[[nodiscard]] constexpr bool Bleeds() const noexcept { return actorData.actorBaseFlags.none(ACTOR_BASE_DATA::Flag::kDoesntBleed); }
		[[nodiscard]] constexpr bool IsEssential() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kEssential); }
		[[nodiscard]] constexpr bool IsFemale() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kFemale); }
		[[nodiscard]] inline bool    IsGhost() const { return GetIsGhost(); }
		[[nodiscard]] constexpr bool IsPreset() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kIsChargenFacePreset); }
		[[nodiscard]] constexpr bool IsProtected() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kProtected); }
		[[nodiscard]] constexpr bool IsSimpleActor() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kSimpleActor); }
		[[nodiscard]] constexpr bool IsSummonable() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kSummonable); }
		[[nodiscard]] constexpr bool IsUnique() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kUnique); }
		[[nodiscard]] inline bool    IsInvulnerable() const { return GetInvulnerable(); }
		[[nodiscard]] constexpr bool HasAutoCalcStats() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kAutoCalcStats); }
		[[nodiscard]] constexpr bool HasBleedoutOverride() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kBleedoutOverride); }
		[[nodiscard]] constexpr bool HasPCLevelMult() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kPCLevelMult); }
		[[nodiscard]] constexpr bool Respawns() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kRespawn); }
		[[nodiscard]] constexpr bool UsesOppositeGenderAnims() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kOppositeGenderAnims); }
		[[nodiscard]] constexpr bool UsesTemplate() const noexcept { return actorData.actorBaseFlags.all(ACTOR_BASE_DATA::Flag::kUsesTemplate); }

		[[nodiscard]] std::uint16_t GetLevel() const
		{
			using func_t = decltype(&TESActorBaseData::GetLevel);
			REL::Relocation<func_t> func{ RELOCATION_ID(14262, 14384) };
			return func(this);
		}

		// members
		ACTOR_BASE_DATA        actorData;         // 08
		TESLevItem*            deathItem;         // 20 - INAM
		BGSVoiceType*          voiceType;         // 28 - VTCK
		TESForm*               baseTemplateForm;  // 30 - TPLT
		TESForm**              templateForms;     // 38
		BSTArray<FACTION_RANK> factions;          // 40
	};
	static_assert(sizeof(TESActorBaseData) == 0x58);
}


===============================================
File: include/RE/T/TESActorLocationChangeEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BGSLocation;
	class TESObjectREFR;

	struct TESActorLocationChangeEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> actor;
		BGSLocation*             oldLoc;
		BGSLocation*             newLoc;
	};
	static_assert(sizeof(TESActorLocationChangeEvent) == 0x18);
}


===============================================
File: include/RE/T/TESAmmo.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSMessageIcon.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	struct AMMO_DATA  // DATA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kIgnoresNormalWeaponResistance = 1 << 0,
			kNonPlayable = 1 << 1,
			kNonBolt = 1 << 2
		};

		// members
		BGSProjectile*                       projectile;  // 00
		stl::enumeration<Flag, std::uint8_t> flags;       // 08
		std::uint8_t                         pa09;        // 09
		std::uint16_t                        pa0A;        // 0A
		float                                damage;      // 0C
	};
	static_assert(sizeof(AMMO_DATA) == 0x10);

	class TESAmmo :
		public TESBoundObject,       // 000
		public TESFullName,          // 030
		public TESModelTextureSwap,  // 040
		public TESIcon,              // 078
		public BGSMessageIcon,       // 088
#ifndef ENABLE_SKYRIM_VR
		public TESValueForm,               // 0A0
		public TESWeightForm,              // 0B0
		public BGSDestructibleObjectForm,  // 0C0
		public BGSPickupPutdownSounds,     // 0D0
		public TESDescription,             // 0E8
		public BGSKeywordForm              // 0F8
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		public TESValueForm,               // 0A0
		public BGSDestructibleObjectForm,  // 0B0
		public BGSPickupPutdownSounds,     // 0C0
		public TESDescription,             // 0D8
		public BGSKeywordForm              // 0E8
#else
		public TESValueForm  // 0A0
#endif
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESAmmo;
		inline static constexpr auto VTABLE = VTABLE_TESAmmo;
		inline static constexpr auto FORMTYPE = FormType::Ammo;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                 \
	AMMO_DATA     data;      /* 00 - DATA */ \
	BSFixedString shortDesc; /* 10 - ONAM */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x18);

		~TESAmmo() override;  // 00

		// override (TESBoundObject)
		void        InitializeData() override;                                           // 04
		bool        Load(TESFile* a_mod) override;                                       // 06
		void        SaveGame(BGSSaveFormBuffer* a_buf) override;                         // 0E
		void        LoadGame(BGSLoadFormBuffer* a_buf) override;                         // 0F
		void        InitItemImpl() override;                                             // 13
		bool        GetPlayable() const override;                                        // 19 - { return ~((data.flags >> 1) & 1); }
		NiAVObject* Clone3D(TESObjectREFR* a_ref, bool a_arg3) override;                 // 40
		void        HandleRemoveItemFromContainer(TESObjectREFR* a_container) override;  // 4E

#ifndef ENABLE_SKYRIM_VR
		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05
#endif

		bool IgnoresNormalWeaponResistance();
		bool IsBolt();

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x110, 0x100);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x110, 0x100);
		}

		[[nodiscard]] inline BGSDestructibleObjectForm* AsDestructibleObjectForm() noexcept
		{
			return &REL::RelocateMember<BGSDestructibleObjectForm>(this, 0xC0, 0xB0);
		}

		[[nodiscard]] inline const BGSDestructibleObjectForm* AsDestructibleObjectForm() const noexcept
		{
			return &REL::RelocateMember<BGSDestructibleObjectForm>(this, 0xC0, 0xB0);
		}

		[[nodiscard]] inline BGSPickupPutdownSounds* AsPickupPutdownSoundsForm() noexcept
		{
			return &REL::RelocateMember<BGSPickupPutdownSounds>(this, 0xD0, 0xC0);
		}

		[[nodiscard]] inline const BGSPickupPutdownSounds* AsPickupPutdownSoundsForm() const noexcept
		{
			return &REL::RelocateMember<BGSPickupPutdownSounds>(this, 0xD0, 0xC0);
		}

		[[nodiscard]] inline TESDescription* AsDescriptionForm() noexcept
		{
			return &REL::RelocateMember<TESDescription>(this, 0xE8, 0xD8);
		}

		[[nodiscard]] inline const TESDescription* AsDescriptionForm() const noexcept
		{
			return &REL::RelocateMember<TESDescription>(this, 0xE8, 0xD8);
		}

		[[nodiscard]] inline BGSKeywordForm* AsKeywordForm() noexcept
		{
			return &REL::RelocateMember<BGSKeywordForm>(this, 0xF8, 0xE8);
		}

		[[nodiscard]] inline const BGSKeywordForm* AsKeywordForm() const noexcept
		{
			return &REL::RelocateMember<BGSKeywordForm>(this, 0xF8, 0xE8);
		}

		// members
		RUNTIME_DATA_CONTENT  // 110, 100
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(TESAmmo) == 0x128);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(TESAmmo) == 0x118);
#endif
}


===============================================
File: include/RE/T/TESAttackDamageForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESAttackDamageForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESAttackDamageForm;

		~TESAttackDamageForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { attackDamage = 0; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual std::uint16_t GetAttackDamage() const;  // 04 - { return attackDamage; }

		// members
		std::uint16_t attackDamage;  // 08
		std::uint16_t pad0A;         // 0A
		std::uint32_t pad0C;         // 0C
	};
	static_assert(sizeof(TESAttackDamageForm) == 0x10);
}


===============================================
File: include/RE/T/TESBipedModelForm.h
===============================================
#pragma once

#include "RE/B/BGSMessageIcon.h"
#include "RE/B/BaseFormComponent.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModelRDT.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	class TESBipedModelForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESBipedModelForm;

		struct Sexes
		{
			enum
			{
				kMale = 0,
				kFemale,
				kTotal
			};
		};

		~TESBipedModelForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		TESModelTextureSwap worldModels[Sexes::kTotal];     // 08
		TESIcon             inventoryIcons[Sexes::kTotal];  // 78
		BGSMessageIcon      messageIcons[Sexes::kTotal];    // 98
		TESModelRDT         constraintTemplate;             // C8
	};
	static_assert(sizeof(TESBipedModelForm) == 0xF0);
}


===============================================
File: include/RE/T/TESBoundAnimObject.h
===============================================
#pragma once

#include "RE/T/TESBoundObject.h"

namespace RE
{
	class TESBoundAnimObject : public TESBoundObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESBoundAnimObject;

		~TESBoundAnimObject() override;  // 00

		// override (TESBoundObject)
		bool IsBoundAnimObject() override;              // 3C - { return true; }
		bool ReplaceModel(const char* a_str) override;  // 4B
	};
	static_assert(sizeof(TESBoundAnimObject) == 0x30);
}


===============================================
File: include/RE/T/TESBoundObject.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESObject.h"

namespace RE
{
	class NiAVObject;
	class TESObjectREFR;

	class NiNPShortPoint3
	{
	public:
		// members
		std::int16_t x;  // 0
		std::int16_t y;  // 2
		std::int16_t z;  // 4
	};
	static_assert(sizeof(NiNPShortPoint3) == 0x6);

	class TESBoundObject : public TESObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESBoundObject;

		struct BOUND_DATA  // OBND
		{
		public:
			// members
			NiNPShortPoint3 boundMin;  // 0
			NiNPShortPoint3 boundMax;  // 6
		};
		static_assert(sizeof(BOUND_DATA) == 0xC);

		~TESBoundObject() override;  // 00

		// override (TESObject)
		void        LoadObjectBound(TESFile* a_mod) override;                                                                                                                 // 26
		bool        IsBoundObject() const override;                                                                                                                           // 27 - { return true; }
		bool        Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		NiAVObject* Clone3D(TESObjectREFR* a_ref, bool a_arg3) override;                                                                                                      // 40
		bool        ReplaceModel() override;                                                                                                                                  // 44

		// add
		virtual void                        SetObjectVoiceType(BGSVoiceType* a_voiceType);                                                 // 48 - { return; }
		[[nodiscard]] virtual BGSVoiceType* GetObjectVoiceType() const;                                                                    // 49 - { return 0; }
		virtual NiAVObject*                 Clone3D(TESObjectREFR* a_ref);                                                                 // 4A - { Clone3D(a_ref, false); }
		virtual bool                        ReplaceModel(const char* a_str);                                                               // 4B
		virtual bool                        GetActivateText(TESObjectREFR* a_activator, BSString& a_dst);                                  // 4C
		virtual bool                        CalculateDoFavor(Actor* a_activator, bool a_arg2, TESObjectREFR* a_toActivate, float a_arg3);  // 4D
		virtual void                        HandleRemoveItemFromContainer(TESObjectREFR* a_container);                                     // 4E - { return; }
		virtual void                        OnRemove3D(NiAVObject* a_obj3D);                                                               // 4F - { return; }
		virtual void                        OnCheckModels();                                                                               // 50 - { return; }
		virtual void                        OnCopyReference();                                                                             // 51 - { return; }
		virtual void                        OnFinishScale();                                                                               // 52 - { return; }

		// members
		BOUND_DATA    boundData;  // 20 - OBND
		std::uint32_t pad2C;      // 2C
	};
	static_assert(sizeof(TESBoundObject) == 0x30);
}


===============================================
File: include/RE/T/TESCamera.h
===============================================
#pragma once

#include "RE/B/BSTPoint.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/N/NiNode.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESCameraState;

	class TESCamera
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESCamera;

		virtual ~TESCamera();  // 00

		virtual void SetCameraRoot(NiPointer<NiNode> a_root);  // 01 - { if (cameraRoot != a_root) cameraRoot = a_root; }
		virtual void Update();                                 // 02

		void SetState(TESCameraState* a_state);

		// members
		BSTPoint2<float>                rotationInput;     // 08
		BSTPoint3<float>                translationInput;  // 10
		float                           zoomInput;         // 1C
		NiPointer<NiNode>               cameraRoot;        // 20
		BSTSmartPointer<TESCameraState> currentState;      // 28
		bool                            enabled;           // 30
		std::uint8_t                    pad31;             // 31
		std::uint16_t                   pad32;             // 32
		std::uint32_t                   pad34;             // 34
	};
	static_assert(sizeof(TESCamera) == 0x38);
}


===============================================
File: include/RE/T/TESCameraState.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/P/PlayerCamera.h"

namespace RE
{
	class BGSLoadFormBuffer;
	class BGSSaveFormBuffer;
	class NiPoint3;
	class NiQuaternion;
	class TESCamera;

	class TESCameraState : public BSIntrusiveRefCounted
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESCameraState;
		inline static constexpr auto VTABLE = VTABLE_TESCameraState;

		virtual ~TESCameraState();  // 00

		// add
		virtual void Begin();                                               // 01 - { return; }
		virtual void End();                                                 // 02 - { return; }
		virtual void Update(BSTSmartPointer<TESCameraState>& a_nextState);  // 03
		virtual void GetRotation(NiQuaternion& a_rotation);                 // 04
		virtual void GetTranslation(NiPoint3& a_translation);               // 05
		virtual void SaveGame(BGSSaveFormBuffer* a_buf);                    // 06 - { return; }
		virtual void LoadGame(BGSLoadFormBuffer* a_buf);                    // 07 - { return; }
		virtual void Revert(BGSLoadFormBuffer* a_buf);                      // 08 - { return; }

		// members
		std::uint32_t pad0C;   // 0C
		TESCamera*    camera;  // 10
		CameraState   id;      // 18
		std::uint32_t pad1C;   // 1C
	};
	static_assert(sizeof(TESCameraState) == 0x20);
}


===============================================
File: include/RE/T/TESCellAttachDetachEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESObjectREFR.h"

namespace RE
{
	class TESObjectCELL;

	struct TESCellAttachDetachEvent
	{
		NiPointer<TESObjectREFR> reference;  // 00
		bool                     attached;   // 08	- 01 - attached, 00 - detached
	};

	static_assert(sizeof(TESCellAttachDetachEvent) == 0x10);
}


===============================================
File: include/RE/T/TESCellFullyLoadedEvent.h
===============================================
#pragma once

namespace RE
{
	class TESObjectCELL;

	struct TESCellFullyLoadedEvent
	{
	public:
		// members
		TESObjectCELL* cell;
	};
	static_assert(sizeof(TESCellFullyLoadedEvent) == 0x8);
}


===============================================
File: include/RE/T/TESChildCell.h
===============================================
#pragma once

namespace RE
{
	class TESChildCell
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESChildCell;

		virtual ~TESChildCell();  // 00

		// add
		[[nodiscard]] virtual TESObjectCELL* GetSaveParentCell() = 0;  // 01
	};
	static_assert(sizeof(TESChildCell) == 0x8);
}


===============================================
File: include/RE/T/TESClass.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	struct CLASS_DATA  // DATA
	{
	public:
		enum class Skill
		{
			kOneHanded = 0,
			kTwoHanded = 1,
			kArchery = 2,
			kBlock = 3,
			kSmithing = 4,
			kHeavyArmor = 5,
			kLightArmor = 6,
			kPickpocket = 7,
			kLockpicking = 8,
			kSneak = 9,
			kAlchemy = 10,
			kSpeech = 11,
			kAlteration = 12,
			kConjuration = 13,
			kDestruction = 14,
			kIllusion = 15,
			kRestoration = 16,
			kEnchanting = 17,
		};

		struct SkillWeights
		{
		public:
			// members
			std::uint8_t oneHanded;    // 00
			std::uint8_t twoHanded;    // 01
			std::uint8_t archery;      // 02
			std::uint8_t block;        // 03
			std::uint8_t smithing;     // 04
			std::uint8_t heavyArmor;   // 05
			std::uint8_t lightArmor;   // 06
			std::uint8_t pickpocket;   // 07
			std::uint8_t lockpicking;  // 08
			std::uint8_t sneak;        // 09
			std::uint8_t alchemy;      // 0A
			std::uint8_t speech;       // 0B
			std::uint8_t alteration;   // 0C
			std::uint8_t conjuration;  // 0D
			std::uint8_t destruction;  // 0E
			std::uint8_t illusion;     // 0F
			std::uint8_t restoration;  // 10
			std::uint8_t enchanting;   // 11
		};
		static_assert(sizeof(SkillWeights) == 0x12);

		struct AttributeWeights
		{
		public:
			// members
			std::uint8_t health;   // 0
			std::uint8_t magicka;  // 1
			std::uint8_t stamina;  // 2
		};
		static_assert(sizeof(AttributeWeights) == 0x3);

		// members
		std::uint32_t                         unk00;                 // 00
		stl::enumeration<Skill, std::uint8_t> teaches;               // 04
		std::uint8_t                          maximumTrainingLevel;  // 05
		SkillWeights                          skillWeights;          // 06
		float                                 bleedoutDefault;       // 18
		std::uint32_t                         voicePoints;           // 1C
		AttributeWeights                      attributeWeights;      // 20
		std::uint8_t                          pad23;                 // 23
	};
	static_assert(sizeof(CLASS_DATA) == 0x24);

	class TESClass :
		public TESForm,         // 00
		public TESFullName,     // 20
		public TESDescription,  // 30
		public TESTexture       // 40
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESClass;
		inline static constexpr auto VTABLE = VTABLE_TESClass;
		inline static constexpr auto FORMTYPE = FormType::Class;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kTagSkills = 1 << 1
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESClass() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06

		// members
		CLASS_DATA    data;   // 50 - DATA
		std::uint32_t pad74;  // 74
	};
	static_assert(sizeof(TESClass) == 0x78);
}


===============================================
File: include/RE/T/TESClimate.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESTexture.h"
#include "RE/W/WeatherType.h"

namespace RE
{
	class TESClimate : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESClimate;
		inline static constexpr auto VTABLE = VTABLE_TESClimate;
		inline static constexpr auto FORMTYPE = FormType::Climate;

		struct SkyObjects
		{
			enum SkyObject
			{
				kSun,
				kSunGlare,

				kTotal
			};
		};
		using SkyObject = SkyObjects::SkyObject;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Timing
		{
		public:
			enum class MoonPhaseLength
			{
				kPhaseLengthMask = 0x3F,

				kNone = 0,
				kMasser = 1 << 6,
				kSecunda = 1 << 7
			};

			struct Interval
			{
			public:
				[[nodiscard]] std::tm ConvertInterval(std::uint8_t a_time) const;
				[[nodiscard]] std::tm GetBeginTime() const;
				[[nodiscard]] std::tm GetEndTime() const;

				// members
				std::uint8_t begin;  // 0
				std::uint8_t end;    // 1
			};
			static_assert(sizeof(Interval) == 0x2);

			[[nodiscard]] bool         IncludesMasser() const;
			[[nodiscard]] bool         IncludesSecunda() const;
			[[nodiscard]] std::uint8_t GetPhaseLength() const;

			// members
			Interval                                        sunrise;          // 0
			Interval                                        sunset;           // 2
			std::uint8_t                                    volatility;       // 4
			stl::enumeration<MoonPhaseLength, std::uint8_t> moonPhaseLength;  // 5
			std::uint8_t                                    unk6;             // 6
			std::uint8_t                                    unk7;             // 7
		};
		static_assert(sizeof(Timing) == 0x8);

		~TESClimate() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06

		// members
		TESModel                   nightSky;                        // 20
		BSSimpleList<WeatherType*> weatherList;                     // 48 - WLST
		TESTexture                 skyObjects[SkyObjects::kTotal];  // 58 - FNAM - GNAM
		Timing                     timing;                          // 78 - TNAM
	};
	static_assert(sizeof(TESClimate) == 0x80);
}


===============================================
File: include/RE/T/TESCombatEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	enum class ACTOR_COMBAT_STATE
	{
		kNone = 0,
		kCombat = 1,
		kSearching = 2
	};

	struct TESCombatEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR>                            actor;        // 00
		NiPointer<TESObjectREFR>                            targetActor;  // 08
		stl::enumeration<ACTOR_COMBAT_STATE, std::uint32_t> newState;     // 10
		std::uint32_t                                       pad14{ 0 };   // 14
	};
	static_assert(sizeof(TESCombatEvent) == 0x18);
}


===============================================
File: include/RE/T/TESCombatStyle.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct CombatStyleGeneralData  // CSGD
	{
		float offensiveMult;       // 00
		float defensiveMult;       // 04
		float groupOffensiveMult;  // 08
		float meleeScoreMult;      // 0C
		float magicScoreMult;      // 10
		float rangedScoreMult;     // 14
		float shoutScoreMult;      // 18
		float unarmedScoreMult;    // 1C
		float staffScoreMult;      // 20
		float avoidThreatChance;   // 24
	};
	static_assert(sizeof(CombatStyleGeneralData) == 0x28);

	struct CombatStyleMeleeData  // CSME
	{
		float attackIncapacitatedMult;       // 00
		float powerAttackIncapacitatedMult;  // 04
		float powerAttackBlockingMult;       // 08
		float bashMult;                      // 0C
		float bashRecoilMult;                // 10
		float bashAttackMult;                // 14
		float bashPowerAttackMult;           // 18
		float specialAttackMult;             // 1C
	};
	static_assert(sizeof(CombatStyleMeleeData) == 0x20);

	struct CombatStyleCloseRangeData  // CSCR
	{
		float circleMult;         // 00
		float fallbackMult;       // 04
		float flankDistanceMult;  // 08
		float stalkTimeMult;      // 0C
	};
	static_assert(sizeof(CombatStyleCloseRangeData) == 0x10);

	struct CombatStyleLongRangeData  // CSLR
	{
		float strafeMult;  // 0
	};
	static_assert(sizeof(CombatStyleLongRangeData) == 0x4);

	struct CombatStyleFlightData  // CSFL
	{
		float hoverChance;           // 00
		float diveBombChance;        // 04
		float groundAttackChance;    // 08
		float hoverTimeMult;         // 0C
		float groundAttackTimeMult;  // 10
		float perchAttackChance;     // 14
		float perchAttackTimeMult;   // 18
		float flyingAttackChance;    // 1C
	};
	static_assert(sizeof(CombatStyleFlightData) == 0x20);

	class TESCombatStyle : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESCombatStyle;
		inline static constexpr auto VTABLE = VTABLE_TESCombatStyle;
		inline static constexpr auto FORMTYPE = FormType::CombatStyle;

		enum class FLAG  // DATA
		{
			kNone = 0,
			kDuelingStyle = 1 << 0,
			kFlankingStyle = 1 << 1,
			kAllowDualWielding = 1 << 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kAllowDualWielding = 1 << 19
			};
		};

		~TESCombatStyle() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		CombatStyleGeneralData                generalData;     // 20 - CSGD
		CombatStyleMeleeData                  meleeData;       // 48 - CSME
		CombatStyleCloseRangeData             closeRangeData;  // 68 - CSCR
		CombatStyleLongRangeData              longRangeData;   // 78 - CSLR
		CombatStyleFlightData                 flightData;      // 7C - CSFL
		stl::enumeration<FLAG, std::uint32_t> flags;           // 9C - DATA
	};
	static_assert(sizeof(TESCombatStyle) == 0xA0);
}


===============================================
File: include/RE/T/TESCondition.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class TESGlobal;
	class TESObjectREFR;

	enum class CONDITIONITEMOBJECT
	{
		kSelf = 0,
		kTarget = 1,
		kRef = 2,
		kCombatTarget = 3,
		kLinkedRef = 4,
		kQuestAlias = 5,
		kPackData = 6,
		kEventData = 7,
		kCommandTarget = 8
	};

	struct FUNCTION_DATA
	{
	public:
		// Betheseda keeps these in a giant lookup table
		// using func_t = bool(TESObjectREFR* a_thisObj, void* a_param1, void* a_param2, double& a_result);
		enum class FunctionID
		{
			kGetWantBlocking = 0,
			kGetDistance = 1,
			kAddItem = 2,
			kSetEssential = 3,
			kRotate = 4,
			kGetLocked = 5,
			kGetPos = 6,
			kSetPos = 7,
			kGetAngle = 8,
			kSetAngle = 9,
			kGetStartingPos = 10,
			kGetStartingAngle = 11,
			kGetSecondsPassed = 12,
			kActivate = 13,
			kGetActorValue = 14,
			kGetAV = static_cast<std::underlying_type_t<FunctionID>>(kGetActorValue),
			kSetActorValue = 15,
			kSetAV = static_cast<std::underlying_type_t<FunctionID>>(kSetActorValue),
			kModActorValue = 16,
			kModAV = static_cast<std::underlying_type_t<FunctionID>>(kModActorValue),
			kSetAtStart = 17,
			kGetCurrentTime = 18,
			kPlayGroup = 19,
			kLoopGroup = 20,
			kSkipAnim = 21,
			kStartCombat = 22,
			kStopCombat = 23,
			kGetScale = 24,
			kIsMoving = 25,
			kIsTurning = 26,
			kGetLineOfSight = 27,
			kGetLOS = static_cast<std::underlying_type_t<FunctionID>>(kGetLineOfSight),
			kAddSpell = 28,
			kRemoveSpell = 29,
			kCast = 30,
			kGetButtonPressed = 31,
			kGetInSameCell = 32,
			kEnable = 33,
			kDisable = 34,
			kGetDisabled = 35,
			kMenuMode = 36,
			kPlaceAtMe = 37,
			kPlaySound = 38,
			kGetDisease = 39,
			kFailAllObjectives = 40,
			kGetClothingValue = 41,
			kSameFaction = 42,
			kSameRace = 43,
			kSameSex = 44,
			kGetDetected = 45,
			kGetDead = 46,
			kGetItemCount = 47,
			kGetGold = 48,
			kGetSleeping = 49,
			kGetTalkedToPC = 50,
			kSay = 51,
			kSayTo = 52,
			kGetScriptVariable = 53,
			kStartQuest = 54,
			kStopQuest = 55,
			kGetQuestRunning = 56,
			kGetQR = static_cast<std::underlying_type_t<FunctionID>>(kGetQuestRunning),
			kSetStage = 57,
			kGetStage = 58,
			kGetStageDone = 59,
			kGetFactionRankDifference = 60,
			kGetAlarmed = 61,
			kIsRaining = 62,
			kGetAttacked = 63,
			kGetIsCreature = 64,
			kGetLockLevel = 65,
			kGetShouldAttack = 66,
			kGetInCell = 67,
			kGetIsClass = 68,
			kGetIsRace = 69,
			kGetIsSex = 70,
			kGetInFaction = 71,
			kGetIsID = 72,
			kGetFactionRank = 73,
			kGetGlobalValue = 74,
			kIsSnowing = 75,
			kFastTravel = 76,
			kFT = static_cast<std::underlying_type_t<FunctionID>>(kFastTravel),
			kGetRandomPercent = 77,
			kRemoveMusic = 78,
			kGetQuestVariable = 79,
			kGetLevel = 80,
			kIsRotating = 81,
			kRemoveItem = 82,
			kGetLeveledEncounterValue = 83,
			kGetDeadCount = 84,
			kAddToMap = 85,
			kShowMap = static_cast<std::underlying_type_t<FunctionID>>(kAddToMap),
			kStartConversation = 86,
			kDrop = 87,
			kAddTopic = 88,
			kShowMessage = 89,
			kSetAlert = 90,
			kGetIsAlerted = 91,
			kLook = 92,
			kStopLook = 93,
			kEvaluatePackage = 94,
			kEvP = static_cast<std::underlying_type_t<FunctionID>>(kEvaluatePackage),
			kSendAssaultAlarm = 95,
			kEnablePlayerControls = 96,
			kEPC = static_cast<std::underlying_type_t<FunctionID>>(kEnablePlayerControls),
			kDisablePlayerControls = 97,
			kDPC = static_cast<std::underlying_type_t<FunctionID>>(kDisablePlayerControls),
			kGetPlayerControlsDisabled = 98,
			kGPC = static_cast<std::underlying_type_t<FunctionID>>(kGetPlayerControlsDisabled),
			kGetHeadingAngle = 99,
			kPickIdle = 100,
			kIsWeaponMagicOut = 101,
			kIsTorchOut = 102,
			kIsShieldOut = 103,
			kCreateDetectionEvent = 104,
			kIsActionRef = 105,
			kIsFacingUp = 106,
			kGetKnockedState = 107,
			kGetWeaponAnimType = 108,
			kIsWeaponSkillType = 109,
			kGetCurrentAIPackage = 110,
			kIsWaiting = 111,
			kIsIdlePlaying = 112,
			kCompleteQuest = 113,
			kLock = 114,
			kUnLock = 115,
			kIsIntimidatedByPlayer = 116,
			kIsPlayerInRegion = 117,
			kGetActorAggroRadiusViolated = 118,
			kGetCrimeKnown = 119,
			kSetEnemy = 120,
			kSetAlly = 121,
			kGetCrime = 122,
			kIsGreetingPlayer = 123,
			kStartMisterSandMan = 124,
			kIsGuard = 125,
			kStartCannibal = 126,
			kHasBeenEaten = 127,
			kGetStaminaPercentage = 128,
			kGetStamina = static_cast<std::underlying_type_t<FunctionID>>(kGetStaminaPercentage),
			kGetPCIsClass = 129,
			kGetPCIsRace = 130,
			kGetPCIsSex = 131,
			kGetPCInFaction = 132,
			kSameFactionAsPC = 133,
			kSameRaceAsPC = 134,
			kSameSexAsPC = 135,
			kGetIsReference = 136,
			kSetFactionRank = 137,
			kModFactionRank = 138,
			kKillActor = 139,
			kkill = static_cast<std::underlying_type_t<FunctionID>>(kKillActor),
			kResurrectActor = 140,
			kResurrect = static_cast<std::underlying_type_t<FunctionID>>(kResurrectActor),
			kIsTalking = 141,
			kGetWalkSpeed = 142,
			kGetWalk = static_cast<std::underlying_type_t<FunctionID>>(kGetWalkSpeed),
			kGetCurrentAIProcedure = 143,
			kGetTrespassWarningLevel = 144,
			kIsTrespassing = 145,
			kIsInMyOwnedCell = 146,
			kGetWindSpeed = 147,
			kGetCurrentWeatherPercent = 148,
			kGetweatherpct = static_cast<std::underlying_type_t<FunctionID>>(kGetCurrentWeatherPercent),
			kGetIsCurrentWeather = 149,
			kGetweather = static_cast<std::underlying_type_t<FunctionID>>(kGetIsCurrentWeather),
			kIsContinuingPackagePCNear = 150,
			kSetCrimeFaction = 151,
			kGetIsCrimeFaction = 152,
			kCanHaveFlames = 153,
			kHasFlames = 154,
			kAddFlames = 155,
			kRemoveFlames = 156,
			kGetOpenState = 157,
			kMoveToMarker = 158,
			kMoveTo = static_cast<std::underlying_type_t<FunctionID>>(kMoveToMarker),
			kGetSitting = 159,
			kGetFurnitureMarkerID = 160,
			kGetIsCurrentPackage = 161,
			kIsCurrentFurnitureRef = 162,
			kIsCurrentFurnitureObj = 163,
			kSetSize = 164,
			kCSize = static_cast<std::underlying_type_t<FunctionID>>(kSetSize),
			kRemoveMe = 165,
			kDropMe = 166,
			kGetFactionReaction = 167,
			kSetFactionReaction = 168,
			kModFactionReaction = 169,
			kGetDayOfWeek = 170,
			kIgnoreCrime = 171,
			kGetTalkedToPCParam = 172,
			kRemoveAllItems = 173,
			kWakeUpPC = 174,
			kIsPCSleeping = 175,
			kIsPCAMurderer = 176,
			kSetCombatStyle = 177,
			kSetCS = static_cast<std::underlying_type_t<FunctionID>>(kSetCombatStyle),
			kPlaySound3D = 178,
			kSelectPlayerSpell = 179,
			kSPSpell = static_cast<std::underlying_type_t<FunctionID>>(kSelectPlayerSpell),
			kHasSameEditorLocAsRef = 180,
			kHasSameEditorLocAsRefAlias = 181,
			kGetEquipped = 182,
			kWait = 183,
			kStopWaiting = 184,
			kIsSwimming = 185,
			kScriptEffectElapsedSeconds = 186,
			kSetCellPublicFlag = 187,
			kSetPublic = static_cast<std::underlying_type_t<FunctionID>>(kSetCellPublicFlag),
			kGetPCSleepHours = 188,
			kSetPCSleepHours = 189,
			kGetAmountSoldStolen = 190,
			kModAmountSoldStolen = 191,
			kGetIgnoreCrime = 192,
			kGetPCExpelled = 193,
			kSetPCExpelled = 194,
			kGetPCFactionMurder = 195,
			kSetPCFactionMurder = 196,
			kGetPCEnemyofFaction = 197,
			kSetPCEnemyofFaction = 198,
			kGetPCFactionAttack = 199,
			kSetPCFactionAttack = 200,
			kStartScene = 201,
			kStopScene = 202,
			kGetDestroyed = 203,
			kSetDestroyed = 204,
			kGetActionRef = 205,
			kGetAR = static_cast<std::underlying_type_t<FunctionID>>(kGetActionRef),
			kGetSelf = 206,
			kThis = static_cast<std::underlying_type_t<FunctionID>>(kGetSelf),
			kGetContainer = 207,
			kGetForceRun = 208,
			kSetForceRun = 209,
			kGetForceSneak = 210,
			kSetForceSneak = 211,
			kAdvancePCSkill = 212,
			kAdvSkill = static_cast<std::underlying_type_t<FunctionID>>(kAdvancePCSkill),
			kAdvancePCLevel = 213,
			kAdvLevel = static_cast<std::underlying_type_t<FunctionID>>(kAdvancePCLevel),
			kHasMagicEffect = 214,
			kGetDefaultOpen = 215,
			kSetDefaultOpen = 216,
			kShowClassMenu = 217,
			kShowRaceMenu = 218,
			kSetPlayerRace = static_cast<std::underlying_type_t<FunctionID>>(kShowRaceMenu),
			kGetAnimAction = 219,
			kShowNameMenu = 220,
			kSetOpenState = 221,
			kResetReference = 222,
			kRecycleActor = static_cast<std::underlying_type_t<FunctionID>>(kResetReference),
			kIsSpellTarget = 223,
			kGetVATSMode = 224,
			kGetPersuasionNumber = 225,
			kGetVampireFeed = 226,
			kGetCannibal = 227,
			kGetIsClassDefault = 228,
			kGetClassDefaultMatch = 229,
			kGetInCellParam = 230,
			kUnusedFunction1 = 231,
			kGetCombatTarget = 232,
			kGetPackageTarget = 233,
			kShowSpellMaking = 234,
			kGetVatsTargetHeight = 235,
			kSetGhost = 236,
			kGetIsGhost = 237,
			kEquipItem = 238,
			kEquipObject = static_cast<std::underlying_type_t<FunctionID>>(kEquipItem),
			kUnequipItem = 239,
			kUnEquipObject = static_cast<std::underlying_type_t<FunctionID>>(kUnequipItem),
			kSetClass = 240,
			kSetUnconscious = 241,
			kGetUnconscious = 242,
			kSetRestrained = 243,
			kGetRestrained = 244,
			kForceFlee = 245,
			kFlee = static_cast<std::underlying_type_t<FunctionID>>(kForceFlee),
			kGetIsUsedItem = 246,
			kGetIsUsedItemType = 247,
			kIsScenePlaying = 248,
			kIsInDialogueWithPlayer = 249,
			kGetLocationCleared = 250,
			kSetLocationCleared = 251,
			kForceRefIntoAlias = 252,
			kEmptyRefAlias = 253,
			kGetIsPlayableRace = 254,
			kGetOffersServicesNow = 255,
			kGetGameSetting = 256,
			kGetGS = static_cast<std::underlying_type_t<FunctionID>>(kGetGameSetting),
			kStopCombatAlarmOnActor = 257,
			kSCAOnActor = static_cast<std::underlying_type_t<FunctionID>>(kStopCombatAlarmOnActor),
			kHasAssociationType = 258,
			kHasFamilyRelationship = 259,
			kFamily = static_cast<std::underlying_type_t<FunctionID>>(kHasFamilyRelationship),
			kSetWeather = 260,
			kSW = static_cast<std::underlying_type_t<FunctionID>>(kSetWeather),
			kHasParentRelationship = 261,
			kIsParent = static_cast<std::underlying_type_t<FunctionID>>(kHasParentRelationship),
			kIsWarningAbout = 262,
			kIsWeaponOut = 263,
			kHasSpell = 264,
			kIsTimePassing = 265,
			kIsPleasant = 266,
			kIsCloudy = 267,
			kTrapUpdate = 268,
			kShowQuestObjectives = 269,
			kSQO = static_cast<std::underlying_type_t<FunctionID>>(kShowQuestObjectives),
			kForceActorValue = 270,
			kForceAV = static_cast<std::underlying_type_t<FunctionID>>(kForceActorValue),
			kIncrementPCSkill = 271,
			kIncPCS = static_cast<std::underlying_type_t<FunctionID>>(kIncrementPCSkill),
			kDoTrap = 272,
			kEnableFastTravel = 273,
			kEnableFast = static_cast<std::underlying_type_t<FunctionID>>(kEnableFastTravel),
			kIsSmallBump = 274,
			kGetParentRef = 275,
			kPlayBink = 276,
			kGetBaseActorValue = 277,
			kGetBaseAV = static_cast<std::underlying_type_t<FunctionID>>(kGetBaseActorValue),
			kIsOwner = 278,
			kSetOwnership = 279,
			kIsCellOwner = 280,
			kSetCellOwnership = 281,
			kIsHorseStolen = 282,
			kSetCellFullName = 283,
			kSetActorFullName = 284,
			kIsLeftUp = 285,
			kIsSneaking = 286,
			kIsRunning = 287,
			kGetFriendHit = 288,
			kIsInCombat = 289,
			kSetPackDuration = 290,
			kSPDur = static_cast<std::underlying_type_t<FunctionID>>(kSetPackDuration),
			kPlayMagicShaderVisuals = 291,
			kPMS = static_cast<std::underlying_type_t<FunctionID>>(kPlayMagicShaderVisuals),
			kPlayMagicEffectVisuals = 292,
			kPME = static_cast<std::underlying_type_t<FunctionID>>(kPlayMagicEffectVisuals),
			kStopMagicShaderVisuals = 293,
			kSMS = static_cast<std::underlying_type_t<FunctionID>>(kStopMagicShaderVisuals),
			kStopMagicEffectVisuals = 294,
			kSME = static_cast<std::underlying_type_t<FunctionID>>(kStopMagicEffectVisuals),
			kResetInterior = 295,
			kIsAnimPlaying = 296,
			kSetActorAlpha = 297,
			kSAA = static_cast<std::underlying_type_t<FunctionID>>(kSetActorAlpha),
			kEnableLinkedPathPoints = 298,
			kDisableLinkedPathPoints = 299,
			kIsInInterior = 300,
			kForceWeather = 301,
			kFW = static_cast<std::underlying_type_t<FunctionID>>(kForceWeather),
			kToggleActorsAI = 302,
			kIsActorsAIOff = 303,
			kIsWaterObject = 304,
			kGetPlayerAction = 305,
			kIsActorUsingATorch = 306,
			kSetLevel = 307,
			kResetFallDamageTimer = 308,
			kIsXBox = 309,
			kGetInWorldspace = 310,
			kModPCMiscStat = 311,
			kModPCMS = static_cast<std::underlying_type_t<FunctionID>>(kModPCMiscStat),
			kGetPCMiscStat = 312,
			kGetPCMS = static_cast<std::underlying_type_t<FunctionID>>(kGetPCMiscStat),
			kGetPairedAnimation = 313,
			kGPA = static_cast<std::underlying_type_t<FunctionID>>(kGetPairedAnimation),
			kIsActorAVictim = 314,
			kGetTotalPersuasionNumber = 315,
			kSetScale = 316,
			kModScale = 317,
			kGetIdleDoneOnce = 318,
			kKillAllActors = 319,
			kkillall = static_cast<std::underlying_type_t<FunctionID>>(kKillAllActors),
			kGetNoRumors = 320,
			kSetNoRumors = 321,
			kDispel = 322,
			kGetCombatState = 323,
			kTriggerHitShader = 324,
			kTHS = static_cast<std::underlying_type_t<FunctionID>>(kTriggerHitShader),
			kGetWithinPackageLocation = 325,
			kReset3DState = 326,
			kIsRidingMount = 327,
			kDispelAllSpells = 328,
			kIsFleeing = 329,
			kAddAchievement = 330,
			kDuplicateAllItems = 331,
			kIsInDangerousWater = 332,
			kEssentialDeathReload = 333,
			kSetShowQuestItems = 334,
			kDuplicateNPCStats = 335,
			kResetHealth = 336,
			kSetIgnoreFriendlyHits = 337,
			kSIFH = static_cast<std::underlying_type_t<FunctionID>>(kSetIgnoreFriendlyHits),
			kGetIgnoreFriendlyHits = 338,
			kGIFH = static_cast<std::underlying_type_t<FunctionID>>(kGetIgnoreFriendlyHits),
			kIsPlayersLastRiddenMount = 339,
			kSetActorRefraction = 340,
			kSAR = static_cast<std::underlying_type_t<FunctionID>>(kSetActorRefraction),
			kSetItemValue = 341,
			kSetRigidBodyMass = 342,
			kShowViewerStrings = 343,
			kSVS = static_cast<std::underlying_type_t<FunctionID>>(kShowViewerStrings),
			kReleaseWeatherOverride = 344,
			kRWO = static_cast<std::underlying_type_t<FunctionID>>(kReleaseWeatherOverride),
			kSetAllReachable = 345,
			kSetAllVisible = 346,
			kSetNoAvoidance = 347,
			kSendTrespassAlarm = 348,
			kSetSceneIsComplex = 349,
			kAutosave = 350,
			kStartMasterFileSeekData = 351,
			kDumpMasterFileSeekData = 352,
			kIsActor = 353,
			kIsEssential = 354,
			kPreloadMagicEffect = 355,
			kShowDialogSubtitles = 356,
			kSetPlayerResistingArrest = 357,
			kIsPlayerMovingIntoNewSpace = 358,
			kGetInCurrentLoc = 359,
			kGetInCurrentLocAlias = 360,
			kGetTimeDead = 361,
			kHasLinkedRef = 362,
			kGetLinkedRef = 363,
			kDamageObject = 364,
			kDO = static_cast<std::underlying_type_t<FunctionID>>(kDamageObject),
			kIsChild = 365,
			kGetStolenItemValueNoCrime = 366,
			kGetLastPlayerAction = 367,
			kIsPlayerActionActive = 368,
			kSetTalkingActivatorActor = 369,
			kIsTalkingActivatorActor = 370,
			kShowBarterMenu = 371,
			kSBM = static_cast<std::underlying_type_t<FunctionID>>(kShowBarterMenu),
			kIsInList = 372,
			kGetStolenItemValue = 373,
			kAddPerk = 374,
			kGetCrimeGoldViolent = 375,
			kGetviolent = static_cast<std::underlying_type_t<FunctionID>>(kGetCrimeGoldViolent),
			kGetCrimeGoldNonviolent = 376,
			kGetnonviolent = static_cast<std::underlying_type_t<FunctionID>>(kGetCrimeGoldNonviolent),
			kShowRepairMenu = 377,
			kSRM = static_cast<std::underlying_type_t<FunctionID>>(kShowRepairMenu),
			kHasShout = 378,
			kAddNote = 379,
			kAN = static_cast<std::underlying_type_t<FunctionID>>(kAddNote),
			kRemoveNote = 380,
			kRN = static_cast<std::underlying_type_t<FunctionID>>(kRemoveNote),
			kGetHasNote = 381,
			kGetN = static_cast<std::underlying_type_t<FunctionID>>(kGetHasNote),
			kAddToFaction = 382,
			kAddFac = static_cast<std::underlying_type_t<FunctionID>>(kAddToFaction),
			kRemoveFromFaction = 383,
			kRemoveFac = static_cast<std::underlying_type_t<FunctionID>>(kRemoveFromFaction),
			kDamageActorValue = 384,
			kDamageAV = static_cast<std::underlying_type_t<FunctionID>>(kDamageActorValue),
			kRestoreActorValue = 385,
			kRestoreAV = static_cast<std::underlying_type_t<FunctionID>>(kRestoreActorValue),
			kTriggerHUDShudder = 386,
			kHudSH = static_cast<std::underlying_type_t<FunctionID>>(kTriggerHUDShudder),
			kGetObjectiveFailed = 387,
			kSetObjectiveFailed = 388,
			kSetGlobalTimeMultiplier = 389,
			kSGTM = static_cast<std::underlying_type_t<FunctionID>>(kSetGlobalTimeMultiplier),
			kGetHitLocation = 390,
			kIsPC1stPerson = 391,
			kPC1st = static_cast<std::underlying_type_t<FunctionID>>(kIsPC1stPerson),
			kPurgeCellBuffers = 392,
			kPCB = static_cast<std::underlying_type_t<FunctionID>>(kPurgeCellBuffers),
			kPushActorAway = 393,
			kSetActorsAI = 394,
			kClearOwnership = 395,
			kGetCauseofDeath = 396,
			kIsLimbGone = 397,
			kIsWeaponInList = 398,
			kPlayIdle = 399,
			kApplyImageSpaceModifier = 400,
			kIMod = static_cast<std::underlying_type_t<FunctionID>>(kApplyImageSpaceModifier),
			kRemoveImageSpaceModifier = 401,
			kRIMod = static_cast<std::underlying_type_t<FunctionID>>(kRemoveImageSpaceModifier),
			kIsBribedbyPlayer = 402,
			kGetRelationshipRank = 403,
			kSetRelationshipRank = 404,
			kSetCellImageSpace = 405,
			kShowChargenMenu = 406,
			kSCGM = static_cast<std::underlying_type_t<FunctionID>>(kShowChargenMenu),
			kGetVATSValue = 407,
			kIsKiller = 408,
			kIsKillerObject = 409,
			kGetFactionCombatReaction = 410,
			kUseWeapon = 411,
			kEvaluateSpellConditions = 412,
			kESC = static_cast<std::underlying_type_t<FunctionID>>(kEvaluateSpellConditions),
			kToggleMotionBlur = 413,
			kTMB = static_cast<std::underlying_type_t<FunctionID>>(kToggleMotionBlur),
			kExists = 414,
			kGetGroupMemberCount = 415,
			kGetGroupTargetCount = 416,
			kSetObjectiveCompleted = 417,
			kSetObjectiveDisplayed = 418,
			kGetObjectiveCompleted = 419,
			kGetObjectiveDisplayed = 420,
			kSetImageSpace = 421,
			kPipboyRadio = 422,
			kPRad = static_cast<std::underlying_type_t<FunctionID>>(kPipboyRadio),
			kRemovePerk = 423,
			kDisableAllActors = 424,
			kDisAA = static_cast<std::underlying_type_t<FunctionID>>(kDisableAllActors),
			kGetIsFormType = 425,
			kGetIsVoiceType = 426,
			kGetPlantedExplosive = 427,
			kCompleteAllObjectives = 428,
			kIsScenePackageRunning = 429,
			kGetHealthPercentage = 430,
			kSetAudioMultithreading = 431,
			kSAM = static_cast<std::underlying_type_t<FunctionID>>(kSetAudioMultithreading),
			kGetIsObjectType = 432,
			kShowChargenMenuParams = 433,
			kSCGMP = static_cast<std::underlying_type_t<FunctionID>>(kShowChargenMenuParams),
			kGetDialogueEmotion = 434,
			kGetDialogueEmotionValue = 435,
			kExitGame = 436,
			kExit = static_cast<std::underlying_type_t<FunctionID>>(kExitGame),
			kGetIsCreatureType = 437,
			kPlayerCreatePotion = 438,
			kPlayerEnchantObject = 439,
			kShowWarning = 440,
			kEnterTrigger = 441,
			kMarkForDelete = 442,
			kSetPlayerAIDriven = 443,
			kGetInCurrentLocFormList = 444,
			kGetInZone = 445,
			kGetVelocity = 446,
			kGetGraphVariableFloat = 447,
			kHasPerk = 448,
			kGetFactionRelation = 449,
			kIsLastIdlePlayed = 450,
			kSetNPCRadio = 451,
			kSNR = static_cast<std::underlying_type_t<FunctionID>>(kSetNPCRadio),
			kSetPlayerTeammate = 452,
			kGetPlayerTeammate = 453,
			kGetPlayerTeammateCount = 454,
			kOpenActorContainer = 455,
			kClearFactionPlayerEnemyFlag = 456,
			kClearActorsFactionsPlayerEnemyFlag = 457,
			kGetActorCrimePlayerEnemy = 458,
			kGetCrimeGold = 459,
			kSetCrimeGold = 460,
			kModCrimeGold = 461,
			kGetPlayerGrabbedRef = 462,
			kIsPlayerGrabbedRef = 463,
			kPlaceLeveledActorAtMe = 464,
			kGetKeywordItemCount = 465,
			kShowLockpickMenu = 466,
			kSLPM = static_cast<std::underlying_type_t<FunctionID>>(kShowLockpickMenu),
			kGetBroadcastState = 467,
			kSetBroadcastState = 468,
			kStartRadioConversation = 469,
			kGetDestructionStage = 470,
			kClearDestruction = 471,
			kCastImmediateOnSelf = 472,
			kCIOS = static_cast<std::underlying_type_t<FunctionID>>(kCastImmediateOnSelf),
			kGetIsAlignment = 473,
			kResetQuest = 474,
			kSetQuestDelay = 475,
			kIsProtected = 476,
			kGetThreatRatio = 477,
			kMatchFaceGeometry = 478,
			kGetIsUsedItemEquipType = 479,
			kGetPlayerName = 480,
			kFireWeapon = 481,
			kPayCrimeGold = 482,
			kUnusedFunction2 = 483,
			kMatchRace = 484,
			kSetPCYoung = 485,
			kSexChange = 486,
			kIsCarryable = 487,
			kGetConcussed = 488,
			kSetZoneRespawns = 489,
			kSetVATSTarget = 490,
			kGetMapMarkerVisible = 491,
			kResetInventory = 492,
			kPlayerKnows = 493,
			kGetPermanentActorValue = 494,
			kGetPermAV = static_cast<std::underlying_type_t<FunctionID>>(kGetPermanentActorValue),
			kGetKillingBlowLimb = 495,
			kGoToJail = 496,
			kCanPayCrimeGold = 497,
			kServeTime = 498,
			kGetDaysInJail = 499,
			kEPAlchemyGetMakingPoison = 500,
			kEPAlchemyEffectHasKeyword = 501,
			kShowAllMapMarkers = 502,
			kTMM = static_cast<std::underlying_type_t<FunctionID>>(kShowAllMapMarkers),
			kGetAllowWorldInteractions = 503,
			kResetAI = 504,
			kSetRumble = 505,
			kSetNoActivationSound = 506,
			kClearNoActivationSound = 507,
			kGetLastHitCritical = 508,
			kAddMusic = 509,
			kUnusedFunction3 = 510,
			kUnusedFunction4 = 511,
			kSetPCToddler = 512,
			kIsCombatTarget = 513,
			kTriggerScreenBlood = 514,
			kTSB = static_cast<std::underlying_type_t<FunctionID>>(kTriggerScreenBlood),
			kGetVATSRightAreaFree = 515,
			kGetVATSLeftAreaFree = 516,
			kGetVATSBackAreaFree = 517,
			kGetVATSFrontAreaFree = 518,
			kGetIsLockBroken = 519,
			kIsPS3 = 520,
			kIsWin32 = 521,
			kGetVATSRightTargetVisible = 522,
			kGetVATSLeftTargetVisible = 523,
			kGetVATSBackTargetVisible = 524,
			kGetVATSFrontTargetVisible = 525,
			kAttachAshPile = 526,
			kSetCriticalStage = 527,
			kIsInCriticalStage = 528,
			kRemoveFromAllFactions = 529,
			kGetXPForNextLevel = 530,
			kShowLockpickMenuDebug = 531,
			kSLPMD = static_cast<std::underlying_type_t<FunctionID>>(kShowLockpickMenuDebug),
			kForceSave = 532,
			kGetInfamy = 533,
			kGetInfamyViolent = 534,
			kGetInfamyNonViolent = 535,
			kUnusedFunction5 = 536,
			kSin = 537,
			kCos = 538,
			kTan = 539,
			kSqrt = 540,
			kLog = 541,
			kAbs = 542,
			kGetQuestCompleted = 543,
			kGetQC = static_cast<std::underlying_type_t<FunctionID>>(kGetQuestCompleted),
			kUnusedFunction6 = 544,
			kPipBoyRadioOff = 545,
			kAutoDisplayObjectives = 546,
			kIsGoreDisabled = 547,
			kFadeSFX = 548,
			kFSFX = static_cast<std::underlying_type_t<FunctionID>>(kFadeSFX),
			kSetMinimalUse = 549,
			kIsSceneActionComplete = 550,
			kShowQuestStages = 551,
			kSQS = static_cast<std::underlying_type_t<FunctionID>>(kShowQuestStages),
			kGetSpellUsageNum = 552,
			kForceRadioStationUpdate = 553,
			kFRSU = static_cast<std::underlying_type_t<FunctionID>>(kForceRadioStationUpdate),
			kGetActorsInHigh = 554,
			kHasLoaded3D = 555,
			kDisableAllMines = 556,
			kSetLastExtDoorActivated = 557,
			kKillQuestUpdates = 558,
			kKQU = static_cast<std::underlying_type_t<FunctionID>>(kKillQuestUpdates),
			kIsImageSpaceActive = 559,
			kHasKeyword = 560,
			kHasRefType = 561,
			kLocationHasKeyword = 562,
			kLocationHasRefType = 563,
			kCreateEvent = 564,
			kGetIsEditorLocation = 565,
			kGetIsAliasRef = 566,
			kGetIsEditorLocAlias = 567,
			kIsSprinting = 568,
			kIsBlocking = 569,
			kHasEquippedSpell = 570,
			kGetCurrentCastingType = 571,
			kGetCasting = static_cast<std::underlying_type_t<FunctionID>>(kGetCurrentCastingType),
			kGetCurrentDeliveryType = 572,
			kGetDelivery = static_cast<std::underlying_type_t<FunctionID>>(kGetCurrentDeliveryType),
			kEquipSpell = 573,
			kGetAttackState = 574,
			kGetAliasedRef = 575,
			kGetEventData = 576,
			kIsCloserToAThanB = 577,
			kEquipShout = 578,
			kGetEquippedShout = 579,
			kIsBleedingOut = 580,
			kUnlockWord = 581,
			kTeachWord = 582,
			kAddToContainer = 583,
			kGetRelativeAngle = 584,
			kSendAnimEvent = 585,
			kSAE = static_cast<std::underlying_type_t<FunctionID>>(kSendAnimEvent),
			kShout = 586,
			kAddShout = 587,
			kRemoveShout = 588,
			kGetMovementDirection = 589,
			kIsInScene = 590,
			kGetRefTypeDeadCount = 591,
			kGetRefTypeAliveCount = 592,
			kApplyHavokImpulse = 593,
			kGetIsFlying = 594,
			kIsCurrentSpell = 595,
			kSpellHasKeyword = 596,
			kGetEquippedItemType = 597,
			kGetLocationAliasCleared = 598,
			kSetLocationAliasCleared = 599,
			kGetLocAliasRefTypeDeadCount = 600,
			kGetLocAliasRefTypeAliveCount = 601,
			kIsWardState = 602,
			kIsInSameCurrentLocAsRef = 603,
			kIsInSameCurrentLocAsRefAlias = 604,
			kLocAliasIsLocation = 605,
			kGetKeywordDataForLocation = 606,
			kSetKeywordDataForLocation = 607,
			kGetKeywordDataForAlias = 608,
			kSetKeywordDataForAlias = 609,
			kLocAliasHasKeyword = 610,
			kIsNullPackageData = 611,
			kGetNumericPackageData = 612,
			kIsFurnitureAnimType = 613,
			kIsFurnitureEntryType = 614,
			kGetHighestRelationshipRank = 615,
			kGetLowestRelationshipRank = 616,
			kHasAssociationTypeAny = 617,
			kHasFamilyRelationshipAny = 618,
			kGetPathingTargetOffset = 619,
			kGetPathingTargetAngleOffset = 620,
			kGetPathingTargetSpeed = 621,
			kGetPathingTargetSpeedAngle = 622,
			kGetMovementSpeed = 623,
			kGetInContainer = 624,
			kIsLocationLoaded = 625,
			kIsLocAliasLoaded = 626,
			kIsDualCasting = 627,
			kDualCast = 628,
			kGetVMQuestVariable = 629,
			kGetVMScriptVariable = 630,
			kIsEnteringInteractionQuick = 631,
			kIsCasting = 632,
			kGetFlyingState = 633,
			kSetFavorState = 634,
			kIsInFavorState = 635,
			kHasTwoHandedWeaponEquipped = 636,
			kIsExitingInstant = 637,
			kIsInFriendStateWithPlayer = 638,
			kGetWithinDistance = 639,
			kGetActorValuePercent = 640,
			kIsUnique = 641,
			kGetLastBumpDirection = 642,
			kCameraShake = 643,
			kIsInFurnitureState = 644,
			kGetIsInjured = 645,
			kGetIsCrashLandRequest = 646,
			kGetIsHastyLandRequest = 647,
			kUpdateQuestInstanceGlobal = 648,
			kSetAllowFlying = 649,
			kIsLinkedTo = 650,
			kGetKeywordDataForCurrentLocation = 651,
			kGetInSharedCrimeFaction = 652,
			kGetBribeAmount = 653,
			kGetBribeSuccess = 654,
			kGetIntimidateSuccess = 655,
			kGetArrestedState = 656,
			kGetArrestingActor = 657,
			kClearArrestState = 658,
			kEPTemperingItemIsEnchanted = 659,
			kEPTemperingItemHasKeyword = 660,
			kGetReceivedGiftValue = 661,
			kGetGiftGivenValue = 662,
			kForceLocIntoAlias = 663,
			kGetReplacedItemType = 664,
			kSetHorseActor = 665,
			kPlayReferenceEffect = 666,
			kPRE = static_cast<std::underlying_type_t<FunctionID>>(kPlayReferenceEffect),
			kStopReferenceEffect = 667,
			kSRE = static_cast<std::underlying_type_t<FunctionID>>(kStopReferenceEffect),
			kPlayShaderParticleGeometry = 668,
			kPSPG = static_cast<std::underlying_type_t<FunctionID>>(kPlayShaderParticleGeometry),
			kStopShaderParticleGeometry = 669,
			kSSPG = static_cast<std::underlying_type_t<FunctionID>>(kStopShaderParticleGeometry),
			kApplyImageSpaceModifierCrossFade = 670,
			kIModCF = static_cast<std::underlying_type_t<FunctionID>>(kApplyImageSpaceModifierCrossFade),
			kRemoveImageSpaceModifierCrossFade = 671,
			kRIModCF = static_cast<std::underlying_type_t<FunctionID>>(kRemoveImageSpaceModifierCrossFade),
			kIsAttacking = 672,
			kIsPowerAttacking = 673,
			kIsLastHostileActor = 674,
			kGetGraphVariableInt = 675,
			kGetCurrentShoutVariation = 676,
			kPlayImpactEffect = 677,
			kPIE = static_cast<std::underlying_type_t<FunctionID>>(kPlayImpactEffect),
			kShouldAttackKill = 678,
			kSendStealAlarm = 679,
			kSteal = static_cast<std::underlying_type_t<FunctionID>>(kSendStealAlarm),
			kGetActivationHeight = 680,
			kEPModSkillUsage_IsAdvanceSkill = 681,
			kWornHasKeyword = 682,
			kGetPathingCurrentSpeed = 683,
			kGetPathingCurrentSpeedAngle = 684,
			kKnockAreaEffect = 685,
			kKAE = static_cast<std::underlying_type_t<FunctionID>>(kKnockAreaEffect),
			kInterruptCast = 686,
			kAddFormToFormList = 687,
			kRevertFormList = 688,
			kAddFormToLeveledList = 689,
			kRevertLeveledList = 690,
			kEPModSkillUsage_AdvanceObjectHasKeyword = 691,
			kEPModSkillUsage_IsAdvanceAction = 692,
			kEPMagic_SpellHasKeyword = 693,
			kGetNoBleedoutRecovery = 694,
			kSetNoBleedoutRecovery = 695,
			kEPMagic_SpellHasSkill = 696,
			kIsAttackType = 697,
			kIsAllowedToFly = 698,
			kHasMagicEffectKeyword = 699,
			kIsCommandedActor = 700,
			kIsStaggered = 701,
			kIsRecoiling = 702,
			kIsExitingInteractionQuick = 703,
			kIsPathing = 704,
			kGetShouldHelp = 705,
			kHasBoundWeaponEquipped = 706,
			kGetCombatTargetHasKeyword = 707,
			kGCTHK = static_cast<std::underlying_type_t<FunctionID>>(kGetCombatTargetHasKeyword),
			kUpdateLevel = 708,
			kGetCombatGroupMemberCount = 709,
			kGCGMC = static_cast<std::underlying_type_t<FunctionID>>(kGetCombatGroupMemberCount),
			kIsIgnoringCombat = 710,
			kGetLightLevel = 711,
			kGLL = static_cast<std::underlying_type_t<FunctionID>>(kGetLightLevel),
			kSavePCFace = 712,
			kSPF = static_cast<std::underlying_type_t<FunctionID>>(kSavePCFace),
			kSpellHasCastingPerk = 713,
			kIsBeingRidden = 714,
			kIsUndead = 715,
			kGetRealHoursPassed = 716,
			kUnequipAll = 717,
			kIsUnlockedDoor = 718,
			kIsHostileToActor = 719,
			kGetTargetHeight = 720,
			kIsPoison = 721,
			kWornApparelHasKeywordCount = 722,
			kGetItemHealthPercent = 723,
			kEffectWasDualCast = 724,
			kGetKnockStateEnum = 725,
			kDoesNotExist = 726,
			kUnequipItemSlot = 727,
			kMountActor = 728,
			kDismountActor = 729,
			kIsOnFlyingMount = 730,
			kCanFlyHere = 731,
			kIsFlyingMountPatrolQueued = 732,
			kIsFlyingMountFastTravelling = 733,
			kIsOverEncumbered = 734,
			kGetActorWarmth = 735,

			kTotal
		};

		FUNCTION_DATA();
		~FUNCTION_DATA() = default;

		// members
		stl::enumeration<FunctionID, std::uint16_t> function;   // 00
		std::uint16_t                               pad02;      // 02
		std::uint32_t                               pad04;      // 04
		void*                                       params[2];  // 08
	};
	static_assert(sizeof(FUNCTION_DATA) == 0x18);

	struct CONDITION_ITEM_DATA
	{
	public:
		enum class OpCode : std::uint8_t
		{
			kEqualTo,               // ==
			kNotEqualTo,            // !=
			kGreaterThan,           // >
			kGreaterThanOrEqualTo,  // >=
			kLessThan,              // <
			kLessThanOrEqualTo,     // <=
		};

		union GlobalOrFloat
		{
			GlobalOrFloat();
			~GlobalOrFloat() = default;

			TESGlobal* g;
			float      f;
		};
		static_assert(sizeof(GlobalOrFloat) == 0x8);

		struct Flags
		{
		public:
			Flags();
			~Flags() = default;

			// members
			bool   isOR: 1;         // 0 - false == AND, true == OR
			bool   usesAliases: 1;  // 1
			bool   global: 1;       // 2
			bool   usePackData: 1;  // 3
			bool   swapTarget: 1;   // 4
			OpCode opCode: 3;       // 5
		};
		static_assert(sizeof(Flags) == 0x1);

		CONDITION_ITEM_DATA();
		~CONDITION_ITEM_DATA() = default;

		// members
		GlobalOrFloat                                       comparisonValue;  // 08
		ObjectRefHandle                                     runOnRef;         // 10 - kReference
		std::uint32_t                                       dataID;           // 14
		FUNCTION_DATA                                       functionData;     // 18
		Flags                                               flags;            // 30
		stl::enumeration<CONDITIONITEMOBJECT, std::uint8_t> object;           // 31
		std::uint16_t                                       pad32;            // 32
		std::uint32_t                                       pad34;            // 34
	};
	static_assert(sizeof(CONDITION_ITEM_DATA) == 0x30);

	struct ConditionCheckParams
	{
	public:
		constexpr ConditionCheckParams(TESObjectREFR* a_actionRef, TESObjectREFR* a_targetRef) :
			actionRef(a_actionRef),
			targetRef(a_targetRef),
			unk10(nullptr),
			unk18(nullptr),
			unk20(nullptr),
			unk28(nullptr)
		{}

		// members
		TESObjectREFR* actionRef;  // 00
		TESObjectREFR* targetRef;  // 08
		void*          unk10;      // 10
		void*          unk18;      // 18
		void*          unk20;      // 20
		void*          unk28;      // 28
	};
	static_assert(sizeof(ConditionCheckParams) == 0x30);

	struct TESConditionItem  // CTDA
	{
		TESConditionItem();
		~TESConditionItem() = default;

		TES_HEAP_REDEFINE_NEW();

		bool operator()(ConditionCheckParams& a_solution) const;
		bool IsTrue(ConditionCheckParams& a_solution) const;

		// members
		TESConditionItem*   next;  // 00
		CONDITION_ITEM_DATA data;  // 08
	};
	static_assert(sizeof(TESConditionItem) == 0x38);

	class TESCondition
	{
	public:
		TESCondition();
		~TESCondition();

		TES_HEAP_REDEFINE_NEW();

		[[nodiscard]] explicit operator bool() const;

		bool operator()(TESObjectREFR* a_actionRef, TESObjectREFR* a_targetRef) const;
		bool IsTrue(TESObjectREFR* a_actionRef, TESObjectREFR* a_targetRef) const;  // Perk fragments will short circuit

		// members
		TESConditionItem* head;  // 0
	};
	static_assert(sizeof(TESCondition) == 0x8);
}


===============================================
File: include/RE/T/TESContainer.h
===============================================
#pragma once

#include "RE/B/BSContainer.h"
#include "RE/B/BaseFormComponent.h"
#include "RE/C/ContainerItemExtra.h"

#include "RE/M/MemoryManager.h"

namespace RE
{
	class TESBoundObject;

	struct ContainerObject
	{
	public:
		ContainerObject();
		ContainerObject(TESBoundObject* a_obj, std::int32_t a_count);
		ContainerObject(TESBoundObject* a_obj, std::int32_t a_count, TESForm* a_owner);

		~ContainerObject() = default;

		TES_HEAP_REDEFINE_NEW();

		// members
		std::int32_t        count;      // 00 - CNTO~
		std::uint32_t       pad04;      // 04
		TESBoundObject*     obj;        // 08 - ~CNTO
		ContainerItemExtra* itemExtra;  // 10 - COED
	};
	static_assert(sizeof(ContainerObject) == 0x18);

	class TESContainer : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESContainer;

		~TESContainer() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { return; }
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		inline void ForEachContainerObject(std::function<BSContainer::ForEachResult(ContainerObject&)> a_fn) const
		{
			for (std::uint32_t i = 0; i < numContainerObjects; ++i) {
				auto entry = containerObjects[i];
				if (entry) {
					if (a_fn(*entry) == BSContainer::ForEachResult::kStop) {
						break;
					}
				}
			}
		}

		std::optional<ContainerObject*> GetContainerObjectAt(std::uint32_t a_idx) const;
		std::optional<std::uint32_t>    GetContainerObjectIndex(TESBoundObject* a_object, std::int32_t a_count) const;
		bool                            AddObjectToContainer(TESBoundObject* a_object, std::int32_t a_count, TESForm* a_owner);
		bool                            AddObjectsToContainer(std::map<TESBoundObject*, std::int32_t>& a_objects, TESForm* a_owner);
		std::int32_t                    CountObjectsInContainer(TESBoundObject* a_object) const;
		bool                            RemoveObjectFromContainer(TESBoundObject* a_object, std::int32_t a_count);

		// members
		ContainerObject** containerObjects;     // 08
		std::uint32_t     numContainerObjects;  // 10
		std::uint32_t     pad14;                // 14

	private:
		void CopyObjectList(const std::vector<ContainerObject*>& a_copiedData);
	};
	static_assert(sizeof(TESContainer) == 0x18);
}


===============================================
File: include/RE/T/TESContainerChangedEvent.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"

namespace RE
{
	struct TESContainerChangedEvent
	{
	public:
		// members
		FormID          oldContainer;  // 00
		FormID          newContainer;  // 04
		FormID          baseObj;       // 08
		std::int32_t    itemCount;     // 0C
		ObjectRefHandle reference;     // 10
		std::uint16_t   uniqueID;      // 14
		std::uint16_t   pad16;         // 16
	};
	static_assert(sizeof(TESContainerChangedEvent) == 0x18);
}


===============================================
File: include/RE/T/TESCustomPackageData.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/T/TESPackageData.h"

namespace RE
{
	class IPackageData;
	class IProcedureTreeItem;
	class TESPackage;

	struct BGSPackageDataList
	{
		IPackageData** data;      // 00
		std::int8_t*   uids;      // 08
		std::uint16_t  dataSize;  // 10
		std::int8_t    nextUID;   // 12 - XNAM
		std::uint8_t   pad13;     // 13
		std::uint32_t  pad14;     // 14
	};
	static_assert(sizeof(BGSPackageDataList) == 0x18);

	struct BGSPackageDataNameMap : public BSIntrusiveRefCounted
	{
	public:
		struct NameMapData
		{
		public:
			enum class Flag
			{
				kNone = 0,
				kPublic = 1 << 0
			};

			// members
			BSFixedString name;      // 00 - BNAM
			std::int8_t   uid;       // 08 - UNAM
			bool          isPublic;  // 09 - PNAM
			std::uint8_t  pad0A;     // 0A
			std::uint8_t  pad0B;     // 0B
			std::uint32_t pad0C;     // 0C
		};
		static_assert(sizeof(NameMapData) == 0x10);

		// members
		std::uint32_t         pad04;    // 04
		BSTArray<NameMapData> nameMap;  // 08
	};
	static_assert(sizeof(BGSPackageDataNameMap) == 0x20);

	class TESCustomPackageData : public TESPackageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESCustomPackageData;

		~TESCustomPackageData() override;  // 00

		// override (TESPackageData)
		void Copy(TESPackageData* a_package, TESForm* a_form) override;  // 01
		void InitItem(TESForm* a_form) override;                         // 03
		void SaveGame(BGSSaveFormBuffer* a_buf) override;                // 04 - { return; }
		void LoadGame(BGSLoadFormBuffer* a_buf) override;                // 05 - { return; }

		// members
		BGSPackageDataList                     data;                     // 08
		IProcedureTreeItem*                    procedureTree;            // 20
		BSTSmartPointer<BGSPackageDataNameMap> nameMap;                  // 28
		TESPackage*                            templateParent;           // 30
		std::uint16_t                          version;                  // 38
		bool                                   alwaysRecheckConditions;  // 3A
		std::uint8_t                           pad3B;                    // 3B
		std::uint32_t                          pad3C;                    // 3C
	};
	static_assert(sizeof(TESCustomPackageData) == 0x40);
}


===============================================
File: include/RE/T/TESDataHandler.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSingleton.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiTArray.h"
#include "RE/N/NiTList.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSPrimitive;
	class InventoryChanges;
	class NiPoint3;
	class TESFile;
	class TESRegionDataManager;
	class TESRegionList;

	struct TESObjectList
	{
	public:
		// members
		std::uint8_t pad0;  // 0
	};
	static_assert(sizeof(TESObjectList) == 0x1);

	struct TESFileCollection
	{
	public:
		// members
		BSTArray<TESFile*> files;       // 00
		BSTArray<TESFile*> smallFiles;  // 18
	};
	static_assert(sizeof(TESFileCollection) == 0x30);

	class TESDataHandler : public BSTSingletonSDM<TESDataHandler>
	{
	public:
		static TESDataHandler* GetSingleton();

		std::uint32_t LoadScripts();
		TESForm*      LookupForm(FormID a_localFormID, std::string_view a_modName);
		TESForm*      LookupFormRaw(FormID a_rawFormID, std::string_view a_modName);
		template <class T>
		T* LookupForm(FormID a_localFormID, std::string_view a_modName);
		template <class T>
		T*     LookupFormRaw(FormID a_rawFormID, std::string_view a_modName);
		FormID LookupFormID(FormID a_localFormID, std::string_view a_modName);
		FormID LookupFormIDRaw(FormID a_rawFormID, std::string_view a_modName);

		const TESFile*              LookupModByName(std::string_view a_modName);
		std::optional<std::uint8_t> GetModIndex(std::string_view a_modName);

		const TESFile*              LookupLoadedModByName(std::string_view a_modName);
		const TESFile*              LookupLoadedModByIndex(std::uint8_t a_index);
		std::optional<std::uint8_t> GetLoadedModIndex(std::string_view a_modName);

		const TESFile*               LookupLoadedLightModByName(std::string_view a_modName);
		const TESFile*               LookupLoadedLightModByIndex(std::uint16_t a_index);
		std::optional<std::uint16_t> GetLoadedLightModIndex(std::string_view a_modName);

		bool IsGeneratedID(FormID a_formID);

		BSTArray<TESForm*>& GetFormArray(FormType a_formType);
		template <class T>
		BSTArray<T*>& GetFormArray();

		ObjectRefHandle CreateReferenceAtLocation(TESBoundObject* a_base, const NiPoint3& a_location, const NiPoint3& a_rotation, TESObjectCELL* a_targetCell, TESWorldSpace* a_selfWorldSpace, TESObjectREFR* a_alreadyCreatedRef, BGSPrimitive* a_primitive, const ObjectRefHandle& a_linkedRoomRefHandle, bool a_forcePersist, bool a_arg11);

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT \
	bool masterSave;         \
	bool blockSave;          \
	bool saveLoadGame;       \
	bool autoSaving;         \
	bool exportingPlugin;    \
	bool clearingData;       \
	bool hasDesiredFiles;    \
	bool checkingModels;     \
	bool loadingFiles;       \
	bool dontRemoveIDs;

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline RUNTIME_DATA& GetGeometryRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0xDA0, 0x1570);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetGeometryRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0xDA0, 0x1570);
		}

		[[nodiscard]] inline TESFile** GetLoadedMods() noexcept {
			if SKYRIM_REL_CONSTEXPR (REL::Module::IsVR()) {
				return &REL::RelocateMember<TESFile*>(this, 0x0, 0xD78);
			} else {
				return REL::RelocateMember<TESFileCollection>(this, 0xD70, 0).files.data();
			}
		}

		[[nodiscard]] inline const TESFile* const * GetLoadedMods() const noexcept {
			if SKYRIM_REL_CONSTEXPR (REL::Module::IsVR()) {
				return &REL::RelocateMember<const TESFile*>(this, 0x0, 0xD78);
			} else {
				return REL::RelocateMember<const TESFileCollection>(this, 0xD70, 0).files.data();
			}
		}

		[[nodiscard]] inline std::uint8_t GetLoadedModCount() const noexcept {
			if SKYRIM_REL_CONSTEXPR (REL::Module::IsVR()) {
				return static_cast<std::uint8_t>(REL::RelocateMember<std::uint32_t>(this, 0x0, 0xD70));
			} else {
				return static_cast<std::uint8_t>(REL::RelocateMember<const TESFileCollection>(this, 0xD70, 0).files.size());
			}
		}

		[[nodiscard]] inline TESFile** GetLoadedLightMods() noexcept {
			if SKYRIM_REL_CONSTEXPR (REL::Module::IsVR()) {
				return nullptr;
			} else {
				return REL::RelocateMember<TESFileCollection>(this, 0xD70, 0).smallFiles.data();
			}
		}

		[[nodiscard]] inline const TESFile* const * GetLoadedLightMods() const noexcept {
			if SKYRIM_REL_CONSTEXPR (REL::Module::IsVR()) {
				return nullptr;
			} else {
				return REL::RelocateMember<const TESFileCollection>(this, 0xD70, 0).smallFiles.data();
			}
		}

		[[nodiscard]] inline std::uint8_t GetLoadedLightModCount() const noexcept {
			if SKYRIM_REL_CONSTEXPR (REL::Module::IsVR()) {
				return 0;
			} else {
				return static_cast<std::uint8_t>(REL::RelocateMember<const TESFileCollection>(this, 0xD70, 0).smallFiles.size());
			}
		}

		[[nodiscard]] inline TESRegionDataManager* GetRegionDataManager() noexcept {
			return REL::RelocateMember<TESRegionDataManager*>(this, 0xDB0, 0x1580);
		}

		[[nodiscard]] inline const TESRegionDataManager* GetRegionDataManager() const noexcept {
			return REL::RelocateMember<TESRegionDataManager*>(this, 0xDB0, 0x1580);
		}

		[[nodiscard]] inline InventoryChanges* GetMerchantInventory() noexcept {
			return REL::RelocateMember<InventoryChanges*>(this, 0xDB8, 0x1588);
		}

		[[nodiscard]] inline const InventoryChanges* GetMerchantInventory() const noexcept {
			return REL::RelocateMember<InventoryChanges*>(this, 0xDB8, 0x1588);
		}

		// members
		std::uint8_t                      pad001;                                         // 001
		std::uint16_t                     pad002;                                         // 002
		std::uint32_t                     pad004;                                         // 004
		TESObjectList*                    objectList;                                     // 008
		BSTArray<TESForm*>                formArrays[stl::to_underlying(FormType::Max)];  // 010
		TESRegionList*                    regionList;                                     // D00
		NiTPrimitiveArray<TESObjectCELL*> interiorCells;                                  // D08
		NiTPrimitiveArray<BGSAddonNode*>  addonNodes;                                     // D20
		NiTList<TESForm*>                 badForms;                                       // D38
		FormID                            nextID;                                         // D50
		std::uint32_t                     padD54;                                         // D54
		TESFile*                          activeFile;                                     // D58
		BSSimpleList<TESFile*>            files;                                          // D60
#ifndef ENABLE_SKYRIM_VR
		TESFileCollection                 compiledFileCollection;                         // D70
		RUNTIME_DATA_CONTENT
		std::uint8_t                      unkDAA;                                         // DAA
		std::uint8_t                      padDAB;                                         // DAB
		std::uint32_t                     padDAC;                                         // DAC
		TESRegionDataManager*             regionDataManager;                              // DB0
		InventoryChanges*                 merchantInventory;                              // DB8
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		std::uint32_t         loadedModCount;     // D70
		std::uint32_t         pad14;              // D74
		TESFile*              loadedMods[0xFF];   // D78
		RUNTIME_DATA_CONTENT
		std::uint8_t          pad157B[5];         // 157B
		TESRegionDataManager* regionDataManager;  // 1580
		InventoryChanges*     merchantInventory;  // 1588
#endif
	};

	template <class T>
	T* TESDataHandler::LookupForm(FormID a_localFormID, std::string_view a_modName)
	{
		auto form = LookupForm(a_localFormID, a_modName);
		if (!form) {
			return 0;
		}

		return form->Is(T::FORMTYPE) ? static_cast<T*>(form) : 0;
	}

	template <class T>
	T* TESDataHandler::LookupFormRaw(FormID a_rawFormID, std::string_view a_modName)
	{
		auto form = LookupFormRaw(a_rawFormID, a_modName);
		if (!form) {
			return 0;
		}

		return form->Is(T::FORMTYPE) ? static_cast<T*>(form) : 0;
	}

	template <class T>
	BSTArray<T*>& TESDataHandler::GetFormArray()
	{
		return reinterpret_cast<BSTArray<T*>&>(GetFormArray(T::FORMTYPE));
	}
}


===============================================
File: include/RE/T/TESDeathEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESDeathEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> actorDying;   // 00
		NiPointer<TESObjectREFR> actorKiller;  // 08
		bool                     dead;         // 10
		std::uint8_t             pad11{ 0 };   // 11
		std::uint16_t            pad12{ 0 };   // 12
		std::uint32_t            pad14{ 0 };   // 14
	};
	static_assert(sizeof(TESDeathEvent) == 0x18);
}


===============================================
File: include/RE/T/TESDescription.h
===============================================
#pragma once

#include "RE/B/BGSLocalizedStringDL.h"
#include "RE/B/BSString.h"
#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESForm;

	class TESDescription : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESDescription;

		~TESDescription() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		void GetDescription(BSString& a_out, TESForm* a_parent, std::uint32_t a_fieldType = 'CSED');

		// members
		std::uint32_t        fileOffset;       // 08
		BGSLocalizedStringDL descriptionText;  // 0C
	};
	static_assert(sizeof(TESDescription) == 0x10);
}


===============================================
File: include/RE/T/TESEffectShader.h
===============================================
#pragma once

#include "RE/C/Color.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	enum class D3DBLEND;
	enum class D3DBLENDOP;

	enum class D3DCMPFUNC
	{
		kNever = 1,
		kLess,
		kEqual,
		kLessEqual,
		kGreater,
		kNotEqual,
		kGreaterEqual,
		kAlways
	};

	struct EffectShaderData  // DATA
	{
	public:
		enum class Flags
		{
			kNone = 0,
			kDisableTextureShader = 1 << 0,
			kGreyscaleToColor = 1 << 1,
			kGreyscaleToAlpha = 1 << 2,
			kDisableParticleShader = 1 << 3,
			kEdgeColorSubtractive = 1 << 4,
			kSkinOnly = 1 << 5,
			kIgnoreTexAlpha = 1 << 6,
			kFillTexProjectedUV = 1 << 7,
			kIgnoreBaseGeomTexAlpha = 1 << 8,
			kLighting = 1 << 9,
			kIgnoreWeapons = 1 << 10,
			kAlpha = 1 << 11,
			kPreferDismemberedLimb = 1 << 12,
			kParticleAnimated = 1 << 15,
			kParticleGreyscaleColor = 1 << 16,
			kParticleGreyscaleAlpha = 1 << 17,
			kUseBloodGeometry = 1 << 24
		};

		// members
		std::uint32_t unk00;  // 000

		D3DBLEND   membraneShaderSourceBlendMode;  // 004
		D3DBLENDOP membraneShaderBlendOperation;   // 008
		D3DCMPFUNC membraneShaderZTestFunction;    // 00C

		Color fillTextureEffectColorKey1;               // 010
		float fillTextureEffectAlphaFadeInTime;         // 014
		float fillTextureEffectFullAlphaTime;           // 018
		float fillTextureEffectAlphaFadeOutTime;        // 01C
		float fillTextureEffectPersistentAlphaRatio;    // 020
		float fillTextureEffectAlphaPulseAmplitude;     // 024
		float fillTextureEffectAlphaPulseFrequency;     // 028
		float fillTextureEffectTextureAnimationSpeedU;  // 02C
		float fillTextureEffectTextureAnimationSpeedV;  // 030

		float edgeEffectFallOff;               // 034
		Color edgeEffectColor;                 // 038
		float edgeEffectAlphaFadeInTime;       // 03C
		float edgeEffectFullAlphaTime;         // 040
		float edgeEffectAlphaFadeOutTime;      // 044
		float edgeEffectPersistentAlphaRatio;  // 048
		float edgeEffectAlphaPulseAmplitude;   // 04C
		float edgeEffectAlphaPulseFrequency;   // 050

		float fillTextureEffectFullAlphaRatio;  // 054

		float edgeEffectFullAlphaRatio;  // 058

		D3DBLEND membraneShaderDestBlendMode;  // 05C

		D3DBLEND   particleShaderSourceBlendMode;            // 060
		D3DBLENDOP particleShaderBlendOperation;             // 064
		D3DCMPFUNC particleShaderZTestOperation;             // 068
		D3DBLEND   particleShaderDestBlendMode;              // 06C
		float      particleShaderParticleBirthRampUpTime;    // 070
		float      particleShaderFullParticleBirthTime;      // 074
		float      particleShaderParticleBirthRampDownTime;  // 078
		float      particleShaderFullParticleBirthRatio;     // 07C
		float      particleShaderPersistantParticleCount;    // 080
		float      particleShaderParticleLifetime;           // 084
		float      particleShaderParticleLifetimeVariance;   // 088
		float      particleShaderInitialSpeedAlongNormal;    // 08C
		float      particleShaderAccelerationAlongNormal;    // 090
		float      particleShaderInitialVelocity1;           // 094
		float      particleShaderInitialVelocity2;           // 098
		float      particleShaderInitialVelocity3;           // 09C
		float      particleShaderAcceleration1;              // 0A0
		float      particleShaderAcceleration2;              // 0A4
		float      particleShaderAcceleration3;              // 0A8
		float      particleShaderScaleKey1;                  // 0AC
		float      particleShaderScaleKey2;                  // 0B0
		float      particleShaderScaleKey1Time;              // 0B4
		float      particleShaderScaleKey2Time;              // 0B8

		Color colorKey1;              // 0BC
		Color colorKey2;              // 0C0
		Color colorKey3;              // 0C4
		float colorKey1ColorAlpha;    // 0C8
		float colorKey2ColorAlpha;    // 0CC
		float colorKey3ColorAlpha;    // 0D0
		float colorKey1ColorKeyTime;  // 0D4
		float colorKey2ColorKeyTime;  // 0D8
		float colorKey3ColorKeyTime;  // 0DC

		float particleShaderInitialSpeedAlongNormalVariance;  // 0E0
		float particleShaderInitialRotation;                  // 0E4
		float particleShaderInitialRotationVariance;          // 0E8
		float particleShaderRotationSpeed;                    // 0EC
		float particleShaderRotationSpeedVariance;            // 0F0

		std::uint32_t pad0D4;  // 0F4

		BGSDebris* addonModels;  // 0F8

		float holesStartTime;  // 100
		float holesEndTime;    // 104
		float holesStartVal;   // 108
		float holesEndVal;     // 10C

		float edgeWidthAlphaUnits;  // 110
		Color edgeColor;            // 114

		float explosionWindSpeed;  // 118

		float textureCountU;  // 11C
		float textureCountV;  // 120

		float addonModelsFadeInTime;    // 124
		float addonModelsFadeOutTime;   // 128
		float addonModelsScaleStart;    // 12C
		float addonModelsScaleEnd;      // 130
		float addonModelsScaleInTime;   // 134
		float addonModelsScaleOutTime;  // 138

		std::uint32_t pad13C;  // 13C

		BGSSoundDescriptorForm* ambientSound;  // 140

		Color fillTextureEffectColorKey2;                        // 148
		Color fillTextureEffectColorKey3;                        // 14C
		float fillTextureEffectColorKeyScaleTimeColorKey1Scale;  // 150
		float fillTextureEffectColorKeyScaleTimeColorKey2Scale;  // 154
		float fillTextureEffectColorKeyScaleTimeColorKey3Scale;  // 158
		float fillTextureEffectColorKeyScaleTimeColorKey1Time;   // 15C
		float fillTextureEffectColorKeyScaleTimeColorKey2Time;   // 160
		float fillTextureEffectColorKeyScaleTimeColorKey3Time;   // 164

		float colorScale;  // 168

		float birthPositionOffset;          // 16C
		float birthPositionOffsetVariance;  // 170

		float particleShaderAnimatedStartFrame;          // 174
		float particleShaderAnimatedStartFrameVariance;  // 178
		float particleShaderAnimatedEndFrame;            // 17C
		float particleShaderAnimatedLoopStartFrame;      // 180
		float particleShaderAnimatedLoopStartVariance;   // 184
		float particleShaderAnimatedFrameCount;          // 188
		float particleShaderAnimatedFrameCountVariance;  // 18C

		stl::enumeration<Flags, std::uint32_t> flags;  // 190

		float fillTextureEffectTextureScaleU;  // 194
		float fillTextureEffectTextureScaleV;  // 198

		std::uint32_t sceneGraphEmitDepthLimit;  // 19C - unused
	};
	static_assert(sizeof(EffectShaderData) == 0x1A0);

	class TESEffectShader : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESEffectShader;
		inline static constexpr auto VTABLE = VTABLE_TESEffectShader;
		inline static constexpr auto FORMTYPE = FormType::EffectShader;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESEffectShader() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		EffectShaderData data;                    // 020 - DATA
		TESTexture       fillTexture;             // 1C0 - ICON
		TESTexture       particleShaderTexture;   // 1D0 - ICO2
		TESTexture       holesTexture;            // 1E0 - NAM7
		TESTexture       membranePaletteTexture;  // 1F0 - NAM8
		TESTexture       particlePaletteTexture;  // 200 - NAM9
		void*            unk210;                  // 210 - smart ptr
		void*            unk218;                  // 218 - smart ptr
	};
	static_assert(sizeof(TESEffectShader) == 0x220);
}


===============================================
File: include/RE/T/TESEnchantableForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/M/MagicSystem.h"

namespace RE
{
	class EnchantmentItem;

	class TESEnchantableForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESEnchantableForm;

		~TESEnchantableForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual MagicSystem::CastingType GetCastingType() const;  // 04 - { return castingType; }

		// members
		EnchantmentItem*                                          formEnchanting;       // 08 - EITM
		stl::enumeration<MagicSystem::CastingType, std::uint16_t> castingType;          // 10
		std::uint16_t                                             amountofEnchantment;  // 12 - EAMT
		std::uint32_t                                             pad14;                // 14
	};
	static_assert(sizeof(TESEnchantableForm) == 0x18);
}


===============================================
File: include/RE/T/TESEnterBleedoutEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESEnterBleedoutEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> actor;  // 00
	};
	static_assert(sizeof(TESEnterBleedoutEvent) == 0x8);
}


===============================================
File: include/RE/T/TESEquipEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESEquipEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> actor;         // 00
		FormID                   baseObject;    // 08
		FormID                   originalRefr;  // 0C
		std::uint16_t            uniqueID;      // 10
		bool                     equipped;      // 12
		std::uint8_t             pad13;         // 13
		std::uint32_t            pad14;         // 14
	};
	static_assert(sizeof(TESEquipEvent) == 0x18);
}


===============================================
File: include/RE/T/TESEyes.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	class TESEyes :
		public TESForm,      // 00
		public TESFullName,  // 20
		public TESTexture    // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESEyes;
		inline static constexpr auto VTABLE = VTABLE_TESEyes;
		inline static constexpr auto FORMTYPE = FormType::Eyes;

		enum class Flag
		{
			kNone = 0,
			kPlayable = 1 << 0,
			kNotMale = 1 << 1,
			kNotFemale = 1 << 2
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESEyes() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04 - { flags = 0; }
		bool Load(TESFile* a_mod) override;  // 06 - { return true; }

		// members
		stl::enumeration<Flag, std::uint8_t> flags;  // 40 - DATA
		std::uint8_t                         pad41;  // 41
		std::uint16_t                        pad42;  // 42
		std::uint32_t                        pad44;  // 44
	};
	static_assert(sizeof(TESEyes) == 0x48);
}


===============================================
File: include/RE/T/TESFaction.h
===============================================
#pragma once

#include "RE/A/AITimeStamp.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTList.h"
#include "RE/F/FightReactions.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESReactionForm.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	class TESCondition;
	class PackageLocation;

	struct FACTION_DATA
	{
		enum Flag : std::uint32_t
		{
			kNone = 0,
			kHiddenFromNPC = 1 << 0,
			kSpecialCombat = 1 << 1,
			kPlayerIsExpelled = 1 << 2,
			kPlayerIsEnemy = 1 << 3,
			kTrackCrime = 1 << 6,
			kIgnoresCrimes_Murder = 1 << 7,
			kIgnoresCrimes_Assult = 1 << 8,
			kIgnoresCrimes_Stealing = 1 << 9,
			kIngoresCrimes_Trespass = 1 << 10,
			kDoNotReportCrimesAgainstMembers = 1 << 11,
			kCrimeGold_UseDefaults = 1 << 12,
			kIgnoresCrimes_Pickpocket = 1 << 13,
			kVendor = 1 << 14,
			kCanBeOwner = 1 << 15,
			kIgnoresCrimes_Werewolf = 1 << 16
		};

		Flag flags;  // 0
	};
	static_assert(sizeof(FACTION_DATA) == 0x4);

	struct FACTION_CRIME_DATA_VALUES  // CRVA
	{
	public:
		// members
		bool          arrest;               // 00
		bool          attackOnSight;        // 01
		std::uint16_t murderCrimeGold;      // 02
		std::uint16_t assaultCrimeGold;     // 04
		std::uint16_t trespassCrimeGold;    // 06
		std::uint16_t pickpocketCrimeGold;  // 08
		std::uint16_t pad0A;                // 0A
		float         stealCrimeGoldMult;   // 0C
		std::uint16_t escapeCrimeGold;      // 10
		std::uint16_t werewolfCrimeGold;    // 12
	};
	static_assert(sizeof(FACTION_CRIME_DATA_VALUES) == 0x14);

	struct FACTION_CRIME_DATA
	{
	public:
		// members
		TESObjectREFR*            factionJailMarker;                // 00 - JAIL
		TESObjectREFR*            factionWaitMarker;                // 08 - WAIT
		TESObjectREFR*            factionStolenContainer;           // 10 - STOL
		TESObjectREFR*            factionPlayerInventoryContainer;  // 18 - PLCN
		BGSListForm*              crimeGroup;                       // 20 - CRGR
		BGSOutfit*                jailOutfit;                       // 28 - JOUT
		FACTION_CRIME_DATA_VALUES crimevalues;                      // 30 - CRVA
		std::uint32_t             pad44;                            // 44
	};
	static_assert(sizeof(FACTION_CRIME_DATA) == 0x48);

	struct FACTION_VENDOR_DATA_VALUES  // VENV
	{
	public:
		// members
		std::uint16_t startHour;       // 0
		std::uint16_t endHour;         // 2
		std::uint32_t locationRadius;  // 4
		bool          buysStolen;      // 8
		bool          notBuySell;      // 9
		bool          buysNonStolen;   // A
		std::uint8_t  padB;            // B
	};
	static_assert(sizeof(FACTION_VENDOR_DATA_VALUES) == 0xC);

	struct FACTION_VENDOR_DATA  // VENV
	{
	public:
		// members
		FACTION_VENDOR_DATA_VALUES vendorValues;       // 00
		std::uint32_t              pad0C;              // 0C
		PackageLocation*           vendorLocation;     // 10 - PLVD
		TESCondition*              vendorConditions;   // 18
		BGSListForm*               vendorSellBuyList;  // 20 - VEND
		TESObjectREFR*             merchantContainer;  // 28 - VENC
		std::uint32_t              lastDayReset;       // 30
		std::uint32_t              pad34;              // 34
	};
	static_assert(sizeof(FACTION_VENDOR_DATA) == 0x38);

	struct RANK_DATA
	{
	public:
		// members
		BSFixedString maleRankTitle;    // 00 - MNAM
		BSFixedString femaleRankTitle;  // 08 - FNAM
		TESTexture    textureInsignia;  // 10 - INAM - unused
	};
	static_assert(sizeof(RANK_DATA) == 0x20);

	class TESFaction :
		public TESForm,         // 000
		public TESFullName,     // 020
		public TESReactionForm  // 030
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESFaction;
		inline static constexpr auto VTABLE = VTABLE_TESFaction;
		inline static constexpr auto FORMTYPE = FormType::Faction;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kFactionFlags = 1 << 1,
				kFactionReactions = 1 << 2,
				kFactionCrimeCounts = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESFaction() override;  // 00

		// override (TESForm)
		void InitializeData() override;                    // 04
		void ClearData() override;                         // 05
		bool Load(TESFile* a_mod) override;                // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void InitItemImpl() override;                      // 13

		[[nodiscard]] bool         CanBeOwner() const;
		[[nodiscard]] bool         CanPayCrimeGold() const;
		[[nodiscard]] std::int32_t GetCrimeGold() const;
		[[nodiscard]] std::int32_t GetCrimeGoldNonViolent() const;
		[[nodiscard]] std::int32_t GetCrimeGoldViolent() const;
		[[nodiscard]] std::int32_t GetInfamy() const;
		[[nodiscard]] std::int32_t GetInfamyNonViolent() const;
		[[nodiscard]] std::int32_t GetInfamyViolent() const;
		[[nodiscard]] std::int32_t GetStolenItemValueCrime() const;
		[[nodiscard]] std::int32_t GetStolenItemValueNoCrime() const;
		[[nodiscard]] bool         HasSpecialCombatState() const;
		[[nodiscard]] bool         HasStealMultiplier() const;
		[[nodiscard]] bool         HiddenFromNPC() const;
		[[nodiscard]] bool         IgnoresAssault() const;
		[[nodiscard]] bool         IgnoresMurder() const;
		[[nodiscard]] bool         IgnoresPickpocket() const;
		[[nodiscard]] bool         IgnoresStealing() const;
		[[nodiscard]] bool         IgnoresTrespass() const;
		[[nodiscard]] bool         IgnoresWerewolf() const;
		bool                       IsFactionInCrimeGroup(const TESFaction* a_other) const;
		[[nodiscard]] bool         IsPlayerEnemy() const;
		[[nodiscard]] bool         IsPlayerExpelled() const;
		[[nodiscard]] bool         IsVendor() const;
		void                       ModCrimeGold(std::int32_t a_amount, bool a_violent);
		bool                       OffersServices() const;
		void                       PlayerPayCrimeGold(bool a_removeStolenItems = true, bool a_goToJail = true);
		[[nodiscard]] bool         ReportsCrimesAgainstMembers() const;
		void                       SendPlayerToJail(bool a_removeInventory = true, bool a_realJail = true);
		void                       SetAlly(TESFaction* a_other, bool a_selfIsFriendToOther = false, bool a_otherIsFriendToSelf = false);
		void                       SetCrimeGold(std::int32_t a_gold);
		void                       SetCrimeGoldViolent(std::int32_t a_gold);
		void                       SetEnemy(TESFaction* a_other, bool a_selfIsNeutralToOther = false, bool a_otherIsNeutralToSelf = false);
		void                       SetFactionFightReaction(TESFaction* a_faction, FIGHT_REACTION a_fightReaction);
		[[nodiscard]] bool         TracksCrimes() const;
		[[nodiscard]] bool         UsesCrimeGoldDefaults() const;

		// members
		BSTHashMap<const TESNPC*, std::uint32_t>* crimeGoldMap;           // 050
		FACTION_DATA                              data;                   // 058 - DATA
		std::uint32_t                             pad05C;                 // 05C
		FACTION_CRIME_DATA                        crimeData;              // 060
		FACTION_VENDOR_DATA                       vendorData;             // 0A8
		BSSimpleList<RANK_DATA*>                  rankData;               // 0E0
		std::int32_t                              majorCrime;             // 0F0
		std::int32_t                              minorCrime;             // 0F4
		AITimeStamp                               resistArrestTimeStamp;  // 0F8
		float                                     pcEnemyFlagTimeStamp;   // 0FC - current game time in hours
	};
	static_assert(sizeof(TESFaction) == 0x100);
}


===============================================
File: include/RE/T/TESFastTravelEndEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESFastTravelEndEvent
	{
	public:
		// members
		float         fastTravelEndHours;  // 00
		std::uint32_t pad04;               // 04
	};
	static_assert(sizeof(TESFastTravelEndEvent) == 0x08);
}


===============================================
File: include/RE/T/TESFile.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTList.h"
#include "RE/F/FORM.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiFile.h"

namespace RE
{
	class BSFile;
	struct TESBitArrayFile;

	class TESFile
	{
	public:
		enum class Error
		{
			kNone = 0,
			kNotFound = 1,
			kNoFile = 2,
			kNoForm = 3,
			kNoChunk = 4,
			kNoID = 5,
			kBadFile = 6,
			kBadID = 7,
			kFormOpen = 8,
			kFileOpen = 9,
			kWriteFailure = 10,
			kInvalidFile = 11,
			kFileInUse = 12,
			kCreateFailure = 13
		};

		enum class RecordFlag
		{
			kNone = 0,
			kMaster = 1 << 0,
			kAltered = 1 << 1,
			kChecked = 1 << 2,
			kActive = 1 << 3,
			kOptimizedFile = 1 << 4,
			kTempIDOwner = 1 << 5,
			kDelocalized = 1 << 7,
			kPrecalcDataOnly = 1 << 8,
			kSmallFile = 1 << 9
		};

		bool                                  CloseTES(bool a_force);
		TESFile*                              Duplicate(std::uint32_t a_cacheSize = 0x4000);
		[[nodiscard]] std::uint32_t           GetCombinedIndex() const noexcept { return static_cast<std::uint32_t>(compileIndex + smallFileCompileIndex); }
		[[nodiscard]] std::uint8_t            GetCompileIndex() const noexcept { return compileIndex; }
		std::uint32_t                         GetCurrentSubRecordType();
		[[nodiscard]] constexpr std::uint32_t GetCurrentSubRecordSize() const noexcept { return actualChunkSize; }
		[[nodiscard]] constexpr std::uint32_t GetCurrentChunkID() const noexcept { return currentchunkID; }
		[[nodiscard]] std::string_view        GetFilename() const noexcept { return { fileName }; }
		FormType                              GetFormType();
		[[nodiscard]] std::uint16_t           GetSmallFileCompileIndex() const noexcept { return smallFileCompileIndex; }
		[[nodiscard]] constexpr std::uint32_t GetPartialIndex() const noexcept { return !IsLight() ? compileIndex : (0xFE000 | smallFileCompileIndex); };
		[[nodiscard]] bool                    IsFormInMod(FormID a_formID) const;
		[[nodiscard]] constexpr bool          IsLight() const noexcept { return recordFlags.all(RecordFlag::kSmallFile); };
		[[nodiscard]] constexpr bool          IsLocalized() const noexcept { return recordFlags.all(RecordFlag::kDelocalized); }
		bool                                  OpenTES(NiFile::OpenMode a_accessMode, bool a_lock);
		bool                                  ReadData(void* a_buf, std::uint32_t a_size);
		bool                                  Seek(std::uint32_t a_offset);
		bool                                  SeekNextForm(bool a_skipIgnored);
		bool                                  SeekNextSubrecord();

		// members
		stl::enumeration<Error, std::uint32_t>      lastError;                        // 000
		std::uint32_t                               pad004;                           // 004
		TESFile*                                    threadSafeParent;                 // 008
		void*                                       threadSafeFileMap;                // 010 - NiTPointerMap<std::uint32_t, TESFile*>* - size == 0x20
		std::uint64_t                               unk018;                           // 018
		std::uint64_t                               unk020;                           // 020
		std::uint8_t                                unk028;                           // 028
		std::uint8_t                                unk029;                           // 029
		std::uint16_t                               pad02A;                           // 02A
		std::uint32_t                               pad02C;                           // 02C
		BSFile*                                     lockedFile;                       // 030
		BSFile*                                     file;                             // 038
		TESBitArrayFile*                            formUserDataBitArray;             // 040
		TESBitArrayFile*                            formVersionBitArray;              // 048
		TESBitArrayFile*                            formIDBitArray;                   // 050
		char                                        fileName[MAX_PATH];               // 058
		char                                        path[MAX_PATH];                   // 15C
		char*                                       buffer;                           // 260
		std::uint32_t                               bufferAllocSize;                  // 268
		std::uint32_t                               firstCellOffset;                  // 26C
		std::uint32_t                               currCellOffset;                   // 270
		std::uint32_t                               unk274;                           // 274
		TESObjectCELL*                              currCell;                         // 278
		std::uint32_t                               currRefOffset;                    // 280
		FORM                                        currentform;                      // 284
		std::uint32_t                               currentchunkID;                   // 29C
		std::uint32_t                               actualChunkSize;                  // 2A0
		std::uint32_t                               filesize;                         // 2A4
		std::uint32_t                               fileOffset;                       // 2A8
		std::uint32_t                               formoffset;                       // 2AC
		std::uint32_t                               chunkoffset;                      // 2B0
		FORM                                        saveform;                         // 2B4
		std::uint32_t                               saveFormOffset;                   // 2CC
		std::uint64_t                               saveChunkOffset;                  // 2D0
		std::uint64_t                               unk2D8;                           // 2D8
		std::uint64_t                               unk2E0;                           // 2E0
		std::uint8_t                                unk2E8;                           // 2E8
		bool                                        isBigEndian;                      // 2E9
		std::uint8_t                                unk2EA;                           // 2EA
		std::uint8_t                                pad2EB;                           // 2EB
		WinAPI::WIN32_FIND_DATAA                    fileData;                         // 2EC
		float                                       unk42C;                           // 42C
		std::uint32_t                               unk430;                           // 430
		std::uint32_t                               flags;                            // 434
		stl::enumeration<RecordFlag, std::uint32_t> recordFlags;                      // 438
		std::uint32_t                               pad43C;                           // 43C
		BSSimpleList<const char*>                   masters;                          // 440
		BSSimpleList<std::uint64_t*>                mastersData;                      // 450
		std::uint32_t                               masterCount;                      // 460
		std::uint32_t                               pad464;                           // 464
		TESFile**                                   masterPtrs;                       // 468
		WinAPI::FILETIME                            deletedFormTime;                  // 470
		std::uint8_t                                compileIndex;                     // 478
		std::uint8_t                                pad479;                           // 479
		std::uint16_t                               smallFileCompileIndex;            // 47A
		std::uint32_t                               pad47C;                           // 47C
		BSString                                    createdBy;                        // 480
		BSString                                    summary;                          // 490
		char*                                       decompressedFormBuffer;           // 4A0
		std::uint32_t                               decompressedFormBufferSize;       // 4A8
		std::uint32_t                               pad4AC;                           // 4AC
		void*                                       reservedDecompressionBuffer;      // 4B0
		std::uint32_t                               reservedDecompressionBufferSize;  // 4B8
		std::uint32_t                               pad4BC;                           // 4BC
		void*                                       unk4C0;                           // 4C0
	};
	static_assert(sizeof(TESFile) == 0x4C8);
}


===============================================
File: include/RE/T/TESFlora.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESObjectACTI.h"
#include "RE/T/TESProduceForm.h"

namespace RE
{
	class TESFlora :
		public TESObjectACTI,  // 00
		public TESProduceForm  // C8
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESFlora;
		inline static constexpr auto VTABLE = VTABLE_TESFlora;
		inline static constexpr auto FORMTYPE = FormType::Flora;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESFlora() override;  // 00

		// override (TESObjectACTI)
		bool Load(TESFile* a_mod) override;                                                                                                                            // 06
		void InitItemImpl() override;                                                                                                                                  // 13
		bool Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		bool GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C
		bool CalculateDoFavor(Actor* a_activator, bool a_arg2, TESObjectREFR* a_toActivate, float a_arg3) override;                                                    // 4D
	};
	static_assert(sizeof(TESFlora) == 0xE8);
}


===============================================
File: include/RE/T/TESForm.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BaseFormComponent.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESFile.h"

namespace RE
{
	class BGSLoadFormBuffer;
	class BGSSaveFormBuffer;
	class TESBoundObject;
	class TESFile;
	struct FORM;
	struct FORM_GROUP;

	class TESFileArray : public BSStaticArray<TESFile*>
	{
	public:
	};
	static_assert(sizeof(TESFileArray) == 0x10);

	class TESFileContainer
	{
	public:
		// members
		TESFileArray* array;  // 0
	};
	static_assert(sizeof(TESFileContainer) == 0x8);

	class TESForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESForm;
		inline static constexpr auto FORMTYPE = FormType::None;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kCreated = 0,
				kFlags = 1 << 0
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDestructible = 1 << 0,
				kMaster = 1 << 0,
				kUnlocked = 1 << 0,

				kAltered = 1 << 1,
				kPlayable = 1 << 2,
				kInitialized = 1 << 3,
				kNonOccluder = 1 << 4,
				kDeleted = 1 << 5,

				kBorderRegion = 1 << 6,
				kGlobalConstant = 1 << 6,
				kHasSpokenFlag = 1 << 6,
				kKnown = 1 << 6,
				kInPlaceableWater = 1 << 6,

				kFireOff = 1 << 7,
				kMustUpdate = 1 << 8,
				kOnLocalMap = 1 << 9,
				kPersistent = 1 << 10,

				kDisabled = 1 << 11,
				kUsedAsMovingPlatform = 1 << 11,

				kIgnored = 1 << 12,

				kEmpty = 1 << 13,
				kResetDestruction = 1 << 13,

				kTemporary = 1 << 14,
				kMustBeVisibleDistant = 1 << 15,
				kRandomAnim = 1 << 16,
				kDangerous = 1 << 17,
				kHasCurrents = 1 << 19,
				kIgnoreFriendlyHits = 1 << 20,
				kStillLoading = 1 << 21,
				kFormRetainsID = 1 << 22,
				kDestroyed = 1 << 23,

				kUnk24 = 1 << 24,

				kNoAIAcquire = 1 << 25,
				kObstacle = 1 << 25,

				kVATSTargetOverride = 1 << 26,
				kDisableFade = 1 << 27,

				kReflectedByAutoWater = 1 << 28,
				kShowOnWorldMap = 1 << 28,

				kChildCanUse = 1 << 29
			};
		};

		enum class InGameFormFlag
		{
			kNone = 0,
			kWantsDelete = 1 << 0,
			kForcedPersistent = 1 << 1,
			kNoFavorAllowed = 1 << 4,
			kIsSkyObject = 1 << 5,
			kRefOriginalPersistent = 1 << 6,
			kRefPermanentlyDeleted = 1 << 7
		};

		~TESForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { return; }
		void ClearDataComponent() override;                     // 02 - { SetEditorID(""); }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		virtual void                               InitializeData();                                                                                                                                // 04 - { return; }
		virtual void                               ClearData();                                                                                                                                     // 05 - { return; }
		virtual bool                               Load(TESFile* a_mod);                                                                                                                            // 06 - { return true; }
		virtual bool                               LoadPartial(TESFile* a_mod);                                                                                                                     // 07 - { return true; }
		virtual bool                               LoadEdit(TESFile* a_mod);                                                                                                                        // 08 - { return Load(a_mod); }
		virtual TESForm*                           CreateDuplicateForm(bool a_createEditorID, void* a_arg2);                                                                                        // 09
		virtual bool                               AddChange(std::uint32_t a_changeFlags);                                                                                                          // 0A
		virtual void                               RemoveChange(std::uint32_t a_changeFlags);                                                                                                       // 0B
		virtual bool                               FindInFileFast(TESFile* a_mod);                                                                                                                  // 0C - { return false; }
		virtual bool                               CheckSaveGame(BGSSaveFormBuffer* a_buf);                                                                                                         // 0D - { return true; }
		virtual void                               SaveGame(BGSSaveFormBuffer* a_buf);                                                                                                              // 0E
		virtual void                               LoadGame(BGSLoadFormBuffer* a_buf);                                                                                                              // 0F
		virtual void                               InitLoadGame(BGSLoadFormBuffer* a_buf);                                                                                                          // 10 - { return; }
		virtual void                               FinishLoadGame(BGSLoadFormBuffer* a_buf);                                                                                                        // 11 - { return; }
		virtual void                               Revert(BGSLoadFormBuffer* a_buf);                                                                                                                // 12 - { return; }
		virtual void                               InitItemImpl();                                                                                                                                  // 13 - { return; }
		[[nodiscard]] virtual TESFile*             GetDescriptionOwnerFile() const;                                                                                                                 // 14 - returns the file that last modified this form
		[[nodiscard]] virtual FormType             GetSavedFormType() const;                                                                                                                        // 15 - { return formType; }
		virtual void                               GetFormDetailedString(char* a_buf, std::uint32_t a_bufLen);                                                                                      // 16 - { return std::sprintf_s(a_buf, a_bufLen, "%s Form '%s' (%08X)", g_formStrings[3 * formID], "", formID); }
		[[nodiscard]] virtual bool                 GetKnown() const;                                                                                                                                // 17 - { return (flags >> 6 ) & 1; }
		[[nodiscard]] virtual bool                 GetRandomAnim() const;                                                                                                                           // 18 - { return (flags >> 16) & 1; }
		[[nodiscard]] virtual bool                 GetPlayable() const;                                                                                                                             // 19 - { return (flags >> 2) & 1; }
		[[nodiscard]] virtual bool                 IsHeadingMarker() const;                                                                                                                         // 1A - { return false; }
		[[nodiscard]] virtual bool                 GetDangerous() const;                                                                                                                            // 1B - { return (flags >> 17) & 1; }
		[[nodiscard]] virtual bool                 QHasCurrents() const;                                                                                                                            // 1C - { return (flags >> 19) & 1; }
		[[nodiscard]] virtual bool                 GetObstacle() const;                                                                                                                             // 1D - { return (flags >> 25) & 1; }
		[[nodiscard]] virtual bool                 QIsLODLandObject() const;                                                                                                                        // 1E - { return false; }
		[[nodiscard]] virtual bool                 GetOnLocalMap() const;                                                                                                                           // 1F - { return (flags >> 9) & 1; }
		[[nodiscard]] virtual bool                 GetMustUpdate() const;                                                                                                                           // 20 - { return (flags >> 8) & 1; }
		virtual void                               SetOnLocalMap(bool a_set);                                                                                                                       // 21 - { if (a_set) flags &= 0xFFFFFDFF; else flags |= 0x200; }
		[[nodiscard]] virtual bool                 GetIgnoredBySandbox() const;                                                                                                                     // 22 - { return false; }
		virtual void                               SetDelete(bool a_set);                                                                                                                           // 23 - { bool result = (flags >> 5) & 1; if (result != a_set) { if (a_set) flags |= 0x20; else flags &= 0xFFFFFFDF; AddChange(1); return result; }
		virtual void                               SetAltered(bool a_set);                                                                                                                          // 24
		virtual void                               SaveObjectBound();                                                                                                                               // 25 - { return; }
		virtual void                               LoadObjectBound(TESFile* a_mod);                                                                                                                 // 26 - { return; }
		[[nodiscard]] virtual bool                 IsBoundObject() const;                                                                                                                           // 27 - { return false; }
		[[nodiscard]] virtual bool                 IsObject() const;                                                                                                                                // 28 - { return false; }
		[[nodiscard]] virtual bool                 IsMagicItem() const;                                                                                                                             // 29 - { return false; }
		[[nodiscard]] virtual bool                 IsWater() const;                                                                                                                                 // 2A - { return false; }
		virtual TESObjectREFR*                     AsReference1();                                                                                                                                  // 2B - { return 0; }
		[[nodiscard]] virtual const TESObjectREFR* AsReference2() const;                                                                                                                            // 2C - { return 0; }
		[[nodiscard]] virtual std::uint32_t        GetRefCount() const;                                                                                                                             // 2D - { return 0; }
		[[nodiscard]] virtual const char*          GetTextForParsedSubTag(const BSFixedString& a_tag) const;                                                                                        // 2E
		virtual void                               Copy(TESForm* a_srcForm);                                                                                                                        // 2F - { return; }
		virtual bool                               BelongsInGroup(FORM* a_form, bool a_allowParentGroups, bool a_currentOnly);                                                                      // 30
		virtual void                               CreateGroupData(FORM* a_form, FORM_GROUP* a_group);                                                                                              // 31
		[[nodiscard]] virtual const char*          GetFormEditorID() const;                                                                                                                         // 32 - { return ""; }
		virtual bool                               SetFormEditorID(const char* a_str);                                                                                                              // 33 - { return true; }
		virtual bool                               IsParentForm();                                                                                                                                  // 34 - { return false; }
		virtual bool                               IsParentFormTree();                                                                                                                              // 35 - { return false; }
		virtual bool                               IsFormTypeChild(FormType a_type);                                                                                                                // 36 - { return false; }
		virtual bool                               Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount);  // 37 - { return false; }
		virtual void                               SetFormID(FormID a_id, bool a_updateFile);                                                                                                       // 38
		[[nodiscard]] virtual const char*          GetObjectTypeName() const;                                                                                                                       // 39 - { return ""; }
		[[nodiscard]] virtual bool                 QAvailableInGame() const;                                                                                                                        // 3A - { return true; }

		static void AddCompileIndex(FormID& a_id, TESFile* a_file)
		{
			using func_t = decltype(&TESForm::AddCompileIndex);
			REL::Relocation<func_t> func{ RELOCATION_ID(14509, 14667) };
			return func(a_id, a_file);
		}

		[[nodiscard]] static auto GetAllForms()
			-> std::pair<
				BSTHashMap<FormID, TESForm*>*,
				std::reference_wrapper<BSReadWriteLock>>
		{
			REL::Relocation<BSTHashMap<FormID, TESForm*>**> allForms{ RELOCATION_ID(514351, 400507) };
			REL::Relocation<BSReadWriteLock*>               allFormsMapLock{ RELOCATION_ID(514360, 400517) };
			return { *allForms, std::ref(*allFormsMapLock) };
		}

		[[nodiscard]] static auto GetAllFormsByEditorID()
			-> std::pair<
				BSTHashMap<BSFixedString, TESForm*>*,
				std::reference_wrapper<BSReadWriteLock>>
		{
			REL::Relocation<BSTHashMap<BSFixedString, TESForm*>**> allFormsByEditorID{ RELOCATION_ID(514352, 400509) };
			REL::Relocation<BSReadWriteLock*>                      allFormsEditorIDMapLock{ RELOCATION_ID(514361, 400518) };
			return { *allFormsByEditorID, std::ref(*allFormsEditorIDMapLock) };
		}

		[[nodiscard]] static TESForm* LookupByID(FormID a_formID)
		{
			const auto& [map, lock] = GetAllForms();
			[[maybe_unused]] const BSReadWriteLock l{ lock };
			if (map) {
				const auto it = map->find(a_formID);
				return it != map->end() ? it->second : nullptr;
			} else {
				return nullptr;
			}
		}

		template <class T>
		[[nodiscard]] static T* LookupByID(FormID a_formID)
		{
			const auto form = LookupByID(a_formID);
			return form ? form->As<T>() : nullptr;
		}

		[[nodiscard]] static TESForm* LookupByEditorID(const std::string_view& a_editorID)
		{
			const auto& [map, lock] = GetAllFormsByEditorID();
			[[maybe_unused]] const BSReadWriteLock l{ lock };
			if (map) {
				const auto it = map->find(a_editorID);
				return it != map->end() ? it->second : nullptr;
			} else {
				return nullptr;
			}
		}

		template <class T>
		[[nodiscard]] static T* LookupByEditorID(const std::string_view& a_editorID)
		{
			const auto form = LookupByEditorID(a_editorID);
			return form ? form->As<T>() : nullptr;
		}

		template <
			class T,
			class = std::enable_if_t<
				std::negation_v<
					std::disjunction<
						std::is_pointer<T>,
						std::is_reference<T>,
						std::is_const<T>,
						std::is_volatile<T>>>>>
		[[nodiscard]] T* As() noexcept;

		template <
			class T,
			class = std::enable_if_t<
				std::negation_v<
					std::disjunction<
						std::is_pointer<T>,
						std::is_reference<T>,
						std::is_const<T>,
						std::is_volatile<T>>>>>
		[[nodiscard]] const T* As() const noexcept;

		[[nodiscard]] TESObjectREFR*       AsReference() { return AsReference1(); }
		[[nodiscard]] const TESObjectREFR* AsReference() const { return AsReference2(); }

		[[nodiscard]] TESFile* GetFile(std::int32_t a_idx = -1) const
		{
			const auto array = sourceFiles.array;
			if (!array || array->empty()) {
				return nullptr;
			}

			if (a_idx < 0 || static_cast<std::uint32_t>(a_idx) >= array->size()) {
				return array->back();
			} else {
				return (*array)[a_idx];
			}
		}

		[[nodiscard]] std::uint32_t GetFormFlags() const noexcept { return formFlags; }
		[[nodiscard]] FormID        GetFormID() const noexcept { return formID; }
		[[nodiscard]] FormType      GetFormType() const noexcept { return *formType; }
		[[nodiscard]] std::int32_t  GetGoldValue() const;

		[[nodiscard]] FormID GetRawFormID() const;
		[[nodiscard]] FormID GetLocalFormID() const
		{
			auto file = GetFile(0);

			RE::FormID fileIndex = file->compileIndex << (3 * 8);
			fileIndex += file->smallFileCompileIndex << ((1 * 8) + 4);

			return formID & ~fileIndex;
		}

		[[nodiscard]] const char* GetName() const;
		[[nodiscard]] float       GetWeight() const;
		[[nodiscard]] bool        HasKeywordInArray(const std::vector<BGSKeyword*>& a_keywords, bool a_matchAll) const;
		[[nodiscard]] bool        HasKeywordInList(BGSListForm* a_keywordList, bool a_matchAll) const;
		[[nodiscard]] bool        HasVMAD() const;
		[[nodiscard]] bool        HasWorldModel() const noexcept;
		void                      InitItem() { InitItemImpl(); }

		[[nodiscard]] bool Is(FormType a_type) const noexcept { return GetFormType() == a_type; }

		template <class... Args>
		[[nodiscard]] bool Is(Args... a_args) const noexcept  //
			requires(std::same_as<Args, FormType>&&...)
		{
			return (Is(a_args) || ...);
		}

		[[nodiscard]] bool IsAmmo() const noexcept { return Is(FormType::Ammo); }
		[[nodiscard]] bool IsArmor() const noexcept { return Is(FormType::Armor); }
		[[nodiscard]] bool IsBook() const noexcept { return Is(FormType::Book); }
		[[nodiscard]] bool IsDeleted() const noexcept { return (GetFormFlags() & RecordFlags::kDeleted) != 0; }
		[[nodiscard]] bool IsDynamicForm() const noexcept { return GetFormID() >= 0xFF000000; }
		[[nodiscard]] bool IsGold() const noexcept { return GetFormID() == 0x0000000F; }
		[[nodiscard]] bool IsIgnored() const noexcept { return (GetFormFlags() & RecordFlags::kIgnored) != 0; }
		[[nodiscard]] bool IsInventoryObject() const;
		[[nodiscard]] bool IsInitialized() const noexcept { return (GetFormFlags() & RecordFlags::kInitialized) != 0; }
		[[nodiscard]] bool IsKey() const noexcept { return Is(FormType::KeyMaster); }
		[[nodiscard]] bool IsLockpick() const noexcept { return GetFormID() == 0x0000000A; }

		[[nodiscard]] bool IsNot(FormType a_type) const noexcept { return !Is(a_type); }

		template <class... Args>
		[[nodiscard]] bool IsNot(Args... a_args) const noexcept  //
			requires(std::same_as<Args, FormType>&&...)
		{
			return (IsNot(a_args) && ...);
		}

		[[nodiscard]] bool IsNote() const noexcept { return Is(FormType::Note); }
		[[nodiscard]] bool IsPlayer() const noexcept { return GetFormID() == 0x00000007; }
		[[nodiscard]] bool IsPlayerRef() const noexcept { return GetFormID() == 0x00000014; }
		[[nodiscard]] bool IsSoulGem() const noexcept { return Is(FormType::SoulGem); }
		[[nodiscard]] bool IsWeapon() const noexcept { return Is(FormType::Weapon); }

		// members
		TESFileContainer                                sourceFiles;      // 08
		std::uint32_t                                   formFlags;        // 10
		FormID                                          formID;           // 14
		stl::enumeration<InGameFormFlag, std::uint16_t> inGameFormFlags;  // 18
		stl::enumeration<FormType, std::uint8_t>        formType;         // 1A
		std::uint8_t                                    pad1B;            // 1B
		std::uint32_t                                   pad1C;            // 1C
	};
	static_assert(sizeof(TESForm) == 0x20);
}


===============================================
File: include/RE/T/TESFormDeleteEvent.h
===============================================
#pragma once

namespace RE
{
	class TESObjectREFR;

	struct TESFormDeleteEvent
	{
	public:
		FormID        formID;  // 00
		std::uint32_t pad04;   // 04
	};
	static_assert(sizeof(TESFormDeleteEvent) == 0x08);
}


===============================================
File: include/RE/T/TESFullName.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESFullName : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESFullName;

		~TESFullName() override;

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { name = ""; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual std::uint32_t GetFullNameLength() const;  // 04
		[[nodiscard]] virtual const char*   GetFullName() const;        // 05

		// members
		BSFixedString fullName;  // 08 - FULL
	};
	static_assert(sizeof(TESFullName) == 0x10);
}


===============================================
File: include/RE/T/TESFurniture.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESObjectACTI.h"

namespace RE
{
	class TESFurniture : public TESObjectACTI
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESFurniture;
		inline static constexpr auto VTABLE = VTABLE_TESFurniture;
		inline static constexpr auto FORMTYPE = FormType::Furniture;

		enum class ActiveMarker
		{
			kNone = 0,
			kSit0 = 1 << 0,
			kSit1 = 1 << 1,
			kSit2 = 1 << 2,
			kSit3 = 1 << 3,
			kSit4 = 1 << 4,
			kSit5 = 1 << 5,
			kSit6 = 1 << 6,
			kSit7 = 1 << 7,
			kSit8 = 1 << 8,
			kSit9 = 1 << 9,
			kSit10 = 1 << 10,
			kSit11 = 1 << 11,
			kSit12 = 1 << 12,
			kSit13 = 1 << 13,
			kSit14 = 1 << 14,
			kSit15 = 1 << 15,
			kSit16 = 1 << 16,
			kSit17 = 1 << 17,
			kSit18 = 1 << 18,
			kSit19 = 1 << 19,
			kSit20 = 1 << 20,
			kSit21 = 1 << 21,
			kSit22 = 1 << 22,
			kSit23 = 1 << 23,
			kDisablesActivation = 1 << 25,
			kIsPerch = 1 << 26,
			kMustExitToTalk = 1 << 27,
			kSit28 = 1 << 28,
			kCanLean = 1 << 29,
			kCanSit = 1 << 30,
			kCanSleep = 1 << 31
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIsPerch = 1 << 7,
				kIgnored = 1 << 12,
				kHasDistantLOD = 1 << 15,
				kRandomAnimStart = 1 << 16,
				kIsMarker = 1 << 23,
				kMustExitToTalk = 1 << 28,
				kChildCanUse = 1 << 29
			};
		};

		struct WorkBenchData  // WBDT
		{
		public:
			enum class BenchType
			{
				kNone = 0,
				kCreateObject = 1,
				kSmithingWeapon = 2,
				kEnchanting = 3,
				kEnchantingExperiment = 4,
				kAlchemy = 5,
				kAlchemyExperiment = 6,
				kSmithingArmor = 7,
			};

			// members
			stl::enumeration<BenchType, std::uint8_t>  benchType;  // 0
			stl::enumeration<ActorValue, std::uint8_t> usesSkill;  // 1
		};
		static_assert(sizeof(WorkBenchData) == 0x2);

		struct EntryPointData
		{
		public:
			struct DisabledEntryPoint  // NAM0
			{
			public:
				enum class DisabledPoint
				{
					kNone = 0,
					kFront = 1 << 0,
					kBehind = 1 << 1,
					kRight = 1 << 2,
					kLeft = 1 << 3,
					kUp = 1 << 4
				};

				// members
				std::uint16_t                                  unk0;            // 0
				stl::enumeration<DisabledPoint, std::uint16_t> disabledPoints;  // 2
			};
			static_assert(sizeof(DisabledEntryPoint) == 0x4);

			// members
			std::uint32_t      entryPoint;           // 00 - ENAM
			DisabledEntryPoint disabledEntryPoints;  // 04 - NAM0
			BGSKeyword*        keyword;              // 08 - FNMK
		};
		static_assert(sizeof(EntryPointData) == 0x10);

		~TESFurniture() override;  // 00

		// override (TESObjectACTI)
		void        InitializeData() override;                                                                                                                                // 04
		void        ClearData() override;                                                                                                                                     // 05
		bool        Load(TESFile* a_mod) override;                                                                                                                            // 06
		void        InitItemImpl() override;                                                                                                                                  // 13
		bool        Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		NiAVObject* Clone3D(TESObjectREFR* a_ref) override;                                                                                                                   // 4A
		bool        GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C
		bool        CalculateDoFavor(Actor* a_activator, bool a_arg2, TESObjectREFR* a_toActivate, float a_arg3) override;                                                    // 4D

		// members
		BSTArray<EntryPointData>                      entryPointDataArray;  // C8
		WorkBenchData                                 workBenchData;        // E0 - WBDT
		std::uint16_t                                 padE2;                // E2
		stl::enumeration<ActiveMarker, std::uint32_t> furnFlags;            // E4
		SpellItem*                                    associatedForm;       // E8
	};
	static_assert(sizeof(TESFurniture) == 0xF0);
}


===============================================
File: include/RE/T/TESFurnitureEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESFurnitureEvent
	{
	public:
		enum class FurnitureEventType
		{
			kEnter = 0,
			kExit = 1
		};

		// members
		NiPointer<TESObjectREFR>                            actor;            // 00
		NiPointer<TESObjectREFR>                            targetFurniture;  // 08
		stl::enumeration<FurnitureEventType, std::uint32_t> type;             // 10
	};
	static_assert(sizeof(TESFurnitureEvent) == 0x18);
}


===============================================
File: include/RE/T/TESGlobal.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class TESGlobal : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESGlobal;
		inline static constexpr auto VTABLE = VTABLE_TESGlobal;
		inline static constexpr auto FORMTYPE = FormType::Global;

		enum class Type
		{
			kFloat = 'f',
			kLong = 'l',
			kShort = 's'
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kConstant = 1 << 6,
				kIgnored = 1 << 12
			};
		};

		~TESGlobal() override;  // 00

		// override (TESform)
		bool        Load(TESFile* a_mod) override;                // 06
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { formEditorID = a_str; return true; }

		// members
		BSString                             formEditorID;  // 20 - EDID
		stl::enumeration<Type, std::uint8_t> type;          // 30 - ENAM
		std::uint8_t                         pad31;         // 31
		std::uint16_t                        pad32;         // 32
		float                                value;         // 34 - FLTV
	};
	static_assert(sizeof(TESGlobal) == 0x38);
}


===============================================
File: include/RE/T/TESGrabReleaseEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESGrabReleaseEvent
	{
	public:
		NiPointer<TESObjectREFR> ref;      // 00
		bool                     grabbed;  // 08
		std::uint8_t             pad09;    // 09
		std::uint16_t            pad0A;    // 09
		std::uint32_t            pad0C;    // 0C
	};
	static_assert(sizeof(TESGrabReleaseEvent) == 0x10);
}


===============================================
File: include/RE/T/TESGrass.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class TESGrass :
		public TESBoundObject,  // 00
		public TESModel         // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESGrass;
		inline static constexpr auto VTABLE = VTABLE_TESGrass;
		inline static constexpr auto FORMTYPE = FormType::Grass;

		enum class GRASS_WATER_STATE
		{
			kAboveOnlyAtLeast = 0,
			kAboveOnlyAtMost = 1,
			kBelowOnlyAtLeast = 2,
			kBelowOnlyAtMost = 3,
			kBothAtLeast = 4,
			kBothAtMost = 5,
			kBothAtMostAbove = 6,
			kBothAtMostBelow = 7
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct GRASS_DATA  // DATA
		{
			enum class Flag
			{
				kNone = 0,
				kVertexLighting = 1 << 0,
				kUniformScale = 1 << 1,
				kFitSlope = 1 << 2
			};

			std::int8_t                                        density;                 // 00
			std::int8_t                                        minSlopeDegrees;         // 01
			std::int8_t                                        maxSlopeDegrees;         // 02
			std::uint8_t                                       pad03;                   // 03
			std::uint16_t                                      distanceFromWaterLevel;  // 04
			std::uint16_t                                      pad06;                   // 06
			stl::enumeration<GRASS_WATER_STATE, std::uint32_t> underwater;              // 08
			float                                              positionRange;           // 0C
			float                                              heightRange;             // 10
			float                                              colorRange;              // 14
			float                                              wavePeriod;              // 18
			stl::enumeration<Flag, std::uint8_t>               flags;                   // 1C
			std::uint8_t                                       pad1D;                   // 1D
			std::uint16_t                                      pad1E;                   // 1E
		};
		static_assert(sizeof(GRASS_DATA) == 0x20);

		~TESGrass() override;  // 00

		// override (TESBoundObject)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// add
		[[nodiscard]] virtual std::uint8_t      GetDensity() const;                                         // 53 - { return data.density; }
		virtual bool                            SetDensity(std::uint8_t a_density);                         // 54 - { if (a_density > 100) return false; data.density = a_density; return true; }
		[[nodiscard]] virtual std::uint8_t      GetMinSlopeDegrees() const;                                 // 55 - { return data.minSlope; }
		virtual bool                            SetMinSlopeDegrees(std::uint8_t a_minSlope);                // 56 - { if (a_minSlope > 90 || a_minSlope > data.maxSlopeDegrees) return false; data.minSlopeDegrees = a_minSlope; return true; }
		[[nodiscard]] virtual std::uint8_t      GetMaxSlopeDegrees() const;                                 // 57 - { return data.maxSlope; }
		virtual bool                            SetMaxSlopeDegrees(std::uint8_t a_maxSlope);                // 58 - { if (a_maxSlope > 90 || a_maxSlope < data.minSlopeDegrees) return false; data.maxSlopeDegrees = a_maxSlope; return true; }
		[[nodiscard]] virtual float             GetMinSlope() const;                                        // 59 - { return data.minSlopeDegrees * 1deg; }
		[[nodiscard]] virtual float             GetMaxSlope() const;                                        // 5A - { return data.maxSlopeDegrees * 1deg; }
		[[nodiscard]] virtual std::uint16_t     GetDistanceFromWaterLevel() const;                          // 5B - { return data.distanceFromWaterLevel; }
		virtual void                            SetDistanceFromWaterLevel(std::uint16_t a_unitsFromWater);  // 5C - { data.distanceFromWaterLevel = a_unitsFromWater; }
		[[nodiscard]] virtual GRASS_WATER_STATE GetUnderwaterState() const;                                 // 5D - { return data.underwater; }
		virtual void                            SetUnderwaterState(GRASS_WATER_STATE a_waterState);         // 5E - { data.underwater = a_waterState; }
		[[nodiscard]] virtual float             GetPositionRange() const;                                   // 5F - { return data.positionRange; }
		virtual bool                            SetPositionRange(float a_positionRange);                    // 60 - { if (a_positionRange < 0.0 || a_positionRange > 512.0) return false; data.positionRange = a_positionRange; return true; }
		[[nodiscard]] virtual float             GetHeightRange() const;                                     // 61 - { return data.heightRange; }
		virtual bool                            SetHeightRange(float a_heightRange);                        // 62 - { if (a_heightRange < 0.0 || a_heightRange > 1.0) return false; data.heightRange = a_heightRange; return true; }
		[[nodiscard]] virtual float             GetColorRange() const;                                      // 63 - { return data.colorRange; }
		virtual bool                            SetColorRange(float a_colorRange);                          // 64 - { if (a_colorRange < 0.0 || a_colorRange > 1.0) return false; data.colorRange = a_colorRange; return true; }
		[[nodiscard]] virtual float             GetWavePeriod() const;                                      // 65 - { return data.wavePeriod; }
		virtual bool                            SetWavePeriod(float a_wavePeriod);                          // 66 - { if (a_wavePeriod <= 0.0) return false; data.wavePeriod = a_wavePeriod; return true; }
		[[nodiscard]] virtual bool              GetVertexLighting() const;                                  // 67 - { return data.flags & 1; }
		virtual void                            SetVertexLighting(bool a_set);                              // 68 - { if (a_set) data.flags |= 0x1; else data.flags &= 0xFE; }
		[[nodiscard]] virtual bool              GetUniformScaling() const;                                  // 69 - { return (data.flags >> 1) & 1; }
		virtual void                            SetUniformScaling(bool a_set);                              // 6A - { if (a_set) data.flags |= 0x2; else data.flags &= 0xFD; }
		[[nodiscard]] virtual bool              GetFitToSlope() const;                                      // 6B - { return (data.flags >> 2) & 1; }
		virtual void                            SetFitToSlope(bool a_set);                                  // 6C - { if (a_set) data.flags |= 0x4; else data.flags &= 0xFB; }

		// members
		GRASS_DATA data;  // 58 - DATA
	};
	static_assert(sizeof(TESGrass) == 0x78);
}


===============================================
File: include/RE/T/TESHavokUtilities.h
===============================================
#pragma once

namespace RE
{
	class HitData;
	class hkVector4;
	class bhkRigidBody;
	class hkpCollidable;
	class NiAVObject;
	class TESObjectREFR;

	namespace TESHavokUtilities
	{
		void           AddExplosionImpulse(NiAVObject* a_obj3D, hkVector4& a_pos, float a_force, const HitData* a_hitData);
		TESObjectREFR* FindCollidableRef(const hkpCollidable& a_linkedCollidable);
		NiAVObject*    FindCollidableObject(const hkpCollidable& a_linkedCollidable);
		float          GetDamageForImpact(float a_mass, float a_speed);
		float          ScaleGameplayImpulseForce(float a_inputForce, bhkRigidBody* a_body, bool a_factorMass);
	}
}


===============================================
File: include/RE/T/TESHitEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESHitEvent
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kPowerAttack = 1 << 0,
			kSneakAttack = 1 << 1,
			kBashAttack = 1 << 2,
			kHitBlocked = 1 << 3
		};

		TESHitEvent();
		TESHitEvent(TESObjectREFR* a_target, TESObjectREFR* a_aggressor, FormID a_weapon, FormID a_projectile, Flag a_flags);
		~TESHitEvent() = default;

		// members
		NiPointer<TESObjectREFR>             target;      // 00
		NiPointer<TESObjectREFR>             cause;       // 08
		FormID                               source;      // 10
		FormID                               projectile;  // 14
		stl::enumeration<Flag, std::uint8_t> flags;       // 18
		std::uint8_t                         pad19;       // 19
		std::uint16_t                        pad1A;       // 1A
		std::uint32_t                        pad1C;       // 1C
	};
	static_assert(sizeof(TESHitEvent) == 0x20);
}


===============================================
File: include/RE/T/TESIcon.h
===============================================
#pragma once

#include "RE/T/TESTexture.h"

namespace RE
{
	class TESIcon : public TESTexture
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESTexture;

		~TESIcon() override;  // 00

		// override (TESTexture)
		[[nodiscard]] const char* GetDefaultPath() const override;  // 06 - { return "Textures"; }
	};
	static_assert(sizeof(TESIcon) == 0x10);
}


===============================================
File: include/RE/T/TESIdleForm.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class Actor;
	class NiFormArray;
	class TESObjectREFR;

	struct IDLE_DATA  // DATA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kParent = 1 << 0,
			kSequence = 1 << 1,
			kNoAttacking = 1 << 2,
			kBlocking = 1 << 3
		};

		// members
		std::int8_t                          loopMin;                  // 0
		std::int8_t                          loopMax;                  // 1
		stl::enumeration<Flag, std::uint8_t> flags;                    // 2
		std::uint8_t                         animationGroupSelection;  // 3
		std::uint16_t                        replayDelay;              // 4
	};
	static_assert(sizeof(IDLE_DATA) == 0x6);

	class TESIdleForm : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESIdleForm;
		inline static constexpr auto VTABLE = VTABLE_TESIdleForm;
		inline static constexpr auto FORMTYPE = FormType::Idle;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESIdleForm() override;  // 00

		// override (TESForm)
		void        InitializeData() override;                                          // 04
		void        ClearData() override;                                               // 05
		bool        Load(TESFile* a_mod) override;                                      // 06
		TESForm*    CreateDuplicateForm(bool a_createEditorID, void* a_arg2) override;  // 09
		void        InitItemImpl() override;                                            // 13
		const char* GetFormEditorID() const override;                                   // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;                        // 33

		bool CheckConditions(Actor* a_actor, TESObjectREFR* a_target, bool a_checkParentIdle)
		{
			using func_t = decltype(&TESIdleForm::CheckConditions);
			REL::Relocation<func_t> func{ RELOCATION_ID(24069, 24572) };
			return func(this, a_actor, a_target, a_checkParentIdle);
		}

		// members
		TESCondition  conditions;     // 20
		IDLE_DATA     data;           // 28 - DATA
		std::uint16_t pad2E;          // 2E
		NiFormArray*  childIdles;     // 30
		TESIdleForm*  parentIdle;     // 38 - ANAM~
		TESIdleForm*  prevIdle;       // 40 - ~ANAM
		BSFixedString animFileName;   // 48 - DNAM
		BSFixedString animEventName;  // 50 - ENAM
		BSString      formEditorID;   // 58 - EDID
	};
	static_assert(sizeof(TESIdleForm) == 0x68);
}


===============================================
File: include/RE/T/TESImageSpace.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/I/ImageSpaceData.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class TESImageSpace : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESImageSpace;
		inline static constexpr auto VTABLE = VTABLE_TESImageSpace;
		inline static constexpr auto FORMTYPE = FormType::ImageSpace;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESImageSpace() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		bool Load(TESFile* a_mod) override;  // 06

		// members
		ImageSpaceBaseData data;  // 20
	};
	static_assert(sizeof(TESImageSpace) == 0x70);
}


===============================================
File: include/RE/T/TESImageSpaceModifiableForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESImageSpaceModifier;

	class TESImageSpaceModifiableForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESImageSpaceModifiableForm;

		~TESImageSpaceModifiableForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { imageSpaceModifying = 0; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		TESImageSpaceModifier* imageSpaceModifying;  // 08 - MNAM
	};
	static_assert(sizeof(TESImageSpaceModifiableForm) == 0x10);
}


===============================================
File: include/RE/T/TESImageSpaceModifier.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/F/FormTypes.h"
#include "RE/I/ImageSpaceModifierInstanceDOF.h"
#include "RE/N/NiPoint2.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class NiColorInterpolator;
	class NiFloatInterpolator;

	struct ImageSpaceModifierData  // DNAM
	{
	public:
		template <typename T>
		struct MultAdd
		{
		public:
			// members
			T mult;
			T add;
		};

		template <typename T>
		struct MinMax
		{
		public:
			// members
			MultAdd<T> min;
			MultAdd<T> max;
		};

		struct HDR
		{
		public:
			// members
			MultAdd<float> eyeAdaptSpeed;    // 00
			MultAdd<float> bloomBlurRadius;  // 08
			MultAdd<float> bloomThreshold;   // 10
			MultAdd<float> bloomScale;       // 18
			MinMax<float>  targetLum;        // 20
			MultAdd<float> sunlightScale;    // 30
			MultAdd<float> skyScale;         // 38
			MultAdd<float> empty[6];         // 40
		};
		static_assert(sizeof(HDR) == 0x70);

		struct Bloom
		{
		public:
			// members
			MultAdd<float> empty[3];  // 00
		};
		static_assert(sizeof(Bloom) == 0x18);

		struct Cinematic
		{
		public:
			// members
			MultAdd<float> saturation;  // 00
			MultAdd<float> brightness;  // 08
			MultAdd<float> contrast;    // 10
			MultAdd<float> empty;       // 18
		};
		static_assert(sizeof(Cinematic) == 0x20);

		struct DOF
		{
		public:
			using Mode = ImageSpaceModifierInstanceDOF::DepthOfFieldMode;

			// members
			std::uint32_t                        strength;   // 00
			std::uint32_t                        distance;   // 04
			std::uint32_t                        range;      // 08
			bool                                 useTarget;  // 0C
			stl::enumeration<Mode, std::uint8_t> flags;      // 0D
			std::uint16_t                        pad0E;      // 0E
		};
		static_assert(sizeof(DOF) == 0x10);

		// members
		bool          animatable;              // 00
		std::uint8_t  pad01;                   // 01
		std::uint16_t pad02;                   // 01
		float         duration;                // 04
		HDR           hdr;                     // 08
		Bloom         bloom;                   // 78
		Cinematic     cinematic;               // 90
		std::uint32_t tintColor;               // B0
		std::uint32_t blurRadius;              // B4
		std::uint32_t doubleVisionStrength;    // B8
		std::uint32_t radialBlurStrength;      // BC
		std::uint32_t radialBlurRampUp;        // C0
		std::uint32_t radialBlurStart;         // C4
		bool          useTargetForRadialBlur;  // C8
		std::uint8_t  padC9;                   // C9
		std::uint16_t padCA;                   // CA
		NiPoint2      radialBlurCenter;        // CC
		DOF           dof;                     // D4
		std::uint32_t radialBlurRampDown;      // E4
		std::uint32_t radialBlurDownStart;     // E8
		std::uint32_t fadeColor;               // EC
		std::uint32_t motionBlurStrength;      // F0
	};
	static_assert(sizeof(ImageSpaceModifierData) == 0xF4);

	class TESImageSpaceModifier : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESImageSpaceModifier;
		inline static constexpr auto VTABLE = VTABLE_TESImageSpaceModifier;
		inline static constexpr auto FORMTYPE = FormType::ImageAdapter;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		template <typename T>
		struct MultAdd
		{
			T mult;
			T add;
		};

		template <typename T>
		struct MinMax
		{
			MultAdd<T> min;
			MultAdd<T> max;
		};

		struct HDR
		{
			MultAdd<NiPointer<NiFloatInterpolator>> eyeAdaptSpeed;    // 00 - aIAD - @IAD
			MultAdd<NiPointer<NiFloatInterpolator>> bloomBlurRadius;  // 10 - bIAD - AIAD
			MultAdd<NiPointer<NiFloatInterpolator>> bloomThreshold;   // 20 - cIAD - BIAD
			MultAdd<NiPointer<NiFloatInterpolator>> bloomScale;       // 30 - dIAD - CIAD
			MinMax<NiPointer<NiFloatInterpolator>>  targetLum;        // 40 - eIAD - EIAD
			MultAdd<NiPointer<NiFloatInterpolator>> sunlightScale;    // 60 - gIAD - FIAD
			MultAdd<NiPointer<NiFloatInterpolator>> skyScale;         // 70 - hIAD - GIAD
			MultAdd<NiPointer<NiFloatInterpolator>> empty[6];         // 80 - iIAD - MIAD
		};
		static_assert(sizeof(HDR) == 0xE0);

		struct Bloom
		{
			MultAdd<NiPointer<NiFloatInterpolator>> empty[3];  // 00 - oIAD - PIAD
		};
		static_assert(sizeof(Bloom) == 0x30);

		struct Cinematic
		{
			MultAdd<NiPointer<NiFloatInterpolator>> saturation;  // 00 - rIAD - QIAD
			MultAdd<NiPointer<NiFloatInterpolator>> brightness;  // 10 - sIAD - RIAD
			MultAdd<NiPointer<NiFloatInterpolator>> contrast;    // 20 - tIAD - SIAD
			MultAdd<NiPointer<NiFloatInterpolator>> empty;       // 30 - uIAD - TIAD
		};
		static_assert(sizeof(Cinematic) == 0x40);

		struct RadialBlur
		{
			NiPointer<NiFloatInterpolator> strength;   // 00 - RNAM
			NiPointer<NiFloatInterpolator> rampUp;     // 08 - SNAM
			NiPointer<NiFloatInterpolator> start;      // 10 - UNAM
			NiPointer<NiFloatInterpolator> rampDown;   // 18 - NAM1
			NiPointer<NiFloatInterpolator> downStart;  // 20 - NAM2
		};
		static_assert(sizeof(RadialBlur) == 0x28);

		struct DOF
		{
			NiPointer<NiFloatInterpolator> strength;  // 00 - WNAM
			NiPointer<NiFloatInterpolator> distance;  // 08 - XNAM
			NiPointer<NiFloatInterpolator> range;     // 10 - YNAM
		};
		static_assert(sizeof(DOF) == 0x18);

		~TESImageSpaceModifier() override;  // 00

		// override (TESForm)
		void        InitializeData() override;                    // 04
		void        ClearData() override;                         // 05
		bool        Load(TESFile* a_mod) override;                // 06
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { formEditorID = a_str; }

		ImageSpaceModifierInstanceForm* TriggerIfNotActive(float a_strength, NiAVObject* a_target)
		{
			using func_t = decltype(&TESImageSpaceModifier::TriggerIfNotActive);
			REL::Relocation<func_t> func{ RELOCATION_ID(18187, 18572) };
			return func(this, a_strength, a_target);
		}

		// members
		ImageSpaceModifierData         data;                  // 020 - DNAM
		std::uint32_t                  pad114;                // 114
		HDR                            hdr;                   // 118
		Bloom                          bloom;                 // 1F8
		Cinematic                      cinematic;             // 228
		NiPointer<NiFloatInterpolator> blurRadius;            // 268 - BNAM
		NiPointer<NiFloatInterpolator> doubleVisionStrength;  // 270 - VNAM
		NiPointer<NiColorInterpolator> tintColor;             // 278 - TNAM
		NiPointer<NiColorInterpolator> fadeColor;             // 280 - NAM3
		RadialBlur                     radialBlur;            // 288
		DOF                            dof;                   // 2B0
		NiPointer<NiColorInterpolator> motionBlurStrength;    // 2C8 - NAM4
		BSString                       formEditorID;          // 2D0 - EDID
	};
	static_assert(sizeof(TESImageSpaceModifier) == 0x2E0);
}


===============================================
File: include/RE/T/TESInitScriptEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESInitScriptEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> objectInitialized;  // 0
	};
	static_assert(sizeof(TESInitScriptEvent) == 0x8);
}


===============================================
File: include/RE/T/TESKey.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESObjectMISC.h"

namespace RE
{
	class TESKey : public TESObjectMISC
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESKey;
		inline static constexpr auto VTABLE = VTABLE_TESKey;
		inline static constexpr auto FORMTYPE = FormType::KeyMaster;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESKey() override;  // 00

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05
	};
	static_assert(sizeof(TESKey) == 0x100);
}


===============================================
File: include/RE/T/TESLandTexture.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct TEXTURE_HAVOK_DATA  // HNAM
	{
		std::int32_t friction;     // 0
		std::int32_t restitution;  // 4
	};
	static_assert(sizeof(TEXTURE_HAVOK_DATA) == 0x8);

	class TESLandTexture : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESLandTexture;
		inline static constexpr auto VTABLE = VTABLE_TESLandTexture;
		inline static constexpr auto FORMTYPE = FormType::LandTexture;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESLandTexture() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		BGSTextureSet*          textureSet;          // 20 - TNAM
		TEXTURE_HAVOK_DATA      havokData;           // 28 - HNAM
		BGSMaterialType*        materialType;        // 30 - MNAM
		std::int8_t             specularExponent;    // 38 - SNAM
		std::uint8_t            pad39;               // 39
		std::uint16_t           pad3A;               // 3A
		std::int32_t            shaderTextureIndex;  // 3C - INAM
		BSSimpleList<TESGrass*> textureGrassList;    // 40 - GNAM
	};
	static_assert(sizeof(TESLandTexture) == 0x50);
}


===============================================
File: include/RE/T/TESLevCharacter.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundAnimObject.h"
#include "RE/T/TESLeveledList.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	class TESLevCharacter :
		public TESBoundAnimObject,  // 00
		public TESLeveledList,      // 30
		public TESModelTextureSwap  // 58
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESLevCharacter;
		inline static constexpr auto VTABLE = VTABLE_TESLevCharacter;
		inline static constexpr auto FORMTYPE = FormType::LeveledNPC;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kAddedObject = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESLevCharacter() override;  // 00

		// override (TESBoundAnimObject)
		bool        Load(TESFile* a_mod) override;                // 06
		void        SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void        LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void        Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void        InitItemImpl() override;                      // 13
		void        UnClone3D(TESObjectREFR* a_ref) override;     // 4A - { return; }
		NiAVObject* Clone3D(TESObjectREFR* a_ref) override;       // 4A - { return 0; }

		// override (TESLeveledList)
		[[nodiscard]] std::int32_t GetLevDifferenceMax() override;                            // 06 - { return iLevCharLevelDifferenceMax; }
		[[nodiscard]] bool         GetCanContainFormsOfType(FormType a_type) const override;  // 07 - { return a_type <= FormType::LeveledCharacter; }
	};
	static_assert(sizeof(TESLevCharacter) == 0x90);
}


===============================================
File: include/RE/T/TESLevItem.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESLeveledList.h"

namespace RE
{
	class TESLevItem :
		public TESBoundObject,  // 00
		public TESLeveledList   // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESLevItem;
		inline static constexpr auto VTABLE = VTABLE_TESLevItem;
		inline static constexpr auto FORMTYPE = FormType::LeveledItem;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kAddedObject = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESLevItem() override;  // 00

		// override (TESBoundObject)
		bool Load(TESFile* a_mod) override;                // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void InitItemImpl() override;                      // 13

		// override (TESLeveledList)
		[[nodiscard]] std::int32_t GetLevDifferenceMax() override;                            // 06 - { return iLevItemLevelDifferenceMax; }
		[[nodiscard]] bool         GetCanContainFormsOfType(FormType a_type) const override;  // 07
	};
	static_assert(sizeof(TESLevItem) == 0x58);
}


===============================================
File: include/RE/T/TESLevSpell.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESLeveledList.h"

namespace RE
{
	class TESLevSpell :
		public TESBoundObject,  // 00
		public TESLeveledList   // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESLevSpell;
		inline static constexpr auto VTABLE = VTABLE_TESLevSpell;
		inline static constexpr auto FORMTYPE = FormType::LeveledSpell;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kAddedObject = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESLevSpell() override;  // 00

		// override (TESBoundObject)
		bool Load(TESFile* a_mod) override;                // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void InitItemImpl() override;                      // 13

		// override (TESLeveledList)
		[[nodiscard]] bool GetCanContainFormsOfType(FormType a_type) const override;  // 07
	};
	static_assert(sizeof(TESLevSpell) == 0x58);
}


===============================================
File: include/RE/T/TESLeveledList.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/B/BaseFormComponent.h"
#include "RE/C/ContainerItemExtra.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class TESFaction;
	class TESForm;
	class TESGlobal;

	struct LEVELED_OBJECT
	{
	public:
		// members
		TESForm*            form;       // 00 - LVLO~
		std::uint16_t       count;      // 08
		std::uint16_t       level;      // 0A - ~LVLO
		std::uint32_t       pad0C;      // 0C
		ContainerItemExtra* itemExtra;  // 10 - COED
	};
	static_assert(sizeof(LEVELED_OBJECT) == 0x18);

	struct CALCED_OBJECT
	{
	public:
		// members
		TESForm*           form;           // 00
		std::uint16_t      count;          // 08
		std::uint16_t      pad0A;          // 08
		std::uint32_t      pad0C;          // 0C
		ContainerItemExtra containerItem;  // 10
	};
	static_assert(sizeof(CALCED_OBJECT) == 0x28);

	class TESLeveledList : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESLeveledList;

		enum Flag : std::uint8_t  // LVLF
		{
			kCalculateFromAllLevelsLTOrEqPCLevel = 1 << 0,
			kCalculateForEachItemInCount = 1 << 1,
			kUseAll = 1 << 2,
			kSpecialLoot = 1 << 3
		};

		~TESLeveledList() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual std::uint8_t GetChanceNone();                                      // 04 - { if (global) return global->value; else return chanceNone; }
		[[nodiscard]] virtual bool         GetMultCalc();                                        // 05 - { return (flags >> 1) & 1; }
		[[nodiscard]] virtual std::int32_t GetLevDifferenceMax();                                // 06 - { return 0; }
		[[nodiscard]] virtual bool         GetCanContainFormsOfType(FormType a_type) const = 0;  // 07

		void                                CalculateCurrentFormList(std::uint16_t a_level, std::int16_t a_count, BSScrapArray<CALCED_OBJECT>& a_calcedObjects, std::uint32_t a_arg5, bool a_usePlayerLevel);
		[[nodiscard]] std::vector<TESForm*> GetContainedForms() const;

		// members
		SimpleArray<LEVELED_OBJECT> entries;       // 08
		std::int8_t                 chanceNone;    // 10 - LVLD
		Flag                        llFlags;       // 11 - LVLF
		std::uint8_t                numEntries;    // 12 - LLCT
		std::uint8_t                unk13;         // 13
		std::uint32_t               pad14;         // 14
		void*                       unk18;         // 18
		TESGlobal*                  chanceGlobal;  // 20 - LVLG
	};
	static_assert(sizeof(TESLeveledList) == 0x28);
}


===============================================
File: include/RE/T/TESLoadGameEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESLoadGameEvent
	{
	public:
	};
	static_assert(sizeof(TESLoadGameEvent) == 0x1);
}


===============================================
File: include/RE/T/TESLoadScreen.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class TESLoadScreen : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESLoadScreen;
		inline static constexpr auto VTABLE = VTABLE_TESLoadScreen;
		inline static constexpr auto FORMTYPE = FormType::LoadScreen;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kDisplaysInMainMenu = 1 << 10,
				kIgnored = 1 << 12
			};
		};

		struct LoadNIFData
		{
			TESBoundObject* loadNIF;                       // 00 - NNAM
			float           initialScale;                  // 08 - SNAM
			std::int16_t    rotationConstraints[3];        // 0C - RNAM
			std::int16_t    rotationOffsetConstraints[2];  // 12 - ONAM
			std::uint16_t   pad16;                         // 16
			float           initialTranslationOffset[3];   // 18 - XNAM
			std::uint32_t   pad24;                         // 24
			TESModel        cameraPath;                    // 28 - MOD2
		};
		static_assert(sizeof(LoadNIFData) == 0x50);

		~TESLoadScreen() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04 - { return; }
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		TESCondition  conditions;   // 20
		LoadNIFData*  loadNIFData;  // 28
		BSFixedString loadingText;  // 30
	};
	static_assert(sizeof(TESLoadScreen) == 0x38);
}


===============================================
File: include/RE/T/TESLockChangedEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESLockChangedEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> lockedObject;  // 0
	};
	static_assert(sizeof(TESLockChangedEvent) == 0x8);
}


===============================================
File: include/RE/T/TESMagicCasterForm.h
===============================================
#pragma once

namespace RE
{
	class TESMagicCasterForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESMagicCasterForm;
	};
	static_assert(sizeof(TESMagicCasterForm) == 0x1);
}


===============================================
File: include/RE/T/TESMagicEffectApplyEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESMagicEffectApplyEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> target;       // 00
		NiPointer<TESObjectREFR> caster;       // 08
		FormID                   magicEffect;  // 10
		std::uint32_t            pad14;        // 14
	};
	static_assert(sizeof(TESMagicEffectApplyEvent) == 0x18);
}


===============================================
File: include/RE/T/TESMagicTargetForm.h
===============================================
#pragma once

namespace RE
{
	class TESMagicTargetForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESMagicTargetForm;
	};
	static_assert(sizeof(TESMagicTargetForm) == 0x1);
}


===============================================
File: include/RE/T/TESModel.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BaseFormComponent.h"

namespace RE
{
	namespace BSResource
	{
		struct ID;
	}

	class TESModelTextureSwap;

	class TESModel : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESModel;
		inline static constexpr auto VTABLE = VTABLE_TESModel;

		~TESModel() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		[[nodiscard]] virtual const char* GetModel() const;               // 04 - { return model.c_str(); }
		virtual void                      SetModel(const char* a_model);  // 05 - { model = a_model; }
		virtual TESModelTextureSwap*      GetAsModelTextureSwap();        // 06 - { return 0; }

		// members
		BSFixedString   model;        // 08 - MODL
		BSResource::ID* textures;     // 10 - MODT
		std::uint32_t*  addons;       // 18
		std::uint16_t   numTextures;  // 20
		std::uint16_t   numAddons;    // 22
		std::uint32_t   pad24;        // 24
	};
	static_assert(sizeof(TESModel) == 0x28);
}


===============================================
File: include/RE/T/TESModelPSA.h
===============================================
#pragma once

#include "RE/T/TESModel.h"

namespace RE
{
	class TESModelPSA : public TESModel
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESModelPSA;

		~TESModelPSA() override;  // 00
	};
	static_assert(sizeof(TESModelPSA) == 0x28);
}


===============================================
File: include/RE/T/TESModelRDT.h
===============================================
#pragma once

#include "RE/T/TESModel.h"

namespace RE
{
	class TESModelRDT : public TESModel
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESModelRDT;

		~TESModelRDT() override;  // 00
	};
	static_assert(sizeof(TESModelRDT) == 0x28);
}


===============================================
File: include/RE/T/TESModelTextureSwap.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESModel.h"

namespace RE
{
	class TESModelTextureSwap : public TESModel
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESModelTextureSwap;

		struct AlternateTexture  // MODS
		{
			BGSTextureSet* textureSet;  // 00
			std::uint32_t  index3D;     // 08
			std::uint32_t  unk0C;       // 0C
			BSFixedString  name3D;      // 10
		};
		static_assert(sizeof(AlternateTexture) == 0x18);

		~TESModelTextureSwap() override;  // 00

		// override (TESModel)
		void                 InitializeDataComponent() override;                // 01
		void                 ClearDataComponent() override;                     // 02
		void                 CopyComponent(BaseFormComponent* a_rhs) override;  // 03
		TESModelTextureSwap* GetAsModelTextureSwap() override;                  // 06 - { return this; }

		// members
		AlternateTexture* alternateTextures;     // 28 - MODS
		std::uint32_t     numAlternateTextures;  // 30
		std::uint32_t     pad34;                 // 34
	};
	static_assert(sizeof(TESModelTextureSwap) == 0x38);
}


===============================================
File: include/RE/T/TESModelTri.h
===============================================
#pragma once

#include "RE/T/TESModel.h"

namespace RE
{
	class TESModelTri : public TESModel
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESModelTri;

		~TESModelTri() override;  // 00

		// override (TESModel)
		void SetModel(const char* a_model) override;  // 05
	};
	static_assert(sizeof(TESModelTri) == 0x28);
}


===============================================
File: include/RE/T/TESMoveAttachDetachEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESMoveAttachDetachEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> movedRef;        // 00
		bool                     isCellAttached;  // 08
		std::uint8_t             pad09;           // 09
		std::uint16_t            pad0A;           // 0A
		std::uint32_t            pad0C;           // 0C
	};
	static_assert(sizeof(TESMoveAttachDetachEvent) == 0x10);
}


===============================================
File: include/RE/T/TESNPC.h
===============================================
#pragma once

#include "RE/B/BGSHeadPart.h"
#include "RE/B/BGSOverridePackCollection.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/C/Color.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MemoryManager.h"
#include "RE/S/Sexes.h"
#include "RE/S/SoundLevels.h"
#include "RE/T/TESActorBase.h"
#include "RE/T/TESRaceForm.h"

namespace RE
{
	class BSFaceGenNiNode;
	class MenuOpenCloseEvent;
	class NiColorA;
	class TintMask;

	class CreatureSounds
	{
	public:
		// members
		BSTArray<void*>* unk00[8];  // 00
	};
	static_assert(sizeof(CreatureSounds) == 0x40);

	class TESNPC :
		public TESActorBase,                     // 000
		public TESRaceForm,                      // 150
		public BGSOverridePackCollection,        // 160
		public BSTEventSink<MenuOpenCloseEvent>  // 188
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESNPC;
		inline static constexpr auto VTABLE = VTABLE_TESNPC;

		using HeadPartType = BGSHeadPart::HeadPartType;
		inline static constexpr auto FORMTYPE = FormType::NPC;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kBaseData = 1 << 1,
				kAttributes = 1 << 2,
				kAIData = 1 << 3,
				kSpellList = 1 << 4,
				kFullName = 1 << 5,
				kFactions = 1 << 6,
				kNPCSkills = 1 << 9,
				kClass = 1 << 10,
				kFace = 1 << 11,
				kDefaultOutfit = 1 << 12,
				kSleepOutfit = 1 << 13,
				kGender = 1 << 24,
				kRace = 1 << 25
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kCompressed = 1 << 18,
				kBleedoutOverride = 1 << 29
			};
		};

		struct Skills
		{
		public:
			enum
			{
				kOneHanded = 0,
				kTwoHanded = 1,
				kMarksman = 2,
				kBlock = 3,
				kSmithing = 4,
				kHeavyArmor = 5,
				kLightArmor = 6,
				kPickpocket = 7,
				kLockpicking = 8,
				kSneak = 9,
				kAlchemy = 10,
				kSpeechcraft = 11,
				kAlteration = 12,
				kConjuration = 13,
				kDestruction = 14,
				kIllusion = 15,
				kRestoration = 16,
				kEnchanting = 17,

				kTotal
			};

			// members
			std::uint8_t  values[kTotal];        // 00
			std::uint8_t  offsets[kTotal];       // 12
			std::uint16_t health;                // 24
			std::uint16_t magicka;               // 26
			std::uint16_t stamina;               // 28
			std::uint16_t pad2A;                 // 2A
			float         farawayModelDistance;  // 2C
		};
		static_assert(sizeof(Skills) == 0x30);

		struct HeadRelatedData
		{
		public:
			HeadRelatedData();
			~HeadRelatedData() = default;

			TES_HEAP_REDEFINE_NEW();

			// members
			BGSColorForm*  hairColor;    // 00 - HCLF
			BGSTextureSet* faceDetails;  // 08 - FTST
		};
		static_assert(sizeof(HeadRelatedData) == 0x10);

		union Sounds
		{
			TESNPC*         soundCreature;
			CreatureSounds* creatureSounds;
		};
		static_assert(sizeof(Sounds) == 0x8);

		struct FaceData
		{
		public:
			struct Morphs
			{
				enum
				{
					kNose_LongShort = 0,
					kNose_UpDown = 1,
					kJaw_UpDown = 2,
					kJaw_NarrowWide = 3,
					kJaw_ForwardBack = 4,
					kCheeks_UpDown = 5,
					kCheeks_ForwardBack = 6,
					kEyes_UpDown = 7,
					kEyes_InOut = 8,
					kBrows_UpDown = 9,
					kBrows_InOut = 10,
					kBrows_ForwardBack = 11,
					kLips_UpDown = 12,
					kLips_InOut = 13,
					kChin_NarrowWide = 14,
					kChin_UpDown = 15,
					kChin_UnderbiteOverbite = 16,
					kEyes_ForwardBack = 17,
					kUnk = 18,

					kTotal = 19
				};
			};

			struct Parts
			{
				enum
				{
					kNose = 0,
					kUnknown = 1,
					kEyes = 2,
					kMouth = 3,

					kTotal = 4
				};
			};

			enum
			{
				kDefault = 0x7F7FFFFF,
				kTotalPresets = 4
			};

			// members
			float        morphs[Morphs::kTotal];  // 00 - NAM9
			std::int32_t parts[Parts::kTotal];    // 4C - NAMA
		};
		static_assert(sizeof(FaceData) == 0x5C);

		struct Layer
		{
		public:
			[[nodiscard]] float GetInterpolationValue() const;

			// members
			Color         tintColor;           // 00 - TINC
			std::uint16_t tintIndex;           // 04 - TINI
			std::uint16_t preset;              // 06 - TIAS
			std::uint16_t interpolationValue;  // 08 - TINV - CK value * 100 as an int
			std::uint16_t pad0A;               // 0A
			std::uint32_t pad0C;               // 0C
		};
		static_assert(sizeof(Layer) == 0x10);

		~TESNPC() override;  // 00

		// override (TESActorBase)
		void            InitializeData() override;                                                                                                                                // 04
		void            ClearData() override;                                                                                                                                     // 05
		bool            Load(TESFile* a_mod) override;                                                                                                                            // 06
		bool            FindInFileFast(TESFile* a_mod) override;                                                                                                                  // 0C
		void            SaveGame(BGSSaveFormBuffer* a_buf) override;                                                                                                              // 0E
		void            LoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                              // 0F
		void            Revert(BGSLoadFormBuffer* a_buf) override;                                                                                                                // 12
		void            InitItemImpl() override;                                                                                                                                  // 13
		const char*     GetTextForParsedSubTag(const BSFixedString& a_tag) const override;                                                                                        // 2E
		void            Copy(TESForm* a_srcForm) override;                                                                                                                        // 2F
		bool            Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		void            UnClone3D(TESObjectREFR* a_ref) override;                                                                                                                 // 41
		void            SetObjectVoiceType(BGSVoiceType* a_voiceType) override;                                                                                                   // 48 - { TESActorBaseData::voice = a_voiceType; }
		BGSVoiceType*   GetObjectVoiceType() const override;                                                                                                                      // 49
		NiAVObject*     Clone3D(TESObjectREFR* a_ref) override;                                                                                                                   // 4A
		bool            GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C
		bool            CalculateDoFavor(Actor* a_activator, bool a_arg2, TESObjectREFR* a_toActivate, float a_arg3) override;                                                    // 4D
		TESCombatStyle* GetCombatStyle() override;                                                                                                                                // 54 - { return combatStyle; }
		void            SetCombatStyle(TESCombatStyle* a_combatStyle) override;                                                                                                   // 55 - { combatStyle = a_combatStyle; }

		// override (TESActorBaseData)
		void CopyFromTemplateForms(TESActorBase** a_templateForms) override;  // 04

		// override (ActorValueOwner)
		float GetActorValue(ActorValue a_akValue) override;                 // 01
		void  SetActorValue(ActorValue a_akValue, float a_value) override;  // 07

		// override (BSTEventSink<MenuOpenCloseEvent>)
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01

		bool                         AddPerk(BGSPerk* a_perk, std::int8_t a_rank);
		bool                         AddPerks(const std::vector<BGSPerk*>& a_perks, std::int8_t a_rank);
		void                         ChangeHeadPart(BGSHeadPart* a_target);
		bool                         ContainsKeyword(std::string_view a_editorID);
		[[nodiscard]] BGSHeadPart**  GetBaseOverlays() const;
		BGSHeadPart*                 GetCurrentHeadPartByType(HeadPartType a_type);
		BGSHeadPart*                 GetHeadPartByType(HeadPartType a_type);
		BGSHeadPart*                 GetHeadPartOverlayByType(HeadPartType a_type);
		[[nodiscard]] float          GetHeight() const;
		[[nodiscard]] std::uint32_t  GetNumBaseOverlays() const;
		std::optional<std::uint32_t> GetPerkIndex(BGSPerk* a_perk) const;
		TESSpellList::SpellData*     GetSpellList();
		TESRace*                     GetRace();
		TESNPC*                      GetRootFaceNPC();
		[[nodiscard]] const TESNPC*  GetRootFaceNPC() const;
		[[nodiscard]] SEX            GetSex() const;
		bool                         HasApplicableKeywordString(std::string_view a_editorID);
		bool                         HasOverlays();
		bool                         IsInFaction(TESFaction* a_faction) const;
		bool                         RemovePerk(BGSPerk* a_perk);
		bool                         RemovePerks(const std::vector<BGSPerk*>& a_perks);
		bool                         SetDefaultOutfit(BGSOutfit* a_outfit);
		void                         SetFaceTexture(BGSTextureSet* a_textureSet);
		void                         SetHairColor(BGSColorForm* a_hairColor);
		void                         SetSkinFromTint(NiColorA* a_result, TintMask* a_tintMask, bool a_fromTint);
		bool                         SetSleepOutfit(BGSOutfit* a_outfit);
		void                         UpdateNeck(BSFaceGenNiNode* a_faceNode);

		// members
		Skills                                      playerSkills;     // 190 - DNAM
		TESClass*                                   npcClass;         // 1C0 - CNAM
		HeadRelatedData*                            headRelatedData;  // 1C8
		BGSListForm*                                giftFilter;       // 1D0 - GNAM
		TESCombatStyle*                             combatStyle;      // 1D8 - ZNAM
		std::uint32_t                               fileOffset;       // 1E0
		std::uint32_t                               pad1E4;           // 1E4
		TESRace*                                    originalRace;     // 1E8
		TESNPC*                                     faceNPC;          // 1F0
		float                                       height;           // 1F8 - NAM6
		float                                       weight;           // 1FC - NAM7
		Sounds                                      sounds;           // 200 - CSCR
		BSFixedString                               shortName;        // 208 - SHRT
		TESObjectARMO*                              farSkin;          // 210 - ANAM
		BGSOutfit*                                  defaultOutfit;    // 218 - DOFT
		BGSOutfit*                                  sleepOutfit;      // 220 - SOFT
		BGSListForm*                                defaultPackList;  // 228 - DPLT
		TESFaction*                                 crimeFaction;     // 230 - CRIF
		BGSHeadPart**                               headParts;        // 238 - PNAM
		std::int8_t                                 numHeadParts;     // 240
		std::uint8_t                                unk241;           // 241
		std::uint8_t                                unk242;           // 242
		std::uint8_t                                unk243;           // 243
		std::uint8_t                                unk244;           // 244
		stl::enumeration<SOUND_LEVEL, std::uint8_t> soundLevel;       // 245 - NAM8
		Color                                       bodyTintColor;    // 246 - QNAM
		std::uint16_t                               pad24A;           // 24A
		std::uint32_t                               pad24C;           // 24C
		BSTArray<BGSRelationship*>*                 relationships;    // 250
		FaceData*                                   faceData;         // 258
		BSTArray<Layer*>*                           tintLayers;       // 260

	private:
		void CopyPerkRankArray(const std::vector<PerkRankData>& a_copiedData);
	};
	static_assert(sizeof(TESNPC) == 0x268);
}


===============================================
File: include/RE/T/TESObject.h
===============================================
#pragma once

#include "RE/T/TESForm.h"

namespace RE
{
	class NiAVObject;
	class TESObjectREFR;

	class TESObject : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObject;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kObjectValue = 1 << 1,
				kObjectFullName = 1 << 2
			};
		};

		~TESObject() override;  // 00

		// override (TESForm)
		bool                        IsObject() const override;     // 28 - { return true; }
		[[nodiscard]] std::uint32_t GetRefCount() const override;  // 2D - { return 0; }

		// add
		virtual void                        Unk_3B(void);                                // 3B - { return 0; }
		virtual bool                        IsBoundAnimObject();                         // 3C - { return false; }
		[[nodiscard]] virtual TESWaterForm* GetWaterType() const;                        // 3D - { return 0; }
		[[nodiscard]] virtual bool          IsAutoCalc() const;                          // 3E - { return false; }
		virtual void                        SetAutoCalc(bool a_autoCalc);                // 3F - { return; }
		virtual NiAVObject*                 Clone3D(TESObjectREFR* a_ref, bool a_arg3);  // 40 - { return 0; }
		virtual void                        UnClone3D(TESObjectREFR* a_ref);             // 41
		virtual bool                        IsMarker();                                  // 42
		virtual bool                        IsOcclusionMarker();                         // 43 - { return formType == FormType::Static && this == Plane/Room/PortalMarker; }
		virtual bool                        ReplaceModel();                              // 44
		virtual std::uint32_t               IncRef();                                    // 45 - { return 0; }
		virtual std::uint32_t               DecRef();                                    // 46 - { return 0; }
		virtual NiAVObject*                 LoadGraphics(TESObjectREFR* a_ref);          // 47
	};
	static_assert(sizeof(TESObject) == 0x20);
}


===============================================
File: include/RE/T/TESObjectACTI.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSOpenCloseForm.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundAnimObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESMagicTargetForm.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	class TESObjectACTI :
		public TESBoundAnimObject,         // 00
		public TESFullName,                // 30
		public TESModelTextureSwap,        // 40
		public TESMagicTargetForm,         // A8
		public BGSDestructibleObjectForm,  // 78
		public BGSOpenCloseForm,           // 88
		public BGSKeywordForm              // 90
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectACTI;
		inline static constexpr auto VTABLE = VTABLE_TESObjectACTI;
		inline static constexpr auto FORMTYPE = FormType::Activator;

		enum class ActiFlags
		{
			kNone = 0,
			kNoDisplacement = 1 << 0,
			kIgnoredBySandbox = 1 << 1,
			kIsProceduralWater = 1 << 2,
			kIsLODWater = 1 << 3
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kHasTreeLOD = 1 << 6,
				kMustUpdateAnims = 1 << 8,
				kHiddenFromLocalMap = 1 << 9,
				kIgnored = 1 << 12,
				kHasDistantLOD = 1 << 15,
				kRandomAnimStart = 1 << 16,
				kDangerous = 1 << 17,
				kIgnoresObjectInteraction = 1 << 20,
				kIsMarker = 1 << 23,
				kObstacle = 1 << 25,
				kNavMeshGeneration_Filter = 1 << 26,
				kNavMeshGeneration_BoundingBox = 1 << 27,
				kChildCanUse = 1 << 29,
				kNavMeshGeneration_Ground = 1 << 30
			};
		};

		~TESObjectACTI() override;  // 00

		// override (TESBoundAnimObject)
		void          InitializeData() override;                                                                                                                                // 04
		void          ClearData() override;                                                                                                                                     // 05
		bool          Load(TESFile* a_mod) override;                                                                                                                            // 06
		void          SaveGame(BGSSaveFormBuffer* a_buf) override;                                                                                                              // 0E
		void          LoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                              // 0F
		void          InitItemImpl() override;                                                                                                                                  // 13
		bool          GetIgnoredBySandbox() const override;                                                                                                                     // 22 - { return (flags >> 1) & 1; }
		bool          IsWater() const override;                                                                                                                                 // 2A - { return waterType != 0; }
		bool          Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		TESWaterForm* GetWaterType() const override;                                                                                                                            // 3D - { return waterType; }
		bool          GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C
		bool          CalculateDoFavor(Actor* a_activator, bool a_arg2, TESObjectREFR* a_toActivate, float a_arg3) override;                                                    // 4D

		// members
		BGSSoundDescriptorForm*                    soundLoop;      // A8 - SNAM
		BGSSoundDescriptorForm*                    soundActivate;  // B0 - VNAM
		TESWaterForm*                              waterForm;      // B8 - WNAM
		stl::enumeration<ActiFlags, std::uint16_t> flags;          // C0 - FNAM
		std::uint16_t                              padC2;          // C2
		std::uint32_t                              padC4;          // C4
	};
	static_assert(sizeof(TESObjectACTI) == 0xC8);
}


===============================================
File: include/RE/T/TESObjectANIO.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	class TESObjectANIO :
		public TESForm,             // 00
		public TESModelTextureSwap  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectANIO;
		inline static constexpr auto VTABLE = VTABLE_TESObjectANIO;
		inline static constexpr auto FORMTYPE = FormType::AnimatedObject;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESObjectANIO() override;  // 00

		// override (TESForm)
		bool        Load(TESFile* a_mod) override;                // 06
		void        InitItemImpl() override;                      // 13
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { if (formEditorID == a_str) return false; formEditorID = a_str; return true; }

		// members
		BSFixedString formEditorID;     // 58 - EDID
		BSFixedString unloadEventName;  // 60 - BNAM
	};
	static_assert(sizeof(TESObjectANIO) == 0x68);
}


===============================================
File: include/RE/T/TESObjectARMA.h
===============================================
#pragma once

#include "RE/B/BGSBipedObjectForm.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/S/Sexes.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESObject.h"
#include "RE/T/TESRaceForm.h"

namespace RE
{
	struct OBJ_ARMA  // DNAM
	{
		std::int8_t  priorities[SEXES::kTotal];  // 0
		std::int8_t  modelRange[SEXES::kTotal];  // 2
		std::int8_t  unused[SEXES::kTotal];      // 4
		std::int8_t  detectionSoundValue;        // 6
		std::uint8_t pad07;                      // 7
		float        weaponAdjust;               // 8
	};
	static_assert(sizeof(OBJ_ARMA) == 0xC);

	class TESObjectARMA :
		public TESObject,          // 00
		public TESRaceForm,        // 20
		public BGSBipedObjectForm  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectARMA;
		inline static constexpr auto VTABLE = VTABLE_TESObjectARMA;
		inline static constexpr auto FORMTYPE = FormType::Armature;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESObjectARMA() override;  // 00

		// override (TESObject)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		[[nodiscard]] bool IsValidRace(TESRace* a_sourceRace) const;
		void               GetNodeName(char* a_dstBuff, const TESObjectREFR* a_refr, const TESObjectARMO* a_armor, float a_weightOverride);

		// members
		OBJ_ARMA            data;                                 // 040 - DNAM
		std::uint32_t       pad04C;                               // 04C
		TESModelTextureSwap bipedModels[SEXES::kTotal];           // 050
		TESModelTextureSwap bipedModel1stPersons[SEXES::kTotal];  // 0C0
		BGSTextureSet*      skinTextures[SEXES::kTotal];          // 130 - NAM0 - NAM1
		BGSListForm*        skinTextureSwapLists[SEXES::kTotal];  // 140 - NAM2 - NAM3
		BSTArray<TESRace*>  additionalRaces;                      // 150 - MODL
		BGSFootstepSet*     footstepSet;                          // 168 - SNDD
		BGSArtObject*       artObject;                            // 170 - ONAM
	};
	static_assert(sizeof(TESObjectARMA) == 0x178);
}


===============================================
File: include/RE/T/TESObjectARMO.h
===============================================
#pragma once

#include "RE/B/BGSBipedObjectForm.h"
#include "RE/B/BGSBlockBashData.h"
#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBipedModelForm.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESEnchantableForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESRaceForm.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	class TESObjectARMO :
		public TESBoundObject,             // 000
		public TESFullName,                // 030
		public TESRaceForm,                // 040
		public TESEnchantableForm,         // 050
		public TESValueForm,               // 068
		public TESWeightForm,              // 078
		public BGSDestructibleObjectForm,  // 088
		public BGSPickupPutdownSounds,     // 098
		public TESBipedModelForm,          // 0B0
		public BGSEquipType,               // 1A0
		public BGSBipedObjectForm,         // 1B0
		public BGSBlockBashData,           // 1C0
		public BGSKeywordForm,             // 1D8
		public TESDescription              // 1F0
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectARMO;
		inline static constexpr auto VTABLE = VTABLE_TESObjectARMO;
		inline static constexpr auto FORMTYPE = FormType::Armor;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kShield = 1 << 6,
				kIgnored = 1 << 12
			};
		};

		// override (TESBoundObject)
		void     InitializeData() override;                    // 04
		bool     Load(TESFile* a_mod) override;                // 06
		void     SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void     LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void     InitItemImpl() override;                      // 13
		TESFile* GetDescriptionOwnerFile() const override;     // 14 - { return templateArmor ? templateArmor->GetFile(-1) : GetFile(-1); }
		void     Copy(TESForm* a_srcForm) override;            // 2F

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05

		[[nodiscard]] float          GetArmorRating();
		[[nodiscard]] TESObjectARMA* GetArmorAddon(TESRace* a_race);
		[[nodiscard]] TESObjectARMA* GetArmorAddonByMask(TESRace* a_race, BipedObjectSlot a_slot);

		// members
		std::uint32_t            armorRating;    // 200 - DNAM - CK value * 100 as a std::uint32_t
		std::uint32_t            pad204;         // 204
		BSTArray<TESObjectARMA*> armorAddons;    // 208
		TESObjectARMO*           templateArmor;  // 220 - TNAM
	};
	static_assert(sizeof(TESObjectARMO) == 0x228);
}


===============================================
File: include/RE/T/TESObjectBOOK.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSMessageIcon.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	struct OBJ_BOOK  // DATA
	{
		enum class Flag
		{
			kNone = 0,
			kAdvancesActorValue = 1 << 0,
			kCantTake = 1 << 1,
			kTeachesSpell = 1 << 2,  // takes priority over skill
			kHasBeenRead = 1 << 3
		};

		enum class Type
		{
			kBookTome = 0x00,
			kNoteScroll = static_cast<std::underlying_type_t<Type>>(-1),
		};

		union Teaches
		{
			ActorValue actorValueToAdvance;
			SpellItem* spell;
		};
		static_assert(sizeof(Teaches) == 0x8);

		[[nodiscard]] Flag GetSanitizedType() const;

		// members
		stl::enumeration<Flag, std::uint8_t> flags;    // 00
		stl::enumeration<Type, std::uint8_t> type;     // 01
		std::uint16_t                        pad02;    // 02
		std::uint32_t                        pad04;    // 04
		Teaches                              teaches;  // 08
	};
	static_assert(sizeof(OBJ_BOOK) == 0x10);

	class TESObjectBOOK :
		public TESBoundObject,             // 00
		public TESFullName,                // 30
		public TESModelTextureSwap,        // 40
		public TESIcon,                    // 78
		public TESValueForm,               // 88
		public TESWeightForm,              // 98
		public TESDescription,             // A8
		public BGSDestructibleObjectForm,  // B8
		public BGSMessageIcon,             // C8
		public BGSPickupPutdownSounds,     // E0
		public BGSKeywordForm              // F8
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectBOOK;
		inline static constexpr auto VTABLE = VTABLE_TESObjectBOOK;
		inline static constexpr auto FORMTYPE = FormType::Book;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kTeachesSkill = 1 << 5,
				kRead = 1 << 6
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESObjectBOOK() override;  // 00

		// override (TESBoundObject)
		void InitializeData() override;                                                                                                                                // 04
		void ClearData() override;                                                                                                                                     // 05 - { return TESForm::ClearData(); }
		bool Load(TESFile* a_mod) override;                                                                                                                            // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;                                                                                                              // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                              // 0F
		void InitItemImpl() override;                                                                                                                                  // 13
		bool Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		bool GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05

		[[nodiscard]] bool       TeachesSkill() const;
		[[nodiscard]] bool       TeachesSpell() const;
		[[nodiscard]] bool       IsRead() const;
		[[nodiscard]] bool       CanBeTaken() const;
		[[nodiscard]] bool       IsBookTome() const;
		[[nodiscard]] bool       IsNoteScroll() const;
		[[nodiscard]] ActorValue GetSkill() const;
		[[nodiscard]] SpellItem* GetSpell();
		bool                     Read(TESObjectREFR* a_reader);

		// members
		OBJ_BOOK       data;                 // 110 - DATA
		TESObjectSTAT* inventoryModel;       // 120 - INAM
		TESDescription itemCardDescription;  // 128 - CNAM
	};
	static_assert(sizeof(TESObjectBOOK) == 0x138);
}


===============================================
File: include/RE/T/TESObjectCELL.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSBitField.h"
#include "RE/B/BSContainer.h"
#include "RE/B/BSMultiBoundNode.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTList.h"
#include "RE/C/Color.h"
#include "RE/E/ExtraDataList.h"
#include "RE/F/FormTypes.h"
#include "RE/I/InteriorData.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTMap.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESObjectREFR.h"
#include "SKSE/Version.h"

namespace RE
{
	class TESRegionList;

	namespace BGSWaterCollisionManager
	{
		class BGSWaterUpdateI;
	}

	class BSTempEffectParticle;
	class bhkWorld;
	class BSPortalGraph;
	class NavMesh;
	class NiNode;

	class BGSTerrainVisibilityData
	{
	public:
		// members
		BSBitField<>* visData;  // 0
	};
	static_assert(sizeof(BGSTerrainVisibilityData) == 0x8);

	struct EXTERIOR_DATA  // XCLC
	{
	public:
		enum class LandHideFlag
		{
			kNone = 0,
			kQuad1 = 1 << 0,
			kQuad2 = 1 << 1,
			kQuad3 = 1 << 2,
			kQuad4 = 1 << 3
		};

		// members
		std::int32_t                                 cellX;          // 00
		std::int32_t                                 cellY;          // 04
		char*                                        maxHeightData;  // 08
		BGSTerrainVisibilityData*                    lodVisData;     // 10
		float                                        worldX;         // 18
		float                                        worldY;         // 1C
		stl::enumeration<LandHideFlag, std::uint8_t> landHideFlags;  // 20
		std::uint8_t                                 pad21;          // 21
		std::uint16_t                                pad22;          // 22
		std::uint32_t                                pad24;          // 24
	};
	static_assert(sizeof(EXTERIOR_DATA) == 0x28);

	class NavMeshArray
	{
	public:
		// members
		BSTArray<BSTSmartPointer<NavMesh>> navMeshes;  // 00
	};
	static_assert(sizeof(NavMeshArray) == 0x18);

	struct LOADED_CELL_DATA
	{
	public:
		// members
		NiPointer<BSPortalGraph>                             portalGraph;             // 000 - smart ptr
		NiPointer<NiNode>                                    cell3D;                  // 008
		void*                                                unk010;                  // 010 - smart ptr
		void*                                                unk018;                  // 018 - smart ptr
		void*                                                unk020;                  // 020 - smart ptr
		std::uint64_t                                        unk028;                  // 028
		std::uint64_t                                        unk030;                  // 030
		std::uint64_t                                        unk038;                  // 038
		BSTArray<void*>                                      unk040;                  // 040
		BSTArray<void*>                                      unk058;                  // 058
		NiTMap<TESForm*, ObjectRefHandle>                    unk070;                  // 070
		NiTMap<ObjectRefHandle, NiNode*>                     emittanceLightRefMap;    // 090
		NiTMap<ObjectRefHandle, NiPointer<BSMultiBoundNode>> multiboundRefMap;        // 0B0
		NiTMap<BSMultiBoundNode*, ObjectRefHandle>           refMultiboundMap;        // 0D0
		BSSimpleList<ObjectRefHandle>                        activatingRefs;          // 0F0
		BSSimpleList<ObjectRefHandle>                        unk100;                  // 100
		std::uint64_t                                        unk110;                  // 110
		BSTArray<void*>                                      unk118;                  // 118
		BSTArray<void*>                                      unk130;                  // 130
		BSTArray<void*>                                      unk148;                  // 148
		BGSEncounterZone*                                    encounterZone;           // 160
		std::uint32_t                                        unk168;                  // 168
		volatile mutable std::int32_t                        criticalQueuedRefCount;  // 16C
		volatile mutable std::int32_t                        queuedRefCount;          // 170
		volatile mutable std::int32_t                        queuedDistantRefCount;   // 174
		std::uint32_t                                        unk178;                  // 178
		std::uint32_t                                        unk17C;                  // 17C
	};
	static_assert(sizeof(LOADED_CELL_DATA) == 0x180);

	class TESObjectCELL :
		public TESForm,     // 000
		public TESFullName  // 020
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectCELL;
		inline static constexpr auto VTABLE = VTABLE_TESObjectCELL;
		inline static constexpr auto FORMTYPE = FormType::Cell;

		enum class Flag  // DATA
		{
			kNone = 0,
			kIsInteriorCell = 1 << 0,
			kHasWater = 1 << 1,
			kCanTravelFromHere = 1 << 2,
			kNoLODWater = 1 << 3,
			kHasTempData = 1 << 4,
			kPublicArea = 1 << 5,
			kHandChanged = 1 << 6,
			kShowSky = 1 << 7,
			kUseSkyLighting = 1 << 8,
			kWarnToLeave = 1 << 9
		};

		enum class CellState
		{
			kAttached = 7
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kFlags = 1 << 1,
				kFullName = 1 << 2,
				kOwnership = 1 << 3,
				kExteriorShort = 1 << 28,
				kExteriorChar = 1 << 29,
				kDetachTime = 1 << 30,
				kSeendData = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kPersistent = 1 << 10,
				kIgnored = 1 << 12,
				kOffLimits = 1 << 17,
				kCompressed = 1 << 18,
				kCantWait = 1 << 19
			};
		};

		union CellData
		{
			EXTERIOR_DATA* exterior;  // XCLC
			INTERIOR_DATA* interior;  // XCLL
		};
		static_assert(sizeof(CellData) == 0x8);

		~TESObjectCELL() override;  // 00

		// override (TESForm)
		void               ClearData() override;                                                                 // 05
		bool               Load(TESFile* a_mod) override;                                                        // 06
		TESForm*           CreateDuplicateForm(bool a_createEditorID, void* a_arg2) override;                    // 09 - { return 0; }
		bool               FindInFileFast(TESFile* a_mod) override;                                              // 0C
		void               SaveGame(BGSSaveFormBuffer* a_buf) override;                                          // 0E
		void               LoadGame(BGSLoadFormBuffer* a_buf) override;                                          // 0F
		void               Revert(BGSLoadFormBuffer* a_buf) override;                                            // 12
		void               InitItemImpl() override;                                                              // 13
		void               GetFormDetailedString(char* a_buf, std::uint32_t a_bufLen) override;                  // 16
		void               SetAltered(bool a_set) override;                                                      // 24
		bool               BelongsInGroup(FORM* a_form, bool a_allowParentGroups, bool a_currentOnly) override;  // 30
		void               CreateGroupData(FORM* a_form, FORM_GROUP* a_group) override;                          // 31
		const char*        GetFormEditorID() const override;                                                     // 32
		bool               SetFormEditorID(const char* a_str) override;                                          // 33
		[[nodiscard]] bool IsParentForm() override;                                                              // 34 - { return true; }
		[[nodiscard]] bool IsFormTypeChild(FormType a_type) override;                                            // 36

		TESNPC* GetActorOwner();

		inline bhkWorld* GetbhkWorld() const
		{
			using func_t = decltype(&TESObjectCELL::GetbhkWorld);
			REL::Relocation<func_t> func{ RELOCATION_ID(18536, 18995) };
			return func(this);
		}

		void                         ForEachReference(std::function<BSContainer::ForEachResult(TESObjectREFR&)> a_callback) const;
		void                         ForEachReferenceInRange(const NiPoint3& a_origin, float a_radius, std::function<BSContainer::ForEachResult(TESObjectREFR&)> a_callback) const;
		[[nodiscard]] EXTERIOR_DATA* GetCoordinates();
		[[nodiscard]] TESFaction*    GetFactionOwner();
		[[nodiscard]] INTERIOR_DATA* GetLighting();

		[[nodiscard]] inline BGSLocation* GetLocation() const
		{
			using func_t = decltype(&TESObjectCELL::GetLocation);
			REL::Relocation<func_t> func{ RELOCATION_ID(18474, 18905) };
			return func(this);
		}

		[[nodiscard]] float          GetNorthRotation();
		[[nodiscard]] TESForm*       GetOwner();
		[[nodiscard]] float          GetExteriorWaterHeight() const;
		[[nodiscard]] TESRegionList* GetRegionList(bool a_createIfMissing);
		bool                         GetWaterHeight(const NiPoint3& a_pos, float& a_waterHeight);
		[[nodiscard]] bool           IsAttached() const;
		[[nodiscard]] bool           IsExteriorCell() const;
		[[nodiscard]] bool           IsInteriorCell() const;
		void                         SetActorOwner(TESNPC* a_owner);
		void                         SetFactionOwner(TESFaction* a_owner);
		void                         SetFogColor(Color a_near, Color a_far);
		void                         SetFogPlanes(float a_near, float a_far);
		void                         SetFogPower(float a_power);
		void                         SetHandChanged(bool a_changed);
		void                         SetOwner(TESForm* a_owner);
		void                         SetPublic(bool a_public);
		[[nodiscard]] bool           UsesSkyLighting() const;

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                                                                                   \
	CellData                                             cellData;         /* 060, 068 - XCLL if interior, XCLC if exterior */ \
	TESObjectLAND*                                       cellLand;         /* 068, 070 */                                      \
	float                                                waterHeight;      /* 070, 078 - XCLW */                               \
	NavMeshArray*                                        navMeshes;        /* 078, 080 */                                      \
	BSTSet<NiPointer<TESObjectREFR>>                     references;       /* 080, 088 */                                      \
	TESForm*                                             unk0B0;           /* 0B0, 0B8 - REFR owner of cell? */                \
	BSTArray<TESObjectREFR*>                             objectList;       /* 0B8, 0C0 - persistent */                         \
	BSTArray<void*>                                      unk0D0;           /* 0D0, 0D8 */                                      \
	BSTArray<BGSWaterCollisionManager::BGSWaterUpdateI*> waterObjects;     /* 0E8, 0F0 */                                      \
	BSTArray<void*>                                      unk100;           /* 100, 108 */                                      \
	mutable BSSpinLock                                   spinLock;         /* 118, 120 */                                      \
	TESWorldSpace*                                       worldSpace;       /* 120, 128 */                                      \
	LOADED_CELL_DATA*                                    loadedData;       /* 128, 130 */                                      \
	BGSLightingTemplate*                                 lightingTemplate; /* 130, 138 - LTMP */                               \
	std::uint64_t                                        unk138;           /* 138, 140 */

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x60, 0x68);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x60, 0x68);
		}

		// members
		mutable BSSpinLock                                   grassCreateLock;   // 030
		mutable BSSpinLock                                   grassTaskLock;     // 038
		stl::enumeration<Flag, std::uint16_t>                cellFlags;         // 040
		std::uint16_t                                        cellGameFlags;     // 042
		stl::enumeration<CellState, std::uint8_t>            cellState;         // 044
		bool                                                 autoWaterLoaded;   // 045
		bool                                                 cellDetached;      // 046
		std::uint8_t                                         pad047;            // 047
		ExtraDataList                                        extraList;         // 048

#ifndef ENABLE_SKYRIM_AE
		RUNTIME_DATA_CONTENT
#endif
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(TESObjectCELL) == 0x140);
#endif
}
#undef RUNTIME_DATA


===============================================
File: include/RE/T/TESObjectCONT.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSOpenCloseForm.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundAnimObject.h"
#include "RE/T/TESContainer.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESMagicCasterForm.h"
#include "RE/T/TESMagicTargetForm.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	struct CONT_DATA
	{
		enum class Flag
		{
			kNone = 0,
			kAllowsSoundsWhenAnimation = 1 << 0,
			kRespawn = 1 << 1,
			kShowOwner = 1 << 2
		};

		stl::enumeration<Flag, std::uint8_t> flags;  // 0
	};
	static_assert(sizeof(CONT_DATA) == 0x1);

	class TESObjectCONT :
		public TESBoundAnimObject,         // 00
		public TESContainer,               // 30
		public TESFullName,                // 48
		public TESModelTextureSwap,        // 58
		public TESWeightForm,              // 90
		public TESMagicCasterForm,         // B8
		public TESMagicTargetForm,         // B9
		public BGSDestructibleObjectForm,  // A0
		public BGSOpenCloseForm            // B0
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectCONT;
		inline static constexpr auto FORMTYPE = FormType::Container;
		inline static constexpr auto VTABLE = VTABLE_TESObjectCONT;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kHasDistantLOD = 1 << 15,
				kRandomAnimStart = 1 << 16,
				kObstacle = 1 << 25,
				kNavMeshGeneration_Filter = 1 << 26,
				kNavMeshGeneration_BoundingBox = 1 << 27,
				kNavMeshGeneration_Ground = 1 << 30
			};
		};

		~TESObjectCONT() override;  // 00

		// override (TESBoundAnimObject)
		void InitializeData() override;                                                                                                                                // 04
		bool Load(TESFile* a_mod) override;                                                                                                                            // 06
		void InitItemImpl() override;                                                                                                                                  // 13
		bool Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		bool GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C
		bool CalculateDoFavor(Actor* a_activator, bool a_arg2, TESObjectREFR* a_toActivate, float a_arg3) override;                                                    // 4D

		// override (BGSOpenCloseForm)
		void HandleOpen(TESObjectREFR* a_target, TESObjectREFR* a_activator) override;   // 01
		void HandleClose(TESObjectREFR* a_target, TESObjectREFR* a_activator) override;  // 02

		// members
		CONT_DATA               data;        // B9 - DATA
		std::uint16_t           padBA;       // BA
		std::uint32_t           padBC;       // BC
		BGSSoundDescriptorForm* openSound;   // C0 - SNAM
		BGSSoundDescriptorForm* closeSound;  // C8 - QNAM
	};
	static_assert(offsetof(TESObjectCONT, data) == 0xB9);
	static_assert(sizeof(TESObjectCONT) == 0xD0);
}


===============================================
File: include/RE/T/TESObjectDOOR.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSOpenCloseForm.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundAnimObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	class TESObjectDOOR :
		public TESBoundAnimObject,         // 00
		public TESFullName,                // 30
		public TESModelTextureSwap,        // 40
		public BGSDestructibleObjectForm,  // 78
		public BGSOpenCloseForm            // 88
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectDOOR;
		inline static constexpr auto VTABLE = VTABLE_TESObjectDOOR;
		inline static constexpr auto FORMTYPE = FormType::Door;

		enum class Flag
		{
			kNone = 0,
			kAutomatic = 1 << 1,
			kHidden = 1 << 2,
			kMinimalUse = 1 << 3,
			kSliding = 1 << 4,
			kDoNotOpenInCombatSearch = 1 << 5
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kTeleportExtra = 1 << 17
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kHasDistantLOD = 1 << 15,
				kRandomAnimStart = 1 << 16,
				kIsMarker = 1 << 23
			};
		};

		~TESObjectDOOR() override;  // 00

		// override (TESBoundAnimObject)
		void        InitializeData() override;                                                                                                                                // 04
		void        ClearData() override;                                                                                                                                     // 05
		bool        Load(TESFile* a_mod) override;                                                                                                                            // 06
		void        InitItemImpl() override;                                                                                                                                  // 13
		bool        Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		NiAVObject* Clone3D(TESObjectREFR* a_ref) override;                                                                                                                   // 4A
		bool        GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C
		bool        CalculateDoFavor(Actor* a_activator, bool a_arg2, TESObjectREFR* a_toActivate, float a_arg3) override;                                                    // 4D

		// override (BGSOpenCloseForm)
		void HandleOpen(TESObjectREFR* a_target, TESObjectREFR* a_activator) override;  // 01

		static void LinkRandomTeleportDoors(TESObjectREFR* a_door, TESObjectREFR* a_linkedDoor)
		{
			using func_t = decltype(&TESObjectDOOR::LinkRandomTeleportDoors);
			REL::Relocation<func_t> func{ RELOCATION_ID(17539, 17944) };
			return func(a_door, a_linkedDoor);
		}

		// members
		std::uint64_t                        unk90;            // 90
		BGSSoundDescriptorForm*              openSound;        // 98 - SNAM
		BGSSoundDescriptorForm*              closeSound;       // A0 - ANAM
		BGSSoundDescriptorForm*              loopSound;        // A8 - BNAM
		stl::enumeration<Flag, std::uint8_t> flags;            // B0 - FNAM
		std::uint8_t                         padB1;            // B1
		std::uint16_t                        padB2;            // B2
		std::uint32_t                        padB4;            // B4
		BSTArray<TESForm*>                   randomTeleports;  // B8
	};
	static_assert(sizeof(TESObjectDOOR) == 0xD0);
}


===============================================
File: include/RE/T/TESObjectLAND.h
===============================================
#pragma once

#include "RE/B/BSTriShape.h"
#include "RE/F/FormTypes.h"
#include "RE/H/hkpMoppCode.h"
#include "RE/N/NiPoint2.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESChildCell.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class NiNode;
	class QueuedFile;

	struct OBJ_LAND
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kVertexNormals_HeightMap = 1 << 0,
			kVertexColors = 1 << 1,
			kLayers = 1 << 2,
			kMPCD = 1 << 10
		};

		// members
		stl::enumeration<Flag, std::uint32_t> flags;  // 0
	};
	static_assert(sizeof(OBJ_LAND) == 0x4);

	struct CHAR_NORM
	{
	public:
		// members
		std::int8_t x;  // 0
		std::int8_t y;  // 1
		std::int8_t z;  // 2
	};
	static_assert(sizeof(CHAR_NORM) == 0x3);

	class TESObjectLAND :
		public TESForm,      // 00
		public TESChildCell  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectLAND;
		inline static constexpr auto VTABLE = VTABLE_TESObjectLAND;
		inline static constexpr auto FORMTYPE = FormType::Land;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kCompressed = 1 << 18
			};
		};

		struct LoadedLandData
		{
		public:
			// members
			NiNode*               mesh[4];              // 0000
			float                 heights[4][289];      // 0020
			std::int8_t           percents[4][289][6];  // 1230
			std::int8_t           colors[4][289][3];    // 2D48
			CHAR_NORM             normals[4][289];      // 3AD4
			NiPointer<BSTriShape> geom[4];              // 4860
			NiPointer<BSTriShape> border;               // 4880
			NiPoint2              heightExtents;        // 4888
			TESLandTexture*       defQuadTextures[4];   // 4890
			TESLandTexture*       quadTextures[4][6];   // 48B0
			hkpMoppCode           moppCode;             // 4970
			std::uint64_t         unk49B0;              // 49B0
			std::uint64_t         unk49B8;              // 49B8
			std::uint64_t         unk49C0;              // 49C0
			std::uint64_t         unk49C8;              // 49C8
		};
		static_assert(sizeof(LoadedLandData) == 0x49D0);

		~TESObjectLAND() override;  // 00

		// override (TESForm)
		bool     Load(TESFile* a_mod) override;                                                        // 06 - { return true; }
		TESForm* CreateDuplicateForm(bool a_createEditorID, void* a_arg2) override;                    // 09
		void     SetAltered(bool a_set) override;                                                      // 24
		bool     BelongsInGroup(FORM* a_form, bool a_allowParentGroups, bool a_currentOnly) override;  // 30
		void     CreateGroupData(FORM* a_form, FORM_GROUP* a_group) override;                          // 31

		// override (TESChildCell)
		[[nodiscard]] TESObjectCELL* GetSaveParentCell() override;  // 01 - { return parentCell; }

		// members
		OBJ_LAND              data;            // 28 - DATA
		std::uint32_t         pad2C;           // 2C
		TESObjectCELL*        parentCell;      // 30
		NiPointer<QueuedFile> queuedTextures;  // 38
		LoadedLandData*       loadedData;      // 40
	};
	static_assert(sizeof(TESObjectLAND) == 0x48);
}


===============================================
File: include/RE/T/TESObjectLIGH.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSMessageIcon.h"
#include "RE/C/Color.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiColor.h"
#include "RE/T/TESBoundAnimObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	enum class TES_LIGHT_FLAGS
	{
		kNone = 0,
		kDynamic = 1 << 0,
		kCanCarry = 1 << 1,
		kNegative = 1 << 2,
		kFlicker = 1 << 3,
		kDeepCopy = 1 << 4,
		kOffByDefault = 1 << 5,
		kFlickerSlow = 1 << 6,
		kPulse = 1 << 7,
		kPulseSlow = 1 << 8,
		kSpotlight = 1 << 9,
		kSpotShadow = 1 << 10,
		kHemiShadow = 1 << 11,
		kOmniShadow = 1 << 12,
		kPortalStrict = 1 << 13,

		kType = kSpotlight | kSpotShadow | kHemiShadow | kOmniShadow
	};

	struct OBJ_LIGH  // DATA
	{
	public:
		// members
		std::int32_t                                     time;                       // 00
		std::uint32_t                                    radius;                     // 04
		Color                                            color;                      // 08
		stl::enumeration<TES_LIGHT_FLAGS, std::uint32_t> flags;                      // 0C
		float                                            fallofExponent;             // 10
		float                                            fov;                        // 14
		float                                            nearDistance;               // 18
		float                                            flickerPeriodRecip;         // 1C - CK value * 100
		float                                            flickerIntensityAmplitude;  // 20
		float                                            flickerMovementAmplitude;   // 24
	};
	static_assert(sizeof(OBJ_LIGH) == 0x28);

	class TESObjectLIGH :
		public TESBoundAnimObject,         // 000
		public TESFullName,                // 030
		public TESModelTextureSwap,        // 040
		public TESIcon,                    // 078
		public BGSMessageIcon,             // 088
		public TESWeightForm,              // 0A0
		public TESValueForm,               // 0B0
		public BGSDestructibleObjectForm,  // 0C0
		public BGSEquipType                // 0D0
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectLIGH;
		inline static constexpr auto VTABLE = VTABLE_TESObjectLIGH;
		inline static constexpr auto FORMTYPE = FormType::Light;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kRandomAnimStart = 1 << 16,
				kPortalStrict = 1 << 17,
				kObstacle = 1 << 25
			};
		};

		~TESObjectLIGH() override;  // 00

		// override (TESBoundAnimObject)
		void        InitializeData() override;                                                                                                                                // 04
		bool        Load(TESFile* a_mod) override;                                                                                                                            // 06
		void        SaveGame(BGSSaveFormBuffer* a_buf) override;                                                                                                              // 0E
		void        LoadGame(BGSLoadFormBuffer* a_buf) override;                                                                                                              // 0F
		void        InitItemImpl() override;                                                                                                                                  // 13
		bool        Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		void        UnClone3D(TESObjectREFR* a_ref) override;                                                                                                                 // 41
		NiAVObject* LoadGraphics(TESObjectREFR* a_ref) override;                                                                                                              // 47
		NiAVObject* Clone3D(TESObjectREFR* a_ref) override;                                                                                                                   // 4A

		// override (BGSEquipType)
		BGSEquipSlot* GetEquipSlot() const override;                // 04
		void          SetEquipSlot(BGSEquipSlot* a_slot) override;  // 05 - { return; }

		[[nodiscard]] constexpr bool CanBeCarried() const noexcept { return data.flags.all(TES_LIGHT_FLAGS::kCanCarry); }

		// members
		OBJ_LIGH                data;            // 0E0 - DATA
		float                   fade;            // 108 - FNAM
		std::uint32_t           pad10C;          // 10C
		BGSSoundDescriptorForm* sound;           // 110 - SNAM
		NiColor                 emittanceColor;  // 118
		std::uint32_t           pad124;          // 124
		BGSLensFlare*           lensFlare;       // 128
	};
	static_assert(sizeof(TESObjectLIGH) == 0x130);
}


===============================================
File: include/RE/T/TESObjectLoadedEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESObjectLoadedEvent
	{
	public:
		// members
		FormID        formID;  // 0
		bool          loaded;  // 4
		std::uint8_t  pad5;    // 5
		std::uint16_t pad6;    // 6
	};
	static_assert(sizeof(TESObjectLoadedEvent) == 0x8);
}


===============================================
File: include/RE/T/TESObjectMISC.h
===============================================
#pragma once

#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSMessageIcon.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	class TESObjectMISC :
		public TESBoundObject,             // 000
		public TESFullName,                // 030
		public TESModelTextureSwap,        // 040
		public TESIcon,                    // 078
		public TESValueForm,               // 088
		public TESWeightForm,              // 098
		public BGSDestructibleObjectForm,  // 0A8
		public BGSMessageIcon,             // 0B8
		public BGSPickupPutdownSounds,     // 0D0
		public BGSKeywordForm              // 0E8
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectMISC;
		inline static constexpr auto VTABLE = VTABLE_TESObjectMISC;
		inline static constexpr auto FORMTYPE = FormType::Misc;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESObjectMISC() override;  // 00

		// override (TESBoundObject)
		bool Load(TESFile* a_mod) override;                // 06
		void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void InitItemImpl() override;                      // 13

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05

		// add
		virtual void SaveImpl();                                         // 53 - { return; }
		virtual void LoadImpl(TESFile* a_mod, std::uint32_t a_chunkID);  // 54 - { return; }
		virtual void InitImpl();                                         // 55 - { return; }
	};
	static_assert(sizeof(TESObjectMISC) == 0x100);
}


===============================================
File: include/RE/T/TESObjectREFR.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSHandleRefObject.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTList.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/B/BipedObjects.h"
#include "RE/E/ExtraDataList.h"
#include "RE/F/FormTypes.h"
#include "RE/H/hkVector4.h"
#include "RE/I/IAnimationGraphManagerHolder.h"
#include "RE/M/MagicSystem.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTransform.h"
#include "RE/T/TESForm.h"
#include "SKSE/Version.h"

namespace RE
{
	enum class LOCK_LEVEL;
	class hkpCollidable;
	class Actor;
	class ActorCause;
	class BGSAnimationSequencer;
	class BGSArtObject;
	class BGSDialogueBranch;
	class BipedAnim;
	class BSAnimNoteReceiver;
	class BSFaceGenAnimationData;
	class BSFaceGenNiNode;
	class BSFlattenedBoneTree;
	class DialogueResponse;
	class Explosion;
	class InventoryChanges;
	class InventoryEntryData;
	class MagicCaster;
	class MagicTarget;
	class ModelReferenceEffect;
	class NiAVObject;
	class NiControllerManager;
	class NiControllerSequence;
	class NiNode;
	class NiObject;
	class Projectile;
	class ShaderReferenceEffect;
	class TargetEntry;
	class TESActorBase;
	class TESBoundObject;
	class TESContainer;
	class TESEffectShader;
	class TrapData;
	class TrapEntry;
	struct BGSDecalGroup;
	struct BSAnimationGraphEvent;
	struct BSAnimationUpdateData;
	struct REFR_LOCK;

	enum class ITEM_REMOVE_REASON
	{
		kRemove,
		kSteal,
		kSelling,
		kDropping,
		kStoreInContainer,
		kStoreInTeammate
	};

	struct OBJ_REFR
	{
	public:
		// members
		TESBoundObject* objectReference;  // 00
		NiPoint3        angle;            // 08
		NiPoint3        location;         // 14
	};
	static_assert(sizeof(OBJ_REFR) == 0x20);

	struct LOADED_REF_DATA
	{
	public:
		// members
		BSTSmallArray<void*>  unk00;                // 00 - handleList?
		TESWaterForm*         currentWaterType;     // 18
		float                 relevantWaterHeight;  // 20
		float                 cachedRadius;         // 24
		std::uint16_t         flags;                // 28
		std::int16_t          underwaterCount;      // 2A
		std::uint32_t         pad2C;                // 2C
		std::uint64_t         unk30;                // 30 - AIProcess::Data0B8
		std::uint64_t         unk38;                // 38
		std::uint64_t         unk40;                // 40
		std::uint64_t         unk48;                // 48
		std::uint64_t         unk50;                // 50
		std::uint64_t         unk58;                // 58
		std::uint64_t         unk60;                // 60
		NiPointer<NiAVObject> data3D;               // 68
		void*                 unk70;                // 70 - smart ptr
	};
	static_assert(sizeof(LOADED_REF_DATA) == 0x78);

	NiSmartPointer(TESObjectREFR);

	class TESObjectREFR :
		public TESForm,                              // 00
		public BSHandleRefObject,                    // 20
		public BSTEventSink<BSAnimationGraphEvent>,  // 30
		public IAnimationGraphManagerHolder          // 38
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectREFR;
		inline static constexpr auto VTABLE = VTABLE_TESObjectREFR;
		inline static constexpr auto FORMTYPE = FormType::Reference;

		using Count = std::int32_t;
		using InventoryCountMap = std::map<TESBoundObject*, Count>;
		using InventoryItemMap = std::map<TESBoundObject*, std::pair<Count, std::unique_ptr<InventoryEntryData>>>;
		using InventoryDropMap = std::map<TESBoundObject*, std::pair<Count, std::vector<ObjectRefHandle>>>;

		static inline constexpr auto DEFAULT_INVENTORY_FILTER = [](TESBoundObject&) { return true; };

		enum class MotionType  // hkpMotion::MotionType
		{
			kDynamic = 1,
			kSphereInertia = 2,
			kBoxInertia = 3,
			kKeyframed = 4,
			kFixed = 5,
			kThinBoxInertia = 6,
			kCharacter = 7
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kMoved = 1 << 1,
				kHavokMoved = 1 << 2,
				kCellChanged = 1 << 3,
				kScale = 1 << 4,
				kInventory = 1 << 5,
				kOwnershipExtra = 1 << 6,
				kBaseObject = 1 << 7,
				kItemExtraData = 1 << 10,
				kAmmoExtra = 1 << 11,
				kLockExtra = 1 << 12,
				kEmpty = 1 << 21,
				kOpenDefaultState = 1 << 22,
				kOpenState = 1 << 23,
				kPromoted = 1 << 25,
				kActivatingChildren = 1 << 26,
				kLeveledInventory = 1 << 27,
				kAnimation = 1 << 28,
				kEncZoneExtra = 1 << 29,
				kCreatedOnlyExtra = 1 << 30,
				kGameOnlyExtra = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kIsGroundPiece = 1 << 4,
				kCollisionsDisabled = 1 << 4,  // ?

				kDeleted = 1 << 5,
				kHiddenFromLocalMap = 1 << 6,  // TESObjectSTAT
				kTurnOffFire = 1 << 7,

				kInaccessible = 1 << 8,            // TESObjectDOOR
				kLODRespectsEnableState = 1 << 8,  // TESObjectSTAT
				kStartsDead = 1 << 8,              // TESNPC
				kDoesntLightWater = 1 << 8,

				kMotionBlur = 1 << 9,  // TESObjectSTAT
				kPersistent = 1 << 10,
				kInitiallyDisabled = 1 << 11,
				kIgnored = 1 << 12,

				kStartUnconscious = 1 << 13,  // TESNPC
				kSkyMarker = 1 << 13,
				kHarvested = 1 << 13,  // TESObjectTREE

				kIsFullLOD = 1 << 16,   // Actor
				kNeverFades = 1 << 16,  // TESObjectLIGH

				kDoesntLightLandscape = 1 << 17,

				kIgnoreFriendlyHits = 1 << 20,  // Actor

				kNoAIAcquire = 1 << 25,
				kCollisionGeometry_Filter = 1 << 26,
				kCollisionGeometry_BoundingBox = 1 << 27,
				kReflectedByAutoWater = 1 << 28,

				kDontHavokSettle = 1 << 29,

				kGround = 1 << 30,
				kRespawns = 1 << 30,

				kMultibound = (std::uint32_t)1 << 31
			};
		};

		~TESObjectREFR() override;  // 00

		// override (TESForm)
		void                 InitializeData() override;                                                            // 04
		void                 ClearData() override;                                                                 // 05
		bool                 Load(TESFile* a_mod) override;                                                        // 06
		TESForm*             CreateDuplicateForm(bool a_createEditorID, void* a_arg2) override;                    // 09
		bool                 CheckSaveGame(BGSSaveFormBuffer* a_buf) override;                                     // 0D
		void                 SaveGame(BGSSaveFormBuffer* a_buf) override;                                          // 0E
		void                 LoadGame(BGSLoadFormBuffer* a_buf) override;                                          // 0F
		void                 InitLoadGame(BGSLoadFormBuffer* a_buf) override;                                      // 10
		void                 FinishLoadGame(BGSLoadFormBuffer* a_buf) override;                                    // 11
		void                 Revert(BGSLoadFormBuffer* a_buf) override;                                            // 12
		void                 InitItemImpl() override;                                                              // 13
		FormType             GetSavedFormType() const override;                                                    // 15
		void                 GetFormDetailedString(char* a_buf, std::uint32_t a_bufLen) override;                  // 16
		bool                 GetRandomAnim() const override;                                                       // 18 - { return data.objectReference->GetRandomAnim(); }
		bool                 IsHeadingMarker() const override;                                                     // 1A - { return data.objectReference->formType == FormType::Light ? (flags & RecordFlags::kNeverFades) != 0 : false; }
		bool                 GetDangerous() const override;                                                        // 1B - { return data.objectReference->GetDangerous(); }
		bool                 GetObstacle() const override;                                                         // 1D - { return data.objectReference ? data.objectReference->GetObstacle() : false; }
		bool                 GetOnLocalMap() const override;                                                       // 1F - { return (flags >> 9) & 1 && data.objectReference->GetOnLocalMap(); }
		bool                 GetMustUpdate() const override;                                                       // 20 - { return data.objectReference->GetMustUpdate(); }
		void                 SetOnLocalMap(bool a_set) override;                                                   // 21
		bool                 GetIgnoredBySandbox() const override;                                                 // 22
		void                 SetDelete(bool a_set) override;                                                       // 23
		void                 SetAltered(bool a_set) override;                                                      // 24
		bool                 IsWater() const override;                                                             // 2A - { return data.objectReference ? data.objectReference->IsWater() : false; }
		TESObjectREFR*       AsReference1() override;                                                              // 2B - { return this; }
		const TESObjectREFR* AsReference2() const override;                                                        // 2C - { return this; }
		bool                 BelongsInGroup(FORM* a_form, bool a_allowParentGroups, bool a_currentOnly) override;  // 30
		void                 CreateGroupData(FORM* a_form, FORM_GROUP* a_group) override;                          // 31
		const char*          GetFormEditorID() const override;                                                     // 32

		// override (BSTEventSink<BSAnimationGraphEvent>)
		BSEventNotifyControl ProcessEvent(const BSAnimationGraphEvent* a_event, BSTEventSource<BSAnimationGraphEvent>* a_dispatcher) override;  // 01

		// override (IAnimationGraphManagerHolder)
		bool GetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_out) const override;                                                 // 02
		bool SetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_in) override;                                                        // 03
		bool PopulateGraphNodesToTarget(BSScrapArray<NiAVObject*>& a_nodes) override;                                                                      // 04
		bool ConstructAnimationGraph(BSTSmartPointer<BShkbAnimationGraph>& a_out) override;                                                                // 05
		bool SetupAnimEventSinks(const BSTSmartPointer<BShkbAnimationGraph>& a_animGraph) override;                                                        // 08
		void PostChangeAnimationManager(const BSTSmartPointer<BShkbAnimationGraph>& a_arg1, const BSTSmartPointer<BShkbAnimationGraph>& a_arg2) override;  // 0D

		// add
		virtual void                                            Predestroy();                                                                                                                                                                                                // 3B
		[[nodiscard]] virtual BGSLocation*                      GetEditorLocation1() const;                                                                                                                                                                                  // 3C
		virtual bool                                            GetEditorLocation2(NiPoint3& a_outPos, NiPoint3& a_outRot, TESForm*& a_outWorldOrCell, TESObjectCELL* a_fallback);                                                                                           // 3D
		virtual void                                            ForceEditorLocation(BGSLocation* a_location);                                                                                                                                                                // 3E
		virtual void                                            Update3DPosition(bool a_warp);                                                                                                                                                                               // 3F
		virtual void                                            UpdateSoundCallBack(bool a_endSceneAction);                                                                                                                                                                  // 40
		virtual bool                                            SetDialogueWithPlayer(bool a_flag, bool a_forceGreet, TESTopicInfo* a_topic);                                                                                                                                // 41
		virtual void                                            DamageObject(float a_objectHealth, bool a_arg3);                                                                                                                                                             // 42
		[[nodiscard]] virtual bool                              GetFullLODRef() const;                                                                                                                                                                                       // 43
		virtual void                                            SetFullLODRef(bool a_set);                                                                                                                                                                                   // 44
		[[nodiscard]] virtual BGSAnimationSequencer*            GetSequencer() const;                                                                                                                                                                                        // 45
		[[nodiscard]] virtual bool                              QCanUpdateSync() const;                                                                                                                                                                                      // 46 - { return true; }
		[[nodiscard]] virtual bool                              GetAllowPromoteToPersistent() const;                                                                                                                                                                         // 47 - { return true; }
		[[nodiscard]] virtual bool                              HasKeywordHelper(const BGSKeyword* a_keyword) const;                                                                                                                                                         // 48
		[[nodiscard]] virtual TESPackage*                       CheckForCurrentAliasPackage();                                                                                                                                                                               // 49 - { return 0; }
		[[nodiscard]] virtual BGSScene*                         GetCurrentScene() const;                                                                                                                                                                                     // 4A
		virtual void                                            SetCurrentScene(BGSScene* a_scene);                                                                                                                                                                          // 4B
		virtual bool                                            UpdateInDialogue(DialogueResponse* a_response, bool a_unused);                                                                                                                                               // 4C
		[[nodiscard]] virtual BGSDialogueBranch*                GetExclusiveBranch() const;                                                                                                                                                                                  // 4D
		virtual void                                            SetExclusiveBranch(BGSDialogueBranch* a_branch);                                                                                                                                                             // 4E
		virtual void                                            PauseCurrentDialogue();                                                                                                                                                                                      // 4F
		virtual void                                            SetActorCause(ActorCause* a_cause);                                                                                                                                                                          // 50
		[[nodiscard]] virtual ActorCause*                       GetActorCause() const;                                                                                                                                                                                       // 51
		[[nodiscard]] virtual NiPoint3                          GetStartingAngle() const;                                                                                                                                                                                    // 52
		[[nodiscard]] virtual NiPoint3                          GetStartingLocation() const;                                                                                                                                                                                 // 53
		virtual void                                            SetStartingPosition(const NiPoint3& a_pos);                                                                                                                                                                  // 54
		virtual void                                            UpdateRefLight();                                                                                                                                                                                            // 55
		virtual ObjectRefHandle                                 RemoveItem(TESBoundObject* a_item, std::int32_t a_count, ITEM_REMOVE_REASON a_reason, ExtraDataList* a_extraList, TESObjectREFR* a_moveToRef, const NiPoint3* a_dropLoc = 0, const NiPoint3* a_rotate = 0);  // 56
		virtual bool                                            AddWornItem(TESBoundObject* a_item, std::int32_t a_count, bool a_forceEquip, std::uint32_t a_arg4, std::uint32_t a_arg5);                                                                                    // 57
		virtual void                                            DoTrap1(TrapData& a_data);                                                                                                                                                                                   // 58 - { return; }
		virtual void                                            DoTrap2(TrapEntry* a_trap, TargetEntry* a_target);                                                                                                                                                           // 59 - { return; }
		virtual void                                            AddObjectToContainer(TESBoundObject* a_object, ExtraDataList* a_extraList, std::int32_t a_count, TESObjectREFR* a_fromRefr);                                                                                 // 5A
		[[nodiscard]] virtual NiPoint3                          GetLookingAtLocation() const;                                                                                                                                                                                // 5B
		[[nodiscard]] virtual MagicCaster*                      GetMagicCaster(MagicSystem::CastingSource a_source);                                                                                                                                                         // 5C
		[[nodiscard]] virtual MagicTarget*                      GetMagicTarget();                                                                                                                                                                                            // 5D
		[[nodiscard]] virtual bool                              IsChild() const;                                                                                                                                                                                             // 5E - { return false; }
		virtual TESActorBase*                                   GetTemplateActorBase();                                                                                                                                                                                      // 5F - { return 0; }
		virtual void                                            SetTemplateActorBase(TESActorBase* a_template);                                                                                                                                                              // 60 - { return; }
		[[nodiscard]] virtual BSFaceGenNiNode*                  GetFaceNodeSkinned();                                                                                                                                                                                        // 61 - { return 0; }
		[[nodiscard]] virtual BSFaceGenNiNode*                  GetFaceNode();                                                                                                                                                                                               // 62 - { return GetFaceNodeSkinned(); }
		[[nodiscard]] virtual BSFaceGenAnimationData*           GetFaceGenAnimationData();                                                                                                                                                                                   // 63 - { return 0; }
		virtual bool                                            ClampToGround();                                                                                                                                                                                             // 64
		virtual bool                                            DetachHavok(NiAVObject* a_obj3D);                                                                                                                                                                            // 65
		virtual void                                            InitHavok();                                                                                                                                                                                                 // 66
		virtual void                                            Unk_67(void);                                                                                                                                                                                                // 67 - { return; }
		virtual void                                            Unk_68(void);                                                                                                                                                                                                // 68 - { return; }
		virtual void                                            Unk_69(void);                                                                                                                                                                                                // 69 - { return; }
		virtual NiAVObject*                                     Load3D(bool a_backgroundLoading);                                                                                                                                                                            // 6A
		virtual void                                            Release3DRelatedData();                                                                                                                                                                                      // 6B
		virtual void                                            Set3D(NiAVObject* a_object, bool a_queue3DTasks = true);                                                                                                                                                     // 6C
		virtual bool                                            ShouldBackgroundClone() const;                                                                                                                                                                               // 6D
		virtual void                                            Unk_6E(void);                                                                                                                                                                                                // 6E - { return; }
		[[nodiscard]] virtual NiAVObject*                       Get3D1(bool a_firstPerson) const;                                                                                                                                                                            // 6F - { return Get3D2(); }
		[[nodiscard]] virtual NiAVObject*                       Get3D2() const;                                                                                                                                                                                              // 70
		[[nodiscard]] virtual bool                              Is3rdPersonVisible() const;                                                                                                                                                                                  // 71 - { return true; }
		virtual bool                                            PopulateGraphProjectsToLoad(void) const;                                                                                                                                                                     // 72
		[[nodiscard]] virtual NiPoint3                          GetBoundMin() const;                                                                                                                                                                                         // 73
		[[nodiscard]] virtual NiPoint3                          GetBoundMax() const;                                                                                                                                                                                         // 74
		virtual void                                            Unk_75(void);                                                                                                                                                                                                // 75 - { return 0; }
		virtual bool                                            InitNonNPCAnimation(NiNode& a_nodeForAnim);                                                                                                                                                                  // 76
		virtual bool                                            CheckAndFixSkinAndBoneOrder(NiNode& a_nodeToTest);                                                                                                                                                           // 77
		virtual void                                            Unk_78(void);                                                                                                                                                                                                // 78
		virtual void                                            ModifyAnimationUpdateData(BSAnimationUpdateData& a_data);                                                                                                                                                    // 79 - { return; }
		[[nodiscard]] virtual bool                              ShouldSaveAnimationOnUnloading() const;                                                                                                                                                                      // 7A
		[[nodiscard]] virtual bool                              ShouldSaveAnimationOnSaving() const;                                                                                                                                                                         // 7B
		[[nodiscard]] virtual bool                              ShouldPerformRevert() const;                                                                                                                                                                                 // 7C - { return true; }
		virtual void                                            UpdateAnimation(float a_delta);                                                                                                                                                                              // 7D
		[[nodiscard]] virtual const BSTSmartPointer<BipedAnim>& GetBiped1(bool a_firstPerson) const;                                                                                                                                                                         // 7E - { return GetBiped2(); }
		[[nodiscard]] virtual const BSTSmartPointer<BipedAnim>& GetBiped2() const;                                                                                                                                                                                           // 7F
		[[nodiscard]] virtual const BSTSmartPointer<BipedAnim>& GetCurrentBiped() const;                                                                                                                                                                                     // 80 - { return GetBiped2(); }
		virtual void                                            SetBiped(const BSTSmartPointer<BipedAnim>& a_biped);                                                                                                                                                         // 81 - { return; }
		virtual void                                            RemoveWeapon(BIPED_OBJECT equipIndex);                                                                                                                                                                                                // 82 - { return; }
		virtual void                                            Unk_83(void);                                                                                                                                                                                                // 83 - { return; }
																																																																			 // Virtual functions defined in TESObjectREFR after the vtable structure becomes different in VR.
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		virtual void Unk_84(void);  // 84 - sets flag 24 if the object has destructibles
#endif
		SKYRIM_REL_VR_VIRTUAL void                         SetObjectReference(TESBoundObject* a_object);                                         // 84 - sets flag 24 if the object has destructibles
		SKYRIM_REL_VR_VIRTUAL void                         MoveHavok(bool a_forceRec);                                                           // 85
		SKYRIM_REL_VR_VIRTUAL void                         GetLinearVelocity(NiPoint3& a_velocity) const;                                        // 86
		SKYRIM_REL_VR_VIRTUAL void                         SetActionComplete(bool a_set);                                                        // 87 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                         SetMovementComplete(bool a_set);                                                      // 88 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                         Disable();                                                                            // 89
		SKYRIM_REL_VR_VIRTUAL void                         ResetInventory(bool a_leveledOnly);                                                   // 8A
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL NiNode*        GetFireNode();                                                                        // 8B - { return 0; }
		SKYRIM_REL_VR_VIRTUAL void                         SetFireNode(NiNode* a_fireNode);                                                      // 8C - { return; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL NiAVObject*    GetCurrent3D() const;                                                                 // 8D - { return Get3D2(); }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL Explosion*     AsExplosion();                                                                        // 8E - { return 0; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL Projectile*    AsProjectile();                                                                       // 8F - { return 0; }
		SKYRIM_REL_VR_VIRTUAL bool                         OnAddCellPerformQueueReference(TESObjectCELL& a_cell) const;                          // 90 - { return true; }
		SKYRIM_REL_VR_VIRTUAL void                         DoMoveToHigh();                                                                       // 91 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                         TryMoveToMiddleLow();                                                                 // 92 - { return; }
		SKYRIM_REL_VR_VIRTUAL bool                         TryChangeSkyCellActorsProcessLevel();                                                 // 93 - { return false; }
		SKYRIM_REL_VR_VIRTUAL void                         Unk_94(void);                                                                         // 94 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                         TryUpdateActorLastSeenTime();                                                         // 95 - { return; }
		SKYRIM_REL_VR_VIRTUAL void                         Unk_96(void);                                                                         // 96 - related to lockpicking
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL TESObjectCELL* GetSaveParentCell() const;                                                            // 97
		SKYRIM_REL_VR_VIRTUAL void                         SetParentCell(TESObjectCELL* a_cell);                                                 // 98
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL bool           IsDead(bool a_notEssential = true) const;                                             // 99
		SKYRIM_REL_VR_VIRTUAL BSAnimNoteReceiver*          CreateAnimNoteReceiver();                                                             // 9A
		SKYRIM_REL_VR_VIRTUAL BSAnimNoteReceiver*          GetAnimNoteReceiver();                                                                // 9B
		SKYRIM_REL_VR_VIRTUAL bool                         ProcessInWater(hkpCollidable* a_collidable, float a_waterHeight, float a_deltaTime);  // 9C
		SKYRIM_REL_VR_VIRTUAL bool                         ApplyCurrent(float a_velocityTime, const hkVector4& a_velocity);                      // 9D - { return 0; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL TESAmmo*       GetCurrentAmmo() const;                                                               // 9E - { return 0; }
		[[nodiscard]] SKYRIM_REL_VR_VIRTUAL BGSDecalGroup* GetDecalGroup() const;                                                                // 9F
		SKYRIM_REL_VR_VIRTUAL bool                         Unk_A0(NiAVObject* a_node, float& a_angleX, float& a_angleZ, NiPoint3& a_pos);        // A0
		SKYRIM_REL_VR_VIRTUAL void                         UnequipItem(std::uint64_t a_arg1, TESBoundObject* a_object);                          // A1 - { return; }

		static NiPointer<TESObjectREFR> LookupByHandle(RefHandle a_refHandle);
		static bool                     LookupByHandle(RefHandle a_refHandle, NiPointer<TESObjectREFR>& a_refrOut);
		static TESObjectREFR*           FindReferenceFor3D(NiAVObject* a_object3D);

		bool                                            ActivateRef(TESObjectREFR* a_activator, uint8_t a_arg2, TESBoundObject* a_object, int32_t a_count, bool a_defaultProcessingOnly);
		ModelReferenceEffect*                           ApplyArtObject(BGSArtObject* a_artObject, float a_duration = -1.0f, TESObjectREFR* a_facingRef = nullptr, bool a_faceTarget = false, bool a_attachToCamera = false, NiAVObject* a_attachNode = nullptr, bool a_interfaceEffect = false);
		ShaderReferenceEffect*                          ApplyEffectShader(TESEffectShader* a_effectShader, float a_duration = -1.0f, TESObjectREFR* a_facingRef = nullptr, bool a_faceTarget = false, bool a_attachToCamera = false, NiAVObject* a_attachNode = nullptr, bool a_interfaceEffect = false);
		[[nodiscard]] bool                              CanBeMoved();
		ObjectRefHandle                                 CreateRefHandle();
		void                                            DoTrap(TrapData& a_data);
		void                                            DoTrap(TrapEntry* a_trap, TargetEntry* a_target);
		[[nodiscard]] NiAVObject*                       Get3D() const;
		[[nodiscard]] NiAVObject*                       Get3D(bool a_firstPerson) const;
		[[nodiscard]] TESNPC*                           GetActorOwner();
		[[nodiscard]] NiPoint3                          GetAngle() const;
		[[nodiscard]] float                             GetAngleX() const;
		[[nodiscard]] float                             GetAngleY() const;
		[[nodiscard]] float                             GetAngleZ() const;
		[[nodiscard]] float                             GetBaseHeight() const;
		[[nodiscard]] TESBoundObject*                   GetBaseObject();
		[[nodiscard]] const TESBoundObject*             GetBaseObject() const;
		[[nodiscard]] const BSTSmartPointer<BipedAnim>& GetBiped() const;
		[[nodiscard]] const BSTSmartPointer<BipedAnim>& GetBiped(bool a_firstPerson) const;
		[[nodiscard]] std::uint16_t                     GetCalcLevel(bool a_adjustLevel) const;
		[[nodiscard]] TESContainer*                     GetContainer() const;
		[[nodiscard]] BGSLocation*                      GetCurrentLocation() const;
		[[nodiscard]] const char*                       GetDisplayFullName();
		[[nodiscard]] InventoryDropMap                  GetDroppedInventory();
		[[nodiscard]] InventoryDropMap                  GetDroppedInventory(std::function<bool(TESBoundObject&)> a_filter);
		[[nodiscard]] BGSLocation*                      GetEditorLocation() const;
		[[nodiscard]] bool                              GetEditorLocation(NiPoint3& a_outPos, NiPoint3& a_outRot, TESForm*& a_outWorldOrCell, TESObjectCELL* a_fallback);
		[[nodiscard]] std::optional<double>             GetEnchantmentCharge() const;
		[[nodiscard]] TESFaction*                       GetFactionOwner();
		[[nodiscard]] ObjectRefHandle                   GetHandle();
		[[nodiscard]] float                             GetHeadingAngle(const RE::NiPoint3& a_pos, bool a_abs);
		[[nodiscard]] float                             GetHeight() const;
		[[nodiscard]] InventoryItemMap                  GetInventory();
		[[nodiscard]] InventoryItemMap                  GetInventory(std::function<bool(TESBoundObject&)> a_filter, bool a_noInit = false);
		[[nodiscard]] std::int32_t                      GetInventoryCount(bool no_init = false);
		[[nodiscard]] InventoryCountMap                 GetInventoryCounts();
		[[nodiscard]] InventoryCountMap                 GetInventoryCounts(std::function<bool(TESBoundObject&)> a_filter, bool a_noInit = false);
		[[nodiscard]] InventoryChanges*                 GetInventoryChanges(bool a_noInit = false);
		[[nodiscard]] TESObjectREFR*                    GetLinkedRef(BGSKeyword* a_keyword);
		[[nodiscard]] REFR_LOCK*                        GetLock() const;
		[[nodiscard]] LOCK_LEVEL                        GetLockLevel() const;
		[[nodiscard]] const char*                       GetName() const;
		[[nodiscard]] NiAVObject*                       GetNodeByName(const BSFixedString& a_nodeName);
		[[nodiscard]] constexpr TESBoundObject*         GetObjectReference() const noexcept { return data.objectReference; }
		[[nodiscard]] TESForm*                          GetOwner() const;
		[[nodiscard]] constexpr TESObjectCELL*          GetParentCell() const noexcept { return parentCell; }
		[[nodiscard]] constexpr NiPoint3                GetPosition() const noexcept { return data.location; }
		[[nodiscard]] constexpr float                   GetPositionX() const noexcept { return data.location.x; }
		[[nodiscard]] constexpr float                   GetPositionY() const noexcept { return data.location.y; }
		[[nodiscard]] constexpr float                   GetPositionZ() const noexcept { return data.location.z; }
		[[nodiscard]] float                             GetScale() const;
		[[nodiscard]] NiControllerSequence*             GetSequence(stl::zstring a_name) const;
		[[nodiscard]] std::uint32_t                     GetStealValue(const InventoryEntryData* a_entryData, std::uint32_t a_numItems, bool a_useMult) const;
		void                                            GetTransform(NiTransform& a_transform) const;
		[[nodiscard]] float                             GetWaterHeight() const;
		[[nodiscard]] float                             GetWeight() const;
		[[nodiscard]] float                             GetWeightInContainer();
		[[nodiscard]] TESWorldSpace*                    GetWorldspace() const;
		[[nodiscard]] bool                              HasCollision() const;
		[[nodiscard]] bool                              HasContainer() const;
		[[nodiscard]] bool                              HasKeyword(const BGSKeyword* a_keyword) const;
		[[nodiscard]] bool                              HasKeywordInArray(const std::vector<BGSKeyword*>& a_keywords, bool a_matchAll) const;
		[[nodiscard]] bool                              HasKeywordInList(BGSListForm* a_keywordList, bool a_matchAll) const;
		[[nodiscard]] bool                              HasQuestObject() const;
		void                                            InitChildActivates(TESObjectREFR* a_actionRef);
		bool                                            InitInventoryIfRequired(bool a_ignoreContainerExtraData = false);
		ModelReferenceEffect*                           InstantiateHitArt(BGSArtObject* a_art, float a_dur, TESObjectREFR* a_facingRef, bool a_faceTarget, bool a_attachToCamera, NiAVObject* a_attachNode = nullptr, bool a_interfaceEffect = false);
		ShaderReferenceEffect*                          InstantiateHitShader(TESEffectShader* a_shader, float a_dur, TESObjectREFR* a_facingRef = nullptr, bool a_faceTarget = false, bool a_attachToCamera = false, NiAVObject* a_attachNode = nullptr, bool a_interfaceEffect = false);
		[[nodiscard]] bool                              Is3DLoaded() const;
		[[nodiscard]] bool                              IsActivationBlocked() const;
		[[nodiscard]] bool                              IsAnOwner(const Actor* a_testOwner, bool a_useFaction, bool a_requiresOwner) const;
		[[nodiscard]] bool                              IsCrimeToActivate();
		[[nodiscard]] bool                              IsDisabled() const;
		[[nodiscard]] bool                              IsEnchanted() const;
		[[nodiscard]] bool                              IsHorse() const;
		[[nodiscard]] bool                              IsInitiallyDisabled() const;
		[[nodiscard]] bool                              IsInWater() const;
		[[nodiscard]] bool                              IsLocked() const;
		[[nodiscard]] bool                              IsMarkedForDeletion() const;
		[[nodiscard]] bool                              IsOffLimits();
		[[nodiscard]] bool                              IsPersistent() const;
        [[nodiscard]] float                             IsPointDeepUnderWater(float a_zPos, TESObjectCELL* a_cell) const;
        [[nodiscard]] bool                              IsPointSubmergedMoreThan(const NiPoint3& a_pos, TESObjectCELL* a_cell, float a_waterLevel) const;
		void                                            MoveTo(TESObjectREFR* a_target);
		bool                                            MoveToNode(TESObjectREFR* a_target, const BSFixedString& a_nodeName);
		bool                                            MoveToNode(TESObjectREFR* a_target, NiAVObject* a_node);
		NiPointer<TESObjectREFR>                        PlaceObjectAtMe(TESBoundObject* a_baseToPlace, bool a_forcePersist) const;
		void                                            PlayAnimation(stl::zstring a_from, stl::zstring a_to);
		void                                            PlayAnimation(NiControllerManager* a_manager, NiControllerSequence* a_toSeq, NiControllerSequence* a_fromSeq);
		void                                            SetActivationBlocked(bool a_blocked);
		void                                            SetCollision(bool a_enable);
		bool                                            SetDisplayName(const BSFixedString& a_name, bool a_force);
		void                                            SetEncounterZone(BGSEncounterZone* a_zone);
		bool                                            SetMotionType(MotionType a_motionType, bool a_allowActivate = true);
		void                                            SetPosition(float a_x, float a_y, float a_z);
		void                                            SetPosition(NiPoint3 a_pos);

		struct REFERENCE_RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                 \
	std::uint64_t unk88;        /* 88, 90 */ \
	std::uint16_t refScale;     /* 90, 98 */ \
	std::int8_t   modelState;   /* 92, 9A */ \
	bool          preDestroyed; /* 93, 9B */ \
	std::uint32_t pad94;        /* 94, 9C */

			RUNTIME_DATA_CONTENT
		};

		[[nodiscard]] inline REFERENCE_RUNTIME_DATA& GetReferenceRuntimeData() noexcept
		{
			return REL::RelocateMemberIfNewer<REFERENCE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x88, 0x90);
		}

		[[nodiscard]] inline const REFERENCE_RUNTIME_DATA& GetReferenceRuntimeData() const noexcept
		{
			return REL::RelocateMemberIfNewer<REFERENCE_RUNTIME_DATA>(SKSE::RUNTIME_SSE_1_6_629, this, 0x88, 0x90);
		}

		// members
		OBJ_REFR         data;          // 40
		TESObjectCELL*   parentCell;    // 60
		LOADED_REF_DATA* loadedData;    // 68
		ExtraDataList    extraList;     // 70

#ifndef ENABLE_SKYRIM_AE
		RUNTIME_DATA_CONTENT
#endif

	private:
		InventoryChanges* ForceInitInventoryChanges();
		InventoryChanges* MakeInventoryChanges();
		void              MoveTo_Impl(const ObjectRefHandle& a_targetHandle, TESObjectCELL* a_targetCell, TESWorldSpace* a_selfWorldSpace, const NiPoint3& a_position, const NiPoint3& a_rotation);
		void              PlayAnimation_Impl(NiControllerManager* a_manager, NiControllerSequence* a_toSeq, NiControllerSequence* a_fromSeq, bool a_arg4 = false);
	};
#ifndef ENABLE_SKYRIM_AE
	static_assert(sizeof(TESObjectREFR) == 0x98);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/T/TESObjectSTAT.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESModelTextureSwap.h"

namespace RE
{
	struct TESObjectSTATData  // DNAM
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kConsideredSnow = 1 << 0
		};

		// members
		float                                 materialThresholdAngle;  // 00 - (30 - 120)
		std::uint32_t                         pad04;                   // 04
		BGSMaterialObject*                    materialObj;             // 08
		stl::enumeration<Flag, std::uint32_t> flags;                   // 10
		std::uint32_t                         pad14;                   // 14
	};
	static_assert(sizeof(TESObjectSTATData) == 0x18);

	class TESObjectSTAT :
		public TESBoundObject,      // 00
		public TESModelTextureSwap  // 30
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectSTAT;
		inline static constexpr auto VTABLE = VTABLE_TESObjectSTAT;
		inline static constexpr auto FORMTYPE = FormType::Static;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNeverFades = 1 << 2,
				kDeleted = 1 << 5,
				kIsSkyObject = kDeleted,
				kHasTreeLOD = 1 << 6,
				kAddOnLODObject = 1 << 7,
				kHiddenFromLocalMap = 1 << 9,
				kHasDistantLOD = 1 << 15,
				kUsesHDLODTexture = 1 << 17,
				kHasCurrents = 1 << 19,
				kIsMarker = 1 << 23,
				kObstacle = 1 << 25,
				kNavMeshGeneration_Filter = 1 << 26,
				kNavMeshGeneration_BoundingBox = 1 << 27,
				kShowInWorldMap = 1 << 28,
				kNavMeshGeneration_Ground = 1 << 30
			};
		};

		~TESObjectSTAT() override;  // 00

		// override (TESBoundObject)
		void               ClearData() override;              // 05
		bool               Load(TESFile* a_mod) override;     // 06
		void               InitItemImpl() override;           // 13
		bool               GetPlayable() const override;      // 19 - { return true; }
		[[nodiscard]] bool IsHeadingMarker() const override;  // 1A - { return (flags >> 2) & 1; }

		[[nodiscard]] bool HasTreeLOD() const;
		[[nodiscard]] bool IsSkyObject() const;
		[[nodiscard]] bool IsSnowObject() const;

		// members
		TESObjectSTATData data;  // 68 - DNAM
	};
	static_assert(sizeof(TESObjectSTAT) == 0x80);
}


===============================================
File: include/RE/T/TESObjectTREE.h
===============================================
#pragma once

#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/B/BSTArray.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiPoint3.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESProduceForm.h"

namespace RE
{
	struct OBJ_TREE  // CNAM
	{
		float trunkFlexibility;   // 00
		float branchFlexibility;  // 04
		float trunkAmplitude;     // 08
		float frontAmplitude;     // 0C
		float backAmplitude;      // 10
		float sideAmplitude;      // 14
		float frontFrequency;     // 18
		float backFrequency;      // 1C
		float sideFrequency;      // 20
		float leafFlexibility;    // 24
		float leafAmplitude;      // 28
		float leafFrequency;      // 2C
	};
	static_assert(sizeof(OBJ_TREE) == 0x30);

	struct BoneData
	{
		NiMatrix3     localBoneRotation;             // 00
		NiPoint3      worldBoneDir;                  // 24
		std::uint32_t parentWorldBoneRotationIndex;  // 30
	};
	static_assert(sizeof(BoneData) == 0x34);

	struct BaseTreeData : public BSIntrusiveRefCounted
	{
		std::uint32_t       pad04;                     // 04
		BSTArray<BoneData>  branchBoneData;            // 08
		BSTArray<NiMatrix3> parentWorldBoneRotations;  // 20
	};
	static_assert(sizeof(BaseTreeData) == 0x38);

	class TESObjectTREE :
		public TESBoundObject,  // 00
		public TESModel,        // 30
		public TESFullName,     // 58
		public TESProduceForm   // 68
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectTREE;
		inline static constexpr auto VTABLE = VTABLE_TESObjectTREE;
		inline static constexpr auto FORMTYPE = FormType::Tree;

		enum class etTreeType
		{
			kShortAndThin = 0,
			kShortAndThick = 1,
			kTallAndThin = 2,
			kTallAndThick = 3
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kHasDistantLOD = 1 << 15
			};
		};

		~TESObjectTREE() override;  // 00

		// override (TESBoundObject)
		void InitializeData() override;                                                                                                                                // 04
		bool Load(TESFile* a_mod) override;                                                                                                                            // 06
		void InitItemImpl() override;                                                                                                                                  // 13
		bool Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37
		bool ReplaceModel() override;                                                                                                                                  // 44
		bool GetActivateText(TESObjectREFR* a_activator, BSString& a_dst) override;                                                                                    // 4C
		void OnRemove3D(NiAVObject* a_obj3D) override;                                                                                                                 // 4F
		void OnCheckModels() override;                                                                                                                                 // 50 - { return; }
		void OnCopyReference() override;                                                                                                                               // 51 - { return; }
		void OnFinishScale() override;                                                                                                                                 // 52 - { return; }

		// members
		OBJ_TREE                                    data;      // 88
		BaseTreeData*                               baseData;  // B8
		stl::enumeration<etTreeType, std::uint32_t> type;      // C0
		std::uint32_t                               padC4;     // C4
	};
	static_assert(sizeof(TESObjectTREE) == 0xC8);
}


===============================================
File: include/RE/T/TESObjectWEAP.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BGSBlockBashData.h"
#include "RE/B/BGSDestructibleObjectForm.h"
#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSMessageIcon.h"
#include "RE/B/BGSPickupPutdownSounds.h"
#include "RE/B/BGSPreloadable.h"
#include "RE/F/FormTypes.h"
#include "RE/S/SoundLevels.h"
#include "RE/T/TESAttackDamageForm.h"
#include "RE/T/TESBoundObject.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESEnchantableForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESIcon.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESModelTextureSwap.h"
#include "RE/T/TESValueForm.h"
#include "RE/T/TESWeightForm.h"

namespace RE
{
	enum class WEAPONHITBEHAVIOR
	{
		kNormal = 0,
		kDismemberOnly = 1,
		kExplodeOnly = 2,
		kNoDismemberOrExplode = 3
	};

	enum class WEAPON_RUMBLE_PATTERN
	{
		kConstant = 0,
		kPeriodicSquare = 1,
		kPeriodicTriangle = 2,
		kPeriodicSawtooth = 3
	};

	struct WeaponTypes
	{
		enum WEAPON_TYPE : std::uint32_t
		{
			kHandToHandMelee = 0,
			kOneHandSword = 1,
			kOneHandDagger = 2,
			kOneHandAxe = 3,
			kOneHandMace = 4,
			kTwoHandSword = 5,
			kTwoHandAxe = 6,
			kBow = 7,
			kStaff = 8,
			kCrossbow = 9,

			kTotal = 10
		};
	};
	using WEAPON_TYPE = WeaponTypes::WEAPON_TYPE;

	class TESObjectWEAP :
		public TESBoundObject,             // 000
		public TESFullName,                // 030
		public TESModelTextureSwap,        // 040
		public TESIcon,                    // 078
		public TESEnchantableForm,         // 088
		public TESValueForm,               // 0A0
		public TESWeightForm,              // 0B0
		public TESAttackDamageForm,        // 0C0
		public BGSDestructibleObjectForm,  // 0D0
		public BGSEquipType,               // 0E0
		public BGSPreloadable,             // 0F0
		public BGSMessageIcon,             // 0F8
		public BGSPickupPutdownSounds,     // 110
		public BGSBlockBashData,           // 128
		public BGSKeywordForm,             // 140
		public TESDescription              // 158
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESObjectWEAP;
		inline static constexpr auto VTABLE = VTABLE_TESObjectWEAP;
		inline static constexpr auto FORMTYPE = FormType::Weapon;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kNonPlayable = 1 << 2,
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct RangedData
		{
		public:
			// members
			float                                                  sightFOV;                        // 00
			float                                                  unk04;                           // 04
			float                                                  firingRumbleLeftMotorStrength;   // 08
			float                                                  firingRumbleRightMotorStrength;  // 0C
			float                                                  firingRumbleDuration;            // 10
			stl::enumeration<WEAPON_RUMBLE_PATTERN, std::uint32_t> rumblePattern;                   // 14
			std::int8_t                                            numProjectiles;                  // 18
			std::uint8_t                                           pad19;                           // 19
			std::uint16_t                                          pad1A;                           // 1A
		};
		static_assert(sizeof(RangedData) == 0x1C);

		struct Data  // DNAM
		{
		public:
			enum class Flag2
			{
				kNone = 0,
				kPlayerOnly = 1 << 0,
				kNPCsUseAmmo = 1 << 1,
				kNoJamAfterReload = 1 << 2,  // unused
				kMinorCrime = 1 << 4,
				kRangeFixed = 1 << 5,
				kNotUsedInNormalCombat = 1 << 6,
				kDontUse3rdPersonISAnim = 1 << 8,  // unused
				kBurstShot = 1 << 9,
				kRumbleAlternate = 1 << 10,
				kLongBursts = 1 << 11,
				kNonHostile = 1 << 12,
				kBoundWeapon = 1 << 13
			};

			enum class AttackAnimation
			{
				kAttackLeft = 26,
				kAttackRight = 32,
				kAttack3 = 38,
				kAttack4 = 44,
				kAttack5 = 50,
				kAttack7 = 62,
				kAttack8 = 68,
				kAttackLoop = 74,
				kAttackSpin = 80,
				kAttackSpin2 = 86,
				kPlaceMine = 97,
				kPlaceMine2 = 103,
				kAttackThrow = 109,
				kAttackThrow2 = 115,
				kAttackThrow3 = 121,
				kAttackThrow4 = 127,
				kAttackThrow5 = 133,
				kDefault = 255
			};

			enum class Flag
			{
				kNone = 0,
				kIgnoresNormalWeaponResistance = 1 << 0,
				kAutomatic = 1 << 1,  // unused
				kHasScope = 1 << 2,   // unused
				kCantDrop = 1 << 3,
				kHideBackpack = 1 << 4,              // unused
				kEmbeddedWeapon = 1 << 5,            // unused
				kDontUseFirstPersonISAnim = 1 << 6,  // unused
				kNonPlayable = 1 << 7
			};

			// members
			RangedData*                                        rangedData;           // 00
			float                                              speed;                // 08
			float                                              reach;                // 0C
			float                                              minRange;             // 10
			float                                              maxRange;             // 14
			float                                              animationAttackMult;  // 18
			float                                              unk1C;                // 1C
			float                                              staggerValue;         // 20
			stl::enumeration<WEAPONHITBEHAVIOR, std::uint32_t> hitBehavior;          // 24
			stl::enumeration<ActorValue, std::uint32_t>        skill;                // 28
			stl::enumeration<ActorValue, std::uint32_t>        resistance;           // 2C
			stl::enumeration<Flag2, std::uint16_t>             flags2;               // 30
			std::uint8_t                                       baseVATSToHitChance;  // 32
			stl::enumeration<AttackAnimation, std::uint8_t>    attackAnimation;      // 33
			stl::enumeration<ActorValue, std::uint8_t>         embeddedWeaponAV;     // 34 - unused
			stl::enumeration<WEAPON_TYPE, std::uint8_t>        animationType;        // 35
			stl::enumeration<Flag, std::uint8_t>               flags;                // 36
			std::uint8_t                                       unk37;                // 37
		};
		static_assert(sizeof(Data) == 0x38);

		struct CriticalData  // CRDT
		{
		public:
			enum Flag
			{
				kNone = 0,
				kOnDeath = 1 << 0
			};

			// members
			float                                prcntMult;  // 00
			std::uint32_t                        pad04;      // 04
			SpellItem*                           effect;     // 08
			std::uint16_t                        damage;     // 10
			stl::enumeration<Flag, std::uint8_t> flags;      // 12
			std::uint8_t                         pad13;      // 13
			std::uint32_t                        pad14;      // 14
		};
		static_assert(sizeof(CriticalData) == 0x18);

		struct Unk1B8
		{
		public:
			// members
			TESModel         unk00;  // 00
			TESEffectShader* unk28;  // 28
		};
		static_assert(sizeof(Unk1B8) == 0x30);

		~TESObjectWEAP() override;  // 00

		// override (TESBoundObject)
		void        InitializeData() override;                    // 04
		void        ClearData() override;                         // 05
		bool        Load(TESFile* a_mod) override;                // 06
		void        SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void        LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void        InitItemImpl() override;                      // 13
		TESFile*    GetDescriptionOwnerFile() const override;     // 14
		bool        GetPlayable() const override;                 // 19 - { return ~((data.flags >> 7) & 1); }
		const char* GetObjectTypeName() const override;           // 39 - { return g_animationStrings[data.animationType]; }

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05

		[[nodiscard]] float         GetSpeed() const;
		[[nodiscard]] float         GetReach() const;
		[[nodiscard]] float         GetStagger() const;
		[[nodiscard]] float         GetMinRange() const;
		[[nodiscard]] float         GetMaxRange() const;
		[[nodiscard]] std::uint16_t GetCritDamage() const;
		NiAVObject*                 GetFireNode(NiAVObject* a_root) const;
		void                        GetNodeName(char* a_dstBuff) const;
		[[nodiscard]] WEAPON_TYPE   GetWeaponType() const;
		[[nodiscard]] bool          IsBound() const;
		[[nodiscard]] bool          IsMelee() const;
		[[nodiscard]] bool          IsRanged() const;
		[[nodiscard]] bool          IsHandToHandMelee() const;
		[[nodiscard]] bool          IsOneHandedSword() const;
		[[nodiscard]] bool          IsOneHandedDagger() const;
		[[nodiscard]] bool          IsOneHandedAxe() const;
		[[nodiscard]] bool          IsOneHandedMace() const;
		[[nodiscard]] bool          IsTwoHandedSword() const;
		[[nodiscard]] bool          IsTwoHandedAxe() const;
		[[nodiscard]] bool          IsBow() const;
		[[nodiscard]] bool          IsStaff() const;
		[[nodiscard]] bool          IsCrossbow() const;

		// members
		Data                                         weaponData;              // 168 - DNAM
		CriticalData                                 criticalData;            // 1A0 - CRDT
		Unk1B8*                                      unk1B8;                  // 1B8
		BGSSoundDescriptorForm*                      attackSound;             // 1C0 - SNAM
		BGSSoundDescriptorForm*                      attackSound2D;           // 1C8 - XNAM
		BGSSoundDescriptorForm*                      attackLoopSound;         // 1D0 - NAM7
		BGSSoundDescriptorForm*                      attackFailSound;         // 1D8 - TNAM
		BGSSoundDescriptorForm*                      idleSound;               // 1E0 - UNAM
		BGSSoundDescriptorForm*                      equipSound;              // 1E8 - NAM9
		BGSSoundDescriptorForm*                      unequipSound;            // 1F0 - NAM8
		BGSImpactDataSet*                            impactDataSet;           // 1F8
		TESObjectSTAT*                               firstPersonModelObject;  // 200 - WNAM
		TESObjectWEAP*                               templateWeapon;          // 208 - CNAM
		BSFixedString                                embeddedNode;            // 210
		stl::enumeration<SOUND_LEVEL, std::uint32_t> soundLevel;              // 218 - VNAM
		std::uint32_t                                pad21C;                  // 21C
	};
	static_assert(sizeof(TESObjectWEAP) == 0x220);
}


===============================================
File: include/RE/T/TESOpenCloseEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESOpenCloseEvent
	{
		NiPointer<TESObjectREFR> ref;        // 00
		NiPointer<TESObjectREFR> activeRef;  // 08
		bool                     opened;     // 10
		std::uint8_t             pad11;      // 11
		std::uint16_t            pad12;      // 12
		std::uint32_t            pad14;      // 14
	};
	static_assert(sizeof(TESOpenCloseEvent) == 0x18);
}


===============================================
File: include/RE/T/TESPackage.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class BGSIdleCollection;
	class PackageLocation;
	class TESPackageData;

	enum class PACKAGE_OBJECT_TYPE
	{
		kNone = 0,
		kACTI = 1,
		kARMO = 2,
		kBOOK = 3,
		kCONT = 4,
		kDOOR = 5,
		kINGR = 6,
		kLIGH = 7,
		kMISC = 8,
		kFLOR = 9,
		kFURN = 10,
		kWEAP = 11,
		kAMMO = 12,
		kKEYM = 13,
		kALCH = 14,
		kFOOD = 15
	};

	enum class PACKAGE_PROCEDURE_TYPE
	{
		kNone = static_cast<std::underlying_type_t<PACKAGE_PROCEDURE_TYPE>>(-1),
		kFind = 0,
		kFollow = 1,
		kEscort = 2,
		kEat = 3,
		kSleep = 4,
		kWander = 5,
		kTravel = 6,
		kAccompany = 7,
		kUseItemAt = 8,
		kAmbush = 9,
		kFleeNotCombat = 10,
		kCastMagic = 11,
		kSandbox = 12,
		kPatrol = 13,
		kGuard = 14,
		kDialogue = 15,
		kUseWeapon = 16,
		kFind2 = 17,
		kPackage = 18,
		kPackageTemplate = 19,
		kActivate = 20,
		kAlarm = 21,
		kFlee = 22,
		kTrespass = 23,
		kSpectator = 24,
		kReactToDead = 25,
		kGetUpFromChairBed = 26,
		kDoNothing = 27,
		kInGameDialogue = 28,
		kSurface = 29,
		kSearchForAttacker = 30,
		kAvoidPlayer = 31,
		kReactToDestroyedObject = 32,
		kReactToGrenadeOrMine = 33,
		kStealWarning = 34,
		kPickPocketWarning = 35,
		kMovementBlocked = 36,
		kVampireFeed = 37,
		kCannibal = 38
	};

	enum class PACK_EVENT_ACTION_TYPE
	{
		kBegin = 0,
		kEnd,
		kChange,
		kPatrol
	};

	enum class PACK_INTERRUPT_TARGET
	{
		kNone = static_cast<std::underlying_type_t<PACK_INTERRUPT_TARGET>>(-1),
		kSpectator = 0,
		kObserveDead = 0x1,
		kGuardWarn = 0x2,
		kCombat = 0x3
	};

	struct PACKAGE_DATA  // PKDT
	{
	public:
		enum class GeneralFlag
		{
			kNone = 0,
			kOffersServices = 1 << 0,
			kMustComplete = 1 << 2,
			kMaintainSpeedAtGoal = 1 << 3,
			kUnlocksDoorsAtPackageStart = 1 << 6,
			kUnlocksDoorsAtPackageEnd = 1 << 7,
			kContinueIfPCNear = 1 << 9,
			kOncePerDay = 1 << 10,
			kPreferredSpeed = 1 << 13,
			kAlwaysSneak = 1 << 17,
			kAllowSwimming = 1 << 18,
			kIgnoreCombat = 1 << 20,
			kWeaponsUnequipped = 1 << 21,
			kWeaponDrawn = 1 << 23,
			kNoCombatAlert = 1 << 27,
			kWearSleepOutfit = 1 << 29
		};

		enum class PreferredSpeed
		{
			kWalk = 0,
			kJog = 1,
			kRun = 2,
			kFastWalk = 3
		};

		enum class InterruptFlag
		{
			kNone = 0,
			kHellosToPlayer = 1 << 0,
			kRandomConversations = 1 << 1,
			kObserveCombatBehaviour = 1 << 2,
			kGreetCorpseBehaviour = 1 << 3,
			kReactionToPlayerActions = 1 << 4,
			kFriendlyFireComments = 1 << 5,
			kAggroRadiusBehavior = 1 << 6,
			kAllowIdleChatter = 1 << 7,
			kWorldInteractions = 1 << 9
		};

		// members
		stl::enumeration<GeneralFlag, std::uint32_t>           packFlags;              // 0
		stl::enumeration<PACKAGE_PROCEDURE_TYPE, std::uint8_t> packType;               // 4
		stl::enumeration<PACK_INTERRUPT_TARGET, std::uint8_t>  interruptOverrideType;  // 5
		stl::enumeration<PreferredSpeed, std::uint8_t>         maxSpeed;               // 6
		std::uint8_t                                           pad7;                   // 7
		stl::enumeration<InterruptFlag, std::uint16_t>         foBehaviorFlags;        // 8
		std::uint16_t                                          packageSpecificFlags;   // A
	};
	static_assert(sizeof(PACKAGE_DATA) == 0xC);

	class PackageTarget
	{
	public:
		union Target
		{
			inline Target() :
				object(nullptr)
			{}

			~Target() {}

			// members
			ObjectRefHandle                                        handle;
			TESForm*                                               object;
			TESForm*                                               refOrObj;
			stl::enumeration<PACKAGE_OBJECT_TYPE, std::uint32_t>   objType;
			std::uint32_t                                          aliasID;
			stl::enumeration<PACK_INTERRUPT_TARGET, std::uint32_t> interruptTarg;
		};
		static_assert(sizeof(Target) == 0x8);

		// members
		std::int8_t   targType;  // 00
		std::uint8_t  pad01;     // 01
		std::uint16_t pad02;     // 02
		Target        target;    // 08
		std::int32_t  value;     // 10
		std::uint32_t pad14;     // 14
	};
	static_assert(sizeof(PackageTarget) == 0x18);

	struct PACK_SCHED_DATA
	{
		enum class DayOfWeek
		{
			kAny = -1,
			kSunday = 0,
			kMonday = 1,
			kTuesday = 2,
			kWednesday = 3,
			kThursday = 4,
			kFriday = 5,
			kSaturday = 6,
			kWeekdays = 7,
			kWeekends = 8,
			kMondayWednesdayFriday = 9,
			kTuesdayThursday = 10
		};

		// members
		std::int8_t                              month;      // 0
		stl::enumeration<DayOfWeek, std::int8_t> dayOfWeek;  // 1
		std::int8_t                              date;       // 2
		std::int8_t                              hour;       // 3
		std::int8_t                              minute;     // 4
		std::uint8_t                             pad5;       // 5
		std::uint8_t                             pad6;       // 6
		std::uint8_t                             pad7;       // 7
		std::int32_t                             duration;   // 8 - minutes
	};
	static_assert(sizeof(PACK_SCHED_DATA) == 0xC);

	class PackageSchedule  // PSDT
	{
	public:
		// members
		PACK_SCHED_DATA psData;  // 0
	};
	static_assert(sizeof(PackageSchedule) == 0xC);

	class PackageEventAction
	{
	public:
		struct TopicData  // PDTO
		{
			enum class Type
			{
				kTopicRef = 0,
				kTopicSubtype = 1
			};

			// members
			stl::enumeration<Type, std::uint32_t> type;   // 00
			std::uint32_t                         pad04;  // 04
			TESTopic*                             topic;  // 08
		};
		static_assert(sizeof(TopicData) == 0x10);

		// members
		TESIdleForm*                                            idle;   // 00 - INAM
		stl::enumeration<PACK_EVENT_ACTION_TYPE, std::uint32_t> type;   // 08
		std::uint32_t                                           pad0C;  // 0C
		TopicData                                               topic;  // 10 - PDTO
	};
	static_assert(sizeof(PackageEventAction) == 0x20);

	class TESPackage : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESPackage;
		inline static constexpr auto VTABLE = VTABLE_TESPackage;
		inline static constexpr auto FORMTYPE = FormType::Package;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kWaitingFlag = 1 << 26,
				kNeverRunFlag = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESPackage() override;  // 00

		// override (TESForm)
		void                      InitializeData() override;                    // 04
		void                      ClearData() override;                         // 05
		bool                      Load(TESFile* a_mod) override;                // 06
		void                      SaveGame(BGSSaveFormBuffer* a_buf) override;  // 0E
		void                      LoadGame(BGSLoadFormBuffer* a_buf) override;  // 0F
		void                      Revert(BGSLoadFormBuffer* a_buf) override;    // 12
		void                      InitItemImpl() override;                      // 13
		std::uint32_t             GetRefCount() const override;                 // 2D - { return refCount; }
		[[nodiscard]] const char* GetObjectTypeName() const override;           // 39 - { return g_packageTypeStrings[packData.packType]; }

		// add
		[[nodiscard]] virtual bool IsActorAtLocation(Actor* a_actor, bool a_arg2, float a_arg3, bool a_arg4);                      // 3B
		[[nodiscard]] virtual bool IsActorAtSecondLocation(Actor* a_arg1, Actor* a_arg2, bool a_arg3, float a_arg4, bool a_arg5);  // 3C
		[[nodiscard]] virtual bool IsActorAtRefTarget(Actor* a_actor, std::int32_t a_arg2);                                        // 3D
		[[nodiscard]] virtual bool IsTargetAtLocation(Actor* a_actor, std::int32_t a_arg2);                                        // 3E
		[[nodiscard]] virtual bool IsPackageOwner(Actor* a_actor);                                                                 // 3F - { return true; }

		// members
		PACKAGE_DATA                                            packData;        // 20 - PKDT
		std::uint32_t                                           pad2C;           // 2C
		TESPackageData*                                         data;            // 30
		PackageLocation*                                        packLoc;         // 38
		PackageTarget*                                          packTarg;        // 40
		BGSIdleCollection*                                      idleCollection;  // 48
		PackageSchedule                                         packSched;       // 50 - PSDT
		std::uint32_t                                           pad5C;           // 5C
		TESCondition                                            packConditions;  // 60
		TESCombatStyle*                                         combatStyle;     // 68 - CNAM
		TESQuest*                                               ownerQuest;      // 70 - QNAM
		PackageEventAction                                      onBegin;         // 78
		PackageEventAction                                      onEnd;           // 98
		PackageEventAction                                      onChange;        // B8
		stl::enumeration<PACKAGE_PROCEDURE_TYPE, std::uint32_t> procedureType;   // D8
		volatile std::uint32_t                                  refCount;        // DC
	};
	static_assert(sizeof(TESPackage) == 0xE0);
}


===============================================
File: include/RE/T/TESPackageData.h
===============================================
#pragma once

namespace RE
{
	class BGSLoadFormBuffer;
	class BGSSaveFormBuffer;
	class TESForm;

	class TESPackageData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESPackageData;

		virtual ~TESPackageData();  // 00

		// add
		virtual void Copy(TESPackageData* a_package, TESForm* a_form);  // 01 - { return; }
		virtual bool Compare(TESPackageData* a_package);                // 02 - { return true; }
		virtual void InitItem(TESForm* a_form);                         // 03 - { return; }
		virtual void SaveGame(BGSSaveFormBuffer* a_buf);                // 04 - { return; }
		virtual void LoadGame(BGSLoadFormBuffer* a_buf);                // 05 - { return; }
	};
	static_assert(sizeof(TESPackageData) == 0x8);
}


===============================================
File: include/RE/T/TESPlayerBowShotEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESPlayerBowShotEvent
	{
	public:
		// members
		FormID weapon;       // 00
		FormID ammo;         // 04
		float  shotPower;    // 08
		bool   isSunGazing;  // 09
	};
	static_assert(sizeof(TESPlayerBowShotEvent) == 0x10);
}


===============================================
File: include/RE/T/TESProduceForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class BGSSoundDescriptorForm;
	class TESBoundObject;

	struct SEASON
	{
		enum : std::uint32_t
		{
			kNone = static_cast<std::uint32_t>(-1),
			kSpring = 0,
			kSummer,
			kFall,
			kWinter,

			kTotal,
		};
	};

	class TESProduceForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESProduceForm;

		~TESProduceForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;              // 01
		void ClearDataComponent() override;                   // 02 - { return; }
		void CopyComponent(BaseFormComponent* rhs) override;  // 03

		// members
		BGSSoundDescriptorForm* harvestSound;                   // 08 - SNAM
		TESBoundObject*         produceItem;                    // 10 - PFIG
		std::int8_t             produceChance[SEASON::kTotal];  // 18 - PFPC
		std::uint32_t           pad1C;                          // 1C
	};
	static_assert(sizeof(TESProduceForm) == 0x20);
}


===============================================
File: include/RE/T/TESQualityForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESQualityForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESQualityForm;

		enum class Quality
		{
			kNovice = 0,
			kApprentice = 1,
			kJourneyman = 2,
			kExpert = 3,
			kMaster = 4
		};

		~TESQualityForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { quality = 0; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		stl::enumeration<Quality, std::uint32_t> quality;  // 08 - QUAL
		std::uint32_t                            pad0C;    // 0C
	};
	static_assert(sizeof(TESQualityForm) == 0x10);
}


===============================================
File: include/RE/T/TESQuest.h
===============================================
#pragma once

#include "RE/B/BGSStoryManagerTreeForm.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTList.h"
#include "RE/D/DialogueTypes.h"
#include "RE/F/FormTypes.h"
#include "RE/Q/QuestEvents.h"
#include "RE/Q/QuestObjectiveStates.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class BGSBaseAlias;
	class QueuedPromoteQuestTask;

	enum class QuestFlag
	{
		kStopStart = static_cast<std::underlying_type_t<QuestFlag>>(-1),
		kNone = 0,
		kEnabled = 1 << 0,
		kCompleted = 1 << 1,
		kAddIdleToHello = 1 << 2,
		kAllowRepeatStages = 1 << 3,
		kStartsEnabled = 1 << 4,
		kDisplayedInHUD = 1 << 5,
		kFailed = 1 << 6,
		kStageWait = 1 << 7,
		kRunOnce = 1 << 8,
		kExcludeFromExport = 1 << 9,
		kWarnOnAliasFillFailure = 1 << 10,
		kActive = 1 << 11,
		kRepeatsConditions = 1 << 12,
		kKeepInstance = 1 << 13,
		kWantDormant = 1 << 14,
		kHasDialogueData = 1 << 15
	};

	enum class QUEST_OBJECTIVE_FLAGS
	{
		kNone = 0,
		kORWithPrevious = 1 << 0,
		kNoStatsTracking = 1 << 1
	};

	struct BGSQuestInstanceText
	{
	public:
		struct StringData
		{
		public:
			// members
			std::uint32_t aliasID;         // 0
			std::uint32_t fullNameFormID;  // 4
		};
		static_assert(sizeof(StringData) == 0x8);

		struct GlobalValueData
		{
		public:
			// members
			const TESGlobal* global;  // 00
			float            value;   // 08
			std::uint32_t    pad0C;   // 0C
		};
		static_assert(sizeof(GlobalValueData) == 0x10);

		// members
		std::uint32_t             id;                // 00
		std::uint32_t             pad04;             // 04
		BSTArray<StringData>      stringData;        // 08
		BSTArray<GlobalValueData> valueData;         // 20
		std::uint16_t             journalStage;      // 38
		std::int8_t               journalStageItem;  // 3A
		std::uint8_t              pad3B;             // 3B
		std::uint32_t             pad3C;             // 3C
	};
	static_assert(sizeof(BGSQuestInstanceText) == 0x40);

	struct QUEST_DATA  // DNAM
	{
	public:
		enum class Type
		{
			kNone = 0,
			kMainQuest = 1,
			kMagesGuild = 2,
			kThievesGuild = 3,
			kDarkBrotherhood = 4,
			kCompanionsQuest = 5,
			kMiscellaneous = 6,
			kDaedric = 7,
			kSideQuest = 8,
			kCivilWar = 9,
			kDLC01_Vampire = 10,
			kDLC02_Dragonborn = 11
		};

		// members
		float                                      questDelayTime;  // 0
		stl::enumeration<QuestFlag, std::uint16_t> flags;           // 4
		std::int8_t                                priority;        // 6
		stl::enumeration<Type, std::uint8_t>       questType;       // 7
	};
	static_assert(sizeof(QUEST_DATA) == 0x8);

	struct QUEST_STAGE_DATA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kStartUpStage = 1 << 1,
			kShutDownStage = 1 << 2,
			kKeepInstanceDataFromHereOn = 1 << 3
		};

		// members
		std::uint16_t                        index;  // 0
		stl::enumeration<Flag, std::uint8_t> flags;  // 2
		std::uint8_t                         pad3;   // 3
		std::uint32_t                        pad4;   // 4
	};
	static_assert(sizeof(QUEST_STAGE_DATA) == 0x8);

	class TESQuestStage
	{
	public:
		explicit operator bool() const;

		// members
		QUEST_STAGE_DATA data;  // 0
	};
	static_assert(sizeof(TESQuestStage) == 0x8);

	class TESQuestTarget  // QSTA
	{
	public:
		enum class Flag
		{
			kNone = 0,
			kCompassMarkerIgnoresLocks = 1 << 0
		};

		// members
		std::uint64_t unk00;       // 00
		TESCondition  conditions;  // 08
		std::uint8_t  alias;       // 10
		std::uint8_t  unk11;       // 11
		std::uint16_t unk12;       // 12
		std::uint32_t unk14;       // 14
	};
	static_assert(sizeof(TESQuestTarget) == 0x18);

	class BGSQuestObjective
	{
	public:
		// members
		BSFixedString                                          displayText;  // 00 - NNAM
		TESQuest*                                              ownerQuest;   // 08
		TESQuestTarget**                                       targets;      // 10 - QSTA
		std::uint32_t                                          numTargets;   // 18
		std::uint16_t                                          index;        // 1C - QOBJ
		bool                                                   initialized;  // 1E
		stl::enumeration<QUEST_OBJECTIVE_STATE, std::uint8_t>  state;        // 1E
		stl::enumeration<QUEST_OBJECTIVE_FLAGS, std::uint32_t> flags;        // 20 - FNAM
		std::uint32_t                                          pad24;        // 24
	};
	static_assert(sizeof(BGSQuestObjective) == 0x28);

	class BGSStoryEvent
	{
	public:
		// members
		std::uint32_t id;          // 00
		std::uint32_t index;       // 04
		std::uint64_t members[6];  // 08
	};
	static_assert(sizeof(BGSStoryEvent) == 0x38);

	class TESQuest :
		public BGSStoryManagerTreeForm,  // 000
		public TESFullName               // 028
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESQuest;
		inline static constexpr auto VTABLE = VTABLE_TESQuest;

		using DT = DIALOGUE_TYPE;
		inline static constexpr auto FORMTYPE = FormType::Quest;

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kQuestFlags = 1 << 1,
				kQuestScriptDelay = 1 << 2,
				kQuestAlreadyRun = 1 << 26,
				kQuestInstanceData = 1 << 27,
				kQuestRuntimeData = 1 << 28,
				kQuestObjectives = 1 << 29,
				kQuestScript = 1 << 30,
				kQuestStages = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESQuest() override;  // 00

		// override (BGSStoryManagerTreeForm)
		void                                     InitializeData() override;                                      // 04
		void                                     ClearData() override;                                           // 05
		bool                                     Load(TESFile* a_mod) override;                                  // 06
		void                                     SaveGame(BGSSaveFormBuffer* a_buf) override;                    // 0E
		void                                     LoadGame(BGSLoadFormBuffer* a_buf) override;                    // 0F
		void                                     FinishLoadGame(BGSLoadFormBuffer* a_buf) override;              // 11
		void                                     Revert(BGSLoadFormBuffer* a_buf) override;                      // 12
		void                                     InitItemImpl() override;                                        // 13
		const char*                              GetFormEditorID() const override;                               // 32 - { return formEditorID.c_str(); }
		bool                                     SetFormEditorID(const char* a_str) override;                    // 33
		TESCondition*                            QConditions() override;                                         // 3D - { return &objConditions; }
		BGSStoryManagerTreeVisitor::VisitControl AcceptVisitor(BGSStoryManagerTreeVisitor& a_visitor) override;  // 3E

		ObjectRefHandle&                         CreateRefHandleByAliasID(ObjectRefHandle& a_handle, std::uint32_t a_aliasID);
		bool                                     EnsureQuestStarted(bool& a_result, bool a_startNow);
		std::uint16_t                            GetCurrentStageID() const;
		[[nodiscard]] constexpr QUEST_DATA::Type GetType() const noexcept { return data.questType.get(); }
		[[nodiscard]] bool                       IsActive() const;
		[[nodiscard]] bool                       IsCompleted() const;
		[[nodiscard]] bool                       IsEnabled() const;
		[[nodiscard]] bool                       IsRunning() const;
		[[nodiscard]] bool                       IsStarting() const;
		[[nodiscard]] bool                       IsStopped() const;
		[[nodiscard]] bool                       IsStopping() const;
		void                                     Reset();
		void                                     ResetAndUpdate();
		void                                     SetEnabled(bool a_set);
		bool                                     Start();
		[[nodiscard]] bool                       StartsEnabled() const;
		void                                     Stop();

		// members
		BSTArray<BGSQuestInstanceText*>                      instanceData;                             // 038
		std::uint32_t                                        currentInstanceID;                        // 050
		std::uint32_t                                        pad054;                                   // 054
		BSTArray<BGSBaseAlias*>                              aliases;                                  // 058
		BSTHashMap<std::uint32_t, ObjectRefHandle>           refAliasMap;                              // 070
		BSTHashMap<UnkKey, UnkValue>                         unk0A0;                                   // 0A0 - alias related
		mutable BSReadWriteLock                              aliasAccessLock;                          // 0D0
		QUEST_DATA                                           data;                                     // 0D8 - DNAM
		QuestEvent                                           eventID;                                  // 0E0 - ENAM
		std::uint32_t                                        pad0E4;                                   // 0E4
		BSSimpleList<TESQuestStage>*                         executedStages;                           // 0E8
		BSSimpleList<TESQuestStage*>*                        waitingStages;                            // 0F0
		BSSimpleList<BGSQuestObjective*>                     objectives;                               // 0F8
		TESCondition                                         objConditions;                            // 108
		TESCondition                                         storyManagerConditions;                   // 110
		BSTHashMap<BGSDialogueBranch*, BSTArray<TESTopic*>*> branchedDialogue[DT::kBranchedTotal];     // 118
		BSTArray<TESTopic*>                                  topics[DT::kTotal - DT::kBranchedTotal];  // 178
		BSTArray<BGSScene*>                                  scenes;                                   // 208
		BSTArray<TESGlobal*>*                                textGlobals;                              // 220 - QTGL
		std::uint16_t                                        currentStage;                             // 228
		bool                                                 alreadyRun;                               // 22A
		std::uint8_t                                         pad22B;                                   // 22B
		std::uint32_t                                        pad22C;                                   // 22C
		BSString                                             formEditorID;                             // 230
		const BGSStoryEvent*                                 startEventData;                           // 240
		NiPointer<QueuedPromoteQuestTask>                    promoteTask;                              // 248
		BSTArray<ObjectRefHandle>                            promotedRefs;                             // 250
	};
	static_assert(sizeof(TESQuest) == 0x268);
}


===============================================
File: include/RE/T/TESQuestStageEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESQuestStageEvent
	{
	public:
		// members
		void*         finishedCallback;  // 00
		FormID        formID;            // 08
		std::uint16_t stage;             // 0C
		std::uint8_t  unk0E;             // 0E
		std::uint8_t  pad0F;             // 0F
	};
	static_assert(sizeof(TESQuestStageEvent) == 0x10);
}


===============================================
File: include/RE/T/TESQuestStageItem.h
===============================================
#pragma once

#include "RE/B/BGSLocalizedStringDL.h"
#include "RE/T/TESCondition.h"

namespace RE
{
	class TESQuest;
	class TESQuestStage;

	struct TESQuestStageItem
	{
	public:
		// members
		TESCondition         objConditions;  // 00
		TESQuest*            nextQuest;      // 08
		BGSLocalizedStringDL logEntry;       // 10
		std::uint8_t         data;           // 14
		std::int8_t          index;          // 15
		bool                 hasLogEntry;    // 16
		std::uint8_t         pad17;          // 17
		TESQuest*            owner;          // 18
		TESQuestStage*       owningStage;    // 20
	};
	static_assert(sizeof(TESQuestStageItem) == 0x28);
}


===============================================
File: include/RE/T/TESQuestStartStopEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESQuestStartStopEvent
	{
	public:
		// members
		FormID        formID;   // 00
		bool          started;  // 04
		std::uint8_t  unk05;    // 05
		std::uint16_t pad06;    // 06
	};
	static_assert(sizeof(TESQuestStartStopEvent) == 0x8);
}


===============================================
File: include/RE/T/TESRace.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BGSAttackDataForm.h"
#include "RE/B/BGSBehaviorGraphModel.h"
#include "RE/B/BGSBipedObjectForm.h"
#include "RE/B/BGSKeywordForm.h"
#include "RE/B/BGSSkinForm.h"
#include "RE/B/BGSTextureModel.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BipedObjects.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiPoint3.h"
#include "RE/S/Sexes.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESSpellList.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	class AttackAnimationArrayMap;

	namespace BSResource
	{
		struct ID;
	}

	enum class RACE_SIZE
	{
		kSmall = 0,
		kMedium = 1,
		kLarge = 2,
		kExtraLarge = 3
	};

	struct RACE_DATA
	{
	public:
		enum
		{
			kNumSkillBoosts = 7
		};

		enum class Flag
		{
			kNone = 0,
			kPlayable = 1 << 0,
			kFaceGenHead = 1 << 1,
			kChild = 1 << 2,
			kTiltFrontBack = 1 << 3,
			kTiltLeftRight = 1 << 4,
			kNoShadow = 1 << 5,
			kSwims = 1 << 6,
			kFlies = 1 << 7,
			kWalks = 1 << 8,
			kImmobile = 1 << 9,
			kNotPushable = 1 << 10,
			kNoCombatInWater = 1 << 11,
			kNoRotatingToHeadTrack = 1 << 12,
			kDontShowBloodSpray = 1 << 13,
			kDontShowBloodDecal = 1 << 14,
			kUseHeadTrackAnims = 1 << 15,
			kSpellsAlignWithMagicNode = 1 << 16,
			kUseWorldRaycastsForFootIK = 1 << 17,
			kAllowRagdollCollision = 1 << 18,
			kRegenHPInCombat = 1 << 19,
			kCantOpenDoors = 1 << 20,
			kAllowPCDialogue = 1 << 21,
			kNoKnockdowns = 1 << 22,
			kAllowPickpocket = 1 << 23,
			kAlwaysUseProxyController = 1 << 24,
			kDontShowWeaponBlood = 1 << 25,
			kOverlayHeadPartList = 1 << 26,
			kOverrideHeadPartList = 1 << 27,
			kCanPickupItems = 1 << 28,
			kAllowMultipleMembraneShaders = 1 << 29,
			kCanDualWield = 1 << 30,
			kAvoidsRoads = 1 << 31,
		};

		enum class Flag2
		{
			kNone = 0,
			kUseAdvancedAvoidance = 1 << 0,
			kNonHostile = 1 << 1,
			kAllowMountedCombat = 1 << 4
		};

		struct SkillBoost
		{
		public:
			// members
			stl::enumeration<ActorValue, std::uint8_t> skill;  // 0
			std::uint8_t                               bonus;  // 1
		};
		static_assert(sizeof(SkillBoost) == 0x2);

		// members
		SkillBoost                                    skillBoosts[kNumSkillBoosts];  // 00
		std::uint16_t                                 pad0E;                         // 0E
		float                                         height[SEXES::kTotal];         // 10
		float                                         weight[SEXES::kTotal];         // 18
		stl::enumeration<Flag, std::uint32_t>         flags;                         // 20
		float                                         startingHealth;                // 24
		float                                         startingMagicka;               // 28
		float                                         startingStamina;               // 2C
		float                                         baseCarryWeight;               // 30
		float                                         baseMass;                      // 34
		float                                         accelerate;                    // 38
		float                                         decelerate;                    // 3C
		stl::enumeration<RACE_SIZE, std::uint32_t>    raceSize;                      // 40
		stl::enumeration<BIPED_OBJECT, std::uint32_t> headObject;                    // 44
		stl::enumeration<BIPED_OBJECT, std::uint32_t> hairObject;                    // 48
		float                                         injuredHealthPercent;          // 4C
		stl::enumeration<BIPED_OBJECT, std::uint32_t> shieldObject;                  // 50
		float                                         healthRegen;                   // 54
		float                                         magickaRegen;                  // 58
		float                                         staminaRegen;                  // 5C
		float                                         unarmedDamage;                 // 60
		float                                         unarmedReach;                  // 64
		stl::enumeration<BIPED_OBJECT, std::uint32_t> bodyObject;                    // 68
		float                                         aimAngleTolerance;             // 6C
		float                                         flightRadius;                  // 70
		float                                         angleAccelerate;               // 74
		float                                         angleTolerance;                // 78
		stl::enumeration<Flag2, std::uint32_t>        flags2;                        // 7C
		NiPoint3                                      mountOffset;                   // 80
		NiPoint3                                      dismountOffset;                // 8C
		NiPoint3                                      mountCameraOffset;             // 98
	};
	static_assert(sizeof(RACE_DATA) == 0xA4);

	class TESRace :
		public TESForm,             // 000
		public TESFullName,         // 020
		public TESDescription,      // 030
		public TESSpellList,        // 040
		public BGSSkinForm,         // 050
		public BGSBipedObjectForm,  // 060
		public BGSKeywordForm,      // 070
		public BGSAttackDataForm    // 088
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRace;
		inline static constexpr auto VTABLE = VTABLE_TESRace;
		inline static constexpr auto FORMTYPE = FormType::Race;

		enum class EquipmentFlag
		{
			kNone = 0,
			kHandToHandMelee = 1 << 0,
			kOneHandSword = 1 << 1,
			kOneHandDagger = 1 << 2,
			kOneHandAxe = 1 << 3,
			kOneHandMace = 1 << 4,
			kTwoHandSword = 1 << 5,
			kTwoHandAxe = 1 << 6,
			kBow = 1 << 7,
			kStaff = 1 << 8,
			kSpell = 1 << 9,
			kShield = 1 << 10,
			kTorch = 1 << 11,
			kCrossbow = 1 << 12
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kCritter = 1 << 19  // ?
			};
		};

		struct MovementTypes
		{
			enum
			{
				kWalk = 0,
				kRun,
				kSwim,
				kFly,
				kSneak,
				kSprint,
				kTotal
			};
		};

		struct FaceRelatedData
		{
			enum
			{
				kNose = 0,
				kBrows,
				kEyes,
				kLips,

				kNumVariants
			};

			struct Morph
			{
			public:
				// members
				std::uint32_t morphFlags;  // 00
				std::uint32_t unk04;       // 04
				std::uint32_t unk08;       // 08
				std::uint32_t unk0C;       // 0C
				std::uint32_t unk10;       // 10
				std::uint32_t unk14;       // 14
				std::uint32_t unk18;       // 18
				std::uint32_t unk1C;       // 1C
			};
			static_assert(sizeof(Morph) == 0x20);

			struct TintAsset
			{
			public:
				struct TintLayer
				{
				public:
					enum class SkinTone
					{
						kNone = 0,
						kLipColor = 1,
						kCheekColor = 2,
						kEyeliner = 3,
						kEyeSocketUpper = 4,
						kEyeSocketLower = 5,
						kSkinTone = 6,
						kPaint = 7,
						kLaughLines = 8,
						kCheekColorLower = 9,
						kNose = 10,
						kChin = 11,
						kNeck = 12,
						kForehead = 13,
						kDirt = 14,
					};

					// members
					std::uint16_t                            index;          // 00 - TINI
					stl::enumeration<SkinTone, std::uint8_t> skinTone;       // 02 - TINP
					std::uint8_t                             pad03;          // 03
					std::uint32_t                            pad04;          // 04
					TESTexture                               file;           // 08 - TINT
					BGSColorForm*                            presetDefault;  // 18 - TIND
				};
				static_assert(sizeof(TintLayer) == 0x20);

				struct Presets
				{
				public:
					// members
					BSTArray<BGSColorForm*> colors;         // 00 - TINC
					BSTArray<float>         defaultValues;  // 18 - TINV
					BSTArray<std::uint16_t> indices;        // 30 - TIRS
				};
				static_assert(sizeof(Presets) == 0x48);

				// members
				TintLayer texture;  // 00
				Presets   presets;  // 20
			};
			static_assert(sizeof(TintAsset) == 0x68);

			// members
			Morph                     availableMorphs[kNumVariants];  // 00
			std::uint32_t             numFlagsSet[kNumVariants];      // 80
			BSTArray<TintAsset*>*     tintMasks;                      // 90
			BSTArray<BGSTextureSet*>* faceDetailsTextureSets;         // 98 - FTSM / FTSF
			BGSTextureSet*            defaultFaceDetailsTextureSet;   // A0 - DFTM / DFTF
			BSTArray<TESNPC*>*        presetNPCs;                     // A8 - RPRM / RPRF
			BSTArray<BGSColorForm*>*  availableHairColors;            // B0 - AHCM / AHCF
			BGSColorForm*             defaultHairColor;               // B8
			BSTArray<BGSHeadPart*>*   headParts;                      // C0 - HEAD
		};
		static_assert(sizeof(FaceRelatedData) == 0xC8);

		struct UnkData
		{
		public:
			// members
			BSResource::ID** unkHashes;      // 00
			std::uint32_t    numUnkHashes1;  // 08
			std::uint32_t    pad0C;          // 0C
			std::uint32_t    numUnkHashes2;  // 10
			std::uint32_t    pad14;          // 14
		};
		static_assert(sizeof(UnkData) == 0x18);

		~TESRace() override;  // 00

		// override (TESForm)
		void        InitializeData() override;                    // 04
		void        ClearData() override;                         // 05
		bool        Load(TESFile* a_mod) override;                // 06
		void        InitItemImpl() override;                      // 13
		bool        GetPlayable() const override;                 // 19
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { formEditorID = a_str; }

		[[nodiscard]] bool AllowsPCDialogue() const;
		[[nodiscard]] bool AllowsPickpocket() const;
		[[nodiscard]] bool IsChildRace() const;

		// members
		TESModel                                       skeletonModels[SEXES::kTotal];                  // 098 - ANAM
		RACE_DATA                                      data;                                           // 0E8
		float                                          clampFaceGeoValue;                              // 18C - PNAM
		float                                          clampFaceGeoValue2;                             // 18C - UNAM
		std::uint32_t                                  pad194;                                         // 194
		BGSTextureModel                                bodyTextureModels[SEXES::kTotal];               // 198
		BGSBehaviorGraphModel                          behaviorGraphs[SEXES::kTotal];                  // 1E8
		BSFixedString                                  rootBehaviorGraphNames[SEXES::kTotal];          // 238
		BSFixedString                                  behaviorGraphProjectNames[SEXES::kTotal];       // 248
		BGSVoiceType*                                  defaultVoiceTypes[SEXES::kTotal];               // 258 - VTCK
		BGSBodyPartData*                               bodyPartData;                                   // 268 - GNAM
		TESObjectARMO*                                 decapitateArmors[SEXES::kTotal];                // 270 - DNAM
		UnkData                                        unk280;                                         // 280
		UnkData                                        unk298;                                         // 298
		std::uint64_t                                  unk2B0;                                         // 2B0
		std::uint64_t                                  unk2B8;                                         // 2B8
		std::uint64_t                                  unk2C0;                                         // 2C0
		std::uint64_t                                  unk2C8;                                         // 2C8
		AttackAnimationArrayMap*                       attackAnimationArrayMap[SEXES::kTotal];         // 2D0
		BSFixedString                                  formEditorID;                                   // 2E0 - EDID
		BGSMaterialType*                               bloodImpactMaterial;                            // 2E8 - NAM4
		BGSImpactDataSet*                              impactDataSet;                                  // 2F0 - NAM5
		BGSArtObject*                                  dismemberBlood;                                 // 2F8 - NAM7
		BGSSoundDescriptorForm*                        corpseOpenSound;                                // 300 - ONAM
		BGSSoundDescriptorForm*                        corpseCloseSound;                               // 308 - LNAM
		BSFixedString                                  bipedObjectNameA[BIPED_OBJECTS::kEditorTotal];  // 310 - NAME
		BSTArray<BGSEquipSlot*>                        equipSlots;                                     // 410 - QNAM
		stl::enumeration<EquipmentFlag, std::uint32_t> validEquipTypes;                                // 428 - VNAM - bits 13+ are always set
		std::uint32_t                                  unk42C;                                         // 42C - TESModel::unk24
		BGSEquipSlot*                                  unarmedEquipSlot;                               // 430 - UNES
		TESRace*                                       morphRace;                                      // 438 - NAM8
		TESRace*                                       armorParentRace;                                // 440 - RNAM
		UnkData                                        unk448;                                         // 448
		BSTArray<BSFixedString>                        phonemeTargets;                                 // 460 - PHTN
		BGSMovementType*                               baseMoveTypes[MovementTypes::kTotal];           // 478 - WKMV / RNMV / WMMV / FLMV / SNMV / SPMV
		FaceRelatedData*                               faceRelatedData[SEXES::kTotal];                 // 4A8
	};
	static_assert(sizeof(TESRace) == 0x4B8);
}


===============================================
File: include/RE/T/TESRaceForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESRace;

	class TESRaceForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRaceForm;

		~TESRaceForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { race = 0; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		TESRace* race;  // 08 - RNAM
	};
	static_assert(sizeof(TESRaceForm) == 0x10);
}


===============================================
File: include/RE/T/TESReactionForm.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/B/BaseFormComponent.h"
#include "RE/F/FightReactions.h"
#include "RE/F/FormTypes.h"

namespace RE
{
	struct GROUP_REACTION  // XNAM
	{
		TESForm*       form;           // 00
		std::int32_t   reaction;       // 08
		FIGHT_REACTION fightReaction;  // 0C
	};
	static_assert(sizeof(GROUP_REACTION) == 0x10);

	class TESReactionForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESReactionForm;

		~TESReactionForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		BSSimpleList<GROUP_REACTION*>            reactions;      // 08 - XNAM
		stl::enumeration<FormType, std::uint8_t> groupFormType;  // 18
		std::uint8_t                             pad19;          // 19
		std::uint16_t                            pad1A;          // 1A
		std::uint32_t                            pad1C;          // 1C
	};
	static_assert(sizeof(TESReactionForm) == 0x20);
}


===============================================
File: include/RE/T/TESRegion.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint2.h"
#include "RE/T/TESForm.h"

namespace RE
{
	class TESRegionData;

	struct TESRegionDataList
	{
		BSSimpleList<TESRegionData*> regionDataList;  // 00
		bool                         unk11;           // 11
		std::uint16_t                pad12;           // 12
		std::uint32_t                pad14;           // 14
	};
	static_assert(sizeof(TESRegionDataList) == 0x18);

	class TESRegionPoint
	{
	public:
		NiPoint2 point;  // 00
	};
	static_assert(sizeof(TESRegionPoint) == 0x8);

	class TESRegionPointList : public BSSimpleList<TESRegionPoint*>  // RPLD
	{
	public:
		struct ScaleResult
		{
			TESRegionPoint point;  // 00
			float          dist;   // 08
			float          scale;  // 0C
		};
		static_assert(sizeof(ScaleResult) == 0x10);

		ScaleResult*  lastScaleResult;      // 10
		bool          ownsPointMemory;      // 18
		std::uint8_t  pad19;                // 19
		std::uint16_t pad1A;                // 1A
		NiPoint2      minimums;             // 1C
		NiPoint2      maximums;             // 24
		std::uint32_t distanceInsideAtMax;  // 2C - RPLI
		std::uint32_t count;                // 30
		std::uint32_t pad34;                // 34
	};
	static_assert(sizeof(TESRegionPointList) == 0x38);

	class TESRegion : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegion;
		inline static constexpr auto VTABLE = VTABLE_TESRegion;
		inline static constexpr auto FORMTYPE = FormType::Region;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kBorderRegion = 1 << 6,
				kIgnored = 1 << 12
			};
		};

		~TESRegion() override;  // 00

		// override (TESForm)
		void ClearData(void) override;       // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// add
		virtual bool Validate();  // 3B

		// members
		TESRegionDataList*                 dataList;        // 20
		BSSimpleList<TESRegionPointList*>* pointLists;      // 28
		TESWorldSpace*                     worldSpace;      // 30 - WNAM
		TESWeather*                        currentWeather;  // 38
		NiColor                            emittanceColor;  // 40
		std::uint32_t                      pad4C;           // 4C
	};
	static_assert(sizeof(TESRegion) == 0x50);
}


===============================================
File: include/RE/T/TESRegionData.h
===============================================
#pragma once

namespace RE
{
	class TESForm;

	class TESRegionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegionData;

		enum class Type
		{
			kObjects = 2,
			kWeather = 3,
			kMap = 4,
			kLand = 5,
			kGrass = 6,
			kSound = 7,
			kImposter = 8
		};

		struct DataHeader  // RDAT
		{
		public:
			enum class Flag
			{
				kNone = 0,
				kOverride = 1 << 0
			};

			// members
			stl::enumeration<Flag, std::uint8_t> flags;     // 0
			std::uint8_t                         unk09;     // 1
			std::uint8_t                         priority;  // 2
			std::uint8_t                         unk0B;     // 3
			std::uint32_t                        unk0C;     // 4
		};
		static_assert(sizeof(DataHeader) == 0x8);

		virtual ~TESRegionData();  // 00

		// add
		virtual bool               LoadDataHeader(void* a_arg1);                     // 01
		virtual void               LoadData(TESForm* a_form);                        // 02 - { return; }
		[[nodiscard]] virtual Type GetType() const = 0;                              // 03
		virtual void               ConstructSelf() = 0;                              // 04
		virtual void               Unk_05(void) = 0;                                 // 05
		virtual void               CopyFrom(TESRegionData* a_src, bool a_copy) = 0;  // 06
		[[nodiscard]] virtual bool IsLoaded() const = 0;                             // 07

		// members
		DataHeader dataHeader;  // 08 - RDAT
	};
	static_assert(sizeof(TESRegionData) == 0x10);
}


===============================================
File: include/RE/T/TESRegionDataLandscape.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/T/TESRegionData.h"

namespace RE
{
	class TESFile;
	class TESTexture;

	class TESRegionDataLandscape : public TESRegionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegionDataLandscape;
		inline static constexpr auto TYPE = Type::kLand;

		~TESRegionDataLandscape() override;  // 00

		// override (TESRegionData)
		Type               GetType() const override;                              // 03 - { return Type::kLand; }
		void               ConstructSelf() override;                              // 04
		void               Unk_05(void) override;                                 // 05
		void               CopyFrom(TESRegionData* a_src, bool a_copy) override;  // 06
		[[nodiscard]] bool IsLoaded() const override;                             // 07

		// add
		virtual bool LoadIcon(TESFile* a_mod);           // 08
		virtual void GetIconFileName(BSString* a_dst);   // 09
		virtual bool SetIconFileName(BSString* a_name);  // 0A

		// members
		TESTexture* icon;  // 10
	};
	static_assert(sizeof(TESRegionDataLandscape) == 0x18);
}


===============================================
File: include/RE/T/TESRegionDataManager.h
===============================================
#pragma once

namespace RE
{
	enum class REGION_DATA_ID;

	class TESFile;
	class TESRegion;
	class TESRegionData;
	class TESRegionDataGrass;
	class TESRegionDataLandscape;
	class TESRegionDataMap;
	class TESRegionDataObjects;
	class TESRegionDataSound;
	class TESRegionDataWeather;

	class TESRegionDataManager
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegionDataManager;

		virtual ~TESRegionDataManager();  // 00

		// add
		virtual TESRegion*                   GetLastLoadedRegion();                                 // 01 - { return lastLoadedRegion; }
		[[nodiscard]] virtual TESRegionData* ConstructRegionData(REGION_DATA_ID a_id) const;        // 02
		virtual TESRegionDataObjects*        AsRegionDataObjects(TESRegionData* a_data) const;      // 03
		virtual TESRegionDataWeather*        AsRegionDataWeather(TESRegionData* a_data) const;      // 04
		virtual TESRegionDataMap*            AsRegionDataMap(TESRegionData* a_data) const;          // 05
		virtual TESRegionDataLandscape*      AsRegionDataLandscape(TESRegionData* a_data) const;    // 06
		virtual TESRegionDataGrass*          AsRegionDataGrass(TESRegionData* a_data) const;        // 07
		virtual TESRegionDataSound*          AsRegionDataSound(TESRegionData* a_data) const;        // 08
		virtual bool                         LoadRegionData(TESFile* a_file, TESRegion* a_region);  // 09

		// members
		TESRegion* lastLoadedRegion;  // 08
	};
	static_assert(sizeof(TESRegionDataManager) == 0x10);
}


===============================================
File: include/RE/T/TESRegionDataMap.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/T/TESRegionData.h"

namespace RE
{
	class TESRegionDataMap : public TESRegionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegionDataMap;
		inline static constexpr auto TYPE = Type::kMap;

		~TESRegionDataMap() override;  // 00

		// override (TESRegionData)
		Type               GetType() const override;                              // 03 - { return Type::kMap; }
		void               ConstructSelf() override;                              // 04
		void               Unk_05(void) override;                                 // 05
		void               CopyFrom(TESRegionData* a_src, bool a_copy) override;  // 06
		[[nodiscard]] bool IsLoaded() const override;                             // 07 - { return true; }

		// members
		BSFixedString mapName;  // 10 - RDMP
	};
	static_assert(sizeof(TESRegionDataMap) == 0x18);
}


===============================================
File: include/RE/T/TESRegionDataSound.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/T/TESRegionData.h"

namespace RE
{
	class BGSMusicType;
	class BGSSoundDescriptorForm;
	class TESFile;

	class TESRegionDataSound : public TESRegionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegionDataSound;
		inline static constexpr auto TYPE = Type::kSound;

		struct Sound
		{
			enum class Flag
			{
				kNone = 0,
				kPleasant = 1 << 0,
				kCloudy = 1 << 1,
				kRainy = 1 << 2,
				kSnowy = 1 << 3
			};

			BGSSoundDescriptorForm*               sound;   // 00
			stl::enumeration<Flag, std::uint32_t> flags;   // 08
			float                                 chance;  // 0C
		};
		static_assert(sizeof(Sound) == 0x10);

		~TESRegionDataSound() override;  // 00

		// override (TESRegionData)
		void               LoadData(TESForm* a_form) override;                    // 02
		Type               GetType() const override;                              // 03 - { return Type::kSound; }
		void               ConstructSelf() override;                              // 04
		void               Unk_05(void) override;                                 // 05
		void               CopyFrom(TESRegionData* a_src, bool a_copy) override;  // 06
		[[nodiscard]] bool IsLoaded() const override;                             // 07 - { return music == 0; }

		// add
		virtual void Load(TESFile* a_mod);  // 08

		// members
		BGSMusicType*    music;   // 10 - RDMO
		BSTArray<Sound*> sounds;  // 18 - RDSA
	};
	static_assert(sizeof(TESRegionDataSound) == 0x30);
}


===============================================
File: include/RE/T/TESRegionDataWeather.h
===============================================
#pragma once

#include "RE/B/BSTList.h"
#include "RE/T/TESRegionData.h"

namespace RE
{
	struct WeatherType;

	class TESRegionDataWeather : public TESRegionData
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegionDataWeather;
		inline static constexpr auto TYPE = Type::kWeather;

		~TESRegionDataWeather() override;  // 00

		// override (TESRegionData)
		Type               GetType() const override;                              // 03 - { return Type::kWeather; }
		void               ConstructSelf() override;                              // 04
		void               Unk_05(void) override;                                 // 05
		void               CopyFrom(TESRegionData* a_src, bool a_copy) override;  // 06
		[[nodiscard]] bool IsLoaded() const override;                             // 07 - { return weatherTypes.next || weatherTypes.cur; }

		// add
		virtual void Unk_08(void);  // 08

		// members
		BSSimpleList<WeatherType*> weatherTypes;  // 10
	};
	static_assert(sizeof(TESRegionDataWeather) == 0x20);
}


===============================================
File: include/RE/T/TESRegionList.h
===============================================
#pragma once

#include "RE/B/BSTList.h"

namespace RE
{
	class TESRegion;

	class TESRegionList : public BSSimpleList<TESRegion*>
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESRegionList;
		inline static constexpr auto VTABLE = VTABLE_TESRegionList;

		virtual ~TESRegionList();  // 00

		// members
		bool          ownsRegionMemory;  // 18
		std::uint8_t  pad19;             // 19
		std::uint16_t pad1A;             // 1A
		std::uint32_t pad1C;             // 1C
	};
	static_assert(sizeof(TESRegionList) == 0x20);
}


===============================================
File: include/RE/T/TESResetEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESResetEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> object;  // 0
	};
	static_assert(sizeof(TESResetEvent) == 0x8);
}


===============================================
File: include/RE/T/TESResolveNPCTemplatesEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESResolveNPCTemplatesEvent
	{
	public:
		// members
		FormID        templateID;  // 00
		std::uint32_t pad04;       // 04
	};
	static_assert(sizeof(TESResolveNPCTemplatesEvent) == 0x8);
}

===============================================
File: include/RE/T/TESShout.h
===============================================
#pragma once

#include "RE/B/BGSEquipType.h"
#include "RE/B/BGSMenuDisplayObject.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESDescription.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class TESShout :
		public TESForm,               // 00
		public TESFullName,           // 20
		public BGSMenuDisplayObject,  // 30
		public BGSEquipType,          // 40
		public TESDescription         // 50
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESShout;
		inline static constexpr auto VTABLE = VTABLE_TESShout;
		inline static constexpr auto FORMTYPE = FormType::Shout;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kTreatSpellsAsPowers = 1 << 7,
				kIgnored = 1 << 12
			};
		};

		struct Variation  // SNAM
		{
			TESWordOfPower* word;          // 00
			SpellItem*      spell;         // 08
			float           recoveryTime;  // 10
			std::uint32_t   pad14;         // 14
		};
		static_assert(sizeof(Variation) == 0x18);

		struct VariationIDs
		{
			enum VariationID : std::uint32_t
			{
				kNone = static_cast<std::underlying_type_t<VariationID>>(-1),
				kOne = 0,
				kTwo,
				kThree,

				kTotal
			};
		};
		using VariationID = VariationIDs::VariationID;

		~TESShout() override;  // 00

		// override (TESForm)
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13
		bool GetKnown() const override;      // 17

		// override (BGSEquipType)
		BGSEquipSlot* GetEquipSlot() const override;                // 04
		void          SetEquipSlot(BGSEquipSlot* a_slot) override;  // 05 - { return; }

		// members
		Variation variations[VariationIDs::kTotal];  // 60 - SNAM
	};
	static_assert(sizeof(TESShout) == 0xA8);
}


===============================================
File: include/RE/T/TESSleepStopEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESSleepStopEvent
	{
	public:
		// members
		bool interrupted;  // 0
	};
	static_assert(sizeof(TESSleepStopEvent) == 0x1);
}


===============================================
File: include/RE/T/TESSoulGem.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/S/SoulLevels.h"
#include "RE/T/TESObjectMISC.h"

namespace RE
{
	class TESSoulGem : public TESObjectMISC
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESSoulGem;
		inline static constexpr auto VTABLE = VTABLE_TESSoulGem;
		inline static constexpr auto FORMTYPE = FormType::SoulGem;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kCanHoldNPCSoul = 1 << 17
			};
		};

		~TESSoulGem() override;  // 00

		// override (TESObjectMISC)
		void InitializeData() override;                                   // 04
		void LoadImpl(TESFile* a_mod, std::uint32_t a_chunkID) override;  // 54
		void InitImpl() override;                                         // 55

		// override (BGSKeywordForm)
		[[nodiscard]] BGSKeyword* GetDefaultKeyword() const override;  // 05

		[[nodiscard]] bool                 CanHoldNPCSoul() const noexcept { return (GetFormFlags() & RecordFlags::kCanHoldNPCSoul) != 0; }
		[[nodiscard]] constexpr SOUL_LEVEL GetContainedSoul() const noexcept { return *currentSoul; }
		[[nodiscard]] constexpr SOUL_LEVEL GetMaximumCapacity() const noexcept { return *soulCapacity; }

		// members
		TESSoulGem*                                linkedSoulGem;  // 100 - NAM0
		stl::enumeration<SOUL_LEVEL, std::uint8_t> currentSoul;    // 108 - SOUL
		stl::enumeration<SOUL_LEVEL, std::uint8_t> soulCapacity;   // 109 - SLCP
		std::uint16_t                              unk10A;         // 10A
		std::uint32_t                              unk10C;         // 10C
	};
	static_assert(sizeof(TESSoulGem) == 0x110);
}


===============================================
File: include/RE/T/TESSound.h
===============================================
#pragma once

#include "RE/F/FormTypes.h"
#include "RE/T/TESBoundAnimObject.h"

namespace RE
{
	class TESSound : public TESBoundAnimObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESSound;
		inline static constexpr auto VTABLE = VTABLE_TESSound;
		inline static constexpr auto FORMTYPE = FormType::Sound;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESSound() override;  // 00

		// override (TESBoundAnimObject)
		void        InitializeData() override;                    // 04
		bool        Load(TESFile* a_mod) override;                // 06
		void        InitItemImpl() override;                      // 13
		bool        SetFormEditorID(const char* a_str) override;  // 33
		void        UnClone3D(TESObjectREFR* a_ref) override;     // 41
		NiAVObject* Clone3D(TESObjectREFR* a_ref) override;       // 4A - { return 0; }

		// members
		BGSSoundDescriptorForm* descriptor;  // 30 - SDSC
	};
	static_assert(sizeof(TESSound) == 0x38);
}


===============================================
File: include/RE/T/TESSpellCastEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESSpellCastEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> object;  // 00
		FormID                   spell;   // 08
	};
	static_assert(sizeof(TESSpellCastEvent) == 0x10);
}


===============================================
File: include/RE/T/TESSpellList.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"
#include "RE/M/MemoryManager.h"

namespace RE
{
	class SpellItem;
	class TESLevSpell;
	class TESShout;

	class TESSpellList : BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESSpellList;

		struct SpellData  // SPLO
		{
			SpellData();
			~SpellData() = default;

			bool AddLevSpell(TESLevSpell* a_levSpell);
			bool AddLevSpells(const std::vector<TESLevSpell*>& a_levSpells);
			bool AddShout(TESShout* a_shout);
			bool AddShouts(const std::vector<TESShout*>& a_shouts);
			bool AddSpell(SpellItem* a_spell);
			bool AddSpells(const std::vector<SpellItem*>& a_spells);

			std::optional<std::uint32_t> GetIndex(const SpellItem* a_spell) const;
			std::optional<std::uint32_t> GetIndex(const TESLevSpell* a_levSpell) const;
			std::optional<std::uint32_t> GetIndex(const TESShout* a_shout) const;

			bool RemoveLevSpell(TESLevSpell* a_levSpell);
			bool RemoveLevSpells(const std::vector<TESLevSpell*>& a_levSpells);
			bool RemoveShout(TESShout* a_shout);
			bool RemoveShouts(const std::vector<TESShout*>& a_shouts);
			bool RemoveSpell(SpellItem* a_spell);
			bool RemoveSpells(const std::vector<SpellItem*>& a_spells);

			TES_HEAP_REDEFINE_NEW();

			SpellItem**   spells;        // 00
			TESLevSpell** levSpells;     // 08
			TESShout**    shouts;        // 10
			std::uint32_t numSpells;     // 18
			std::uint32_t numlevSpells;  // 1C
			std::uint32_t numShouts;     // 20
			std::uint32_t pad24;         // 24

		private:
			void CopySpellList(const std::vector<TESLevSpell*>& a_copiedData);
			void CopySpellList(const std::vector<TESShout*>& a_copiedData);
			void CopySpellList(const std::vector<SpellItem*>& a_copiedData);
		};
		static_assert(sizeof(SpellData) == 0x28);

		~TESSpellList() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { return; }
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		SpellData* actorEffects;  // 08 - SPLO
	};
	static_assert(sizeof(TESSpellList) == 0x10);
}


===============================================
File: include/RE/T/TESSwitchRaceCompleteEvent.h
===============================================
#pragma once

#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class TESObjectREFR;

	struct TESSwitchRaceCompleteEvent
	{
	public:
		// members
		NiPointer<TESObjectREFR> subject;  // 0
	};
	static_assert(sizeof(TESSwitchRaceCompleteEvent) == 0x8);
}


===============================================
File: include/RE/T/TESTexture.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSString.h"
#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESTexture : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESTexture;

		~TESTexture() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// add
		virtual std::uint32_t             GetMaxAllowedSize();                     // 04 - { return 0; }
		virtual const char*               GetAsNormalFile(BSString& a_out) const;  // 05
		[[nodiscard]] virtual const char* GetDefaultPath() const;                  // 06 - { return "Textures\\"; }

		// members
		BSFixedString textureName;  // 08 - ICON
	};
	static_assert(sizeof(TESTexture) == 0x10);
}


===============================================
File: include/RE/T/TESTexture1024.h
===============================================
#pragma once

#include "RE/T/TESTexture.h"

namespace RE
{
	class TESTexture1024 : public TESTexture
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESTexture1024;

		~TESTexture1024() override;  // 00

		// override (TESTexture)
		std::uint32_t GetMaxAllowedSize() override;  // 04 - { return 1024; }
	};
	static_assert(sizeof(TESTexture1024) == 0x10);
}


===============================================
File: include/RE/T/TESTopic.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/D/DialogueTypes.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	struct DIALOGUE_DATA  // DATA
	{
		enum class TopicFlag
		{
			kNone = 0,
			kDoAllBeforeRepeating = 1 << 0
		};

		enum class Subtype
		{
			kCustom = 0,
			kForceGreet = 1,
			kRumors = 2,
			kUnk3 = 3,  // custom?
			kIntimidate = 4,
			kFlatter = 5,
			kBribe = 6,
			kAskGift = 7,
			kGift = 8,
			kAskFavor = 9,
			kFavor = 10,
			kShowRelationships = 11,
			kFollow = 12,
			kReject = 13,
			kScene = 14,
			kShow = 15,
			kAgree = 16,
			kRefuse = 17,
			kExitFavorState = 18,
			kMoralRefusal = 19,
			kFlyingMountLand = 20,
			kFlyingMountCancelLand = 21,
			kFlyingMountAcceptTarget = 22,
			kFlyingMountRejectTarget = 23,
			kFlyingMountNoTarget = 24,
			kFlyingMountDestinationReached = 25,
			kAttack = 26,
			kPowerAttack = 27,
			kBash = 28,
			kHit = 29,
			kFlee = 30,
			kBleedout = 31,
			kAvoidThreat = 32,
			kDeath = 33,
			kGroupStrategy = 34,
			kBlock = 35,
			kTaunt = 36,
			kAllyKilled = 37,
			kSteal = 38,
			kYield = 39,
			kAcceptYield = 40,
			kPickpocketCombat = 41,
			kAssault = 42,
			kMurder = 43,
			kAssaultNPC = 44,
			kMurderNPC = 45,
			kPickpocketNPC = 46,
			kStealFromNPC = 47,
			kTrespassAgainstNPC = 48,
			kTrespass = 49,
			kWereTransformCrime = 50,
			kVoicePowerStartShort = 51,
			kVoicePowerStartLong = 52,
			kVoicePowerEndShort = 53,
			kVoicePowerEndLong = 54,
			kAlertIdle = 55,
			kLostIdle = 56,
			kNormalToAlert = 57,
			kAlertToCombat = 58,
			kNormalToCombat = 59,
			kAlertToNormal = 60,
			kCombatToNormal = 61,
			kCombatToLost = 62,
			kLostToNormal = 63,
			kLostToCombat = 64,
			kDetectFriendDie = 65,
			kServiceRefusal = 66,
			kRepair = 67,
			kTravel = 68,
			kTraining = 69,
			kBarterExit = 70,
			kRepairExit = 71,
			kRecharge = 72,
			kRechargeExit = 73,
			kTrainingExit = 74,
			kObserveCombat = 75,
			kNoticeCorpse = 76,
			kTimeToGo = 77,
			kGoodBye = 78,
			kHello = 79,
			kSwingMeleeWeapon = 80,
			kShootBow = 81,
			kZKeyObject = 82,
			kJump = 83,
			kKnockOverObject = 84,
			kDestroyObject = 85,
			kStandonFurniture = 86,
			kLockedObject = 87,
			kPickpocketTopic = 88,
			kPursueIdleTopic = 89,
			kSharedInfo = 90,
			kPlayerCastProjectileSpell = 91,
			kPlayerCastSelfSpell = 92,
			kPlayerShout = 93,
			kIdle = 94,
			kEnterSprintBreath = 95,
			kEnterBowZoomBreath = 96,
			kExitBowZoomBreath = 97,
			kActorCollidewithActor = 98,
			kPlayerinIronSights = 99,
			kOutofBreath = 100,
			kCombatGrunt = 101,
			kLeaveWaterBreath = 102
		};

		stl::enumeration<TopicFlag, std::uint8_t>     topicFlags;  // 0
		stl::enumeration<DIALOGUE_TYPE, std::uint8_t> type;        // 1
		stl::enumeration<Subtype, std::uint16_t>      subtype;     // 2
	};
	static_assert(sizeof(DIALOGUE_DATA) == 0x4);

	class TESTopic :
		public TESForm,     // 00
		public TESFullName  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESTopic;
		inline static constexpr auto VTABLE = VTABLE_TESTopic;
		inline static constexpr auto FORMTYPE = FormType::Dialogue;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESTopic() override;  // 00

		// override (TESForm)
		bool        Load(TESFile* a_mod) override;                // 06
		void        InitItemImpl() override;                      // 13
		const char* GetFormEditorID() const override;             // 32 - { return formEditorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;  // 33 - { bool result = formEditorID == a_str; formEditorID = a_str; return result; }
		bool        IsParentForm() override;                      // 34 - { return true; }
		bool        IsFormTypeChild(FormType a_type) override;    // 36 - { return a_type == FormType::Info }

		// override (TESFullName)
		[[nodiscard]] std::uint32_t GetFullNameLength() const override;  // 04
		[[nodiscard]] const char*   GetFullName() const override;        // 05

		[[nodiscard]] float GetPriority() const;

		// members
		DIALOGUE_DATA      data;                     // 30 - DATA
		std::uint32_t      priorityAndJournalIndex;  // 34 - PNAM
		BGSDialogueBranch* ownerBranch;              // 38 - BNAM
		TESQuest*          ownerQuest;               // 40 -	QNAM
		TESTopicInfo**     topicInfos;               // 48 - infoTopics[infoCount]
		std::uint32_t      numTopicInfos;            // 50 - TIFC
		std::uint32_t      firstFileOffset;          // 54
		BSFixedString      formEditorID;             // 58
	};
	static_assert(sizeof(TESTopic) == 0x60);
}


===============================================
File: include/RE/T/TESTopicInfo.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/D/DialogueItem.h"
#include "RE/F/FormTypes.h"
#include "RE/M/MemoryManager.h"
#include "RE/T/TESCondition.h"
#include "RE/T/TESForm.h"

namespace RE
{
	struct TOPIC_INFO_DATA  // ENAM
	{
		enum class TOPIC_INFO_FLAGS
		{
			kNone = 0,
			kStartSceneOnEnd = 1 << 0,
			kRandom = 1 << 1,
			kSayOnce = 1 << 2,
			kRequiresPlayerActivation = 1 << 3,
			kInfoRefusal = 1 << 4,
			kRandomEnd = 1 << 5,
			kEndRunningScene = 1 << 6,
			kIsForceGreet = 1 << 7,
			kPlayerAddress = 1 << 8,
			kForceSubtitle = 1 << 9,
			kCanMoveWhileGreeting = 1 << 10,
			kNoLIPFile = 1 << 11,
			kPostProcess = 1 << 12,
			kCustomSoundOutput = 1 << 13,
			kSpendsFavorPoints = 1 << 14
		};

		[[nodiscard]] float GetResetHours() const;

		stl::enumeration<TOPIC_INFO_FLAGS, std::uint16_t> flags;           // 0
		std::uint16_t                                     timeUntilReset;  // 2 - reset hours as a std::uint16_t
	};
	static_assert(sizeof(TOPIC_INFO_DATA) == 0x4);

	class TESTopicInfo : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESTopicInfo;
		inline static constexpr auto VTABLE = VTABLE_TESTopicInfo;
		inline static constexpr auto FORMTYPE = FormType::Info;

		enum class FavorLevel  // CNAM
		{
			kNone = 0,
			kSmall = 1,
			kMedium = 2,
			kLarge = 3
		};

		struct ChangeFlags
		{
			enum ChangeFlag : std::uint32_t
			{
				kSaidOnce = (std::uint32_t)1 << 31
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct ResponseData  // TRDT
		{
			enum class EmotionType
			{
				kNeutral = 0,
				kAnger = 1,
				kDisgust = 2,
				kFear = 3,
				kSad = 4,
				kHappy = 5,
				kSurprise = 6,
				kPuzzled = 7
			};

			enum class Flag
			{
				kNone = 0,
				kUseEmotionAnimation = 1 << 0
			};

			~ResponseData();
			void PopulateResponseText(TESFile* a_file);

			TES_HEAP_REDEFINE_NEW();

			// members
			stl::enumeration<EmotionType, std::uint32_t> emotionType;     // 00
			std::uint32_t                                emotionValue;    // 04
			TESTopic*                                    unk08;           // 08
			std::uint8_t                                 responseNumber;  // 10
			std::uint8_t                                 pad11;           // 11
			std::uint16_t                                pad12;           // 12
			std::uint32_t                                pad14;           // 14
			BGSSoundDescriptorForm*                      sound;           // 18
			stl::enumeration<Flag, std::uint8_t>         flags;           // 20
			std::uint8_t                                 pad21;           // 21
			std::uint16_t                                pad22;           // 22
			std::uint32_t                                pad24;           // 24
			BSFixedString                                responseText;    // 28 - NAM1
			TESIdleForm*                                 speakerIdle;     // 30
			TESIdleForm*                                 listenerIdle;    // 38
			ResponseData*                                next;            // 40
		};
		static_assert(sizeof(ResponseData) == 0x48);

		~TESTopicInfo() override;  // 00

		// override (TESForm)
		void InitializeData() override;                                                            // 04
		void ClearData() override;                                                                 // 05
		bool Load(TESFile* a_mod) override;                                                        // 06
		void LoadGame(BGSLoadFormBuffer* a_buf) override;                                          // 0F
		void Revert(BGSLoadFormBuffer* a_buf) override;                                            // 12
		void InitItemImpl() override;                                                              // 13
		void GetFormDetailedString(char* a_buf, std::uint32_t a_bufLen) override;                  // 16 - { return; }
		void SetAltered(bool a_set) override;                                                      // 24
		bool BelongsInGroup(FORM* a_form, bool a_allowParentGroups, bool a_currentOnly) override;  // 30
		void CreateGroupData(FORM* a_form, FORM_GROUP* a_group) override;                          // 31

		DialogueItem GetDialogueData(Actor* a_speaker);

		// members
		TESTopic*                                  parentTopic;    // 20
		TESTopicInfo*                              dataInfo;       // 28 - PNAM
		TESCondition                               objConditions;  // 30 - CTDA
		std::uint16_t                              infoIndex;      // 38 - index in infoTopics array of parent topic
		bool                                       saidOnce;       // 3A
		stl::enumeration<FavorLevel, std::uint8_t> favorLevel;     // 3B - CNAM
		TOPIC_INFO_DATA                            data;           // 3C - ENAM
		std::uint32_t                              fileOffset;     // 40
		std::uint32_t                              pad44;          // 44
	};
	static_assert(sizeof(TESTopicInfo) == 0x48);
}


===============================================
File: include/RE/T/TESTrackedStatsEvent.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	struct TESTrackedStatsEvent
	{
	public:
		// members
		BSFixedString stat;   // 00
		std::int32_t  value;  // 08
		std::uint32_t pad0C;  // 0C
	};
	static_assert(sizeof(TESTrackedStatsEvent) == 0x10);
}


===============================================
File: include/RE/T/TESUniqueIDChangeEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESUniqueIDChangeEvent
	{
	public:
		// members
		FormID        oldBaseID;    // 00
		FormID        newBaseID;    // 04
		FormID        objectID;     // 08
		std::uint16_t oldUniqueID;  // 0C
		std::uint16_t newUniqueID;  // 0E
	};
	static_assert(sizeof(TESUniqueIDChangeEvent) == 0x10);
}


===============================================
File: include/RE/T/TESValueForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESValueForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESValueForm;

		~TESValueForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		std::int32_t  value;  // 08
		std::uint32_t pad0C;  // 0C
	};
	static_assert(sizeof(TESValueForm) == 0x10);
}


===============================================
File: include/RE/T/TESWaitStopEvent.h
===============================================
#pragma once

namespace RE
{
	struct TESWaitStopEvent
	{
	public:
		// members
		bool interrupted;  // 0
	};
	static_assert(sizeof(TESWaitStopEvent) == 0x1);
}


===============================================
File: include/RE/T/TESWaterDisplacement.h
===============================================
#pragma once

#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class NiAVObject;
	class TESWaterForm;

	class TESWaterDisplacement : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWaterDisplacement;

		virtual ~TESWaterDisplacement();  // 00

		// members
		TESWaterForm*         waterType;             // 10
		float                 waterHeight;           // 18
		std::uint32_t         unk1C;                 // 1C
		std::uint32_t         flags;                 // 20
		std::uint32_t         pad24;                 // 24
		NiPointer<NiAVObject> displacementGeometry;  // 28
	};
	static_assert(sizeof(TESWaterDisplacement) == 0x30);
}


===============================================
File: include/RE/T/TESWaterForm.h
===============================================
#pragma once

#include "RE/C/Color.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/T/TESAttackDamageForm.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	class BSWaterShaderMaterial;
	class NiTexture;

	struct WaterShaderData  // DNAM
	{
		struct DepthProperties
		{
			float reflections;       // D0
			float refraction;        // D4
			float normals;           // D8
			float specularLighting;  // DC
		};
		static_assert(sizeof(DepthProperties) == 0x10);

		float           unk00;                   // 00
		float           unk04;                   // 04
		float           unk08;                   // 08
		float           unk0C;                   // 0C
		float           sunSpecularPower;        // 10
		float           reflectionAmount;        // 14
		float           fresnelAmount;           // 18
		std::uint32_t   unk1C;                   // 1C
		float           aboveWaterFogDistNear;   // 20
		float           aboveWaterFogDistFar;    // 24
		Color           shallowWaterColor;       // 28
		Color           deepWaterColor;          // 2C
		Color           reflectionWaterColor;    // 30
		std::uint32_t   unk34;                   // 34
		float           unk38;                   // 38
		float           unk3C;                   // 3C
		float           unk40;                   // 40
		float           unk44;                   // 44
		float           displacementSize;        // 48
		float           displacementForce;       // 4C
		float           displacementVelocity;    // 50
		float           displacementFalloff;     // 54
		float           displacementDampener;    // 58
		float           unk5C;                   // 5C
		float           noiseFalloff;            // 60
		float           noiseWindDirectionA[3];  // 64
		float           noiseWindSpeedA[3];      // 70
		float           unk7C;                   // 7C
		float           unk80;                   // 80
		float           aboveWaterFogAmount;     // 84
		float           unk88;                   // 88
		float           underwaterFogAmount;     // 8C
		float           underwaterFogDistNear;   // 90
		float           underwaterFogDistFar;    // 94
		float           refractionMagnitude;     // 98
		float           specularPower;           // 9C
		float           unkA0;                   // A0
		float           specularRadius;          // A4
		float           specularBrightness;      // A8
		float           uvScaleA[3];             // AC
		float           amplitudeA[3];           // B8
		float           reflectionMagnitude;     // C4
		float           sunSparkleMagnitude;     // C8
		float           sunSpecularMagnitude;    // CC
		DepthProperties depthProperties;         // D0
		float           sunSparklePower;         // E0
		float           flowmapScale;            // E4
	};
	static_assert(sizeof(WaterShaderData) == 0xE8);

	class TESWaterForm :
		public TESForm,             // 000
		public TESFullName,         // 020
		public TESAttackDamageForm  // 030
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWaterForm;
		inline static constexpr auto VTABLE = VTABLE_TESWaterForm;
		inline static constexpr auto FORMTYPE = FormType::Water;

		enum class Flag  // FNAM
		{
			kNone = 0,
			kCauseDamage = 1 << 0,
			kEnableFlowmap = 1 << 3,
			kBlendNormals = 1 << 4
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESWaterForm() override;  // 00

		// override (TESForm)
		void InitializeData() override;                                                                                                                                // 04
		bool Load(TESFile* a_mod) override;                                                                                                                            // 06
		void InitItemImpl() override;                                                                                                                                  // 13
		bool GetDangerous() const override;                                                                                                                            // 1B - { return flags & 1; }
		bool Activate(TESObjectREFR* a_targetRef, TESObjectREFR* a_activatorRef, std::uint8_t a_arg3, TESBoundObject* a_object, std::int32_t a_targetCount) override;  // 37

		// members
		bool                                 needUpdate;               // 040
		std::uint8_t                         pad41;                    // 041
		std::uint16_t                        pad42;                    // 042
		NiColorA                             texScroll[3];             // 044
		std::uint32_t                        pad074;                   // 074
		TESTexture                           noiseTextures[4];         // 078 - NAM2 - NAM5
		std::int8_t                          alpha;                    // 0B8 - ANAM
		stl::enumeration<Flag, std::uint8_t> flags;                    // 0B9 - FNAM
		std::uint16_t                        pad0BA;                   // 0BA
		std::uint32_t                        pad0BC;                   // 0BC
		BGSMaterialType*                     materialType;             // 0C0 - TNAM
		BGSSoundDescriptorForm*              waterSound;               // 0C8 - SNAM
		WaterShaderData                      data;                     // 0D0 - DNAM
		TESWaterForm*                        waterWeatherControl[3];   // 1B8
		std::int32_t                         currentTextureSelect[2];  // 1D0
		std::uint32_t                        frequencyX;               // 1D8
		std::uint32_t                        frequencyY;               // 1DC
		std::int32_t                         octaves;                  // 1E0
		float                                amplitude;                // 1E4
		float                                lacunarity;               // 1E8
		float                                bias;                     // 1EC
		float                                gain;                     // 1F0
		std::uint32_t                        pad1F4;                   // 1F4
		SpellItem*                           contactSpell;             // 1F8 - XNAM
		NiPointer<NiTexture>                 noiseTextureData[4];      // 200
		TESObjectACTI*                       placeableAutoWater;       // 220
		TESObjectACTI*                       placeableLODWater;        // 228
		BSWaterShaderMaterial*               waterShaderMaterial;      // 230
		bool                                 resetNoiseTextures;       // 238
		std::uint8_t                         pad239;                   // 239
		std::uint16_t                        pad23A;                   // 23A
		std::uint32_t                        pad23C;                   // 23C
		TESImageSpace*                       imageSpace;               // 240 - INAM
		NiPoint3                             linearVelocity;           // 248 - NAM0
		NiPoint3                             angularVelocity;          // 254 - NAM1
	};
	static_assert(sizeof(TESWaterForm) == 0x260);
}


===============================================
File: include/RE/T/TESWaterNormals.h
===============================================
#pragma once

#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSWaterShaderMaterial;
	class NiSourceTexture;
	class TESWaterForm;

	class TESWaterNormals : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWaterNormals;

		virtual ~TESWaterNormals();  // 00

		// members
		std::uint8_t               flags;          // 10
		TESWaterForm*              waterType;      // 18
		std::uint32_t              unk20;          // 20
		BSWaterShaderMaterial*     waterMaterial;  // 28
		NiPointer<NiSourceTexture> noiseLayer0;    // 30
		NiPointer<NiSourceTexture> noiseLayer1;    // 38
		NiPointer<NiSourceTexture> noiseLayer2;    // 40
		NiPointer<NiSourceTexture> noiseLayer3;    // 48
	};
	static_assert(sizeof(TESWaterNormals) == 0x50);
}


===============================================
File: include/RE/T/TESWaterObject.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/N/NiPlane.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSMultiBoundAABB;
	class BSTriShape;
	class NiAVObject;
	class TESWaterForm;
	class TESWaterDisplacement;
	class TESWaterNormals;
	class TESWaterReflections;

	class TESWaterObject : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWaterObject;

		virtual ~TESWaterObject();  // 00

		// members
		NiPlane                               plane;              // 10
		NiPointer<BSTriShape>                 shape;              // 20
		NiPointer<NiAVObject>                 waterRippleObject;  // 28
		TESWaterForm*                         waterType;          // 30
		std::uint64_t                         unk38;              // 38
		NiPointer<TESWaterReflections>        reflections;        // 40
		NiPointer<TESWaterDisplacement>       displacement;       // 48
		NiPointer<TESWaterNormals>            normals;            // 50
		BSTArray<NiPointer<BSMultiBoundAABB>> multiBounds;        // 58
		std::uint8_t                          flags;              // 70
		std::uint8_t                          pad71;              // 71
		std::uint16_t                         pad72;              // 72
		std::uint32_t                         pad74;              // 74
	};
	static_assert(sizeof(TESWaterObject) == 0x78);
}


===============================================
File: include/RE/T/TESWaterReflections.h
===============================================
#pragma once

#include "RE/N/NiPlane.h"
#include "RE/N/NiRefObject.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSWaterShaderMaterial;
	class BSCubeMapCamera;

	class TESWaterReflections : public NiRefObject
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWaterReflections;

		struct CubeMapSide
		{
			std::uint32_t idx;    // 00
			float         unk04;  // 04
		};
		static_assert(sizeof(CubeMapSide) == 0x8);

		virtual ~TESWaterReflections();  // 00

		// members
		std::uint32_t              flags;            // 10
		NiPlane                    reflectPlane;     // 14
		std::uint32_t              unk24;            // 24
		NiPointer<BSCubeMapCamera> cubeMapCamera;    // 28
		std::uint64_t              unk30;            // 30
		std::uint64_t              unk38;            // 38
		BSWaterShaderMaterial*     waterMaterial;    // 40
		float                      unk48;            // 48
		std::uint32_t              unk4C;            // 4C
		CubeMapSide                cubeMapSides[6];  // 50
		std::uint8_t               unk80;            // 80
		std::uint8_t               pad81;            // 81
		std::uint16_t              pad82;            // 82
		std::uint32_t              pad84;            // 84
	};
	static_assert(sizeof(TESWaterReflections) == 0x88);
}


===============================================
File: include/RE/T/TESWaterSystem.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSPointerHandle.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiPoint2.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTPointerMap.h"

namespace RE
{
	class BSTriShape;
	class NiNode;
	class TESObjectCELL;
	class TESWorldSpace;
	class TESWaterDisplacement;
	class TESWaterNormals;
	class TESWaterObject;
	class TESWaterReflections;
	class WadingWaterData;

	class TESWaterSystem : public BSTSingletonSDM<TESWaterSystem>
	{
	public:
		[[nodiscard]] static TESWaterSystem* GetSingleton()
		{
			REL::Relocation<TESWaterSystem**> singleton{ RELOCATION_ID(514290, 400450) };
			return *singleton;
		}

		void AddRipple(const NiPoint3& a_pos, float a_scale)
		{
			using func_t = decltype(&TESWaterSystem::AddRipple);
			REL::Relocation<func_t> func{ RELOCATION_ID(31410, 32217) };
			return func(this, a_pos, a_scale);
		}

		// members
		std::uint32_t                                pad000;                   // 000
		BSFixedString*                               type;                     // 008
		std::uint32_t                                unk010;                   // 010
		std::uint32_t                                pad014;                   // 014
		float                                        unk018;                   // 018
		float                                        unk01C;                   // 01C
		BSTArray<NiPointer<TESWaterObject>>          waterObjects;             // 020
		BSTArray<NiPointer<TESWaterReflections>>     waterReflections;         // 038
		BSTArray<NiPointer<TESWaterDisplacement>>    waterDisplacement;        // 050
		BSTArray<NiPointer<TESWaterNormals>>         waterNormals;             // 068
		std::uint32_t                                unk080;                   // 080
		NiPoint2                                     unk084;                   // 084
		std::uint32_t                                pad08C;                   // 08C
		NiPointer<NiNode>                            waterRoot;                // 090
		std::uint64_t                                unk098;                   // 098
		std::uint32_t                                reflectionExteriorCount;  // 0A0
		std::uint32_t                                reflectionInteriorCount;  // 0A4
		TESWorldSpace*                               worldSpace;               // 0A8
		bool                                         enabled;                  // 0B0
		std::uint8_t                                 pad0B1;                   // 0B1
		std::uint16_t                                pad0B2;                   // 0B2
		std::uint32_t                                unk0B4;                   // 0B4
		bool                                         playerUnderwater;         // 0B8
		bool                                         unk0B9;                   // 0B9
		bool                                         unk0BA;                   // 0BA
		std::uint8_t                                 pad0BB;                   // 0BB
		std::uint32_t                                unk0BC;                   // 0BC
		float                                        underwaterHeight;         // 0C0
		bool                                         waterRadiusState;         // 0C4
		std::uint8_t                                 pad0C5;                   // 0C5
		std::uint8_t                                 unk0C6;                   // 0C6
		bool                                         showProcedualWater;       // 0C7
		std::uint8_t                                 unk0C8;                   // 0C8
		std::uint8_t                                 padC9;                    // 0C9
		std::uint16_t                                padCA;                    // 0CA
		std::uint32_t                                unk0CC;                   // 0CC
		std::uint32_t                                unk0D0;                   // 0D0
		float                                        unk0D4;                   // 0D4
		NiTPointerMap<ActorHandle, WadingWaterData*> wadingWaterData;          // 0D8
		std::uint64_t                                unk0F8;                   // 0F8
		std::uint64_t                                unk100;                   // 108
		std::uint32_t                                unk108;                   // 108
		std::uint32_t                                pad10C;                   // 10C
		std::uint8_t                                 unk110;                   // 110
		std::uint8_t                                 pad111;                   // 111
		std::uint16_t                                pad112;                   // 112
		std::uint32_t                                pad114;                   // 114
		TESObjectCELL*                               unk118;                   // 118
		mutable BSSpinLock                           lock;                     // 120
		NiPointer<BSTriShape>                        autoWater;                // 128
	};
	static_assert(sizeof(TESWaterSystem) == 0x130);
};


===============================================
File: include/RE/T/TESWeather.h
===============================================
#pragma once

#include "RE/B/BGSDirectionalAmbientLightingColors.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTList.h"
#include "RE/C/Color.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESTexture1024.h"

namespace RE
{
	class BGSVolumetricLighting;

	class TESWeather : public TESForm
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWeather;
		inline static constexpr auto VTABLE = VTABLE_TESWeather;
		inline static constexpr auto FORMTYPE = FormType::Weather;

		enum
		{
			kTotalLayers = 32
		};

		enum class SoundType
		{
			kDefault = 0,
			kPrecip = 1,
			kWind = 2,
			kThunder = 3
		};

		enum class WeatherDataFlag
		{
			kNone = 0,
			kPleasant = 1 << 0,
			kCloudy = 1 << 1,
			kRainy = 1 << 2,
			kSnow = 1 << 3,
			kPermAurora = 1 << 4,
			kAuroraFollowsSun = 1 << 5
		};

		struct ColorTimes
		{
			enum ColorTime : std::uint32_t
			{
				kSunrise = 0,
				kDay,
				kSunset,
				kNight,

				kTotal
			};
		};
		using ColorTime = ColorTimes::ColorTime;

		struct ColorTypes
		{
			enum
			{
				kSkyUpper = 0,
				kFogNear,
				kUnknown,
				kAmbient,
				kSunlight,
				kSun,
				kStars,
				kSkyLower,
				kHorizon,
				kEffectLighting,
				kCloudLODDiffuse,
				kCloudLODAmbient,
				kFogFar,
				kSkyStatics,
				kWaterMultiplier,
				kSunGlare,
				kMoonGlare,

				kTotal
			};
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		struct Data  // DATA
		{
		public:
			struct Color3
			{
			public:
				// members
				std::int8_t red;    // 0
				std::int8_t green;  // 1
				std::int8_t blue;   // 2
			};
			static_assert(sizeof(Color3) == 0x3);

			// members
			std::int8_t                                     windSpeed;                    // 00
			std::int8_t                                     unk01;                        // 01
			std::int8_t                                     unk02;                        // 02
			std::int8_t                                     transDelta;                   // 03
			std::int8_t                                     sunGlare;                     // 04
			std::int8_t                                     sunDamage;                    // 05
			std::int8_t                                     precipitationBeginFadeIn;     // 06
			std::int8_t                                     precipitationEndFadeOut;      // 07
			std::int8_t                                     thunderLightningBeginFadeIn;  // 08
			std::int8_t                                     thunderLightningEndFadeOut;   // 09
			std::int8_t                                     thunderLightningFrequency;    // 0A
			stl::enumeration<WeatherDataFlag, std::uint8_t> flags;                        // 0B
			Color3                                          lightningColor;               // 0C
			std::int8_t                                     visualEffectBegin;            // 0F
			std::int8_t                                     visualEffectEnd;              // 10
			std::int8_t                                     windDirection;                // 11
			std::int8_t                                     windDirectionRange;           // 12
			std::int8_t                                     unk13;                        // 13
		};
		static_assert(sizeof(Data) == 0x14);

		struct FogData  // FNAM
		{
		public:
			// members
			float dayNear;     // 00
			float dayFar;      // 04
			float nightNear;   // 08
			float nightFar;    // 0C
			float dayPower;    // 10
			float nightPower;  // 14
			float dayMax;      // 18
			float nightMax;    // 1C
		};
		static_assert(sizeof(FogData) == 0x20);

		struct WeatherSound  // SNAM
		{
		public:
			// members
			FormID                                     soundFormID;  // 00
			stl::enumeration<SoundType, std::uint32_t> type;         // 04
		};
		static_assert(sizeof(WeatherSound) == 0x8);

		struct WeatherSoundList : public BSSimpleList<WeatherSound*>
		{};

		~TESWeather() override;  // 00

		// override (TESForm)
		void InitializeData() override;      // 04
		void ClearData() override;           // 05
		bool Load(TESFile* a_mod) override;  // 06
		void InitItemImpl() override;        // 13

		// members
		TESTexture1024                      cloudTextures[kTotalLayers];                          // 020 - 00TX - L0TX
		std::int8_t                         cloudLayerSpeedY[kTotalLayers];                       // 220 - RNAM
		std::int8_t                         cloudLayerSpeedX[kTotalLayers];                       // 240 - QNAM
		Color                               cloudColorData[kTotalLayers][ColorTime::kTotal];      // 260 - PNAM
		float                               cloudAlpha[kTotalLayers][ColorTime::kTotal];          // 460 - JNAM
		std::uint32_t                       cloudLayerDisabledBits;                               // 660 - NAM1 - bitfield
		Data                                data;                                                 // 664 - DATA
		FogData                             fogData;                                              // 678 - FNAM
		Color                               colorData[ColorTypes::kTotal][ColorTime::kTotal];     // 698 - NAM0
		WeatherSoundList                    sounds;                                               // 7A8
		BSTArray<TESObjectSTAT*>            skyStatics;                                           // 7B8
		std::uint32_t                       numCloudLayers;                                       // 7D0 - LNAM
		std::uint32_t                       pad7D4;                                               // 7D4
		TESImageSpace*                      imageSpaces[ColorTime::kTotal];                       // 7D8 - IMSP
		BGSDirectionalAmbientLightingColors directionalAmbientLightingColors[ColorTime::kTotal];  // 7F8
		TESModel                            aurora;                                               // 878
		BGSLensFlare*                       sunGlareLensFlare;                                    // 8A0
		BGSVolumetricLighting*              volumetricLighting[ColorTime::kTotal];                // 8A8 - HNAM
		BGSShaderParticleGeometryData*      precipitationData;                                    // 8C8 - MNAM
		BGSReferenceEffect*                 referenceEffect;                                      // 8D0 - NNAM
	};
	static_assert(sizeof(TESWeather) == 0x8D8);
}


===============================================
File: include/RE/T/TESWeightForm.h
===============================================
#pragma once

#include "RE/B/BaseFormComponent.h"

namespace RE
{
	class TESWeightForm : public BaseFormComponent
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWeightForm;

		~TESWeightForm() override;  // 00

		// override (BaseFormComponent)
		void InitializeDataComponent() override;                // 01 - { weight = 0.0; }
		void ClearDataComponent() override;                     // 02 - { return; }
		void CopyComponent(BaseFormComponent* a_rhs) override;  // 03

		// members
		float         weight;  // 08
		std::uint32_t pad0C;   // 0C
	};
	static_assert(sizeof(TESWeightForm) == 0x10);
}


===============================================
File: include/RE/T/TESWordOfPower.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/F/FormTypes.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"

namespace RE
{
	class TESWordOfPower :
		public TESForm,     // 00
		public TESFullName  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWordOfPower;
		inline static constexpr auto VTABLE = VTABLE_TESWordOfPower;
		inline static constexpr auto FORMTYPE = FormType::WordOfPower;

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12
			};
		};

		~TESWordOfPower() override;  // 00

		// override (TESForm)
		bool Load(TESFile* a_mod) override;  // 06

		// members
		BSFixedString translation;  // 30 - TNAM
	};
	static_assert(sizeof(TESWordOfPower) == 0x38);
}


===============================================
File: include/RE/T/TESWorldSpace.h
===============================================
#pragma once

#include "RE/B/BSString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTList.h"
#include "RE/F/FormTypes.h"
#include "RE/N/NiPoint2.h"
#include "RE/N/NiSmartPointer.h"
#include "RE/N/NiTPointerMap.h"
#include "RE/T/TESForm.h"
#include "RE/T/TESFullName.h"
#include "RE/T/TESModel.h"
#include "RE/T/TESTexture.h"

namespace RE
{
	class BGSTerrainManager;
	class BSPortalGraph;
	class NiNode;

	struct WORLD_MAP_DATA  // MNAM
	{
	public:
		struct CameraData
		{
			float minHeight;     // 0
			float maxHeight;     // 4
			float initialPitch;  // 8
		};
		static_assert(sizeof(CameraData) == 0xC);

		// members
		std::uint32_t usableWidth;   // 00
		std::uint32_t usableHeight;  // 04
		std::int16_t  nwCellX;       // 08
		std::int16_t  nwCellY;       // 0A
		std::int16_t  seCellX;       // 0C
		std::int16_t  seCellY;       // 0E
		CameraData    cameraData;    // 10
	};
	static_assert(sizeof(WORLD_MAP_DATA) == 0x1C);

	struct WORLD_MAP_OFFSET_DATA  // ONAM
	{
	public:
		// members
		float mapScale;    // 00
		float mapOffsetX;  // 04
		float mapOffsetY;  // 08
		float mapOffsetZ;  // 0C
	};
	static_assert(sizeof(WORLD_MAP_OFFSET_DATA) == 0x10);

	struct CellID
	{
	public:
		constexpr CellID() noexcept :
			CellID(0, 0)
		{}

		constexpr CellID(std::int16_t a_y, std::int16_t a_x) noexcept :
			y(a_y),
			x(a_x)
		{}

		[[nodiscard]] friend constexpr bool operator==(const CellID& a_lhs, const CellID& a_rhs) noexcept
		{
			return a_lhs[0] == a_rhs[0] && a_lhs[1] == a_rhs[1];
		}

		[[nodiscard]] constexpr std::int16_t& operator[](std::size_t a_idx) noexcept
		{
			assert(a_idx < 2);
			return std::addressof(y)[a_idx];
		}

		[[nodiscard]] constexpr const std::int16_t& operator[](std::size_t a_idx) const noexcept
		{
			assert(a_idx < 2);
			return std::addressof(y)[a_idx];
		}

		// members
		std::int16_t y;
		std::int16_t x;
	};
	static_assert(sizeof(CellID) == 0x4);

	template <>
	struct BSCRC32_<CellID>
	{
	public:
		[[nodiscard]] inline std::uint32_t operator()(CellID a_key) const noexcept
		{
			return BSCRC32_<std::uint32_t>()(reinterpret_cast<const std::uint32_t&>(a_key));
		}
	};

	class BGSLargeRefData  // RNAM
	{
	public:
		// RNAM format in plugins is cell x,y -> formID + cell that contains refr x,y
		// a lot of RNAM data is for refrs that are actually in adjacent cells, it is currently unknown what behavior this has in game
		BSTHashMap<CellID, FormID*> cellFormIDMap;  // 00 - full data merged at runtime, value is an array of FormIDs with array size as the first entry
		BSTHashMap<FormID, CellID>  formIDCellMap;  // 30 - maps FormID to cell so opposite of above map

		// this filtered version of the full data removes all duplicate RNAM entries and also all entries where cell x,y doesn't match cell that contains refr x,y
		// this is the one actually used for loading large references on cell attach
		BSTHashMap<CellID, FormID*> cellFormIDMapFiltered;  // 60
	};
	static_assert(sizeof(BGSLargeRefData) == 0x90);

	class TESWorldSpace :
		public TESForm,      // 000
		public TESFullName,  // 020
		public TESModel      // 030
	{
	public:
		inline static constexpr auto RTTI = RTTI_TESWorldSpace;
		inline static constexpr auto VTABLE = VTABLE_TESWorldSpace;
		inline static constexpr auto FORMTYPE = FormType::WorldSpace;

		enum class Flag
		{
			kNone = 0,
			kSmallWorld = 1 << 0,
			kCantFastTravel = 1 << 1,
			kNoLODWater = 1 << 3,
			kNoLandscape = 1 << 4,
			kNoSky = 1 << 5,
			kFixedDimensions = 1 << 6,
			kNoGrass = 1 << 7,
		};

		enum class ParentUseFlag
		{
			kNone = 0,
			kUseLandData = 1 << 0,
			kUseLODData = 1 << 1,
			kUseMapData = 1 << 2,
			kUseWaterData = 1 << 3,
			kUseClimateData = 1 << 4,
			kUseImageSpaceData = 1 << 5,  // unused
			kUseSkyCell = 1 << 6,
		};

		struct RecordFlags
		{
			enum RecordFlag : std::uint32_t
			{
				kDeleted = 1 << 5,
				kIgnored = 1 << 12,
				kCantWait = 1 << 19
			};
		};

		struct ShortPoint
		{
		public:
			// members
			std::int16_t x;
			std::int16_t y;
		};
		static_assert(sizeof(ShortPoint) == 0x4);

		~TESWorldSpace() override;  // 00

		// override (TESForm)
		void        InitializeData() override;                                          // 04
		void        ClearData() override;                                               // 05
		bool        Load(TESFile* a_mod) override;                                      // 06
		bool        LoadPartial(TESFile* a_mod) override;                               // 07
		TESForm*    CreateDuplicateForm(bool a_createEditorID, void* a_arg2) override;  // 09
		bool        FindInFileFast(TESFile* a_mod) override;                            // 0C
		void        InitItemImpl() override;                                            // 13
		const char* GetFormEditorID() const override;                                   // 32 - { return editorID.c_str(); }
		bool        SetFormEditorID(const char* a_str) override;                        // 33 - { editorID = a_str; }
		bool        IsParentForm() override;                                            // 34 - { return true; }
		bool        IsFormTypeChild(FormType a_type) override;                          // 36

		[[nodiscard]] bool           HasMaxHeightData() const;
		[[nodiscard]] TESObjectCELL* GetSkyCell();
		[[nodiscard]] float          GetDefaultWaterHeight() const;

		// members
		BSTHashMap<CellID, TESObjectCELL*>                            cellMap;                  // 058
		TESObjectCELL*                                                persistentCell;           // 088
		BGSTerrainManager*                                            terrainManager;           // 090
		TESClimate*                                                   climate;                  // 098 - CNAM
		stl::enumeration<Flag, std::uint8_t>                          flags;                    // 0A0 - DATA
		std::uint8_t                                                  unk0A1;                   // 0A1 - more flags
		stl::enumeration<ParentUseFlag, std::uint16_t>                parentUseFlags;           // 0A2 - PNAM
		ShortPoint                                                    fixedCenter;              // 0A4 - WCTR
		BSTHashMap<std::uint32_t, BSTArray<NiPointer<TESObjectREFR>>> fixedPersistentRefMap;    // 0A8
		BSTArray<NiPointer<TESObjectREFR>>                            mobilePersistentRefs;     // 0D8
		NiTPointerMap<std::uint32_t, BSSimpleList<TESObjectREFR*>*>*  overlappedMultiboundMap;  // 0F0
		TESObjectCELL*                                                skyCell;                  // 0F8
		BSTHashMap<FormID, BGSLocation*>                              locationMap;              // 100
		NiPointer<BSPortalGraph>                                      portalGraph;              // 130 - smart ptr
		void*                                                         unk138;                   // 138
		void*                                                         unk140;                   // 140
		NiPointer<NiNode>                                             multiBoundNode;           // 148 - smart ptr
		NiPointer<NiNode>                                             portalSharedNode;         // 150 - smart ptr
		TESWorldSpace*                                                parentWorld;              // 158 - WNAM
		BGSLightingTemplate*                                          lightingTemplate;         // 160 - LTMP
		TESWaterForm*                                                 worldWater;               // 168 - NAM2
		TESWaterForm*                                                 lodWater;                 // 170 - NAM3
		float                                                         lodWaterHeight;           // 178 - NAM4
		std::uint32_t                                                 pad17C;                   // 17C
		std::uint64_t                                                 unk180;                   // 180
		WORLD_MAP_DATA                                                worldMapData;             // 188 - MNAM
		WORLD_MAP_OFFSET_DATA                                         worldMapOffsetData;       // 1A4 - ONAM
		std::uint32_t                                                 pad1B4;                   // 1B4
		BGSMusicType*                                                 musicType;                // 1B8 - ZNAM
		NiPoint2                                                      minimumCoords;            // 1C0
		NiPoint2                                                      maximumCoords;            // 1C8
		BSTHashMap<UnkKey, UnkValue>                                  unk1D0;                   // 1D0 - BSTHashMap<TESFile*, OFFSET_DATA*> offsetDataMap?
		BSString                                                      editorID;                 // 200 - EDID
		float                                                         defaultLandHeight;        // 210 - DNAM~
		float                                                         defaultWaterHeight;       // 214 - ~DNAM
		float                                                         distantLODMult;           // 218 - NAMA
		std::uint32_t                                                 pad21C;                   // 21C
		BGSEncounterZone*                                             encounterZone;            // 220 - XEZN
		BGSLocation*                                                  location;                 // 228 - XLCN
		TESTexture                                                    canopyShadowTexture;      // 230 - TNAM
		TESTexture                                                    waterEnvMap;              // 240 - UNAM
		BGSLargeRefData                                               largeRefData;             // 250 - RNAM
		std::uint64_t                                                 unk2E0;                   // 2E0
		BSTHashMap<UnkKey, UnkValue>                                  unk2E8;                   // 2E8
		BSTHashMap<UnkKey, UnkValue>                                  unk318;                   // 318
		float                                                         northRotation;            // 348
		std::uint32_t                                                 pad34C;                   // 34C
		std::int8_t*                                                  maxHeightData;            // 350 - MHDT
	};
	static_assert(sizeof(TESWorldSpace) == 0x358);
}


===============================================
File: include/RE/T/TLSData.h
===============================================
#pragma once

#include "RE/B/BSExtraData.h"
#include "RE/E/ExtraDataList.h"
#include "RE/E/ExtraDataTypes.h"

namespace RE
{
	struct TLSData
	{
		inline static constexpr uint32_t CACHED_EXTRA_DATA_SIZE = (static_cast<uint32_t>(ExtraDataType::kResourcesPreload) + 1);
		std::uint8_t                     unk000[0x10];                             // 000
		std::uint32_t                    stateCounter;                             // 010 - on GetExtraData(), this gets checked against the GlobalStateCounter, which is incremented every time extra data is changed or removed; if they're not equal, then the following cached extra data is zeroed-out and recached
		std::uint32_t                    pad014;                                   // 014
		ExtraDataList*                   cachedExtraDataList;                      // 018
		BSExtraData*                     cachedExtraData[CACHED_EXTRA_DATA_SIZE];  // 020 - ExtraData types up to kResourcesPreload (0xB5) are cached
		std::uint8_t                     unk5D0[0x30];                             // 5D0
		bool                             consoleMode;                              // 600
		std::uint8_t                     unk601[0x167];                            // 601
		std::uint32_t                    taskFlag;                                 // 768 -- unknown enum
																				   // ... many others ...
	};
	static_assert(offsetof(TLSData, consoleMode) == 0x600);
	static_assert(offsetof(TLSData, taskFlag) == 0x768);

	inline static TLSData* GetStaticTLSData()
	{
		REL::Relocation<std::uint32_t*> tlsIndex{ Offset::TlsIndex };
		auto                            tlsDataArray = reinterpret_cast<TLSData**>(__readgsqword(0x58));
		return tlsDataArray[*tlsIndex];
	}
}


===============================================
File: include/RE/T/TargetValueModifierEffect.h
===============================================
#pragma once

#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class TargetValueModifierEffect : public ValueModifierEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_TargetValueModifierEffect;
		inline static constexpr auto VTABLE = VTABLE_TargetValueModifierEffect;

		// override (ValueModifierEffect)
		bool GetAllowMultipleCastingSourceStacking() override;  // 11 - return { 0; }

		~TargetValueModifierEffect() override;  // 13

		void Start() override;  // 14

		// add
		virtual float GetTargetValue() const = 0;  // 21
	};
	static_assert(sizeof(TargetValueModifierEffect) == 0x98);
}


===============================================
File: include/RE/T/TaskQueueInterface.h
===============================================
#pragma once

#include "RE/B/BSPointerHandle.h"

namespace RE
{
	class NiAVObject;
	class NiNode;
	class NiPoint3;
	class SpellItem;
	class TESObjectREFR;
	class TESWeather;

	class TaskQueueInterface
	{
	public:
		static TaskQueueInterface* GetSingleton();

		static bool ShouldUseTaskQueue();

		void QueueNodeAttach(NiAVObject* a_obj, NiNode* a_root, bool a_arg3 = true, bool a_arg4 = false);                // 04
		void QueueNodeDetach(NiAVObject* a_obj);                                                                         // 05
		void QueueUpdateDestructibleObject(TESObjectREFR* a_refr, float a_damage, bool a_arg3, TESObjectREFR* a_cause);  // 09
		void QueueAddRipple(float a_scale, const NiPoint3& a_pos);                                                       // 45
		void QueueForceWeather(TESWeather* a_weather, bool a_forceOverride);                                             // 64
		void QueueActorDisarm(ActorHandle& a_target, ActorHandle& a_caster);                                             // 91
		void QueueRemoveSpell(ActorHandle& a_actor, SpellItem* a_spellItem);                                             // 93
	};
	//static_assert(sizeof(TaskQueueInterface) == 0x);
}


===============================================
File: include/RE/T/TelekinesisEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/B/BSPointerHandle.h"

namespace RE
{
	class TelekinesisEffect : public ActiveEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_TelekinesisEffect;
		inline static constexpr auto VTABLE = VTABLE_TelekinesisEffect;

		// override (ActiveEffect)
		void Update(float a_delta) override;  // 04

		~TelekinesisEffect() override;  // 13

		void Start() override;   // 14
		void Finish() override;  // 15

		// members
		void*           unk90;          // 90 - smart ptr
		float           moveVelocity;   // 98
		float           unk9C;          // 9C
		ObjectRefHandle grabbedObject;  // A0
		std::uint32_t   unkA4;          // A4
		bool            unkA8;          // A8
		bool            unkA9;          // A9
		std::uint8_t    unkAA;          // AA
		std::uint8_t    unkAB;          // AB
		std::uint32_t   unkAC;          // AC
	};
	static_assert(sizeof(TelekinesisEffect) == 0xB0);
}


===============================================
File: include/RE/T/TempEffectTraits.h
===============================================
#pragma once

#include "RE/B/BSTempEffect.h"
#include "RE/B/BSTempEffectDebris.h"
#include "RE/B/BSTempEffectGeometryDecal.h"
#include "RE/B/BSTempEffectParticle.h"
#include "RE/B/BSTempEffectSPG.h"
#include "RE/B/BSTempEffectSimpleDecal.h"
#include "RE/B/BSTempEffectWeaponBlood.h"
#include "RE/B/BSTerrainEffect.h"
#include "RE/M/ModelReferenceEffect.h"
#include "RE/R/ReferenceEffect.h"
#include "RE/S/ShaderReferenceEffect.h"
#include "RE/S/SummonPlacementEffect.h"

#define TEMPEFFECT_TRAITS(a_elem)                                       \
	case a_elem::TYPE:                                                  \
		if constexpr (std::is_convertible_v<const a_elem*, const T*>) { \
			return static_cast<const a_elem*>(this);                    \
		}                                                               \
		break

namespace RE
{
	template <class T, class>
	T* BSTempEffect::As() noexcept
	{
		return const_cast<T*>(
			static_cast<const BSTempEffect*>(this)->As<T>());
	}

	template <class T, class>
	const T* BSTempEffect::As() const noexcept
	{
		switch (GetType()) {
			TEMPEFFECT_TRAITS(BSTerrainEffect);
			TEMPEFFECT_TRAITS(BSTempEffectWeaponBlood);
			TEMPEFFECT_TRAITS(BSTempEffectSimpleDecal);
			TEMPEFFECT_TRAITS(BSTempEffectGeometryDecal);
			TEMPEFFECT_TRAITS(BSTempEffectParticle);
			TEMPEFFECT_TRAITS(BSTempEffectDebris);
			TEMPEFFECT_TRAITS(BSTempEffectSPG);
			TEMPEFFECT_TRAITS(BSTempEffect);
			TEMPEFFECT_TRAITS(ReferenceEffect);
			TEMPEFFECT_TRAITS(ModelReferenceEffect);
			TEMPEFFECT_TRAITS(ShaderReferenceEffect);
			TEMPEFFECT_TRAITS(SummonPlacementEffect);
		default:
			break;
		}

		return nullptr;
	}
}

#undef TEMPEFFECT_TRAITS


===============================================
File: include/RE/T/TextureAddressModes.h
===============================================
#pragma once

namespace RE
{
	namespace BSGraphics
	{
		enum class TextureAddressMode
		{
			kClampSClampT = 0,
			kClampSWrapT = 1,
			kWrapSClampT = 2,
			kWrapSWrapT = 3
		};
	}
}


===============================================
File: include/RE/T/TextureFileFormat.h
===============================================
#pragma once

namespace RE
{
	namespace BSGraphics
	{
		enum class TextureFileFormat
		{
			kBMP = 0,
			kJPG = 1,
			kTGA = 2,
			kPNG = 3,
			kDDS = 4,
		};
	}
}


===============================================
File: include/RE/T/TextureFilterModes.h
===============================================
#pragma once

namespace RE
{
	namespace BSGraphics
	{
		enum class TextureFilterMode
		{
			kNearest,
			kBilinear,
			kTrilinear,
			kAnisotropic,
			kDefault = kAnisotropic,
			kCompBilinear,
		};
	}
}


===============================================
File: include/RE/T/TextureFormat.h
===============================================
#pragma once

namespace RE
{
	namespace BSGraphics
	{
		enum class Format
		{
			kNone = static_cast<std::underlying_type_t<Format>>(-1),
			kUnknown = 0,
			kR32G32B32A32_TYPELESS = 1,
			kR32G32B32A32_FLOAT = 2,
			kR32G32B32A32_UINT = 3,
			kR32G32B32A32_SINT = 4,
			kR32G32B32_TYPELESS = 5,
			kR32G32B32_FLOAT = 6,
			kR32G32B32_UINT = 7,
			kR32G32B32_SINT = 8,
			kR16G16B16A16_TYPELESS = 9,
			kR16G16B16A16_FLOAT = 10,
			kR16G16B16A16_UNORM = 11,
			kR16G16B16A16_UINT = 12,
			kR16G16B16A16_SNORM = 13,
			kR16G16B16A16_SINT = 14,
			kR32G32_TYPELESS = 15,
			kR32G32_FLOAT = 16,
			kR32G32_UINT = 17,
			kR32G32_SINT = 18,
			kR32G8X24_TYPELESS = 19,
			kD32_FLOAT_S8X24_UINT = 20,
			kR32_FLOAT_X8X24_TYPELESS = 21,
			kX32_TYPELESS_G8X24_UINT = 22,
			kR10G10B10A2_TYPELESS = 23,
			kR10G10B10A2_UNORM = 24,
			kR10G10B10A2_UINT = 25,
			kR11G11B10_FLOAT = 26,
			kR8G8B8A8_TYPELESS = 27,
			kR8G8B8A8_UNORM = 28,
			kR8G8B8A8_UNORM_SRGB = 29,
			kR8G8B8A8_UINT = 30,
			kR8G8B8A8_SNORM = 31,
			kR8G8B8A8_SINT = 32,
			kR16G16_TYPELESS = 33,
			kR16G16_FLOAT = 34,
			kR16G16_UNORM = 35,
			kR16G16_UINT = 36,
			kR16G16_SNORM = 37,
			kR16G16_SINT = 38,
			kR32_TYPELESS = 39,
			kD32_FLOAT = 40,
			kR32_FLOAT = 41,
			kR32_UINT = 42,
			kR32_SINT = 43,
			kR24G8_TYPELESS = 44,
			kD24_UNORM_S8_UINT = 45,
			kR24_UNORM_X8_TYPELESS = 46,
			kX24_TYPELESS_G8_UINT = 47,
			kR8G8_TYPELESS = 48,
			kR8G8_UNORM = 49,
			kR8G8_UINT = 50,
			kR8G8_SNORM = 51,
			kR8G8_SINT = 52,
			kR16_TYPELESS = 53,
			kR16_FLOAT = 54,
			kD16_UNORM = 55,
			kR16_UNORM = 56,
			kR16_UINT = 57,
			kR16_SNORM = 58,
			kR16_SINT = 59,
			kR8_TYPELESS = 60,
			kR8_UNORM = 61,
			kR8_UINT = 62,
			kR8_SNORM = 63,
			kR8_SINT = 64,
			kA8_UNORM = 65,
			kR1_UNORM = 66,
			kR9G9B9E5_SHAREDEXP = 67,
			kR8G8_B8G8_UNORM = 68,
			kG8R8_G8B8_UNORM = 69,
			kBC1_TYPELESS = 70,
			kBC1_UNORM = 71,
			kBC1_UNORM_SRGB = 72,
			kBC2_TYPELESS = 73,
			kBC2_UNORM = 74,
			kBC2_UNORM_SRGB = 75,
			kBC3_TYPELESS = 76,
			kBC3_UNORM = 77,
			kBC3_UNORM_SRGB = 78,
			kBC4_TYPELESS = 79,
			kBC4_UNORM = 80,
			kBC4_SNORM = 81,
			kBC5_TYPELESS = 82,
			kBC5_UNORM = 83,
			kBC5_SNORM = 84,
			kB5G6R5_UNORM = 85,
			kB5G5R5A1_UNORM = 86,
			kB8G8R8A8_UNORM = 87,
			kB8G8R8X8_UNORM = 88,
			kR10G10B10_XR_BIAS_A2_UNORM = 89,
			kB8G8R8A8_TYPELESS = 90,
			kB8G8R8A8_UNORM_SRGB = 91,
			kB8G8R8X8_TYPELESS = 92,
			kB8G8R8X8_UNORM_SRGB = 93,
			kBC6H_TYPELESS = 94,
			kBC6H_UF16 = 95,
			kBC6H_SF16 = 96,
			kBC7_TYPELESS = 97,
			kBC7_UNORM = 98,
			kBC7_UNORM_SRGB = 99,
			kAYUV = 100,
			kY410 = 101,
			kY416 = 102,
			kNV12 = 103,
			kP010 = 104,
			kP016 = 105,
			k420_OPAQUE = 106,
			kYUY2 = 107,
			kY210 = 108,
			kY216 = 109,
			kNV11 = 110,
			kAI44 = 111,
			kIA44 = 112,
			kP8 = 113,
			kA8P8 = 114,
			kB4G4R4A4_UNORM = 115,
			kP208 = 130,
			kV208 = 131,
			kV408 = 132,
		};
	}
}


===============================================
File: include/RE/T/ThirdPersonState.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/N/NiPoint2.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiQuaternion.h"
#include "RE/P/PlayerInputHandler.h"
#include "RE/T/TESCameraState.h"

namespace RE
{
	class NiNode;

	class ThirdPersonState :
		public TESCameraState,     // 00
		public PlayerInputHandler  // 20
	{
	public:
		inline static constexpr auto RTTI = RTTI_ThirdPersonState;
		inline static constexpr auto VTABLE = VTABLE_ThirdPersonState;

		~ThirdPersonState() override;  // 00

		// override (TESCameraState)
		void Begin() override;                                               // 01
		void End() override;                                                 // 02
		void Update(BSTSmartPointer<TESCameraState>& a_nextState) override;  // 03
		void GetRotation(NiQuaternion& a_rotation) override;                 // 04
		void GetTranslation(NiPoint3& a_translation) override;               // 05
		void SaveGame(BGSSaveFormBuffer* a_buf) override;                    // 06
		void LoadGame(BGSLoadFormBuffer* a_buf) override;                    // 07
		void Revert(BGSLoadFormBuffer* a_buf) override;                      // 08

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                          // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_movementData) override;  // 04

		// add
		virtual void SetCameraHandle(RefHandle& a_handle);        // 09 - { return; }
		virtual void Unk_0A(void);                                // 0A - { return; }
		virtual void ProcessWeaponDrawnChange(bool a_drawn);      // 0B
		virtual bool GetFreeRotationMode() const;                 // 0C
		virtual void SetFreeRotationMode(bool a_weaponSheathed);  // 0D
		virtual void UpdateRotation();                            // 0E
		virtual void HandleLookInput(const NiPoint2& a_input);    // 0F

		// members
		NiAVObject*   thirdPersonCameraObj;   // 30
		NiNode*       thirdPersonFOVControl;  // 38
		NiPoint3      translation;            // 40
		NiQuaternion  rotation;               // 4C - [-1, 1]
		NiPoint3      posOffsetExpected;      // 5C
		NiPoint3      posOffsetActual;        // 68
		float         targetZoomOffset;       // 74
		float         currentZoomOffset;      // 78
		float         targetYaw;              // 7C - in radians
		float         currentYaw;             // 80 - in radians
		float         savedZoomOffset;        // 84
		float         pitchZoomOffset;        // 88 - [0, 100]
		float         unk8C;                  // 8C
		NiPoint3      collisionPos;           // 90 - valid if collisionPosValid != NaN
		float         collisionPosValid;      // 9C
		std::uint64_t unkA0;                  // A0
		BSFixedString animatedBoneName;       // A8
		NiQuaternion  animationRotation;      // B0
		std::uint64_t unkC0;                  // C0
		std::uint64_t unkC8;                  // C8
		std::uint32_t unkD0;                  // D0
		NiPoint2      freeRotation;           // D4
		bool          freeRotationEnabled;    // DC
		bool          stateNotActive;         // DD
		std::uint16_t unkDC;                  // DE
		bool          toggleAnimCam;          // E0
		bool          applyOffsets;           // E1
		std::uint16_t unkE2;                  // E2
		std::uint32_t unkE4;                  // E4
	};
	static_assert(sizeof(ThirdPersonState) == 0xE8);
}


===============================================
File: include/RE/T/ThumbstickEvent.h
===============================================
#pragma once

#include "RE/I/IDEvent.h"

namespace RE
{
	class ThumbstickEvent : public IDEvent
	{
	public:
		inline static constexpr auto RTTI = RTTI_ThumbstickEvent;

		struct InputTypes
		{
			enum InputType : std::uint32_t
			{
				kLeftThumbstick = 0x0B,
				kRightThumbstick = 0x0C
			};
		};
		using InputType = InputTypes::InputType;

		[[nodiscard]] bool IsLeft() const;
		[[nodiscard]] bool IsRight() const;

		// members
		float xValue;  // 28
		float yValue;  // 2C
	};
	static_assert(sizeof(ThumbstickEvent) == 0x30);
}


===============================================
File: include/RE/T/TitleSequenceMenu.h
===============================================
#pragma once

#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 4
	// flags = kNone
	// context = kNone
	class TitleSequenceMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_TitleSequenceMenu;
		constexpr static std::string_view MENU_NAME = "TitleSequence Menu";

		~TitleSequenceMenu() override;  // 00

		// override (IMenu)
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(TitleSequenceMenu) == 0x30);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(TitleSequenceMenu) == 0x40);
#endif
}


===============================================
File: include/RE/T/TogglePOVHandler.h
===============================================
#pragma once

#include "RE/H/HeldStateHandler.h"

namespace RE
{
	struct TogglePOVHandler : public HeldStateHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_TogglePOVHandler;

		~TogglePOVHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04

		// members
		bool          pressRegistered;  // 18
		std::uint8_t  pad19;            // 19
		std::uint16_t pad1A;            // 1A
		std::uint32_t pad1C;            // 1C
	};
	static_assert(sizeof(TogglePOVHandler) == 0x20);
}


===============================================
File: include/RE/T/ToggleRunHandler.h
===============================================
#pragma once

#include "RE/P/PlayerInputHandler.h"

namespace RE
{
	struct ToggleRunHandler : public PlayerInputHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_ToggleRunHandler;

		~ToggleRunHandler() override;  // 00

		// override (PlayerInputHandler)
		bool CanProcess(InputEvent* a_event) override;                                  // 01
		void ProcessButton(ButtonEvent* a_event, PlayerControlsData* a_data) override;  // 04
	};
	static_assert(sizeof(ToggleRunHandler) == 0x10);
}


===============================================
File: include/RE/T/TrainingMenu.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BSTEvent.h"
#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class MenuOpenCloseEvent;

	// menuDepth = 3
	// flags = kPausesGame | kUsesMenuContext | kUpdateUsesCursor
	// kUsesCursor if gamepad disabled
	// context = kNone
	class TrainingMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                            // 00
		public BSTEventSink<MenuOpenCloseEvent>  // 30
#else
		public IMenu  // 00
#endif
	{
	public:
		inline static constexpr auto      RTTI = RTTI_TrainingMenu;
		constexpr static std::string_view MENU_NAME = "Training Menu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT                                   \
	Actor*        trainer;          /* 38 - smart ptr */ \
			ActorValue    skill;            /* 40 */ \
			std::uint32_t unk44;            /* 44 */ \
			GFxValue      trainingMenuObj;  /* 48 - MovieClip */ \
			GFxValue      skillName;        /* 60 - TextField */ \
			GFxValue      skillMeter;       /* 78 - Components.Meter */ \
			GFxValue      trainerSkill;     /* 90 - TextField */ \
			GFxValue      timesTrained;     /* A8 - TextField */ \
			GFxValue      trainCost;        /* C0 - TextField */ \
			GFxValue      currentGold;      /* D8 - TextField */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0xB8);

		~TrainingMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_cbReg) override;    // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;  // 04

#ifndef SKYRIM_CROSS_VR
		// override (BSTEventSink<MenuOpenCloseEvent>)
		BSEventNotifyControl ProcessEvent(const MenuOpenCloseEvent* a_event, BSTEventSource<MenuOpenCloseEvent>* a_eventSource) override;  // 01
#endif

		[[nodiscard]] BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() noexcept
		{
			return &REL::RelocateMember<BSTEventSink<MenuOpenCloseEvent>>(this, 0x30, 0x40);
		}

		[[nodiscard]] const BSTEventSink<MenuOpenCloseEvent>* AsMenuOpenCloseEventSink() const noexcept
		{
			return const_cast<TrainingMenu*>(this)->AsMenuOpenCloseEventSink();
		}

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x38, 0x48);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x38, 0x48);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 38, 48
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(TrainingMenu) == 0x0F0);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(TrainingMenu) == 0x100);
#endif
}

#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/T/TurnUndeadEffect.h
===============================================
#pragma once

#include "RE/D/DemoralizeEffect.h"

namespace RE
{
	class TurnUndeadEffect :
		public DemoralizeEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_TurnUndeadEffect;
		inline static constexpr auto VTABLE = VTABLE_TurnUndeadEffect;

		// override (ActiveEffect)
		virtual ~TurnUndeadEffect();  // 13
	};
	static_assert(sizeof(TurnUndeadEffect) == 0x98);
}


===============================================
File: include/RE/T/TutorialMenu.h
===============================================
#pragma once

#include "RE/G/GFxValue.h"
#include "RE/I/IMenu.h"

namespace RE
{
	// menuDepth = 10
	// flags = kPausesGame | kModal | kUpdateUsesCursor
	// context = kMenuMode
	class TutorialMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_TutorialMenu;
		constexpr static std::string_view MENU_NAME = "Tutorial Menu";

		~TutorialMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04

		[[nodiscard]] inline GFxValue GetRoot() const noexcept
		{
			return REL::RelocateMember<GFxValue>(this, 0x30, 0x40);
		}

		inline void SetRoot(GFxValue a_root) noexcept
		{
			REL::RelocateMember<GFxValue>(this, 0x30, 0x40) = a_root;
		}

		// members
#ifndef SKYRIM_CROSS_VR
		GFxValue root;  // 30, 40 - "Menu_mc"
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(TutorialMenu) == 0x48);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(TutorialMenu) == 0x58);
#endif
}


===============================================
File: include/RE/T/TweenMenu.h
===============================================
#pragma once

#include "RE/B/BSTArray.h"
#include "RE/I/IMenu.h"

namespace RE
{
	namespace BSResource
	{
		struct ID;
	}

	// menuDepth = 0
	// flags = kPausesGame | kUpdateUsesCursor | kAllowSaving | kDontHideCursorWhenTopmost | kCustomRendering
	// context = kMenuMode
	class TweenMenu : public IMenu
	{
	public:
		inline static constexpr auto      RTTI = RTTI_TweenMenu;
		constexpr static std::string_view MENU_NAME = "TweenMenu";

		struct RUNTIME_DATA
		{
#define RUNTIME_DATA_CONTENT              \
	BSTArray<PerkData> perkData; /* 00 */ \
	float              unk48;    /* 18 */ \
	float              unk4C;    /* 1C */

			RUNTIME_DATA_CONTENT
		};
		static_assert(sizeof(RUNTIME_DATA) == 0x20);

		struct PerkData
		{
		public:
			// members
			BSResource::ID* fileHash;  // 00
			const char*     fileName;  // 08
		};
		static_assert(sizeof(PerkData) == 0x10);

		~TweenMenu() override;  // 00

		// override (IMenu)
		void               Accept(CallbackProcessor* a_processor) override;  // 01
		UI_MESSAGE_RESULTS ProcessMessage(UIMessage& a_message) override;    // 04
		void               PostDisplay() override;                           // 06

		[[nodiscard]] inline RUNTIME_DATA& GetRuntimeData() noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		[[nodiscard]] inline const RUNTIME_DATA& GetRuntimeData() const noexcept
		{
			return REL::RelocateMember<RUNTIME_DATA>(this, 0x30, 0x40);
		}

		// members
#ifndef SKYRIM_CROSS_VR
		RUNTIME_DATA_CONTENT  // 30, 40
#endif
	};
#ifndef ENABLE_SKYRIM_VR
	static_assert(sizeof(TweenMenu) == 0x50);
#elif !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(TweenMenu) == 0x60);
#endif
}
#undef RUNTIME_DATA_CONTENT


===============================================
File: include/RE/T/TypeInfo.h
===============================================
#pragma once

namespace RE
{
	namespace BSScript
	{
		class ObjectTypeInfo;

		class TypeInfo
		{
		public:
			enum class RawType : std::size_t
			{
				kNone = 0,
				kObject = 1,
				kString = 2,
				kInt = 3,
				kFloat = 4,
				kBool = 5,

				kNoneArray = 10,
				kObjectArray = 11,
				kStringArray = 12,
				kIntArray = 13,
				kFloatArray = 14,
				kBoolArray = 15,

				kArraysEnd

				// the type id for classes IS their class ptr
				// an object is an array if its first bit is set
			};

			TypeInfo();
			explicit TypeInfo(RawType a_type);
			TypeInfo(const TypeInfo& a_rhs);
			TypeInfo(TypeInfo&& a_rhs);

			TypeInfo& operator=(const TypeInfo& a_rhs);
			TypeInfo& operator=(TypeInfo&& a_rhs);
			TypeInfo& operator=(RawType a_rhs);

			friend bool operator==(const TypeInfo& a_lhs, const TypeInfo& a_rhs);
			friend bool operator!=(const TypeInfo& a_lhs, const TypeInfo& a_rhs);
			friend bool operator<(const TypeInfo& a_lhs, const TypeInfo& a_rhs);
			friend bool operator<=(const TypeInfo& a_lhs, const TypeInfo& a_rhs);
			friend bool operator>(const TypeInfo& a_lhs, const TypeInfo& a_rhs);
			friend bool operator>=(const TypeInfo& a_lhs, const TypeInfo& a_rhs);

			[[nodiscard]] RawType         GetRawType() const;
			[[nodiscard]] ObjectTypeInfo* GetTypeInfo() const;
			[[nodiscard]] RawType         GetUnmangledRawType() const;
			[[nodiscard]] bool            IsArray() const;
			[[nodiscard]] bool            IsBool() const;
			[[nodiscard]] bool            IsFloat() const;
			[[nodiscard]] bool            IsInt() const;
			[[nodiscard]] bool            IsLiteralArray() const;
			[[nodiscard]] bool            IsNoneArray() const;
			[[nodiscard]] bool            IsNoneObject() const;
			[[nodiscard]] bool            IsObject() const;
			[[nodiscard]] bool            IsObjectArray() const;
			[[nodiscard]] bool            IsString() const;
			[[nodiscard]] std::string     TypeAsString() const;
			void                          SetType(RawType a_type);

		protected:
			// members
			stl::enumeration<RawType, std::size_t> _rawType;  // 00
		};
		static_assert(sizeof(TypeInfo) == 0x8);
	}
}


===============================================
File: include/RE/T/TypeTraits.h
===============================================
#pragma once

#include "RE/C/CommonTypeTraits.h"
#include "RE/R/ReferenceArray.h"
#include "RE/T/TypeInfo.h"

namespace RE
{
	struct StaticFunctionTag
	{};

	namespace BSScript
	{
		template <class>
		struct _is_reference_wrapper :
			std::false_type
		{};

		template <class T>
		struct _is_reference_wrapper<
			reference_array<T>> :
			std::true_type
		{};

		template <class T>
		struct is_reference_wrapper :
			_is_reference_wrapper<
				std::remove_cv_t<T>>
		{};

		template <class T>
		inline constexpr bool is_reference_wrapper_v = is_reference_wrapper<T>::value;

		template <class T>
		struct is_not_reference_wrapper :
			std::negation<
				is_reference_wrapper<T>>
		{};

		template <class T>
		inline constexpr bool is_not_reference_wrapper_v = is_not_reference_wrapper<T>::value;

		template <class T, class = void>
		struct _unwrapped_type
		{
			using type = decay_pointer_t<T>;
		};

		template <class T>
		struct _unwrapped_type<
			T,
			std::enable_if_t<
				std::disjunction_v<
					is_array<T>,
					is_reference_wrapper<T>>>>
		{
			using type = decay_pointer_t<typename T::value_type>;
		};

		template <class T>
		struct unwrapped_type :
			_unwrapped_type<
				std::remove_cv_t<T>>
		{};

		template <class T>
		using unwrapped_type_t = typename unwrapped_type<T>::type;

		template <TypeInfo::RawType V>
		struct vm_type_constant :
			std::integral_constant<
				TypeInfo::RawType, V>
		{};

		template <class, class = void>
		struct _vm_type;

		template <>
		struct _vm_type<void> :
			vm_type_constant<
				TypeInfo::RawType::kNone>
		{};

		template <class T>
		struct _vm_type<
			T,
			std::enable_if_t<
				is_string_convertible_v<T>>> :
			vm_type_constant<
				TypeInfo::RawType::kString>
		{};

		template <class T>
		struct _vm_type<
			T,
			std::enable_if_t<
				is_integral_convertible_v<T>>> :
			vm_type_constant<
				TypeInfo::RawType::kInt>
		{};

		template <class T>
		struct _vm_type<
			T,
			std::enable_if_t<
				is_floating_point_convertible_v<T>>> :
			vm_type_constant<
				TypeInfo::RawType::kFloat>
		{};

		template <class T>
		struct _vm_type<
			T,
			std::enable_if_t<
				is_boolean_v<T>>> :
			vm_type_constant<
				TypeInfo::RawType::kBool>
		{};

		template <class T>
		struct vm_type :
			_vm_type<
				unwrapped_type_t<T>>
		{};

		template <class T>
		inline constexpr TypeInfo::RawType vm_type_v = vm_type<T>::value;

		template <class T>
		struct is_static_base :
			std::is_same<
				decay_pointer_t<T>,
				StaticFunctionTag>
		{};

		template <class T>
		inline constexpr bool is_static_base_v = is_static_base<T>::value;

		template <class T>
		struct is_static_base_pointer :
			std::conjunction<
				is_static_base<T>,
				std::is_pointer<T>>
		{};

		template <class T>
		inline constexpr bool is_static_base_pointer_v = is_static_base_pointer<T>::value;

		template <class T>
		struct is_valid_base :
			std::disjunction<
				is_static_base_pointer<T>,
				is_form_pointer<T>,
				is_alias_pointer<T>,
				is_active_effect_pointer<T>>
		{};

		template <class T>
		inline constexpr bool is_valid_base_v = is_valid_base<T>::value;

		template <class T>
		struct is_valid_parameter :
			std::conjunction<
				is_not_reference<T>,
				is_not_volatile<T>,
				std::disjunction<
					is_builtin<T>,
					is_form_pointer<T>,
					is_alias_pointer<T>,
					is_active_effect_pointer<T>,
					is_array<T>,
					is_reference_wrapper<T>>>
		{};

		template <class T>
		inline constexpr bool is_valid_parameter_v = is_valid_parameter<T>::value;

		template <class T>
		struct is_parameter_convertible :
			std::conjunction<
				is_not_reference<T>,
				is_not_volatile<T>,
				std::disjunction<
					is_builtin_convertible<T>,
					is_form_pointer<T>,
					is_alias_pointer<T>,
					is_active_effect_pointer<T>,
					is_array<T>,
					is_reference_wrapper<T>>>
		{};

		template <class T>
		inline constexpr bool is_parameter_convertible_v = is_parameter_convertible<T>::value;

		template <class T>
		struct is_valid_return :
			std::conjunction<
				is_not_const<T>,
				is_not_reference_wrapper<T>,
				is_valid_parameter<T>>
		{};

		template <class T>
		inline constexpr bool is_valid_return_v = is_valid_return<T>::value;

		template <class T>
		struct is_return_convertible :
			std::conjunction<
				is_not_const<T>,
				is_not_reference_wrapper<T>,
				is_parameter_convertible<T>>
		{};

		template <class T>
		inline constexpr bool is_return_convertible_v = is_return_convertible<T>::value;

		template <class R, class Cls, class... Args>
		struct is_valid_short_sig :
			std::conjunction<
				is_return_convertible<R>,
				is_valid_base<Cls>,
				is_parameter_convertible<Args>...>
		{};

		template <class R, class Cls, class... Args>
		inline constexpr bool is_valid_short_sig_v = is_valid_short_sig<R, Cls, Args...>::value;

		template <class Int, class R, class Cls, class... Args>
		struct is_valid_long_sig :
			std::conjunction<
				is_integral<Int>,
				is_valid_short_sig<R, Cls, Args...>>
		{};

		template <class R, class Int, class F, class Cls, class... Args>
		struct is_valid_latent_long_sig :
			std::conjunction<
				is_return_convertible<R>,
				is_integral<Int>,
				std::bool_constant<sizeof(F) == 1>,
				std::is_enum<F>,
				is_valid_short_sig<F, Cls, Args...>>
		{};

		template <class Int, class R, class Cls, class... Args>
		inline constexpr bool is_valid_long_sig_v = is_valid_long_sig<Int, R, Cls, Args...>::value;

		template <class R, class Int, class F, class Cls, class... Args>
		inline constexpr bool is_valid_latent_long_sig_v = is_valid_latent_long_sig<R, Int, F, Cls, Args...>::value;
	}
}


===============================================
File: include/RE/U/UI.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTimer.h"
#include "RE/G/GPtr.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class GFxMovieView;
	class IMenu;
	class MenuModeChangeEvent;
	class MenuOpenCloseEvent;

	namespace UIImpl
	{
		template <class, class = void>
		struct _has_menu_name :
			std::false_type
		{};

		template <class T>
		struct _has_menu_name<
			T,
			std::void_t<decltype(T::MENU_NAME)>> :
			std::true_type
		{};

		template <class T>
		struct has_menu_name :
			_has_menu_name<
				std::remove_cv_t<T>>
		{};

		template <class T>
		inline constexpr bool has_menu_name_v = has_menu_name<T>::value;

		template <class T>
		struct is_menu_ptr :
			std::is_convertible<
				std::remove_cv_t<T>,
				IMenu*>
		{};

		template <class T>
		inline constexpr bool is_menu_ptr_v = is_menu_ptr<T>::value;
	}

	class UI :
		public BSTSingletonSDM<UI>,                  // 000
		public BSTEventSource<MenuOpenCloseEvent>,   // 008
		public BSTEventSource<MenuModeChangeEvent>,  // 060
		public BSTEventSource<void*>                 // 0B8 MenuModeCounterChangedEvent/TutorialEvent
	{
	public:
		using Create_t = IMenu*();

		struct UIMenuEntry
		{
		public:
			UIMenuEntry(){};

			UIMenuEntry(GPtr<IMenu> a_menu, Create_t* a_create) :
				menu(a_menu), create(a_create) {}

			~UIMenuEntry() {}

			// members
			GPtr<IMenu> menu;    // 00
			Create_t*   create;  // 08
		};
		static_assert(sizeof(UIMenuEntry) == 0x10);

		static UI* GetSingleton();

		template <class T>
		void AddEventSink(BSTEventSink<T>* a_sink);
		bool GameIsPaused();
		template <class T>
		BSTEventSource<T>* GetEventSource();
		GPtr<IMenu>        GetMenu(const std::string_view& a_menuName);
		GPtr<GFxMovieView> GetMovieView(const std::string_view& a_menuName);
		bool               IsApplicationMenuOpen() const;
		bool               IsCursorHiddenWhenTopmost() const;
		bool               IsItemMenuOpen() const;
		bool               IsMenuOpen(const std::string_view& a_menuName);
		bool               IsModalMenuOpen() const;
		bool               IsPauseMenuDisabled() const;
		bool               IsSavingAllowed() const;
		bool               IsShowingMenus() const;
		bool               IsUsingCustomRendering() const;
		void               Register(std::string_view a_menuName, Create_t* a_creator);

		template <class T>
		void RemoveEventSink(BSTEventSink<T>* a_sink);
		void ShowMenus(bool a_show);

		template <
			class T,
			std::enable_if_t<
				std::conjunction_v<
					UIImpl::is_menu_ptr<T*>,
					UIImpl::has_menu_name<T>>,
				int> = 0>
		GPtr<T> GetMenu()
		{
			return GPtr<T>(static_cast<T*>(GetMenu(T::MENU_NAME).get()));
		}

		template <
			class T,
			std::enable_if_t<
				UIImpl::is_menu_ptr_v<T*>,
				int> = 0>
		GPtr<T> GetMenu(const std::string_view& a_menuName)
		{
			return GPtr<T>(static_cast<T*>(GetMenu(a_menuName).get()));
		}

		// members
		BSTArray<GPtr<IMenu>>                  menuStack;                     // 110
		BSTHashMap<BSFixedString, UIMenuEntry> menuMap;                       // 128
		mutable BSSpinLock                     processMessagesLock;           // 158
		std::uint32_t                          numPausesGame;                 // 160 (= 0) += 1 if (imenu->flags & 0x00001)
		std::uint32_t                          numItemMenus;                  // 164 (= 0) += 1 if (imenu->flags & 0x02000)
		std::uint32_t                          numDisablePauseMenu;           // 168 (= 0) += 1 if (imenu->flags & 0x00080)
		std::uint32_t                          numAllowSaving;                // 16C (= 0) += 1 if (imenu->flags & 0x00800)
		std::uint32_t                          numDontHideCursorWhenTopmost;  // 170 (= 0) += 1 if (imenu->flags & 0x04000)
		std::uint32_t                          numCustomRendering;            // 174 (= 0) += 1 if (imenu->flags & 0x08000)
		std::uint32_t                          numApplicationMenus;           // 178 (= 0) += 1 if (imenu->flags & 0x20000)
		bool                                   modal;                         // 17C (= 0)  = 1 if (imenu->flags & 0x00010)
		std::uint8_t                           pad17D;                        // 17D
		std::uint16_t                          pad17E;                        // 17E
		BSTimer                                uiTimer;                       // 180
		bool                                   menuSystemVisible;             // 1C0
		bool                                   closingAllMenus;               // 1C1
		std::uint16_t                          pad1C2;                        // 1C2
		std::uint32_t                          pad1C4;                        // 1C4
	};
	static_assert(sizeof(UI) == 0x1C8);

	template <class T>
	void UI::AddEventSink(BSTEventSink<T>* a_sink)
	{
		GetEventSource<T>()->AddEventSink(a_sink);
	}

	template <class T>
	BSTEventSource<T>* UI::GetEventSource()
	{
		return static_cast<BSTEventSource<T>*>(this);
	}

	template <class T>
	inline void UI::RemoveEventSink(BSTEventSink<T>* a_sink)
	{
		GetEventSource<T>()->RemoveEventSink(a_sink);
	}
}


===============================================
File: include/RE/U/UI3DSceneManager.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiFrustum.h"
#include "RE/N/NiMatrix3.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSCullingProcess;
	class BSLight;
	class BSShaderAccumulator;
	class NiAVObject;
	class NiCamera;
	class NiNode;
	class ShadowSceneNode;
	class TESImageSpaceModifier;

	enum class INTERFACE_LIGHT_SCHEME
	{
		kJournal = 0,
		kInventory,
		kInventoryMagic,
		kBook,
		kLoading,
		kUnk05,
		kStats,
		kLockpicking,

		kTotal = 8
	};

	class MenuLight
	{
	public:
		// members
		NiColor            color;         // 00
		NiPoint3           translate;     // 0C
		float              radius;        // 18
		float              fade;          // 1C
		bool               castsShadows;  // 20
		NiPointer<BSLight> light;         // 28
		MenuLight*         last;          // 30
	};
	static_assert(sizeof(MenuLight) == 0x38);

	class UI3DSceneManager : public BSTSingletonSDM<UI3DSceneManager>
	{
	public:
		static UI3DSceneManager* GetSingleton();

		void AttachChild(NiAVObject* a_obj);
		void AttachChild(NiAVObject* a_obj, INTERFACE_LIGHT_SCHEME a_scheme);
		void DetachChild(NiAVObject* a_obj);
		void SetCameraFOV(float a_fov);
		void SetCameraRotate(const NiMatrix3& a_rotate);
		void SetCameraPosition(const NiPoint3& a_pos);

		// members
		std::uint8_t                               pad01;               // 01
		std::uint16_t                              pad02;               // 02
		std::uint32_t                              pad04;               // 04
		BSCullingProcess*                          cullingProcess;      // 08
		NiPointer<BSShaderAccumulator>             unk10;               // 10
		NiPointer<BSShaderAccumulator>             unk18;               // 18
		NiPointer<NiCamera>                        camera;              // 20
		mutable BSSpinLock                         lock;                // 28
		ShadowSceneNode*                           shadowSceneNode;     // 30
		NiPointer<NiNode>                          menuObjects[8];      // 38
		BSTArray<MenuLight*>                       menuLights;          // 78
		INTERFACE_LIGHT_SCHEME                     currentlightScheme;  // 90
		std::uint32_t                              pad94;               // 94
		BSTArray<INTERFACE_LIGHT_SCHEME>           lightSchemes;        // 98
		BSTArray<NiPointer<TESImageSpaceModifier>> imageSpaceMods;      // B0
		NiPoint3                                   cachedCameraPos;     // C8
		NiMatrix3                                  cachedCameraRot;     // D0
		NiFrustum                                  viewFrustum;         // F8
	};
	static_assert(sizeof(UI3DSceneManager) == 0x118);
}


===============================================
File: include/RE/U/UIBlurManager.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"
#include "RE/D/DefaultObjectsReadyEvent.h"

namespace RE
{
	class TESImageSpaceModifier;

	class UIBlurManager :
		public BSTSingletonSDM<UIBlurManager>,                // 08
		public BSTEventSink<DefaultObjectsReadyEvent::Event>  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_UIBlurManager;

		~UIBlurManager() override;  // 00

		static UIBlurManager* GetSingleton();

		void DecrementBlurCount();
		void IncrementBlurCount();

		// members
		std::uint8_t           pad09;       // 09
		std::uint16_t          pad0A;       // 0A
		std::uint32_t          pad0C;       // 0C
		TESImageSpaceModifier* blurEffect;  // 10
		std::uint32_t          blurCount;   // 18
		std::uint32_t          pad1C;       // 1C
	};
	static_assert(sizeof(UIBlurManager) == 0x20);
}


===============================================
File: include/RE/U/UIMessage.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"

namespace RE
{
	class IUIMessageData;

	enum class UI_MESSAGE_TYPE
	{
		kUpdate = 0,
		kShow = 1,
		kReshow = 2,
		kHide = 3,
		kForceHide = 4,

		kScaleformEvent = 6,   // BSUIScaleformData
		kUserEvent = 7,        // BSUIMessageData
		kInventoryUpdate = 8,  // InventoryUpdateData
		kUserProfileChange = 9,
		kMUStatusChange = 10,
		kResumeCaching = 11,
		kUpdateController = 12,
		kChatterEvent = 13
	};

	class UIMessage
	{
	public:
		BSFixedString                                    menu;      // 00
		stl::enumeration<UI_MESSAGE_TYPE, std::uint32_t> type;      // 08
		std::uint32_t                                    pad0C;     // 0C
		IUIMessageData*                                  data;      // 10
		bool                                             isPooled;  // 18
		std::uint8_t                                     pad19;     // 19
		std::uint16_t                                    pad1A;     // 1A
		std::uint32_t                                    pad1C;     // 1C
	};
	static_assert(sizeof(UIMessage) == 0x20);
}


===============================================
File: include/RE/U/UIMessageQueue.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTMessageQueue.h"
#include "RE/B/BSTSingleton.h"
#include "RE/U/UIMessage.h"

namespace RE
{
	class IUIMessageData;
	class UIMessage;

	class UIMessageQueue : public BSTSingletonSDM<UIMessageQueue>
	{
	public:
		enum
		{
			kPoolSize = 64
		};

		static UIMessageQueue* GetSingleton();

		void            AddMessage(const BSFixedString& a_menuName, UI_MESSAGE_TYPE a_type, IUIMessageData* a_data);
		IUIMessageData* CreateUIMessageData(const BSFixedString& a_name);  // uses unk348, but doesn't seem to work like the skse thinks it does
		void            ProcessCommands();

		// members
		std::uint8_t                                 pad001;                  // 001
		std::uint16_t                                pad002;                  // 002
		std::uint32_t                                pad004;                  // 004
		BSTCommonStaticMessageQueue<UIMessage*, 100> messages;                // 008
		BSTHashMap<UnkKey, UnkValue>                 unk348;                  // 348
		std::uint32_t                                poolUsed;                // 378
		std::uint32_t                                pad37C;                  // 37C
		UIMessage                                    messagePool[kPoolSize];  // 380
	};
	static_assert(sizeof(UIMessageQueue) == 0xB80);
}


===============================================
File: include/RE/U/UIRenderManager.h
===============================================
#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/N/NiColor.h"
#include "RE/N/NiPoint3.h"
#include "RE/N/NiSmartPointer.h"

namespace RE
{
	class BSCullingProcess;
	class BSLight;
	class BSShaderAccumulator;
	class NiCamera;
	class NiNode;
	class NiFrustum;
	class ShadowSceneNode;

	class UIRenderManager : public BSTSingletonSDM<UIRenderManager>
	{
	public:
		struct UILightData
		{
		public:
			NiColor            color;         // 0
			NiPoint3           translate;     // 0C
			float              radius;        // 18
			float              fade;          // 1C
			bool               castsShadows;  // 20
			NiPointer<BSLight> light;         // 28
			UILightData*       next;          // 30
		};

		static UIRenderManager* GetSingleton()
		{
			REL::Relocation<UIRenderManager**> singleton{ RELOCATION_ID(517052, 403350) };
			return *singleton;
		}

		// members
		std::uint8_t                   pad01;            // 01
		std::uint16_t                  pad02;            // 02
		std::uint32_t                  pad04;            // 04
		BSCullingProcess*              cullingProcess;   // 08
		NiPointer<BSShaderAccumulator> unk10;            // 10
		NiPointer<BSShaderAccumulator> unk18;            // 18
		NiPointer<NiCamera>            camera;           // 20
		mutable BSSpinLock             lock;             // 28
		ShadowSceneNode*               shadowSceneNode;  // 30
		NiPointer<NiNode>              menuObjects[8];   // 38
		BSTArray<UILightData*>         lightData;        // 78 - fixed size of 8
		std::uint32_t                  currentMenu;      // 90
		std::uint32_t                  pad94;            // 94
		BSTArray<std::uint32_t>        menuIDs;          // 98
		BSTArray<void*>                unkB0;            // B0
		std::uint8_t                   padC8[48];        // C8
		NiFrustum                      viewFrustum;      // F8
	};
	static_assert(sizeof(UIRenderManager) == 0x118);
}


===============================================
File: include/RE/U/UISaveLoadManager.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTSingleton.h"
#include "RE/G/GFxValue.h"

namespace RE
{
	class BSSaveDataEvent;
	struct BGSSaveLoadManagerEvent;

	class UISaveLoadManager :
		public BSTSingletonSDM<UISaveLoadManager>,    // 10
		public BSTEventSink<BSSaveDataEvent>,         // 00
		public BSTEventSink<BGSSaveLoadManagerEvent>  // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_UISaveLoadManager;

		~UISaveLoadManager() override;  // 00

		// override (BSTEventSink<BSSaveDataEvent>)
		BSEventNotifyControl ProcessEvent(const BSSaveDataEvent* a_event, BSTEventSource<BSSaveDataEvent>* a_eventSource) override;  // 01

		// override (BSTEventSink<BGSSaveLoadManagerEvent>)
		BSEventNotifyControl ProcessEvent(const BGSSaveLoadManagerEvent* a_event, BSTEventSource<BGSSaveLoadManagerEvent>* a_eventSource) override;  // 01

		// members
		void*         unk18;  // 18
		std::uint64_t unk20;  // 20
		BSFixedString unk28;  // 28
		GFxValue      unk30;  // 30
		BSFixedString unk48;  // 48
		std::uint64_t unk50;  // 50
		std::uint64_t unk58;  // 58
		std::uint64_t unk60;  // 60
	};
	static_assert(sizeof(UISaveLoadManager) == 0x68);
}


===============================================
File: include/RE/U/UnlinkedTypes.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTHashMap.h"
#include "RE/L/LinkerProcessor.h"
#include "RE/T/TypeInfo.h"
#include "RE/V/VirtualMachine.h"

namespace RE
{
	namespace BSScript
	{
		namespace ByteCode
		{
#pragma pack(push, 4)
			struct Argument
			{
				enum class Type : std::uint32_t
				{
					kNone,
					kIdentifier,  // Identifier of object variables (Forms, Actors, etc.)
					kString,
					kInt,
					kFloat,
					kBool,
					kLocalVarIdx,   // index of local variable in function
					kMemberVarIdx,  // index of member variable in script instance
				};
				static_assert(sizeof(Type) == 0x4);

				union Value
				{
					int           i;
					float         f;
					bool          b;
					std::uint32_t idx;
					BSFixedString string;

					~Value(){};
				};
				static_assert(sizeof(Value) == 0x8);

				~Argument()
				{
					if (type == Type::kIdentifier || type == Type::kString) {
						value.string.~BSFixedString();
					}
				};
				// members
				Type  type;   // 00
				Value value;  // 04
			};
			static_assert(sizeof(Argument) == 0xC);
#pragma pack(pop)

			struct InstructionDefinition
			{
			public:
				// members
				std::uint64_t unk00;         // 00
				const char*   opCodeName;    // 08 - ex: iadd
				const char*   opCodeArgs;    // 10 - ex: SII
				std::byte     majorVersion;  // 18 - Papyrus major version when opCode was made
				std::byte     minorVersion;  // 19 - Papyrus minor version when opCode was made
				std::uint16_t pad1A;         // 1A
				std::uint32_t pad1C;         // 1C
			};
			static_assert(sizeof(InstructionDefinition) == 0x20);
		}
		namespace UnlinkedTypes
		{
			class ConvertTypeFunctor
			{
			public:
				inline static constexpr auto RTTI = RTTI_BSScript__UnlinkedTypes__Function__ConvertTypeFunctor;
				inline static constexpr auto VTABLE = VTABLE_BSScript__UnlinkedTypes__Function__ConvertTypeFunctor;

				virtual ~ConvertTypeFunctor();  // 00

				virtual bool ConvertVariableType(BSFixedString* a_typeAsString, TypeInfo& a_typeOut) = 0;  // 01
			};
			static_assert(sizeof(ConvertTypeFunctor) == 0x8);

			class LinkerConvertTypeFunctor : public ConvertTypeFunctor
			{
			public:
				~LinkerConvertTypeFunctor() override;  // 00

				bool ConvertVariableType(BSFixedString* a_typeAsString, TypeInfo& a_typeOut) override;  // 01 - This just jumps to LinkerProcessor::ConvertVariableType

				// members
				LinkerProcessor* linker;  // 08
			};
			static_assert(sizeof(LinkerConvertTypeFunctor) == 0x10);

			class VMTypeResolveFunctor : public ConvertTypeFunctor
			{
			public:
				inline static constexpr auto RTTI = RTTI_BSScript____VMTypeResolveFunctor;
				inline static constexpr auto VTABLE = VTABLE_BSScript____VMTypeResolveFunctor;
				~VMTypeResolveFunctor() override;  // 00

				bool ConvertVariableType(BSFixedString* a_typeAsString, TypeInfo& a_typeOut) override;  // 01
				// members
				Internal::VirtualMachine* vm;  // 08
			};
			static_assert(sizeof(VMTypeResolveFunctor) == 0x10);

			class InstructionStream
			{
			public:
				// members
				ScrapHeap*    threadScrapHeap;   // 00
				std::uint32_t functionCodeSize;  // 08
				std::uint32_t unk0C;             // 0C
				std::uint32_t pad10;             // 10
				std::uint32_t unk14;             // 14
				void*         unk18;             // 18 - Holds arguments
				void*         unk20;             // 20
				void*         unk28;             // 28
				std::uint64_t unk30;             // 30
				void*         unk38;             // 38
				std::uint64_t unk40;             // 40
			};
			static_assert(sizeof(InstructionStream) == 0x48);

			class Function
			{
			public:
				// members
				BSFixedString               returnTypeName;      // 00
				BSFixedString               docString;           // 08
				bool                        isNative;            // 10
				bool                        isGlobal;            // 11
				std::uint16_t               pad12;               // 12
				std::uint32_t               isPropertyFunction;  // 14
				std::uint32_t               userFlags;           // 18
				BSScrapArray<BSFixedString> paramNameArray;      // 20 - index i holds the name of the parameter
				BSScrapArray<BSFixedString> paramTypeArray;      // 40 - index i holds the type of said parameter from above
				BSScrapArray<BSFixedString> localNameArray;      // 60 - index i holds the name of the local var
				BSScrapArray<BSFixedString> localTypeArray;      // 80 - index i holds the type of said local var from above
				InstructionStream           instructionStream;   // A0
			};
			static_assert(sizeof(Function) == 0xE8);

			struct FunctionDebugInfo
			{
			public:
				// members
				std::uint32_t               functionType;            // 00
				BSFixedString               className;               // 08
				BSFixedString               stateName;               // 10
				BSFixedString               functionName;            // 18
				BSScrapArray<std::uint16_t> instructionLineNumbers;  // 20
			};
			static_assert(sizeof(FunctionDebugInfo) == 0x40);

			struct Property
			{
			public:
				// members
				std::uint32_t flags;         // 00
				std::uint32_t pad04;         // 04
				BSFixedString typeName;      // 08
				Function*     readHandler;   // 10 - get() function for the property
				Function*     writeHandler;  // 18 - set() function for the property
				BSFixedString autoVarName;   // 20
				BSFixedString docString;     // 28 - Requires loadDocStrings in CompiledScriptLoader to be true
				std::uint32_t userFlags;     // 30
				std::uint32_t pad34;         // 34
			};
			static_assert(sizeof(Property) == 0x38);

			// Usage: Create an object with Create(), then pass to CompiledScriptLoader::GetClass() to fill it with information of a script class
			// See: https://en.uesp.net/wiki/Skyrim_Mod:Compiled_Script_File_Format
			// Note: This will only grab the raw unlinked data from the script, the game won't use the object when called like this
			class Object
			{
				struct VariableData
				{
				public:
					// members
					BSFixedString typeName;  // 00
					std::uint64_t flags;     // 08
				};
				static_assert(sizeof(VariableData) == 0x10);

			public:
				~Object();

				static Object* Create();

				TES_HEAP_REDEFINE_NEW();

				// members
				BSFixedString                                                              fileName;               // 00
				std::uint64_t                                                              compilationTime;        // 08
				BSFixedString                                                              userName;               // 10
				BSFixedString                                                              computerName;           // 18
				std::byte                                                                  loadDebugInformation;   // 20 - is set to loadDebugInfo from CompiledScriptLoader
				std::uint64_t                                                              modificationTime;       // 28
				RE::BSScrapArray<FunctionDebugInfo*>                                       functionDebugInfoList;  // 30 - requires loadDebugInfo in CompiledScriptLoader to be true
				BSTHashMap<BSFixedString, std::byte>                                       userFlagMap;            // 50
				BSFixedString                                                              className;              // 80
				BSFixedString                                                              parentClassName;        // 88
				BSFixedString                                                              docString;              // 90 - requires loadDocStrings in CompiledScriptLoader to be true
				std::uint32_t                                                              userFlags;              // 98
				std::uint32_t                                                              pad_9C;                 // 9C
				BSTScrapHashMap<BSFixedString, VariableData>                               variables;              // A0
				BSTScrapHashMap<BSFixedString, Property*>                                  properties;             // D0
				BSTScrapHashMap<BSFixedString, Function*>                                  staticFunctions;        // 100
				BSTScrapHashMap<BSFixedString, Function*>                                  memberFunctions;        // 130 - Only has functions in empty state
				BSTScrapHashMap<BSFixedString, BSTScrapHashMap<BSFixedString, Function*>*> stateMap;               // 160 - Does not include the empty state functions
				std::uint32_t                                                              totalFunctions;         // 190 - staticFunctions size + memberFunctions size + all the state function variants in stateMap
				std::uint32_t                                                              pad_194;                // 194
				BSTScrapHashMap<BSFixedString, ByteCode::Argument>                         initialVariableValues;  // 198
				BSFixedString                                                              autoStateName;          // 1C8 - Is blank if no auto state in script

			private:
				void    Dtor();
				Object* Ctor();
			};
			static_assert(sizeof(Object) == 0x1D0);
		}
	}
}


===============================================
File: include/RE/U/UserEventEnabled.h
===============================================
#pragma once

#include "RE/U/UserEvents.h"

namespace RE
{
	class UserEventEnabled
	{
	public:
		using UEFlag = UserEvents::USER_EVENT_FLAG;

		// members
		stl::enumeration<UEFlag, std::uint32_t> newUserEventFlag;  // 0
		stl::enumeration<UEFlag, std::uint32_t> oldUserEventFlag;  // 4
	};
	static_assert(sizeof(UserEventEnabled) == 0x8);
}


===============================================
File: include/RE/U/UserEvents.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSingleton.h"

namespace RE
{
	class UserEvents : public BSTSingletonSDM<UserEvents>
	{
	public:
		struct INPUT_CONTEXT_IDS
		{
			enum INPUT_CONTEXT_ID : std::uint32_t
			{
				kGameplay = 0,
				kMenuMode,
				kConsole,
				kItemMenu,
				kInventory,
				kDebugText,
				kFavorites,
				kMap,
				kStats,
				kCursor,
				kBook,
				kDebugOverlay,
				kJournal,
				kTFCMode,
				kMapDebug,
				kLockpicking,
				kFavor,

				kTotal = 17,

				kNone = 18
			};
		};
		using INPUT_CONTEXT_ID = INPUT_CONTEXT_IDS::INPUT_CONTEXT_ID;

		enum class USER_EVENT_FLAG
		{
			kNone = 0,
			kMovement = 1 << 0,
			kLooking = 1 << 1,
			kActivate = 1 << 2,
			kMenu = 1 << 3,
			kConsole = 1 << 4,
			kPOVSwitch = 1 << 5,
			kFighting = 1 << 6,
			kSneaking = 1 << 7,
			kMainFour = 1 << 8,
			kWheelZoom = 1 << 9,
			kJumping = 1 << 10,
			kVATS = 1 << 11,
			kInvalid = 1 << 31,

			kAll = static_cast<std::underlying_type_t<USER_EVENT_FLAG>>(-1)
		};

		static UserEvents* GetSingleton();

		// members
		std::uint8_t  pad001;             // 001
		std::uint16_t pad002;             // 002
		std::uint32_t pad004;             // 004
		BSFixedString forward;            // 008 - "Forward"
		BSFixedString back;               // 010 - "Back"
		BSFixedString strafeLeft;         // 018 - "Strafe Left"
		BSFixedString strafeRight;        // 020 - "Strafe Right"
		BSFixedString move;               // 028 - "Move"
		BSFixedString look;               // 030 - "Look"
		BSFixedString activate;           // 038 - "Activate"
		BSFixedString leftAttack;         // 040 - "Left Attack/Block"
		BSFixedString rightAttack;        // 048 - "Right Attack/Block"
		BSFixedString dualAttack;         // 050 - "Dual Attack"
		BSFixedString forceRelease;       // 058 - "ForceRelease"
		BSFixedString pause;              // 060 - "Pause"
		BSFixedString readyWeapon;        // 068 - "Ready Weapon"
		BSFixedString togglePOV;          // 070 - "Toggle POV"
		BSFixedString jump;               // 078 - "Jump"
		BSFixedString journal;            // 080 - "Journal"
		BSFixedString sprint;             // 088 - "Sprint"
		BSFixedString sneak;              // 090 - "Sneak"
		BSFixedString shout;              // 098 - "Shout"
		BSFixedString kinectShout;        // 0A0 - "KinectShout"
		BSFixedString grab;               // 0A8 - "Grab"
		BSFixedString run;                // 0B0 - "Run"
		BSFixedString toggleRun;          // 0B8 - "Toggle Always Run"
		BSFixedString autoMove;           // 0C0 - "Auto-Move"
		BSFixedString quicksave;          // 0C8 - "Quicksave"
		BSFixedString quickload;          // 0D0 - "Quickload"
		BSFixedString newSave;            // 0D8 - "NewSave"
		BSFixedString inventory;          // 0E0 - "Inventory"
		BSFixedString stats;              // 0E8 - "Stats"
		BSFixedString map;                // 0F0 - "Map"
		BSFixedString screenshot;         // 0F8 - "Screenshot"
		BSFixedString multiScreenshot;    // 100 - "Multi-Screenshot"
		BSFixedString console;            // 108 - "Console"
		BSFixedString cameraPath;         // 110 - "CameraPath"
		BSFixedString tweenMenu;          // 118 - "Tween Menu"
		BSFixedString takeAll;            // 120 - "Take All"
		BSFixedString accept;             // 128 - "Accept"
		BSFixedString cancel;             // 130 - "Cancel"
		BSFixedString up;                 // 138 - "Up"
		BSFixedString down;               // 140 - "Down"
		BSFixedString left;               // 148 - "Left"
		BSFixedString right;              // 150 - "Right"
		BSFixedString pageUp;             // 158 - "PageUp"
		BSFixedString pageDown;           // 160 - "PageDown"
		BSFixedString pick;               // 168 - "Pick"
		BSFixedString pickNext;           // 170 - "PickNext"
		BSFixedString pickPrevious;       // 178 - "PickPrevious"
		BSFixedString cursor;             // 180 - "Cursor"
		BSFixedString kinect;             // 188 - "Kinect"
		BSFixedString sprintStart;        // 190 - "SprintStart"
		BSFixedString sprintStop;         // 198 - "SprintStop"
		BSFixedString sneakStart;         // 1A0 - "sneakStart"
		BSFixedString sneakStop;          // 1A8 - "sneakStop"
		BSFixedString blockStart;         // 1B0 - "blockStart"
		BSFixedString blockStop;          // 1B8 - "blockStop"
		BSFixedString blockBash;          // 1C0 - "blockBash"
		BSFixedString attackStart;        // 1C8 - "attackStart"
		BSFixedString attackPowerStart;   // 1D0 - "attackPowerStart"
		BSFixedString reverseDirection;   // 1D8 - "reverseDirection"
		BSFixedString unequip;            // 1E0 - "Unequip"
		BSFixedString zoomIn;             // 1E8 - "Zoom In"
		BSFixedString zoomOut;            // 1F0 - "Zoom Out"
		BSFixedString rotateItem;         // 1F8 - "RotateItem"
		BSFixedString leftStick;          // 200 - "Left Stick"
		BSFixedString prevPage;           // 208 - "PrevPage"
		BSFixedString nextPage;           // 210 - "NextPage"
		BSFixedString prevSubPage;        // 218 - "PrevSubPage"
		BSFixedString nextSubPage;        // 220 - "NextSubPage"
		BSFixedString leftEquip;          // 228 - "LeftEquip"
		BSFixedString rightEquip;         // 230 - "RightEquip"
		BSFixedString toggleFavorite;     // 238 - "ToggleFavorite"
		BSFixedString favorites;          // 240 - "Favorites"
		BSFixedString hotkey1;            // 248 - "Hotkey1"
		BSFixedString hotkey2;            // 250 - "Hotkey2"
		BSFixedString hotkey3;            // 258 - "Hotkey3"
		BSFixedString hotkey4;            // 260 - "Hotkey4"
		BSFixedString hotkey5;            // 268 - "Hotkey5"
		BSFixedString hotkey6;            // 270 - "Hotkey6"
		BSFixedString hotkey7;            // 278 - "Hotkey7"
		BSFixedString hotkey8;            // 280 - "Hotkey8"
		BSFixedString quickInventory;     // 288 - "Quick Inventory"
		BSFixedString quickMagic;         // 290 - "Quick Magic"
		BSFixedString quickStats;         // 298 - "Quick Stats"
		BSFixedString quickMap;           // 2A0 - "Quick Map"
		BSFixedString toggleCursor;       // 2A8 - "ToggleCursor"
		BSFixedString wait;               // 2B0 - "Wait"
		BSFixedString click;              // 2B8 - "Click"
		BSFixedString mapLookMode;        // 2C0 - "MapLookMode"
		BSFixedString equip;              // 2C8 - "Equip"
		BSFixedString dropItem;           // 2D0 - "DropItem"
		BSFixedString rotate;             // 2D8 - "Rotate"
		BSFixedString nextFocus;          // 2E0 - "NextFocus"
		BSFixedString prevFocus;          // 2E8 - "PreviousFocus"
		BSFixedString setActiveQuest;     // 2F0 - "SetActiveQuest"
		BSFixedString placePlayerMarker;  // 2F8 - "PlacePlayerMarker"
		BSFixedString xButton;            // 300 - "XButton"
		BSFixedString yButton;            // 308 - "YButton"
		BSFixedString chargeItem;         // 310 - "ChargeItem"
		BSFixedString unk318;             // 318 - ""
		BSFixedString playerPosition;     // 320 - "PlayerPosition"
		BSFixedString localMap;           // 328 - "LocalMap"
		BSFixedString localMapMoveMode;   // 330 - "LocalMapMoveMode"
		BSFixedString itemZoom;           // 338 - "Item Zoom"
	};
	static_assert(sizeof(UserEvents) == 0x340);
}


===============================================
File: include/RE/V/VATS.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTSingleton.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/H/HitData.h"

namespace RE
{
	class Actor;
	class BGSCameraShot;
	class BSLight;
	class ExtraDataList;
	class ImageSpaceModifierInstanceRB;
	class TESBoundObject;

	class VATSCommand
	{
	public:
		std::uint32_t   actionPoints;  // 00 - 12
		std::uint8_t    unk04;         // 04
		std::uint8_t    unk05;         // 05
		std::uint8_t    unk06;         // 06
		std::uint8_t    unk07;         // 07
		std::uint8_t    unk08;         // 08
		std::uint8_t    unk09;         // 09
		std::uint16_t   unk0A;         // 0A
		ObjectRefHandle targetHandle;  // 0C
		ActorValue      bodyPartAV;    // 10
		std::uint32_t   pad14;         // 14
		HitData         hitData;       // 18
		std::uint64_t   unkA8;         // A8
		std::uint32_t   unkB0;         // B0
	};
	static_assert(sizeof(VATSCommand) == 0xB8);

	class VATS : public BSTSingletonSDM<VATS>
	{
	public:
		enum class VATS_MODE : std::uint32_t
		{
			kNone = 0,
			kKillCam = 4
		};

		[[nodiscard]] static VATS* GetSingleton()
		{
			REL::Relocation<VATS**> singleton{ RELOCATION_ID(514725, 400883) };
			return *singleton;
		}

		void SetMagicTimeSlowdown(float a_magicTimeSlowdown, float a_playerMagicTimeSlowdown)
		{
			using func_t = decltype(&VATS::SetMagicTimeSlowdown);
			REL::Relocation<func_t> func{ RELOCATION_ID(43103, 44300) };
			return func(this, a_magicTimeSlowdown, a_playerMagicTimeSlowdown);
		}

		// members
		std::uint32_t                          pad00;                    // 00
		BSTArray<BSTSmartPointer<VATSCommand>> commandList;              // 08
		VATS_MODE                              VATSMode;                 // 20
		std::uint32_t                          pad24;                    // 24
		std::uint64_t                          unk28;                    // 28
		BGSCameraShot*                         cameraShot;               // 30
		float                                  safetyTime;               // 38
		float                                  cameraTime;               // 3C
		float                                  castingAfterKillDelay;    // 40
		std::uint32_t                          pad44;                    // 44
		std::uint64_t                          unk48;                    // 48
		std::uint64_t                          unk50;                    // 50
		std::uint64_t                          unk58;                    // 58
		ImageSpaceModifierInstanceRB*          unk60;                    // 60
		ImageSpaceModifierInstanceRB*          unk68;                    // 68
		NiPointer<BSLight>                     VATSLight;                // 70
		bool                                   unk78;                    // 78
		bool                                   unk79;                    // 79
		std::uint16_t                          pad7A;                    // 7A
		std::int32_t                           unk7C;                    // 7C
		float                                  magicTimeSlowdown;        // 80
		float                                  playerMagicTimeSlowdown;  // 84
		TESBoundObject*                        item;                     // 88
		ExtraDataList*                         extraList;                // 90
		NiPointer<Actor>                       target;                   // 98
		std::int32_t                           unkA0;                    // A0
		std::uint32_t                          padA4;                    // A4
		NiPointer<Actor>                       attacker;                 // A8
		NiPointer<Actor>                       unkB0;                    // B0 - stranger?
		mutable BSSpinLock                     lock;                     // B8
	};
	static_assert(sizeof(VATS) == 0xC0);
}


===============================================
File: include/RE/V/VDescTable.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTTuple.h"
#include "RE/M/MemoryManager.h"
#include "RE/T/TypeInfo.h"

namespace RE
{
	namespace BSScript
	{
		namespace Internal
		{
			struct VDescTable
			{
			public:
				explicit inline VDescTable(std::uint16_t a_numParams, std::uint16_t a_numLocals) :
					entries(static_cast<std::size_t>(a_numParams + a_numLocals)),
					paramCount(a_numParams),
					totalEntries(static_cast<std::uint16_t>(a_numParams + a_numLocals))
				{}

				// members
				SimpleArray<BSTTuple<BSFixedString, TypeInfo>> entries;       // 00
				std::uint16_t                                  paramCount;    // 08
				std::uint16_t                                  totalEntries;  // 0A
				std::uint32_t                                  pad0C{ 0 };    // 0C
			};
			static_assert(sizeof(VDescTable) == 0x10);
		}
	}
}


===============================================
File: include/RE/V/ValueAndConditionsEffect.h
===============================================
#pragma once

#include "RE/A/ActorValues.h"
#include "RE/V/ValueModifierEffect.h"

namespace RE
{
	class ValueAndConditionsEffect :
		public ValueModifierEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_ValueAndConditionsEffect;
		inline static constexpr auto VTABLE = VTABLE_ValueAndConditionsEffect;

		// override (ActiveEffect)
		virtual void SaveGame(BGSSaveFormBuffer* a_buf) override;  // 08
		virtual void LoadGame(BGSLoadFormBuffer* a_buf) override;  // 09
		virtual ~ValueAndConditionsEffect();                       // 13

		// override (ValueModifierEffect)
		virtual void ModifyActorValue(Actor* a_actor, float a_value, ActorValue a_actorValue) override;  // 20

		// members
		ActorValue actorValue;  // 98
	};
	static_assert(sizeof(ValueAndConditionsEffect) == 0xA0);
}


===============================================
File: include/RE/V/ValueModifierEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"
#include "RE/A/ActorValues.h"

namespace RE
{
	class ValueModifierEffect : public ActiveEffect
	{
	public:
		inline static constexpr auto RTTI = RTTI_ValueModifierEffect;
		inline static constexpr auto VTABLE = VTABLE_ValueModifierEffect;

		// override (ActiveEffect)
		void OnAdd(MagicTarget* a_target) override;             // 01
		void Update(float a_delta) override;                    // 04
		bool IsCausingHealthDamage() override;                  // 06
		bool GetAllowMultipleCastingSourceStacking() override;  // 11 - { return  1; };
		void ClearTargetImpl() override;                        // 12

		~ValueModifierEffect() override;  // 13

		void  Start() override;                                                   // 14
		void  Finish() override;                                                  // 15
		bool  CheckCustomSkillUseConditions() const override;                     // 17
		float GetCustomSkillUseMagnitudeMultiplier(float a_mult) const override;  // 18

		// add
		virtual void SetActorValue(ActorValue a_actorValue);                                    // 19 - { actorValue = a_actorValue; }
		virtual bool ShouldModifyOnStart();                                                     // 1A
		virtual void ModifyOnStart();                                                           // 1B
		virtual bool ShouldModifyOnUpdate() const;                                              // 1C
		virtual void ModifyOnUpdate(float a_delta);                                             // 1D
		virtual bool ShouldModifyOnFinish() const;                                              // 1E
		virtual void ModifyOnFinish(Actor* a_caster, Actor* a_target, float a_value);           // 1F
		virtual void ModifyActorValue(Actor* a_actor, float a_value, ActorValue a_actorValue);  // 20

		// members
		ActorValue actorValue;  // 90
		float      value;       // 94
	};
	static_assert(sizeof(ValueModifierEffect) == 0x98);
}


===============================================
File: include/RE/V/VampireLordEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class VampireLordEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_VampireLordEffect;
		inline static constexpr auto VTABLE = VTABLE_VampireLordEffect;

		// override (ActiveEffect)
		virtual ~VampireLordEffect();    // 13
		virtual void Start() override;   // 14
		virtual void Finish() override;  // 15
	};
	static_assert(sizeof(VampireLordEffect) == 0x90);
}


===============================================
File: include/RE/V/Variable.h
===============================================
#pragma once

#include "RE/B/BSFixedString.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/T/TypeInfo.h"

namespace RE
{
	namespace BSScript
	{
		class Array;
		class Object;

		class Variable
		{
		public:
			union Value
			{
				Value(void* a_val = nullptr);
				~Value();

				// members
				std::int32_t            i;
				std::uint32_t           u;
				float                   f;
				bool                    b;
				void*                   p;
				BSTSmartPointer<Array>  arr;
				BSTSmartPointer<Object> obj;
				BSFixedString           str;
			};
			static_assert(sizeof(Value) == 0x8);

			Variable();
			Variable(const TypeInfo& a_type);
			Variable(const Variable& a_rhs);
			Variable(Variable&& a_rhs);
			~Variable();

			Variable& operator=(const Variable& a_rhs);
			Variable& operator=(Variable&& a_rhs);

			bool operator==(const Variable& a_rhs) const;
			bool operator!=(const Variable& a_rhs) const;
			bool operator<(const Variable& a_rhs) const;
			bool operator>(const Variable& a_rhs) const;
			bool operator<=(const Variable& a_rhs) const;
			bool operator>=(const Variable& a_rhs) const;

			[[nodiscard]] bool IsType(TypeInfo a_typeInfo) const;
			[[nodiscard]] bool IsArray() const;
			[[nodiscard]] bool IsBool() const;
			[[nodiscard]] bool IsFloat() const;
			[[nodiscard]] bool IsInt() const;
			[[nodiscard]] bool IsLiteralArray() const;
			[[nodiscard]] bool IsNoneArray() const;
			[[nodiscard]] bool IsNoneObject() const;
			[[nodiscard]] bool IsObject(void) const;
			[[nodiscard]] bool IsObjectArray() const;
			[[nodiscard]] bool IsString() const;

			[[nodiscard]] TypeInfo                GetType() const;
			[[nodiscard]] std::int32_t            GetSInt() const;
			[[nodiscard]] std::uint32_t           GetUInt() const;
			[[nodiscard]] float                   GetFloat() const;
			[[nodiscard]] bool                    GetBool() const;
			[[nodiscard]] BSTSmartPointer<Array>  GetArray() const;
			[[nodiscard]] BSTSmartPointer<Object> GetObject() const;
			[[nodiscard]] std::string_view        GetString() const;

			void SetNone();
			void SetSInt(std::int32_t a_val);
			void SetUInt(std::uint32_t a_val);
			void SetFloat(float a_val);
			void SetBool(bool a_val);
			void SetArray(BSTSmartPointer<Array> a_val);
			void SetObject(BSTSmartPointer<Object> a_val);
			void SetObject(BSTSmartPointer<Object> a_val, TypeInfo::RawType a_type);
			void SetString(std::string_view a_val);

			template <class T>
			void Pack(T&& a_src);

			template <class T>
			[[nodiscard]] T Unpack() const;

		private:
			void ChangeType(TypeInfo::RawType a_type);
			void Cleanup();
			void Assign(const Variable& a_rhs);

			// members
			TypeInfo varType;  // 00
			Value    value;    // 08
		};
		static_assert(sizeof(Variable) == 0x10);
	}
}


===============================================
File: include/RE/V/VertexDesc.h
===============================================
#pragma once

namespace RE
{
	//https://github.com/hexabits/nifskope/blob/develop/src/data/niftypes.h

	namespace BSGraphics
	{
		struct Vertex
		{
			enum Attribute : std::uint8_t
			{
				VA_POSITION = 0x0,
				VA_TEXCOORD0 = 0x1,
				VA_TEXCOORD1 = 0x2,
				VA_NORMAL = 0x3,
				VA_BINORMAL = 0x4,
				VA_COLOR = 0x5,
				VA_SKINNING = 0x6,
				VA_LANDDATA = 0x7,
				VA_EYEDATA = 0x8,

				VA_COUNT = 9
			};

			enum Flags : std::uint16_t
			{
				VF_VERTEX = 1 << VA_POSITION,
				VF_UV = 1 << VA_TEXCOORD0,
				VF_UV_2 = 1 << VA_TEXCOORD1,
				VF_NORMAL = 1 << VA_NORMAL,
				VF_TANGENT = 1 << VA_BINORMAL,
				VF_COLORS = 1 << VA_COLOR,
				VF_SKINNED = 1 << VA_SKINNING,
				VF_LANDDATA = 1 << VA_LANDDATA,
				VF_EYEDATA = 1 << VA_EYEDATA,
				VF_FULLPREC = 0x400
			};

			enum Masks : std::uint64_t
			{
				DESC_MASK_VERT = 0xFFFFFFFFFFFFFFF0,
				DESC_MASK_UVS = 0xFFFFFFFFFFFFFF0F,
				DESC_MASK_NBT = 0xFFFFFFFFFFFFF0FF,
				DESC_MASK_SKCOL = 0xFFFFFFFFFFFF0FFF,
				DESC_MASK_DATA = 0xFFFFFFFFFFF0FFFF,
				DESC_MASK_OFFSET = 0xFFFFFF0000000000,
				DESC_MASK_FLAGS = ~(DESC_MASK_OFFSET)
			};
		};

		class VertexDesc
		{
		public:
			[[nodiscard]] bool HasFlag(Vertex::Flags a_flag) const
			{
				return ((desc >> 44) & a_flag) != 0;
			}
			void SetFlag(Vertex::Flags a_flag)
			{
				desc |= (static_cast<uint64_t>(a_flag) << 44);
			}
			void ClearFlag(Vertex::Flags a_flag)
			{
				desc &= ~(static_cast<uint64_t>(a_flag) << 44);
			}

			[[nodiscard]] std::uint32_t GetAttributeOffset(Vertex::Attribute a_attribute) const
			{
				return (desc >> (4 * static_cast<uint8_t>(a_attribute) + 2)) & 0x3C;
			}
			void SetAttributeOffset(Vertex::Attribute a_attribute, std::uint32_t a_offset)
			{
				if (a_attribute != Vertex::Attribute::VA_POSITION) {
					const uint64_t lhs = static_cast<uint64_t>(a_offset) << (4 * static_cast<uint8_t>(a_attribute) + 2);
					const uint64_t rhs = desc & ~static_cast<uint64_t>(15 << (4 * static_cast<uint8_t>(a_attribute) + 4));

					desc = lhs | rhs;
				}
			}
			void ClearAttributeOffsets()
			{
				desc &= Vertex::Masks::DESC_MASK_OFFSET;
			}

			[[nodiscard]] Vertex::Flags GetFlags() const
			{
				return static_cast<Vertex::Flags>((desc & Vertex::Masks::DESC_MASK_OFFSET) >> 44);
			}
			void SetFlags(Vertex::Flags a_flags)
			{
				desc |= (static_cast<uint64_t>(a_flags) << 44) | (desc & Vertex::Masks::DESC_MASK_FLAGS);
			}

			[[nodiscard]] std::uint32_t GetSize()
			{
				std::uint32_t vertexSize = 0;
				auto          flags = GetFlags();

				if (flags & Vertex::VF_VERTEX) {
					vertexSize += sizeof(float) * 4;
				}
				if (flags & Vertex::VF_UV) {
					vertexSize += sizeof(std::uint16_t) * 2;
				}
				if (flags & Vertex::VF_UV_2) {
					vertexSize += sizeof(std::uint16_t) * 2;
				}
				if (flags & Vertex::VF_NORMAL) {
					vertexSize += sizeof(std::uint16_t) * 2;
					if (flags & Vertex::VF_TANGENT) {
						vertexSize += sizeof(std::uint16_t) * 2;
					}
				}
				if (flags & Vertex::VF_COLORS) {
					vertexSize += sizeof(std::uint8_t) * 4;
				}
				if (flags & Vertex::VF_SKINNED) {
					vertexSize += sizeof(std::uint16_t) * 4 + sizeof(std::uint8_t) * 4;
				}
				if (flags & Vertex::VF_EYEDATA) {
					vertexSize += sizeof(float);
				}

				return vertexSize;
			}

		private:
			// members
			std::uint64_t desc;  // 00
		};
		static_assert(sizeof(VertexDesc) == 0x8);
	}
}


===============================================
File: include/RE/V/VirtualMachine.h
===============================================
#pragma once

#include "RE/A/AttachedScript.h"
#include "RE/B/BSAtomic.h"
#include "RE/B/BSTArray.h"
#include "RE/B/BSTEvent.h"
#include "RE/B/BSTFreeList.h"
#include "RE/B/BSTHashMap.h"
#include "RE/B/BSTMessageQueue.h"
#include "RE/B/BSTSmartPointer.h"
#include "RE/F/FunctionMessage.h"
#include "RE/I/IVMDebugInterface.h"
#include "RE/I/IVMObjectBindInterface.h"
#include "RE/I/IVMSaveLoadInterface.h"
#include "RE/I/IVirtualMachine.h"
#include "RE/L/LinkerProcessor.h"
#include "RE/S/SuspendedStack.h"

namespace RE
{
	namespace BSScript
	{
		class Array;
		class ErrorLogger;
		class IFreezeQuery;
		class IProfilePolicy;
		class ISavePatcherInterface;
		class IStackCallbackFunctor;
		class IStackCallbackSaveInterface;
		class ObjectBindPolicy;
		class Stack;
		struct IMemoryPagePolicy;
		struct IObjectHandlePolicy;
		struct StatsEvent;

		namespace Internal
		{
			class CodeTasklet;

			class VirtualMachine :
				public IVirtualMachine,            // 0000
				public IVMObjectBindInterface,     // 0010
				public IVMSaveLoadInterface,       // 0018
				public IVMDebugInterface,          // 0020
				public BSTEventSource<StatsEvent>  // 0028
			{
			public:
				inline static constexpr auto RTTI = RTTI_BSScript__Internal__VirtualMachine;
				inline static constexpr auto VTABLE = VTABLE_BSScript__Internal__VirtualMachine;

				struct QueuedUnbindRefs
				{
				public:
					// members
					BSTSmartPointer<Object> obj;       // 00
					std::uint32_t           refCount;  // 08
					std::uint32_t           pad0C;     // 0C
				};
				static_assert(sizeof(QueuedUnbindRefs) == 0x10);

				enum class FreezeState
				{
					kNotFrozen = 0,
					kFreezing,
					kFrozen
				};

				~VirtualMachine() override;  // 00

				using RE::BSScript::IVirtualMachine::SendEvent;
				using RE::BSTEventSource<RE::BSScript::StatsEvent>::SendEvent;

				// override (IVirtualMachine)
				void SetLinkedCallback(ITypeLinkedCallback* a_callback) override;                                                                                    // 01
				void TraceStack(const char* a_str, VMStackID a_stackID, Severity a_severity = Severity::kInfo) override;                                             // 02
				void FormatAndPostMessage(const char* a_message, Severity a_severity) override;                                                                      // 03
				void Update(float a_budget) override;                                                                                                                // 04
				void UpdateTasklets(float a_budget) override;                                                                                                        // 05
				void SetOverstressed(bool a_set) override;                                                                                                           // 06 - { overstressed = a_set; }
				bool IsCompletelyFrozen() const override;                                                                                                            // 07
				bool RegisterObjectType(VMTypeID a_typeID, const char* a_className) override;                                                                        // 08
				bool GetScriptObjectType1(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr) override;                             // 09
				bool GetScriptObjectType2(VMTypeID a_typeID, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr) override;                                            // 0A
				bool GetScriptObjectTypeNoLoad1(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_typeInfoPtr) const override;                    // 0B
				bool GetScriptObjectTypeNoLoad2(VMTypeID a_typeID, BSTSmartPointer<ObjectTypeInfo>& a_outTypeInfoPtr) const override;                                // 0C
				bool GetTypeIDForScriptObject(const BSFixedString& a_className, VMTypeID& a_typeID) const override;                                                  // 0D
				void GetScriptObjectsWithATypeID(BSScrapArray<BSFixedString>& a_results) const override;                                                             // 0E
				bool GetParentNativeType(const BSFixedString& a_className, BSTSmartPointer<ObjectTypeInfo>& a_typeInfoPtr) override;                                 // 0F
				bool TypeIsValid(const BSFixedString& a_className) override;                                                                                         // 10
				bool ReloadType(const char* a_className) override;                                                                                                   // 11
				void TasksToJobs(BSJobs::JobList& a_jobList) override;                                                                                               // 12
				void CalculateFullReloadList(void) const override;                                                                                                   // 13
				bool CreateObject1(const BSFixedString& a_className, void* a_property, BSTSmartPointer<Object>& a_objPtr) override;                                  // 14
				bool CreateObject2(const BSFixedString& a_className, BSTSmartPointer<Object>& a_result) override;                                                    // 15
				bool CreateArray1(const TypeInfo& a_typeInfo, std::uint32_t a_size, BSTSmartPointer<Array>& a_arrayPtr) override;                                    // 16
				bool CreateArray2(TypeInfo::RawType a_typeID, const BSFixedString& a_className, std::uint32_t a_size, BSTSmartPointer<Array>& a_arrayPtr) override;  // 17
				bool BindNativeMethod(IFunction* a_fn) override;                                                                                                     // 18
				void SetCallableFromTasklets1(const char* a_className, const char* a_stateName, const char* a_fnName, bool a_callable) override;                     // 19
				void SetCallableFromTasklets2(const char* a_className, const char* a_fnName, bool a_callable) override;                                              // 1A - { SetCallableFromTasklets1(a_className, 0, a_fnName, a_callable); }
				// This is where the vtable differs between AE/SE and VR.
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
				void New_1B(void) override;
#endif
#ifndef SKYRIM_CROSS_VR
				void ForEachBoundObject(VMHandle a_handle, IForEachScriptObjectFunctor* a_functor) override;                                                         // 1B, 1C
#endif
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
				void New_1D(void) override;
#endif
#ifndef SKYRIM_CROSS_VR
				bool                       FindBoundObject(VMHandle a_handle, const char* a_className, BSTSmartPointer<Object>& a_result) const override;                                                                                   // 1C
				void                       MoveBoundObjects(VMHandle a_from, VMHandle a_to) override;                                                                                                                                       // 1D
				void                       ResetAllBoundObjects(VMHandle a_handle) override;                                                                                                                                                // 1E
				bool                       CastObject(const BSTSmartPointer<Object>& a_fromObjPtr, const BSTSmartPointer<ObjectTypeInfo>& a_toTypeInfoPtr, BSTSmartPointer<Object>& a_toObjPtr) override;                                   // 1F
				bool                       SetPropertyValue(BSTSmartPointer<Object>& a_obj, const char* a_propertyName, Variable& a_setVal) override;                                                                                       // 20
				bool                       GetPropertyValue(BSTSmartPointer<Object>& a_obj, const char* a_propertyName, Variable& a_getVal) override;                                                                                       // 21
				bool                       GetVariableValue1(const BSTSmartPointer<Object>& a_objPtr, std::uint32_t a_index, Variable& a_out) const override;                                                                               // 22
				bool                       GetVariableValue2(VMHandle a_handle, const BSFixedString& a_className, std::int32_t a_variableIndex, Variable& a_out) const override;                                                            // 23
				void                       SendEvent(VMHandle a_handle, const BSFixedString& a_eventName, IFunctionArguments* a_args) override;                                                                                             // 24
				void                       SendEventAll(const BSFixedString& a_eventName, IFunctionArguments* a_args) override;                                                                                                             // 25
				bool                       DispatchStaticCall(const BSFixedString& a_className, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result) override;                      // 26
				bool                       DispatchMethodCall1(BSTSmartPointer<Object>& a_obj, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result) override;                       // 27
				bool                       DispatchMethodCall2(VMHandle a_handle, const BSFixedString& a_className, const BSFixedString& a_fnName, IFunctionArguments* a_args, BSTSmartPointer<IStackCallbackFunctor>& a_result) override;  // 28
				bool                       DispatchUnboundMethodCall(void) override;                                                                                                                                                        // 29
				bool                       IsWaitingOnLatent(VMStackID a_stackID) const override;                                                                                                                                           // 2A
				void                       ReturnFromLatent(VMStackID a_stackID, const Variable& a_val) override;                                                                                                                           // 2B
				ErrorLogger*               GetErrorLogger() override;                                                                                                                                                                       // 2C - { return errorLogger; }
				IObjectHandlePolicy*       GetObjectHandlePolicy1() override;                                                                                                                                                               // 2D - { return handlePolicy; }
				const IObjectHandlePolicy* GetObjectHandlePolicy2() const override;                                                                                                                                                         // 2E - { return handlePolicy; }
				ObjectBindPolicy*          GetObjectBindPolicy1() override;                                                                                                                                                                 // 2F - { return objectBindPolicy; }
				const ObjectBindPolicy*    GetObjectBindPolicy2() const override;                                                                                                                                                           // 30 - { return objectBindPolicy; }
				ISavePatcherInterface*     GetSavePatcherInterface() override;                                                                                                                                                              // 31 - { return savePatcherInterface; }
				void                       RegisterForLogEvent(BSTEventSink<LogEvent>* a_sink) override;                                                                                                                                    // 32
				void                       UnregisterForLogEvent(BSTEventSink<LogEvent>* a_sink) override;                                                                                                                                  // 33
				void                       RegisterForStatsEvent(BSTEventSink<StatsEvent>* a_sink) override;                                                                                                                                // 34
				void                       UnregisterForStatsEvent(BSTEventSink<StatsEvent>* a_sink) override;                                                                                                                              // 35
#endif

				// override (IVMObjectBindInterface)
				VMHandle GetBoundHandle(const BSTSmartPointer<Object>& a_objPtr) const override;                                                                   // 01
				bool     TypeCanBeBound(const BSFixedString& a_className, VMHandle a_handle) override;                                                             // 02
				void     BindObject(BSTSmartPointer<Object>& a_objPtr, VMHandle a_handle, bool a_conditional) override;                                            // 03
				void     HandleLoadedBinding(BSTSmartPointer<Object>& a_objPtr, VMHandle a_handle, bool a_conditional) override;                                   // 04
				void     RemoveAllBoundObjects(VMHandle a_handle) override;                                                                                        // 05
				void     RemoveAllDiskLoadedBoundObjects(VMHandle a_handle) override;                                                                              // 06
				void     HandleCObjectDeletion(VMHandle a_handle) override;                                                                                        // 07
				void     UnbindObject(const BSTSmartPointer<Object>& a_objPtr) override;                                                                           // 08
				bool     CreateObjectWithProperties(const BSFixedString& a_className, std::uint32_t a_numProperties, BSTSmartPointer<Object>& a_objPtr) override;  // 09
				bool     InitObjectProperties(BSTSmartPointer<Object>& a_objPtr, void* a_property, bool a_arg3) override;                                          // 0A

				// override (IVMSaveLoadInterface)
				void                                                              SaveGame(SaveStorageWrapper* a_wrapper, SkyrimScript::SaveFileHandleReaderWriter* a_handle, bool unk) override;  // 01
				void                                                              LoadGame(LoadStorageWrapper* a_wrapper, SkyrimScript::SaveFileHandleReaderWriter* a_handle) override;            // 02
				void                                                              MarkSaveInvalid(BSStorage* a_storage) override;                                                                  // 03
				std::byte                                                         GetSaveGameVersion() override;                                                                                   // 04 - { return this->saveGameVersion; }
				void                                                              CleanupSave() override;                                                                                          // 05
				void                                                              Unk_06() override;                                                                                               // 06
				void                                                              DropAllRunningData() override;                                                                                   // 07
				void                                                              Unk_08(void* unk) override;                                                                                      // 08 - { return unk; }
				void                                                              Unk_09(void) override;                                                                                           // 09 - { return 0; }
				void                                                              Unk_0A(VMHandle a_handle, Object** a_out) override;                                                              // 0A
				void                                                              Unk_0B(void* unk) override;                                                                                      // 0B - { return unk; }
				void                                                              Unk_0C(void) override;                                                                                           // 0C - { return 0; }
				void                                                              Unk_0D(VMHandle a_handle, Array** a_out) override;                                                               // 0D
				void                                                              Unk_0E(LoadStorageWrapper* a_storage, void* unk) override;                                                       // 0E
				bool                                                              GetStackByID(VMStackID a_stackID, Stack** a_out) override;                                                       // 0F
				WritableStringTable                                               GetWritableStringTable() override;                                                                               // 10 - { return this->writableStringTable; }
				const WritableStringTable                                         GetWritableStringTable2() override;                                                                              // 11 - { return this->writableStringTable; }
				ReadableStringTable                                               GetReadableStringTable() override;                                                                               // 12 - { return this->readableStringTable; }
				BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>*       GetWritableTypeTable() override;                                                                                 // 13 - { return this->writableTypeTable; }
				const BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>* GetWritableTypeTable2() override;                                                                                // 14 - { return this->writableTypeTable; }
				BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>*       GetReadableTypeTable() override;                                                                                 // 15 - { return this->readableTypeTable; }
				bool                                                              CreateEmptyTasklet(Stack* a_stack, Internal::CodeTasklet** a_out) override;                                      // 16

				static VirtualMachine* GetSingleton();

				// members
				ErrorLogger*                                               errorLogger;                 // 0080
				IMemoryPagePolicy*                                         memoryPagePolicy;            // 0088
				IObjectHandlePolicy*                                       handlePolicy;                // 0090
				ObjectBindPolicy*                                          objectBindPolicy;            // 0098
				IFreezeQuery*                                              freezeQuery;                 // 00A0
				IStackCallbackSaveInterface*                               stackCallbackSaveInterface;  // 00A8
				IProfilePolicy*                                            profilePolicy;               // 00B0
				ISavePatcherInterface*                                     savePatcherInterface;        // 00B8
				mutable BSSpinLock                                         typeInfoLock;                // 00C0
				LinkerProcessor                                            linker;                      // 00C8
				BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>> objectTypeMap;               // 0158
				BSTHashMap<VMTypeID, BSFixedString>                        typeIDToObjectType;          // 0188
				BSTHashMap<BSFixedString, VMTypeID>                        objectTypeToTypeID;          // 01B8
				BSTArray<BSTSmartPointer<ObjectTypeInfo>>                  typesToUnload;               // 01E8
				mutable BSSpinLock                                         funcQueueLock;               // 0200
				BSTStaticFreeList<FunctionMessage, 1024>                   funcMsgPool;                 // 0208
				BSTCommonLLMessageQueue<FunctionMessage>                   funcMsgQueue;                // 8220
				BSTArray<FunctionMessage>                                  overflowFuncMsgs;            // 8248
				BSTArray<CodeTasklet*>                                     vmTasks;                     // 8260
				std::uint32_t                                              uiWaitingFunctionMessages;   // 8278
				bool                                                       overstressed;                // 827C
				bool                                                       initialized;                 // 827D
				std::uint16_t                                              pad827E;                     // 827E
				BSTCommonStaticMessageQueue<SuspendedStack, 128>           suspendQueue1;               // 8280
				BSTCommonStaticMessageQueue<SuspendedStack, 128>           suspendQueue2;               // 8AA0
				BSTArray<SuspendedStack>                                   overflowSuspendArray1;       // 92C0
				BSTArray<SuspendedStack>                                   overflowSuspendArray2;       // 92D8
				mutable BSSpinLock                                         suspendQueueLock;            // 92F0
				BSTCommonStaticMessageQueue<SuspendedStack, 128>*          stacksToResume;              // 92F8 - ref to suspendQueue2
				BSTArray<SuspendedStack>*                                  stacksToResumeOverflow;      // 9300 - ref to overflowSuspendArray2
				BSTCommonStaticMessageQueue<SuspendedStack, 128>*          stacksToSuspend;             // 9308 - ref to suspendQueue1
				BSTArray<SuspendedStack>*                                  stacksToSuspendOverflow;     // 9310 - ref to overflowSuspendArray1
				mutable BSSpinLock                                         runningStacksLock;           // 9318
				BSTHashMap<VMStackID, BSTSmartPointer<Stack>>              allRunningStacks;            // 9320
				BSTHashMap<VMStackID, BSTSmartPointer<Stack>>              waitingLatentReturns;        // 9350
				VMStackID                                                  nextStackID;                 // 9380
				mutable BSSpinLock                                         frozenStacksLock;            // 9384
				std::uint32_t                                              pad938C;                     // 938C
				BSScript::Stack*                                           frozenStacks;                // 9390
				std::uint32_t                                              frozenStacksCount;           // 9398
				stl::enumeration<FreezeState, std::uint32_t>               freezeState;                 // 939C
				mutable BSSpinLock                                         attachedScriptsLock;         // 93A0
				BSTHashMap<VMHandle, BSTSmallSharedArray<AttachedScript>>  attachedScripts;             // 93A8
				std::uint32_t                                              unk93D8;                     // 93D8
				std::uint32_t                                              unk93DC;                     // 93DC
				BSTArray<BSTSmartPointer<Object>>                          objectsAwaitingCleanup;      // 93E0
				mutable BSSpinLock                                         arraysLock;                  // 93F8
				std::uint32_t                                              nextArrayToClean;            // 9400
				std::uint32_t                                              pad9404;                     // 9404
				BSTArray<BSTSmartPointer<Array>>                           arrays;                      // 9408
				mutable BSSpinLock                                         objectResetLock;             // 9420
				BSTArray<BSTSmartPointer<Object>>                          objectsAwaitingReset;        // 9428
				mutable BSSpinLock                                         objectLock;                  // 9440 - Used for objectTable/arrayTable
				BSTHashMap<VMHandle, BSTSmartPointer<Object>>              objectTable;                 // 9448 - Used when loading a save
				BSTHashMap<VMHandle, BSTSmartPointer<Array>>               arrayTable;                  // 9478 - Used when loading a save
				mutable BSSpinLock                                         queuedUnbindLock;            // 94A8
				BSTArray<QueuedUnbindRefs>                                 queuedUnbinds;               // 94B0
				std::byte                                                  saveGameVersion;             // 94C8 - Set when loading a save
				std::uint32_t                                              unk94CC;                     // 94CC
				std::uint32_t                                              unk94D0;                     // 94D0
				WritableStringTable                                        writableStringTable;         // 94D8 - Created/Used only while saving
				ReadableStringTable                                        readableStringTable;         // 94F0 - Created/Used only while loading a save
				BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>* writeableTypeTable;         // 9508 - Created/Used only while saving
				BSTHashMap<BSFixedString, BSTSmartPointer<ObjectTypeInfo>>* readableTypeTable;          // 9510 - Created/Used only while loading a save
			};
			static_assert(sizeof(VirtualMachine) == 0x9518);
		}
	}
}


===============================================
File: include/RE/V/VoiceSpellFireHandler.h
===============================================
#pragma once

#include "RE/I/IHandlerFunctor.h"

namespace RE
{
	class VoiceSpellFireHandler : public AnimHandler
	{
	public:
		inline static constexpr auto RTTI = RTTI_VoiceSpellFireHandler;
		inline static constexpr auto VTABLE = VTABLE_VoiceSpellFireHandler;

		~VoiceSpellFireHandler() override;  // 00

		// override (IHandleFunctor)
		bool ExecuteHandler(Actor& a_actor, const BSFixedString& a_tag) override;
	};
	static_assert(sizeof(VoiceSpellFireHandler) == 0x10);
}


===============================================
File: include/RE/W/WeaponAnimationGraphManagerHolder.h
===============================================
#pragma once

#include "RE/B/BSAnimationGraphManager.h"
#include "RE/B/BSIntrusiveRefCounted.h"
#include "RE/I/IAnimationGraphManagerHolder.h"

namespace RE
{
	class WeaponAnimationGraphManagerHolder :
		public IAnimationGraphManagerHolder,  // 00
		public BSIntrusiveRefCounted          // 08
	{
	public:
		inline static constexpr auto RTTI = RTTI_WeaponAnimationGraphManagerHolder;

		// override (IAnimationGraphManagerHolder)
		bool GetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_out) const override;  // 02 - { a_out = animationGraphManager; return a_out; }
		bool SetAnimationGraphManagerImpl(BSTSmartPointer<BSAnimationGraphManager>& a_in) override;         // 03 - { animationGraphManager = a_in; return true; }
		bool ConstructAnimationGraph(BSTSmartPointer<BShkbAnimationGraph>& a_out) override;                 // 05

		// add
		virtual void Unk_13(void);  // 13
		virtual void Unk_14(void);  // 14

		// members
		std::uint32_t                            pad0C;                  // 0C
		BSTSmartPointer<BSAnimationGraphManager> animationGraphManager;  // 10
	};
	static_assert(sizeof(WeaponAnimationGraphManagerHolder) == 0x18);
}


===============================================
File: include/RE/W/WeatherType.h
===============================================
#pragma once

namespace RE
{
	class TESGlobal;
	class TESWeather;

	struct WeatherType
	{
	public:
		// members
		TESWeather*   weather;  // 00
		std::uint32_t chance;   // 08
		std::uint32_t unk0C;    // 0C
		TESGlobal*    global;   // 10
	};
	static_assert(sizeof(WeatherType) == 0x18);
}


===============================================
File: include/RE/W/WerewolfEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class WerewolfEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_WerewolfEffect;
		inline static constexpr auto VTABLE = VTABLE_WerewolfEffect;

		// override (ActiveEffect)
		virtual ~WerewolfEffect();       // 13
		virtual void Start() override;   // 14
		virtual void Finish() override;  // 15
	};
	static_assert(sizeof(WerewolfEffect) == 0x90);
}


===============================================
File: include/RE/W/WerewolfFeedEffect.h
===============================================
#pragma once

#include "RE/A/ActiveEffect.h"

namespace RE
{
	class WerewolfFeedEffect :
		public ActiveEffect  // 00
	{
	public:
		inline static constexpr auto RTTI = RTTI_WerewolfFeedEffect;
		inline static constexpr auto VTABLE = VTABLE_WerewolfFeedEffect;

		// override (ActiveEffect)
		virtual ~WerewolfFeedEffect();  // 13
		virtual void Start() override;  // 14
	};
	static_assert(sizeof(WerewolfFeedEffect) == 0x90);
}


===============================================
File: include/RE/W/WorldSpaceMenu.h
===============================================
#pragma once

#include "RE/B/BSTEvent.h"
#include "RE/I/IMenu.h"

namespace RE
{
	class HudModeChangeEvent;

	// menuDepth = 4
	// context = 22
	class WorldSpaceMenu :
#ifndef SKYRIM_CROSS_VR
		public IMenu,                            // 00
		public BSTEventSink<HudModeChangeEvent>  // 40
#else
		public IMenu  // 00
#endif
	{
	public:
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		inline static constexpr auto RTTI = RTTI_WorldSpaceMenu;
#endif

		~WorldSpaceMenu() override;  // 00

		[[nodiscard]] BSTEventSink<HudModeChangeEvent>* AsHudModeChangeEventSink() noexcept
		{
			if (!REL::Module::IsVR()) {
				return nullptr;
			}
			return &REL::RelocateMember<BSTEventSink<HudModeChangeEvent>>(this, 0, 0x40);
		}

		[[nodiscard]] const BSTEventSink<HudModeChangeEvent>* AsHudModeChangeEventSink() const noexcept
		{
			return const_cast<WorldSpaceMenu*>(this)->AsHudModeChangeEventSink();
		}

#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
		// add
		virtual void Unk_11();
		virtual void Unk_12();
		virtual void Unk_13();

		// members
		std::uint16_t unk48{ 0 };  // 40
		std::uint8_t  unk50{ 0 };  // 42
		std::uint8_t  unk51{ 0 };  // 43
		std::uint8_t  unk52{ 0 };  // 44
		std::uint8_t  pad53{ 0 };  // 45
		std::uint32_t pad54{ 0 };  // 46
#endif
	};
#if !defined(ENABLE_SKYRIM_AE) && !defined(ENABLE_SKYRIM_SE)
	static_assert(sizeof(WorldSpaceMenu) == 0x58);
#endif
}


===============================================
File: include/RE/Z/ZeroFunctionArguments.h
===============================================
#pragma once

#include "RE/I/IFunctionArguments.h"

namespace RE
{
	namespace BSScript
	{
		class ZeroFunctionArguments : public IFunctionArguments
		{
		public:
			inline static constexpr auto RTTI = RTTI_BSScript__ZeroFunctionArguments;

			// override (IFunctionArguments)
			bool operator()(BSScrapArray<Variable>& a_dst) const override;  // 01
		};
		static_assert(sizeof(ZeroFunctionArguments) == 0x8);
	}
}


===============================================
File: include/RE/Z/ZeroOverheadHeap.h
===============================================
#pragma once

#include "RE/B/BSAtomic.h"
#include "RE/I/IMemoryHeap.h"

namespace RE
{
	class ZeroOverheadHeap : public IMemoryHeap
	{
	public:
		inline static constexpr auto RTTI = RTTI_ZeroOverheadHeap;

		~ZeroOverheadHeap() override;  // 00

		// override (IMemoryHeap)
		std::size_t   Size(const void* a_block) const override;                                      // 01
		void          GetMemoryStats(MemoryStats* a_stats) override;                                 // 02
		bool          ContainsBlockImpl(const void* a_block) const override;                         // 03
		void*         AllocateAlignImpl(std::size_t a_size, std::uint32_t a_alignment) override;     // 04
		const char*   GetName() const override;                                                      // 07 - { return name; }
		void*         Allocate(std::size_t a_size, std::uint32_t a_alignment) override;              // 08
		void          Deallocate(void* a_pointer, std::uint32_t) override;                           // 09 - { return; }
		bool          PointerInHeap(const void* a_pointer) const override;                           // 0A
		std::size_t   TotalSize(const void* a_pointer) const override;                               // 0B
		void          GetHeapStats(HeapStats* a_stats, bool a_fullBlockInfo) override;               // 0C
		bool          ShouldTrySmallBlockPools(std::size_t a_size, MEM_CONTEXT a_context) override;  // 0D - { return 0; }
		std::uint32_t GetPageSize() const override;                                                  // 0E - { return 0; }

		// members
		std::size_t        memSize;      // 08
		const char*        name;         // 10
		void*              memoryBase;   // 18
		void*              nextFreeMem;  // 20
		std::uint32_t      unk28;        // 28
		mutable BSSpinLock unk2C;        // 2C
		std::uint32_t      unk34;        // 34
	};
	static_assert(sizeof(ZeroOverheadHeap) == 0x38);
}


